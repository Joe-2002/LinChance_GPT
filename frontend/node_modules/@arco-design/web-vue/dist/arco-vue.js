var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
(function(global2, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory(require("vue")) : typeof define === "function" && define.amd ? define(["vue"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.ArcoVue = factory(global2.Vue));
})(this, function(vue) {
  "use strict";
  const opt$1 = Object.prototype.toString;
  function isArray$1(obj) {
    return opt$1.call(obj) === "[object Array]";
  }
  function isNull(obj) {
    return opt$1.call(obj) === "[object Null]";
  }
  function isBoolean$1(obj) {
    return opt$1.call(obj) === "[object Boolean]";
  }
  function isObject$1(obj) {
    return opt$1.call(obj) === "[object Object]";
  }
  const isPromise = (obj) => {
    return opt$1.call(obj) === "[object Promise]";
  };
  function isString$1(obj) {
    return opt$1.call(obj) === "[object String]";
  }
  function isNumber$1(obj) {
    return opt$1.call(obj) === "[object Number]" && obj === obj;
  }
  function isUndefined(obj) {
    return obj === void 0;
  }
  function isFunction$1(obj) {
    return typeof obj === "function";
  }
  function isEmptyObject$1(obj) {
    return isObject$1(obj) && Object.keys(obj).length === 0;
  }
  function isWindow(el) {
    return el === window;
  }
  const isComponentInstance = (value) => {
    return (value == null ? void 0 : value.$) !== void 0;
  };
  const isQuarter = (fromat) => {
    return /\[Q]Q/.test(fromat);
  };
  function isDayjs(time) {
    return isObject$1(time) && "$y" in time && "$M" in time && "$D" in time && "$d" in time && "$H" in time && "$m" in time && "$s" in time;
  }
  const configProviderInjectionKey = Symbol("ArcoConfigProvider");
  const calendarLang = {
    formatYear: "YYYY \u5E74",
    formatMonth: "YYYY \u5E74 MM \u6708",
    today: "\u4ECA\u5929",
    view: {
      month: "\u6708",
      year: "\u5E74",
      week: "\u5468",
      day: "\u65E5"
    },
    month: {
      long: {
        January: "\u4E00\u6708",
        February: "\u4E8C\u6708",
        March: "\u4E09\u6708",
        April: "\u56DB\u6708",
        May: "\u4E94\u6708",
        June: "\u516D\u6708",
        July: "\u4E03\u6708",
        August: "\u516B\u6708",
        September: "\u4E5D\u6708",
        October: "\u5341\u6708",
        November: "\u5341\u4E00\u6708",
        December: "\u5341\u4E8C\u6708"
      },
      short: {
        January: "\u4E00\u6708",
        February: "\u4E8C\u6708",
        March: "\u4E09\u6708",
        April: "\u56DB\u6708",
        May: "\u4E94\u6708",
        June: "\u516D\u6708",
        July: "\u4E03\u6708",
        August: "\u516B\u6708",
        September: "\u4E5D\u6708",
        October: "\u5341\u6708",
        November: "\u5341\u4E00\u6708",
        December: "\u5341\u4E8C\u6708"
      }
    },
    week: {
      long: {
        self: "\u5468",
        monday: "\u5468\u4E00",
        tuesday: "\u5468\u4E8C",
        wednesday: "\u5468\u4E09",
        thursday: "\u5468\u56DB",
        friday: "\u5468\u4E94",
        saturday: "\u5468\u516D",
        sunday: "\u5468\u65E5"
      },
      short: {
        self: "\u5468",
        monday: "\u4E00",
        tuesday: "\u4E8C",
        wednesday: "\u4E09",
        thursday: "\u56DB",
        friday: "\u4E94",
        saturday: "\u516D",
        sunday: "\u65E5"
      }
    }
  };
  const lang = {
    locale: "zh-CN",
    empty: {
      description: "\u6682\u65E0\u6570\u636E"
    },
    drawer: {
      okText: "\u786E\u5B9A",
      cancelText: "\u53D6\u6D88"
    },
    popconfirm: {
      okText: "\u786E\u5B9A",
      cancelText: "\u53D6\u6D88"
    },
    modal: {
      okText: "\u786E\u5B9A",
      cancelText: "\u53D6\u6D88"
    },
    pagination: {
      goto: "\u524D\u5F80",
      page: "\u9875",
      countPerPage: "\u6761/\u9875",
      total: "\u5171 {0} \u6761"
    },
    table: {
      okText: "\u786E\u5B9A",
      resetText: "\u91CD\u7F6E"
    },
    upload: {
      start: "\u5F00\u59CB",
      cancel: "\u53D6\u6D88",
      delete: "\u5220\u9664",
      retry: "\u70B9\u51FB\u91CD\u8BD5",
      buttonText: "\u70B9\u51FB\u4E0A\u4F20",
      preview: "\u9884\u89C8",
      drag: "\u70B9\u51FB\u6216\u62D6\u62FD\u6587\u4EF6\u5230\u6B64\u5904\u4E0A\u4F20",
      dragHover: "\u91CA\u653E\u6587\u4EF6\u5E76\u5F00\u59CB\u4E0A\u4F20",
      error: "\u4E0A\u4F20\u5931\u8D25"
    },
    calendar: calendarLang,
    datePicker: {
      view: calendarLang.view,
      month: calendarLang.month,
      week: calendarLang.week,
      placeholder: {
        date: "\u8BF7\u9009\u62E9\u65E5\u671F",
        week: "\u8BF7\u9009\u62E9\u5468",
        month: "\u8BF7\u9009\u62E9\u6708\u4EFD",
        year: "\u8BF7\u9009\u62E9\u5E74\u4EFD",
        quarter: "\u8BF7\u9009\u62E9\u5B63\u5EA6",
        time: "\u8BF7\u9009\u62E9\u65F6\u95F4"
      },
      rangePlaceholder: {
        date: ["\u5F00\u59CB\u65E5\u671F", "\u7ED3\u675F\u65E5\u671F"],
        week: ["\u5F00\u59CB\u5468", "\u7ED3\u675F\u5468"],
        month: ["\u5F00\u59CB\u6708\u4EFD", "\u7ED3\u675F\u6708\u4EFD"],
        year: ["\u5F00\u59CB\u5E74\u4EFD", "\u7ED3\u675F\u5E74\u4EFD"],
        quarter: ["\u5F00\u59CB\u5B63\u5EA6", "\u7ED3\u675F\u5B63\u5EA6"],
        time: ["\u5F00\u59CB\u65F6\u95F4", "\u7ED3\u675F\u65F6\u95F4"]
      },
      selectTime: "\u9009\u62E9\u65F6\u95F4",
      today: "\u4ECA\u5929",
      now: "\u6B64\u523B",
      ok: "\u786E\u5B9A"
    },
    image: {
      loading: "\u52A0\u8F7D\u4E2D"
    },
    imagePreview: {
      fullScreen: "\u5168\u5C4F",
      rotateRight: "\u5411\u53F3\u65CB\u8F6C",
      rotateLeft: "\u5411\u5DE6\u65CB\u8F6C",
      zoomIn: "\u653E\u5927",
      zoomOut: "\u7F29\u5C0F",
      originalSize: "\u539F\u59CB\u5C3A\u5BF8"
    },
    typography: {
      copied: "\u5DF2\u590D\u5236",
      copy: "\u590D\u5236",
      expand: "\u5C55\u5F00",
      collapse: "\u6298\u53E0",
      edit: "\u7F16\u8F91"
    },
    form: {
      validateMessages: {
        required: "#{field} \u662F\u5FC5\u586B\u9879",
        type: {
          string: "#{field} \u4E0D\u662F\u5408\u6CD5\u7684\u6587\u672C\u7C7B\u578B",
          number: "#{field} \u4E0D\u662F\u5408\u6CD5\u7684\u6570\u5B57\u7C7B\u578B",
          boolean: "#{field} \u4E0D\u662F\u5408\u6CD5\u7684\u5E03\u5C14\u7C7B\u578B",
          array: "#{field} \u4E0D\u662F\u5408\u6CD5\u7684\u6570\u7EC4\u7C7B\u578B",
          object: "#{field} \u4E0D\u662F\u5408\u6CD5\u7684\u5BF9\u8C61\u7C7B\u578B",
          url: "#{field} \u4E0D\u662F\u5408\u6CD5\u7684 url \u5730\u5740",
          email: "#{field} \u4E0D\u662F\u5408\u6CD5\u7684\u90AE\u7BB1\u5730\u5740",
          ip: "#{field} \u4E0D\u662F\u5408\u6CD5\u7684 IP \u5730\u5740"
        },
        number: {
          min: "`#{value}` \u5C0F\u4E8E\u6700\u5C0F\u503C `#{min}`",
          max: "`#{value}` \u5927\u4E8E\u6700\u5927\u503C `#{max}`",
          equal: "`#{value}` \u4E0D\u7B49\u4E8E `#{equal}`",
          range: "`#{value}` \u4E0D\u5728 `#{min} ~ #{max}` \u8303\u56F4\u5185",
          positive: "`#{value}` \u4E0D\u662F\u6B63\u6570",
          negative: "`#{value}` \u4E0D\u662F\u8D1F\u6570"
        },
        array: {
          length: "`#{field}` \u4E2A\u6570\u4E0D\u7B49\u4E8E #{length}",
          minLength: "`#{field}` \u4E2A\u6570\u6700\u5C11\u4E3A #{minLength}",
          maxLength: "`#{field}` \u4E2A\u6570\u6700\u591A\u4E3A #{maxLength}",
          includes: "#{field} \u4E0D\u5305\u542B #{includes}",
          deepEqual: "#{field} \u4E0D\u7B49\u4E8E #{deepEqual}",
          empty: "`#{field}` \u4E0D\u662F\u7A7A\u6570\u7EC4"
        },
        string: {
          minLength: "\u5B57\u7B26\u6570\u6700\u5C11\u4E3A #{minLength}",
          maxLength: "\u5B57\u7B26\u6570\u6700\u591A\u4E3A #{maxLength}",
          length: "\u5B57\u7B26\u6570\u5FC5\u987B\u662F #{length}",
          match: "`#{value}` \u4E0D\u7B26\u5408\u6A21\u5F0F #{pattern}",
          uppercase: "`#{value}` \u5FC5\u987B\u5168\u5927\u5199",
          lowercase: "`#{value}` \u5FC5\u987B\u5168\u5C0F\u5199"
        },
        object: {
          deepEqual: "`#{field}` \u4E0D\u7B49\u4E8E\u671F\u671B\u503C",
          hasKeys: "`#{field}` \u4E0D\u5305\u542B\u5FC5\u987B\u5B57\u6BB5",
          empty: "`#{field}` \u4E0D\u662F\u5BF9\u8C61"
        },
        boolean: {
          true: "\u671F\u671B\u662F `true`",
          false: "\u671F\u671B\u662F `false`"
        }
      }
    }
  };
  const LOCALE = vue.ref("zh-CN");
  const I18N_MESSAGES = vue.reactive({
    "zh-CN": lang
  });
  const addI18nMessages = (messages, options) => {
    for (const key of Object.keys(messages)) {
      if (!I18N_MESSAGES[key] || (options == null ? void 0 : options.overwrite)) {
        I18N_MESSAGES[key] = messages[key];
      }
    }
  };
  const useLocale = (locale) => {
    if (!I18N_MESSAGES[locale]) {
      console.warn(`use ${locale} failed! Please add ${locale} first`);
      return;
    }
    LOCALE.value = locale;
  };
  const getLocale = () => {
    return LOCALE.value;
  };
  const useI18n = () => {
    const configProvider = vue.inject(configProviderInjectionKey, void 0);
    const i18nMessage = vue.computed(() => {
      var _a;
      return (_a = configProvider == null ? void 0 : configProvider.locale) != null ? _a : I18N_MESSAGES[LOCALE.value];
    });
    const locale = vue.computed(() => i18nMessage.value.locale);
    const transform = (key, ...args) => {
      const keyArray = key.split(".");
      let temp = i18nMessage.value;
      for (const keyItem of keyArray) {
        if (!temp[keyItem]) {
          return key;
        }
        temp = temp[keyItem];
      }
      if (isString$1(temp)) {
        if (args.length > 0) {
          return temp.replace(/{(\d+)}/g, (sub, index2) => {
            var _a;
            return (_a = args[index2]) != null ? _a : sub;
          });
        }
        return temp;
      }
      return temp;
    };
    return {
      i18nMessage,
      locale,
      t: transform
    };
  };
  const COMPONENT_PREFIX = "A";
  const CLASS_PREFIX = "arco";
  const GLOBAL_CONFIG_NAME = "$arco";
  const getComponentPrefix = (options) => {
    var _a;
    return (_a = options == null ? void 0 : options.componentPrefix) != null ? _a : COMPONENT_PREFIX;
  };
  const setGlobalConfig = (app, options) => {
    var _a;
    if (options && options.classPrefix) {
      app.config.globalProperties[GLOBAL_CONFIG_NAME] = __spreadProps(__spreadValues({}, (_a = app.config.globalProperties[GLOBAL_CONFIG_NAME]) != null ? _a : {}), {
        classPrefix: options.classPrefix
      });
    }
  };
  const getPrefixCls = (componentName) => {
    var _a, _b, _c;
    const instance = vue.getCurrentInstance();
    const configProvider = vue.inject(configProviderInjectionKey, void 0);
    const prefix = (_c = (_b = configProvider == null ? void 0 : configProvider.prefixCls) != null ? _b : (_a = instance == null ? void 0 : instance.appContext.config.globalProperties[GLOBAL_CONFIG_NAME]) == null ? void 0 : _a.classPrefix) != null ? _c : CLASS_PREFIX;
    if (componentName) {
      return `${prefix}-${componentName}`;
    }
    return prefix;
  };
  var MapShim = function() {
    if (typeof Map !== "undefined") {
      return Map;
    }
    function getIndex(arr, key) {
      var result = -1;
      arr.some(function(entry, index2) {
        if (entry[0] === key) {
          result = index2;
          return true;
        }
        return false;
      });
      return result;
    }
    return function() {
      function class_1() {
        this.__entries__ = [];
      }
      Object.defineProperty(class_1.prototype, "size", {
        get: function() {
          return this.__entries__.length;
        },
        enumerable: true,
        configurable: true
      });
      class_1.prototype.get = function(key) {
        var index2 = getIndex(this.__entries__, key);
        var entry = this.__entries__[index2];
        return entry && entry[1];
      };
      class_1.prototype.set = function(key, value) {
        var index2 = getIndex(this.__entries__, key);
        if (~index2) {
          this.__entries__[index2][1] = value;
        } else {
          this.__entries__.push([key, value]);
        }
      };
      class_1.prototype.delete = function(key) {
        var entries = this.__entries__;
        var index2 = getIndex(entries, key);
        if (~index2) {
          entries.splice(index2, 1);
        }
      };
      class_1.prototype.has = function(key) {
        return !!~getIndex(this.__entries__, key);
      };
      class_1.prototype.clear = function() {
        this.__entries__.splice(0);
      };
      class_1.prototype.forEach = function(callback, ctx) {
        if (ctx === void 0) {
          ctx = null;
        }
        for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
          var entry = _a[_i];
          callback.call(ctx, entry[1], entry[0]);
        }
      };
      return class_1;
    }();
  }();
  var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
  var global$1 = function() {
    if (typeof global !== "undefined" && global.Math === Math) {
      return global;
    }
    if (typeof self !== "undefined" && self.Math === Math) {
      return self;
    }
    if (typeof window !== "undefined" && window.Math === Math) {
      return window;
    }
    return Function("return this")();
  }();
  var requestAnimationFrame$1 = function() {
    if (typeof requestAnimationFrame === "function") {
      return requestAnimationFrame.bind(global$1);
    }
    return function(callback) {
      return setTimeout(function() {
        return callback(Date.now());
      }, 1e3 / 60);
    };
  }();
  var trailingTimeout = 2;
  function throttle(callback, delay) {
    var leadingCall = false, trailingCall = false, lastCallTime = 0;
    function resolvePending() {
      if (leadingCall) {
        leadingCall = false;
        callback();
      }
      if (trailingCall) {
        proxy();
      }
    }
    function timeoutCallback() {
      requestAnimationFrame$1(resolvePending);
    }
    function proxy() {
      var timeStamp = Date.now();
      if (leadingCall) {
        if (timeStamp - lastCallTime < trailingTimeout) {
          return;
        }
        trailingCall = true;
      } else {
        leadingCall = true;
        trailingCall = false;
        setTimeout(timeoutCallback, delay);
      }
      lastCallTime = timeStamp;
    }
    return proxy;
  }
  var REFRESH_DELAY = 20;
  var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
  var mutationObserverSupported = typeof MutationObserver !== "undefined";
  var ResizeObserverController = function() {
    function ResizeObserverController2() {
      this.connected_ = false;
      this.mutationEventsAdded_ = false;
      this.mutationsObserver_ = null;
      this.observers_ = [];
      this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
      this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    ResizeObserverController2.prototype.addObserver = function(observer) {
      if (!~this.observers_.indexOf(observer)) {
        this.observers_.push(observer);
      }
      if (!this.connected_) {
        this.connect_();
      }
    };
    ResizeObserverController2.prototype.removeObserver = function(observer) {
      var observers2 = this.observers_;
      var index2 = observers2.indexOf(observer);
      if (~index2) {
        observers2.splice(index2, 1);
      }
      if (!observers2.length && this.connected_) {
        this.disconnect_();
      }
    };
    ResizeObserverController2.prototype.refresh = function() {
      var changesDetected = this.updateObservers_();
      if (changesDetected) {
        this.refresh();
      }
    };
    ResizeObserverController2.prototype.updateObservers_ = function() {
      var activeObservers = this.observers_.filter(function(observer) {
        return observer.gatherActive(), observer.hasActive();
      });
      activeObservers.forEach(function(observer) {
        return observer.broadcastActive();
      });
      return activeObservers.length > 0;
    };
    ResizeObserverController2.prototype.connect_ = function() {
      if (!isBrowser || this.connected_) {
        return;
      }
      document.addEventListener("transitionend", this.onTransitionEnd_);
      window.addEventListener("resize", this.refresh);
      if (mutationObserverSupported) {
        this.mutationsObserver_ = new MutationObserver(this.refresh);
        this.mutationsObserver_.observe(document, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        });
      } else {
        document.addEventListener("DOMSubtreeModified", this.refresh);
        this.mutationEventsAdded_ = true;
      }
      this.connected_ = true;
    };
    ResizeObserverController2.prototype.disconnect_ = function() {
      if (!isBrowser || !this.connected_) {
        return;
      }
      document.removeEventListener("transitionend", this.onTransitionEnd_);
      window.removeEventListener("resize", this.refresh);
      if (this.mutationsObserver_) {
        this.mutationsObserver_.disconnect();
      }
      if (this.mutationEventsAdded_) {
        document.removeEventListener("DOMSubtreeModified", this.refresh);
      }
      this.mutationsObserver_ = null;
      this.mutationEventsAdded_ = false;
      this.connected_ = false;
    };
    ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {
      var _b = _a.propertyName, propertyName = _b === void 0 ? "" : _b;
      var isReflowProperty = transitionKeys.some(function(key) {
        return !!~propertyName.indexOf(key);
      });
      if (isReflowProperty) {
        this.refresh();
      }
    };
    ResizeObserverController2.getInstance = function() {
      if (!this.instance_) {
        this.instance_ = new ResizeObserverController2();
      }
      return this.instance_;
    };
    ResizeObserverController2.instance_ = null;
    return ResizeObserverController2;
  }();
  var defineConfigurable = function(target2, props) {
    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
      var key = _a[_i];
      Object.defineProperty(target2, key, {
        value: props[key],
        enumerable: false,
        writable: false,
        configurable: true
      });
    }
    return target2;
  };
  var getWindowOf = function(target2) {
    var ownerGlobal = target2 && target2.ownerDocument && target2.ownerDocument.defaultView;
    return ownerGlobal || global$1;
  };
  var emptyRect = createRectInit(0, 0, 0, 0);
  function toFloat(value) {
    return parseFloat(value) || 0;
  }
  function getBordersSize(styles) {
    var positions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      positions[_i - 1] = arguments[_i];
    }
    return positions.reduce(function(size, position) {
      var value = styles["border-" + position + "-width"];
      return size + toFloat(value);
    }, 0);
  }
  function getPaddings(styles) {
    var positions = ["top", "right", "bottom", "left"];
    var paddings = {};
    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
      var position = positions_1[_i];
      var value = styles["padding-" + position];
      paddings[position] = toFloat(value);
    }
    return paddings;
  }
  function getSVGContentRect(target2) {
    var bbox = target2.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
  }
  function getHTMLElementContentRect(target2) {
    var clientWidth = target2.clientWidth, clientHeight = target2.clientHeight;
    if (!clientWidth && !clientHeight) {
      return emptyRect;
    }
    var styles = getWindowOf(target2).getComputedStyle(target2);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;
    var width = toFloat(styles.width), height = toFloat(styles.height);
    if (styles.boxSizing === "border-box") {
      if (Math.round(width + horizPad) !== clientWidth) {
        width -= getBordersSize(styles, "left", "right") + horizPad;
      }
      if (Math.round(height + vertPad) !== clientHeight) {
        height -= getBordersSize(styles, "top", "bottom") + vertPad;
      }
    }
    if (!isDocumentElement(target2)) {
      var vertScrollbar = Math.round(width + horizPad) - clientWidth;
      var horizScrollbar = Math.round(height + vertPad) - clientHeight;
      if (Math.abs(vertScrollbar) !== 1) {
        width -= vertScrollbar;
      }
      if (Math.abs(horizScrollbar) !== 1) {
        height -= horizScrollbar;
      }
    }
    return createRectInit(paddings.left, paddings.top, width, height);
  }
  var isSVGGraphicsElement = function() {
    if (typeof SVGGraphicsElement !== "undefined") {
      return function(target2) {
        return target2 instanceof getWindowOf(target2).SVGGraphicsElement;
      };
    }
    return function(target2) {
      return target2 instanceof getWindowOf(target2).SVGElement && typeof target2.getBBox === "function";
    };
  }();
  function isDocumentElement(target2) {
    return target2 === getWindowOf(target2).document.documentElement;
  }
  function getContentRect(target2) {
    if (!isBrowser) {
      return emptyRect;
    }
    if (isSVGGraphicsElement(target2)) {
      return getSVGContentRect(target2);
    }
    return getHTMLElementContentRect(target2);
  }
  function createReadOnlyRect(_a) {
    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
    var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);
    defineConfigurable(rect, {
      x,
      y,
      width,
      height,
      top: y,
      right: x + width,
      bottom: height + y,
      left: x
    });
    return rect;
  }
  function createRectInit(x, y, width, height) {
    return { x, y, width, height };
  }
  var ResizeObservation = function() {
    function ResizeObservation2(target2) {
      this.broadcastWidth = 0;
      this.broadcastHeight = 0;
      this.contentRect_ = createRectInit(0, 0, 0, 0);
      this.target = target2;
    }
    ResizeObservation2.prototype.isActive = function() {
      var rect = getContentRect(this.target);
      this.contentRect_ = rect;
      return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
    };
    ResizeObservation2.prototype.broadcastRect = function() {
      var rect = this.contentRect_;
      this.broadcastWidth = rect.width;
      this.broadcastHeight = rect.height;
      return rect;
    };
    return ResizeObservation2;
  }();
  var ResizeObserverEntry = function() {
    function ResizeObserverEntry2(target2, rectInit) {
      var contentRect = createReadOnlyRect(rectInit);
      defineConfigurable(this, { target: target2, contentRect });
    }
    return ResizeObserverEntry2;
  }();
  var ResizeObserverSPI = function() {
    function ResizeObserverSPI2(callback, controller, callbackCtx) {
      this.activeObservations_ = [];
      this.observations_ = new MapShim();
      if (typeof callback !== "function") {
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      }
      this.callback_ = callback;
      this.controller_ = controller;
      this.callbackCtx_ = callbackCtx;
    }
    ResizeObserverSPI2.prototype.observe = function(target2) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target2 instanceof getWindowOf(target2).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (observations.has(target2)) {
        return;
      }
      observations.set(target2, new ResizeObservation(target2));
      this.controller_.addObserver(this);
      this.controller_.refresh();
    };
    ResizeObserverSPI2.prototype.unobserve = function(target2) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target2 instanceof getWindowOf(target2).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (!observations.has(target2)) {
        return;
      }
      observations.delete(target2);
      if (!observations.size) {
        this.controller_.removeObserver(this);
      }
    };
    ResizeObserverSPI2.prototype.disconnect = function() {
      this.clearActive();
      this.observations_.clear();
      this.controller_.removeObserver(this);
    };
    ResizeObserverSPI2.prototype.gatherActive = function() {
      var _this = this;
      this.clearActive();
      this.observations_.forEach(function(observation) {
        if (observation.isActive()) {
          _this.activeObservations_.push(observation);
        }
      });
    };
    ResizeObserverSPI2.prototype.broadcastActive = function() {
      if (!this.hasActive()) {
        return;
      }
      var ctx = this.callbackCtx_;
      var entries = this.activeObservations_.map(function(observation) {
        return new ResizeObserverEntry(observation.target, observation.broadcastRect());
      });
      this.callback_.call(ctx, entries, ctx);
      this.clearActive();
    };
    ResizeObserverSPI2.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    };
    ResizeObserverSPI2.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI2;
  }();
  var observers = typeof WeakMap !== "undefined" ? new WeakMap() : new MapShim();
  var ResizeObserver$2 = function() {
    function ResizeObserver2(callback) {
      if (!(this instanceof ResizeObserver2)) {
        throw new TypeError("Cannot call a class as a function.");
      }
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      var controller = ResizeObserverController.getInstance();
      var observer = new ResizeObserverSPI(callback, controller, this);
      observers.set(this, observer);
    }
    return ResizeObserver2;
  }();
  [
    "observe",
    "unobserve",
    "disconnect"
  ].forEach(function(method) {
    ResizeObserver$2.prototype[method] = function() {
      var _a;
      return (_a = observers.get(this))[method].apply(_a, arguments);
    };
  });
  var index$1 = function() {
    if (typeof global$1.ResizeObserver !== "undefined") {
      return global$1.ResizeObserver;
    }
    return ResizeObserver$2;
  }();
  const toKebabCase = (string) => {
    return string.replace(/\B([A-Z])/g, "-$1").toLowerCase();
  };
  var ShapeFlags;
  (function(ShapeFlags2) {
    ShapeFlags2[ShapeFlags2["ELEMENT"] = 1] = "ELEMENT";
    ShapeFlags2[ShapeFlags2["FUNCTIONAL_COMPONENT"] = 2] = "FUNCTIONAL_COMPONENT";
    ShapeFlags2[ShapeFlags2["STATEFUL_COMPONENT"] = 4] = "STATEFUL_COMPONENT";
    ShapeFlags2[ShapeFlags2["COMPONENT"] = 6] = "COMPONENT";
    ShapeFlags2[ShapeFlags2["TEXT_CHILDREN"] = 8] = "TEXT_CHILDREN";
    ShapeFlags2[ShapeFlags2["ARRAY_CHILDREN"] = 16] = "ARRAY_CHILDREN";
    ShapeFlags2[ShapeFlags2["SLOTS_CHILDREN"] = 32] = "SLOTS_CHILDREN";
    ShapeFlags2[ShapeFlags2["TELEPORT"] = 64] = "TELEPORT";
    ShapeFlags2[ShapeFlags2["SUSPENSE"] = 128] = "SUSPENSE";
    ShapeFlags2[ShapeFlags2["COMPONENT_SHOULD_KEEP_ALIVE"] = 256] = "COMPONENT_SHOULD_KEEP_ALIVE";
    ShapeFlags2[ShapeFlags2["COMPONENT_KEPT_ALIVE"] = 512] = "COMPONENT_KEPT_ALIVE";
  })(ShapeFlags || (ShapeFlags = {}));
  var PatchFlags;
  (function(PatchFlags2) {
    PatchFlags2[PatchFlags2["TEXT"] = 1] = "TEXT";
    PatchFlags2[PatchFlags2["CLASS"] = 2] = "CLASS";
    PatchFlags2[PatchFlags2["STYLE"] = 4] = "STYLE";
    PatchFlags2[PatchFlags2["PROPS"] = 8] = "PROPS";
    PatchFlags2[PatchFlags2["FULL_PROPS"] = 16] = "FULL_PROPS";
    PatchFlags2[PatchFlags2["HYDRATE_EVENTS"] = 32] = "HYDRATE_EVENTS";
    PatchFlags2[PatchFlags2["STABLE_FRAGMENT"] = 64] = "STABLE_FRAGMENT";
    PatchFlags2[PatchFlags2["KEYED_FRAGMENT"] = 128] = "KEYED_FRAGMENT";
    PatchFlags2[PatchFlags2["UNKEYED_FRAGMENT"] = 256] = "UNKEYED_FRAGMENT";
    PatchFlags2[PatchFlags2["NEED_PATCH"] = 512] = "NEED_PATCH";
    PatchFlags2[PatchFlags2["DYNAMIC_SLOTS"] = 1024] = "DYNAMIC_SLOTS";
    PatchFlags2[PatchFlags2["DEV_ROOT_FRAGMENT"] = 2048] = "DEV_ROOT_FRAGMENT";
    PatchFlags2[PatchFlags2["HOISTED"] = -1] = "HOISTED";
    PatchFlags2[PatchFlags2["BAIL"] = -2] = "BAIL";
  })(PatchFlags || (PatchFlags = {}));
  const isElement = (vn) => {
    return Boolean(vn && vn.shapeFlag & 1);
  };
  const isComponent = (vn, type) => {
    return Boolean(vn && vn.shapeFlag & 6);
  };
  const isTextChildren = (child, children) => {
    return Boolean(child && child.shapeFlag & 8);
  };
  const isArrayChildren = (vn, children) => {
    return Boolean(vn && vn.shapeFlag & 16);
  };
  const isSlotsChildren = (vn, children) => {
    return Boolean(vn && vn.shapeFlag & 32);
  };
  const getFirstComponent = (children) => {
    var _a, _b;
    if (!children) {
      return void 0;
    }
    for (const child of children) {
      if (isElement(child) || isComponent(child)) {
        return child;
      }
      if (isArrayChildren(child, child.children)) {
        const result = getFirstComponent(child.children);
        if (result)
          return result;
      } else if (isSlotsChildren(child, child.children)) {
        const children2 = (_b = (_a = child.children).default) == null ? void 0 : _b.call(_a);
        if (children2) {
          const result = getFirstComponent(children2);
          if (result)
            return result;
        }
      } else if (isArray$1(child)) {
        const result = getFirstComponent(child);
        if (result)
          return result;
      }
    }
    return void 0;
  };
  const isEmptyChildren = (children) => {
    if (!children) {
      return true;
    }
    for (const item of children) {
      if (item.children) {
        return false;
      }
    }
    return true;
  };
  const mergeFirstChild = (children, extraProps) => {
    if (children && children.length > 0) {
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isElement(child) || isComponent(child)) {
          const props = isFunction$1(extraProps) ? extraProps(child) : extraProps;
          children[i] = vue.cloneVNode(child, props, true);
          return true;
        }
        const _children = getChildrenArray(child);
        if (_children && _children.length > 0) {
          const result = mergeFirstChild(_children, extraProps);
          if (result)
            return true;
        }
      }
    }
    return false;
  };
  const getChildrenArray = (vn) => {
    if (isArrayChildren(vn, vn.children)) {
      return vn.children;
    }
    if (isArray$1(vn)) {
      return vn;
    }
    return void 0;
  };
  const getFirstElementFromVNode = (vn) => {
    var _a, _b;
    if (isElement(vn)) {
      return vn.el;
    }
    if (isComponent(vn)) {
      if (((_a = vn.el) == null ? void 0 : _a.nodeType) === 1) {
        return vn.el;
      }
      if ((_b = vn.component) == null ? void 0 : _b.subTree) {
        const ele = getFirstElementFromVNode(vn.component.subTree);
        if (ele)
          return ele;
      }
    } else {
      const children = getChildrenArray(vn);
      return getFirstElementFromChildren(children);
    }
    return void 0;
  };
  const getFirstElementFromChildren = (children) => {
    if (children && children.length > 0) {
      for (const child of children) {
        const element = getFirstElementFromVNode(child);
        if (element)
          return element;
      }
    }
    return void 0;
  };
  const getAllElements = (children, includeText = false) => {
    var _a, _b;
    const results = [];
    for (const item of children != null ? children : []) {
      if (isElement(item) || isComponent(item) || includeText && isTextChildren(item, item.children)) {
        results.push(item);
      } else if (isArrayChildren(item, item.children)) {
        results.push(...getAllElements(item.children, includeText));
      } else if (isSlotsChildren(item, item.children)) {
        results.push(...getAllElements((_b = (_a = item.children).default) == null ? void 0 : _b.call(_a), includeText));
      } else if (isArray$1(item)) {
        results.push(...getAllElements(item, includeText));
      }
    }
    return results;
  };
  function unFragment(nodeList) {
    function loop(nodes) {
      const unFragmentNodeList = [];
      nodes.forEach((node) => {
        var _a, _b;
        if (vue.isVNode(node) && node.type === vue.Fragment) {
          if (isSlotsChildren(node, node.children)) {
            unFragmentNodeList.push(...loop(((_b = (_a = node.children).default) == null ? void 0 : _b.call(_a)) || []));
          } else if (isArrayChildren(node, node.children)) {
            unFragmentNodeList.push(...loop(node.children));
          } else if (isString$1(node.children)) {
            unFragmentNodeList.push(node.children);
          }
        } else {
          unFragmentNodeList.push(node);
        }
      });
      return unFragmentNodeList;
    }
    return loop(nodeList);
  }
  const getSlotFunction = (param) => {
    if (param) {
      if (isFunction$1(param))
        return param;
      return () => param;
    }
    return void 0;
  };
  const getComponentsFromVNode = (vn, name) => {
    var _a;
    const components2 = [];
    if (isComponent(vn, vn.type)) {
      if (vn.type.name === name) {
        if (vn.component) {
          components2.push(vn.component.uid);
        }
      } else if ((_a = vn.component) == null ? void 0 : _a.subTree) {
        components2.push(...getComponentsFromVNode(vn.component.subTree, name));
      }
    } else {
      const children = getChildrenArray(vn);
      if (children) {
        components2.push(...getComponentsFromChildren(children, name));
      }
    }
    return components2;
  };
  const getComponentsFromChildren = (children, name) => {
    const components2 = [];
    if (children && children.length > 0) {
      for (const child of children) {
        components2.push(...getComponentsFromVNode(child, name));
      }
    }
    return components2;
  };
  var ResizeObserver$1 = vue.defineComponent({
    name: "ResizeObserver",
    emits: [
      "resize"
    ],
    setup(props, {
      emit,
      slots
    }) {
      let resizeObserver;
      const componentRef = vue.ref();
      const element = vue.computed(() => isComponentInstance(componentRef.value) ? componentRef.value.$el : componentRef.value);
      const createResizeObserver = (target2) => {
        if (!target2)
          return;
        resizeObserver = new index$1((entries) => {
          const entry = entries[0];
          emit("resize", entry);
        });
        resizeObserver.observe(target2);
      };
      const destroyResizeObserver = () => {
        if (resizeObserver) {
          resizeObserver.disconnect();
          resizeObserver = null;
        }
      };
      vue.watch(element, (_element) => {
        if (resizeObserver)
          destroyResizeObserver();
        if (_element)
          createResizeObserver(_element);
      });
      vue.onMounted(() => {
        if (element.value) {
          createResizeObserver(element.value);
        }
      });
      vue.onUnmounted(() => {
        destroyResizeObserver();
      });
      return () => {
        var _a, _b;
        const firstChild = getFirstComponent((_b = (_a = slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : []);
        if (firstChild) {
          return vue.cloneVNode(firstChild, {
            ref: componentRef
          }, true);
        }
        return null;
      };
    }
  });
  const target$1 = typeof window === "undefined" ? global : window;
  const raf = target$1.requestAnimationFrame;
  const caf = target$1.cancelAnimationFrame;
  function throttleByRaf(cb) {
    let timer = 0;
    const throttle2 = (...args) => {
      if (timer) {
        caf(timer);
      }
      timer = raf(() => {
        cb(...args);
        timer = 0;
      });
    };
    throttle2.cancel = () => {
      caf(timer);
      timer = 0;
    };
    return throttle2;
  }
  const NOOP = () => {
    return void 0;
  };
  const isServerRendering = (() => {
    try {
      return !(typeof window !== "undefined" && document !== void 0);
    } catch (e2) {
      return true;
    }
  })();
  const on = (() => {
    if (isServerRendering) {
      return NOOP;
    }
    return (element, event, handler, options = false) => {
      element.addEventListener(event, handler, options);
    };
  })();
  const off = (() => {
    if (isServerRendering) {
      return NOOP;
    }
    return (element, type, handler, options = false) => {
      element.removeEventListener(type, handler, options);
    };
  })();
  const contains = (root, ele) => {
    if (!root || !ele) {
      return false;
    }
    let node = ele;
    while (node) {
      if (node === root) {
        return true;
      }
      node = node.parentNode;
    }
    return false;
  };
  const getOverlay = (type) => {
    const popper = document.createElement("div");
    popper.setAttribute("class", `arco-overlay arco-overlay-${type}`);
    return popper;
  };
  const querySelector = (selectors, container2) => {
    var _a;
    if (isServerRendering) {
      return NOOP();
    }
    return (_a = (container2 != null ? container2 : document).querySelector(selectors)) != null ? _a : void 0;
  };
  const getElement = (target2, container2) => {
    if (isString$1(target2)) {
      const selector = target2[0] === "#" ? `[id='${target2.slice(1)}']` : target2;
      return querySelector(selector, container2);
    }
    return target2;
  };
  const getRelativeRect = (target2, relative) => {
    const targetRect = target2.getBoundingClientRect();
    const relativeRect = relative.getBoundingClientRect();
    return {
      top: targetRect.top - relativeRect.top,
      bottom: relativeRect.bottom - targetRect.bottom,
      left: targetRect.left - relativeRect.left,
      right: relativeRect.right - targetRect.right,
      width: targetRect.width,
      height: targetRect.height
    };
  };
  const isScroll = (element) => {
    return element.tagName === "BODY" ? document.documentElement.scrollHeight > window.innerHeight : element.scrollHeight > element.offsetHeight;
  };
  const getScrollBarWidth = (element) => {
    return element.tagName === "BODY" ? window.innerWidth - (document.documentElement.offsetWidth || document.body.offsetWidth) : element.offsetWidth - element.clientWidth;
  };
  var _export_sfc = (sfc, props) => {
    for (const [key, val] of props) {
      sfc[key] = val;
    }
    return sfc;
  };
  function getTargetRect(target2) {
    return isWindow(target2) ? {
      top: 0,
      bottom: window.innerHeight
    } : target2.getBoundingClientRect();
  }
  const _sfc_main$30 = vue.defineComponent({
    name: "Affix",
    components: {
      ResizeObserver: ResizeObserver$1
    },
    props: {
      offsetTop: {
        type: Number,
        default: 0
      },
      offsetBottom: {
        type: Number
      },
      target: {
        type: [String, Object, Function]
      },
      targetContainer: {
        type: [String, Object, Function]
      }
    },
    emits: {
      change: (fixed) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("affix");
      const { target: target2, targetContainer } = vue.toRefs(props);
      const wrapperRef = vue.ref();
      const targetRef = vue.ref();
      const isFixed = vue.ref(false);
      const placeholderStyles = vue.ref({});
      const fixedStyles = vue.ref({});
      const classNames = vue.computed(() => ({ [prefixCls]: isFixed.value }));
      const updatePositionThrottle = throttleByRaf(() => {
        if (!wrapperRef.value || !targetRef.value)
          return;
        const { offsetTop, offsetBottom } = props;
        const offsetType = isUndefined(offsetBottom) ? "top" : "bottom";
        const wrapperRect = wrapperRef.value.getBoundingClientRect();
        const targetRect = getTargetRect(targetRef.value);
        let newIsFixed = false;
        let newFixedStyles = {};
        const newPlaceholderStyles = {
          width: `${wrapperRef.value.offsetWidth}px`,
          height: `${wrapperRef.value.offsetHeight}px`
        };
        if (offsetType === "top") {
          newIsFixed = wrapperRect.top - targetRect.top < (offsetTop || 0);
          newFixedStyles = newIsFixed ? {
            position: "fixed",
            top: `${targetRect.top + (offsetTop || 0)}px`
          } : {};
        } else {
          newIsFixed = targetRect.bottom - wrapperRect.bottom < (offsetBottom || 0);
          newFixedStyles = newIsFixed ? {
            position: "fixed",
            bottom: `${window.innerHeight - targetRect.bottom + (offsetBottom || 0)}px`
          } : {};
        }
        if (newIsFixed !== isFixed.value) {
          isFixed.value = newIsFixed;
          emit("change", newIsFixed);
        }
        placeholderStyles.value = newPlaceholderStyles;
        fixedStyles.value = __spreadValues(__spreadValues({}, newFixedStyles), newIsFixed ? newPlaceholderStyles : {});
      });
      vue.onMounted(() => {
        vue.watchEffect((onInvalidate) => {
          const element = target2 && target2.value !== window && getElement(target2.value) || window;
          targetRef.value = element;
          if (element) {
            on(element, "scroll", updatePositionThrottle);
            on(element, "resize", updatePositionThrottle);
            onInvalidate(() => {
              off(element, "scroll", updatePositionThrottle);
              off(element, "resize", updatePositionThrottle);
            });
          }
        });
        vue.watchEffect((onInvalidate) => {
          if (!targetRef.value)
            return;
          const container2 = targetContainer && targetContainer.value !== window && getElement(targetContainer.value) || window;
          if (container2) {
            on(container2, "scroll", updatePositionThrottle);
            on(container2, "resize", updatePositionThrottle);
            onInvalidate(() => {
              off(container2, "scroll", updatePositionThrottle);
              off(container2, "resize", updatePositionThrottle);
            });
          }
        });
      });
      return {
        wrapperRef,
        isFixed,
        classNames,
        placeholderStyles,
        fixedStyles,
        updatePositionThrottle
      };
    },
    methods: {
      updatePosition() {
        this.updatePositionThrottle();
      }
    }
  });
  const _hoisted_1$1k = { ref: "wrapperRef" };
  function _sfc_render$2$(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_ResizeObserver = vue.resolveComponent("ResizeObserver");
    return vue.openBlock(), vue.createBlock(_component_ResizeObserver, { onResize: _ctx.updatePositionThrottle }, {
      default: vue.withCtx(() => [
        vue.createElementVNode("div", _hoisted_1$1k, [
          _ctx.isFixed ? (vue.openBlock(), vue.createElementBlock("div", {
            key: 0,
            style: vue.normalizeStyle(_ctx.placeholderStyles)
          }, null, 4)) : vue.createCommentVNode("v-if", true),
          vue.createElementVNode("div", {
            class: vue.normalizeClass(_ctx.classNames),
            style: vue.normalizeStyle(_ctx.fixedStyles)
          }, [
            vue.createVNode(_component_ResizeObserver, { onResize: _ctx.updatePositionThrottle }, {
              default: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["onResize"])
          ], 6)
        ], 512)
      ]),
      _: 3
    }, 8, ["onResize"]);
  }
  var _Affix = /* @__PURE__ */ _export_sfc(_sfc_main$30, [["render", _sfc_render$2$]]);
  const Affix = Object.assign(_Affix, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Affix.name, _Affix);
    }
  });
  const _sfc_main$2$ = vue.defineComponent({
    name: "IconHover",
    props: {
      prefix: {
        type: String
      },
      size: {
        type: String,
        default: "medium"
      },
      disabled: {
        type: Boolean,
        default: false
      }
    },
    setup() {
      const prefixCls = getPrefixCls("icon-hover");
      return {
        prefixCls
      };
    }
  });
  function _sfc_render$2_(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("span", {
      class: vue.normalizeClass([
        _ctx.prefixCls,
        {
          [`${_ctx.prefix}-icon-hover`]: _ctx.prefix,
          [`${_ctx.prefixCls}-size-${_ctx.size}`]: _ctx.size !== "medium",
          [`${_ctx.prefixCls}-disabled`]: _ctx.disabled
        }
      ])
    }, [
      vue.renderSlot(_ctx.$slots, "default")
    ], 2);
  }
  var IconHover = /* @__PURE__ */ _export_sfc(_sfc_main$2$, [["render", _sfc_render$2_]]);
  const _sfc_main$2_ = vue.defineComponent({
    name: "IconClose",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-close`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$1j = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$12 = /* @__PURE__ */ vue.createElementVNode("path", { d: "M9.857 9.858 24 24m0 0 14.142 14.142M24 24 38.142 9.858M24 24 9.857 38.142" }, null, -1);
  const _hoisted_3$Z = [
    _hoisted_2$12
  ];
  function _sfc_render$2Z(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$Z, 14, _hoisted_1$1j);
  }
  var _IconClose = /* @__PURE__ */ _export_sfc(_sfc_main$2_, [["render", _sfc_render$2Z]]);
  const IconClose = Object.assign(_IconClose, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconClose.name, _IconClose);
    }
  });
  const _sfc_main$2Z = vue.defineComponent({
    name: "IconInfoCircleFill",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-info-circle-fill`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$1i = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$11 = /* @__PURE__ */ vue.createElementVNode("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm2-30a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-2Zm0 17h1a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-6a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1h1v-8a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1h3a1 1 0 0 1 1 1v11Z",
    fill: "currentColor",
    stroke: "none"
  }, null, -1);
  const _hoisted_3$Y = [
    _hoisted_2$11
  ];
  function _sfc_render$2Y(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$Y, 14, _hoisted_1$1i);
  }
  var _IconInfoCircleFill = /* @__PURE__ */ _export_sfc(_sfc_main$2Z, [["render", _sfc_render$2Y]]);
  const IconInfoCircleFill = Object.assign(_IconInfoCircleFill, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconInfoCircleFill.name, _IconInfoCircleFill);
    }
  });
  const _sfc_main$2Y = vue.defineComponent({
    name: "IconCheckCircleFill",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-check-circle-fill`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$1h = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$10 = /* @__PURE__ */ vue.createElementVNode("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm10.207-24.379a1 1 0 0 0 0-1.414l-1.414-1.414a1 1 0 0 0-1.414 0L22 26.172l-4.878-4.88a1 1 0 0 0-1.415 0l-1.414 1.415a1 1 0 0 0 0 1.414l7 7a1 1 0 0 0 1.414 0l11.5-11.5Z",
    fill: "currentColor",
    stroke: "none"
  }, null, -1);
  const _hoisted_3$X = [
    _hoisted_2$10
  ];
  function _sfc_render$2X(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$X, 14, _hoisted_1$1h);
  }
  var _IconCheckCircleFill = /* @__PURE__ */ _export_sfc(_sfc_main$2Y, [["render", _sfc_render$2X]]);
  const IconCheckCircleFill = Object.assign(_IconCheckCircleFill, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconCheckCircleFill.name, _IconCheckCircleFill);
    }
  });
  const _sfc_main$2X = vue.defineComponent({
    name: "IconExclamationCircleFill",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-exclamation-circle-fill`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$1g = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$$ = /* @__PURE__ */ vue.createElementVNode("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm-2-11a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v2Zm4-18a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V15Z",
    fill: "currentColor",
    stroke: "none"
  }, null, -1);
  const _hoisted_3$W = [
    _hoisted_2$$
  ];
  function _sfc_render$2W(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$W, 14, _hoisted_1$1g);
  }
  var _IconExclamationCircleFill = /* @__PURE__ */ _export_sfc(_sfc_main$2X, [["render", _sfc_render$2W]]);
  const IconExclamationCircleFill = Object.assign(_IconExclamationCircleFill, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconExclamationCircleFill.name, _IconExclamationCircleFill);
    }
  });
  const _sfc_main$2W = vue.defineComponent({
    name: "IconCloseCircleFill",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-close-circle-fill`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$1f = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$_ = /* @__PURE__ */ vue.createElementVNode("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm4.955-27.771-4.95 4.95-4.95-4.95a1 1 0 0 0-1.414 0l-1.414 1.414a1 1 0 0 0 0 1.414l4.95 4.95-4.95 4.95a1 1 0 0 0 0 1.414l1.414 1.414a1 1 0 0 0 1.414 0l4.95-4.95 4.95 4.95a1 1 0 0 0 1.414 0l1.414-1.414a1 1 0 0 0 0-1.414l-4.95-4.95 4.95-4.95a1 1 0 0 0 0-1.414l-1.414-1.414a1 1 0 0 0-1.414 0Z",
    fill: "currentColor",
    stroke: "none"
  }, null, -1);
  const _hoisted_3$V = [
    _hoisted_2$_
  ];
  function _sfc_render$2V(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$V, 14, _hoisted_1$1f);
  }
  var _IconCloseCircleFill = /* @__PURE__ */ _export_sfc(_sfc_main$2W, [["render", _sfc_render$2V]]);
  const IconCloseCircleFill = Object.assign(_IconCloseCircleFill, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconCloseCircleFill.name, _IconCloseCircleFill);
    }
  });
  const _sfc_main$2V = vue.defineComponent({
    name: "Alert",
    components: {
      IconHover,
      IconClose,
      IconInfoCircleFill,
      IconCheckCircleFill,
      IconExclamationCircleFill,
      IconCloseCircleFill
    },
    props: {
      type: {
        type: String,
        default: "info"
      },
      showIcon: {
        type: Boolean,
        default: true
      },
      closable: {
        type: Boolean,
        default: false
      },
      title: String,
      banner: {
        type: Boolean,
        default: false
      },
      center: {
        type: Boolean,
        default: false
      }
    },
    emits: {
      close: (ev) => true,
      afterClose: () => true
    },
    setup(props, { slots, emit }) {
      const prefixCls = getPrefixCls("alert");
      const visible = vue.ref(true);
      const handleClose = (ev) => {
        visible.value = false;
        emit("close", ev);
      };
      const handleAfterLeave = () => {
        emit("afterClose");
      };
      const cls = vue.computed(() => [
        prefixCls,
        `${prefixCls}-${props.type}`,
        {
          [`${prefixCls}-with-title`]: Boolean(props.title || slots.title),
          [`${prefixCls}-banner`]: props.banner,
          [`${prefixCls}-center`]: props.center
        }
      ]);
      return {
        prefixCls,
        cls,
        visible,
        handleClose,
        handleAfterLeave
      };
    }
  });
  function _sfc_render$2U(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_icon_info_circle_fill = vue.resolveComponent("icon-info-circle-fill");
    const _component_icon_check_circle_fill = vue.resolveComponent("icon-check-circle-fill");
    const _component_icon_exclamation_circle_fill = vue.resolveComponent("icon-exclamation-circle-fill");
    const _component_icon_close_circle_fill = vue.resolveComponent("icon-close-circle-fill");
    const _component_icon_close = vue.resolveComponent("icon-close");
    const _component_icon_hover = vue.resolveComponent("icon-hover");
    return vue.openBlock(), vue.createBlock(vue.Transition, {
      name: "zoom-in-top",
      onAfterLeave: _ctx.handleAfterLeave
    }, {
      default: vue.withCtx(() => [
        _ctx.visible ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 0,
          role: "alert",
          class: vue.normalizeClass(_ctx.cls)
        }, [
          _ctx.showIcon && !(_ctx.type === "normal" && !_ctx.$slots.icon) ? (vue.openBlock(), vue.createElementBlock("div", {
            key: 0,
            class: vue.normalizeClass(`${_ctx.prefixCls}-icon`)
          }, [
            vue.renderSlot(_ctx.$slots, "icon", {}, () => [
              _ctx.type === "info" ? (vue.openBlock(), vue.createBlock(_component_icon_info_circle_fill, { key: 0 })) : _ctx.type === "success" ? (vue.openBlock(), vue.createBlock(_component_icon_check_circle_fill, { key: 1 })) : _ctx.type === "warning" ? (vue.openBlock(), vue.createBlock(_component_icon_exclamation_circle_fill, { key: 2 })) : _ctx.type === "error" ? (vue.openBlock(), vue.createBlock(_component_icon_close_circle_fill, { key: 3 })) : vue.createCommentVNode("v-if", true)
            ])
          ], 2)) : vue.createCommentVNode("v-if", true),
          vue.createElementVNode("div", {
            class: vue.normalizeClass(`${_ctx.prefixCls}-body`)
          }, [
            _ctx.title || _ctx.$slots.title ? (vue.openBlock(), vue.createElementBlock("div", {
              key: 0,
              class: vue.normalizeClass(`${_ctx.prefixCls}-title`)
            }, [
              vue.renderSlot(_ctx.$slots, "title", {}, () => [
                vue.createTextVNode(vue.toDisplayString(_ctx.title), 1)
              ])
            ], 2)) : vue.createCommentVNode("v-if", true),
            vue.createElementVNode("div", {
              class: vue.normalizeClass(`${_ctx.prefixCls}-content`)
            }, [
              vue.renderSlot(_ctx.$slots, "default")
            ], 2)
          ], 2),
          _ctx.$slots.action ? (vue.openBlock(), vue.createElementBlock("div", {
            key: 1,
            class: vue.normalizeClass(`${_ctx.prefixCls}-action`)
          }, [
            vue.renderSlot(_ctx.$slots, "action")
          ], 2)) : vue.createCommentVNode("v-if", true),
          _ctx.closable ? (vue.openBlock(), vue.createElementBlock("div", {
            key: 2,
            tabindex: "-1",
            role: "button",
            "aria-label": "Close",
            class: vue.normalizeClass(`${_ctx.prefixCls}-close-btn`),
            onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClose && _ctx.handleClose(...args))
          }, [
            vue.renderSlot(_ctx.$slots, "close-element", {}, () => [
              vue.createVNode(_component_icon_hover, null, {
                default: vue.withCtx(() => [
                  vue.createVNode(_component_icon_close)
                ]),
                _: 1
              })
            ])
          ], 2)) : vue.createCommentVNode("v-if", true)
        ], 2)) : vue.createCommentVNode("v-if", true)
      ]),
      _: 3
    }, 8, ["onAfterLeave"]);
  }
  var _Alert = /* @__PURE__ */ _export_sfc(_sfc_main$2V, [["render", _sfc_render$2U]]);
  const Alert = Object.assign(_Alert, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Alert.name, _Alert);
    }
  });
  function t(t2) {
    return typeof t2 == "object" && t2 != null && t2.nodeType === 1;
  }
  function e(t2, e2) {
    return (!e2 || t2 !== "hidden") && t2 !== "visible" && t2 !== "clip";
  }
  function n(t2, n2) {
    if (t2.clientHeight < t2.scrollHeight || t2.clientWidth < t2.scrollWidth) {
      var r2 = getComputedStyle(t2, null);
      return e(r2.overflowY, n2) || e(r2.overflowX, n2) || function(t3) {
        var e2 = function(t4) {
          if (!t4.ownerDocument || !t4.ownerDocument.defaultView)
            return null;
          try {
            return t4.ownerDocument.defaultView.frameElement;
          } catch (t5) {
            return null;
          }
        }(t3);
        return !!e2 && (e2.clientHeight < t3.scrollHeight || e2.clientWidth < t3.scrollWidth);
      }(t2);
    }
    return false;
  }
  function r(t2, e2, n2, r2, i, o, l, d) {
    return o < t2 && l > e2 || o > t2 && l < e2 ? 0 : o <= t2 && d <= n2 || l >= e2 && d >= n2 ? o - t2 - r2 : l > e2 && d < n2 || o < t2 && d > n2 ? l - e2 + i : 0;
  }
  function compute(e2, i) {
    var o = window, l = i.scrollMode, d = i.block, u = i.inline, h = i.boundary, a = i.skipOverflowHiddenElements, c = typeof h == "function" ? h : function(t2) {
      return t2 !== h;
    };
    if (!t(e2))
      throw new TypeError("Invalid target");
    for (var f = document.scrollingElement || document.documentElement, s = [], p = e2; t(p) && c(p); ) {
      if ((p = p.parentElement) === f) {
        s.push(p);
        break;
      }
      p != null && p === document.body && n(p) && !n(document.documentElement) || p != null && n(p, a) && s.push(p);
    }
    for (var m = o.visualViewport ? o.visualViewport.width : innerWidth, g = o.visualViewport ? o.visualViewport.height : innerHeight, w = window.scrollX || pageXOffset, v = window.scrollY || pageYOffset, W = e2.getBoundingClientRect(), b = W.height, H = W.width, y = W.top, E = W.right, M = W.bottom, V = W.left, x = d === "start" || d === "nearest" ? y : d === "end" ? M : y + b / 2, I = u === "center" ? V + H / 2 : u === "end" ? E : V, C = [], T = 0; T < s.length; T++) {
      var k = s[T], B = k.getBoundingClientRect(), D = B.height, O = B.width, R = B.top, X = B.right, Y = B.bottom, L = B.left;
      if (l === "if-needed" && y >= 0 && V >= 0 && M <= g && E <= m && y >= R && M <= Y && V >= L && E <= X)
        return C;
      var S = getComputedStyle(k), j = parseInt(S.borderLeftWidth, 10), q = parseInt(S.borderTopWidth, 10), z = parseInt(S.borderRightWidth, 10), A = parseInt(S.borderBottomWidth, 10), F = 0, G = 0, J = "offsetWidth" in k ? k.offsetWidth - k.clientWidth - j - z : 0, K = "offsetHeight" in k ? k.offsetHeight - k.clientHeight - q - A : 0;
      if (f === k)
        F = d === "start" ? x : d === "end" ? x - g : d === "nearest" ? r(v, v + g, g, q, A, v + x, v + x + b, b) : x - g / 2, G = u === "start" ? I : u === "center" ? I - m / 2 : u === "end" ? I - m : r(w, w + m, m, j, z, w + I, w + I + H, H), F = Math.max(0, F + v), G = Math.max(0, G + w);
      else {
        F = d === "start" ? x - R - q : d === "end" ? x - Y + A + K : d === "nearest" ? r(R, Y, D, q, A + K, x, x + b, b) : x - (R + D / 2) + K / 2, G = u === "start" ? I - L - j : u === "center" ? I - (L + O / 2) + J / 2 : u === "end" ? I - X + z + J : r(L, X, O, j, z + J, I, I + H, H);
        var N = k.scrollLeft, P = k.scrollTop;
        x += P - (F = Math.max(0, Math.min(P + F, k.scrollHeight - D + K))), I += N - (G = Math.max(0, Math.min(N + G, k.scrollWidth - O + J)));
      }
      C.push({ el: k, top: F, left: G });
    }
    return C;
  }
  var easeInBy = function(power) {
    return function(t2) {
      return Math.pow(t2, power);
    };
  };
  var easeOutBy = function(power) {
    return function(t2) {
      return 1 - Math.abs(Math.pow(t2 - 1, power));
    };
  };
  var easeInOutBy = function(power) {
    return function(t2) {
      return t2 < 0.5 ? easeInBy(power)(t2 * 2) / 2 : easeOutBy(power)(t2 * 2 - 1) / 2 + 0.5;
    };
  };
  var linear = function(t2) {
    return t2;
  };
  var quadIn = easeInBy(2);
  var quadOut = easeOutBy(2);
  var quadInOut = easeInOutBy(2);
  var cubicIn = easeInBy(3);
  var cubicOut = easeOutBy(3);
  var cubicInOut = easeInOutBy(3);
  var quartIn = easeInBy(4);
  var quartOut = easeOutBy(4);
  var quartInOut = easeInOutBy(4);
  var quintIn = easeInBy(5);
  var quintOut = easeOutBy(5);
  var quintInOut = easeInOutBy(5);
  var sineIn = function(t2) {
    return 1 + Math.sin(Math.PI / 2 * t2 - Math.PI / 2);
  };
  var sineOut = function(t2) {
    return Math.sin(Math.PI / 2 * t2);
  };
  var sineInOut = function(t2) {
    return (1 + Math.sin(Math.PI * t2 - Math.PI / 2)) / 2;
  };
  var bounceOut = function(t2) {
    var s = 7.5625;
    var p = 2.75;
    if (t2 < 1 / p) {
      return s * t2 * t2;
    }
    if (t2 < 2 / p) {
      t2 -= 1.5 / p;
      return s * t2 * t2 + 0.75;
    }
    if (t2 < 2.5 / p) {
      t2 -= 2.25 / p;
      return s * t2 * t2 + 0.9375;
    }
    t2 -= 2.625 / p;
    return s * t2 * t2 + 0.984375;
  };
  var bounceIn = function(t2) {
    return 1 - bounceOut(1 - t2);
  };
  var bounceInOut = function(t2) {
    return t2 < 0.5 ? bounceIn(t2 * 2) * 0.5 : bounceOut(t2 * 2 - 1) * 0.5 + 0.5;
  };
  var easing = /* @__PURE__ */ Object.freeze({
    linear,
    quadIn,
    quadOut,
    quadInOut,
    cubicIn,
    cubicOut,
    cubicInOut,
    quartIn,
    quartOut,
    quartInOut,
    quintIn,
    quintOut,
    quintInOut,
    sineIn,
    sineOut,
    sineInOut,
    bounceOut,
    bounceIn,
    bounceInOut
  });
  var Tween = function Tween2(settings) {
    var from = settings.from;
    var to = settings.to;
    var duration = settings.duration;
    var delay = settings.delay;
    var easing2 = settings.easing;
    var onStart = settings.onStart;
    var onUpdate = settings.onUpdate;
    var onFinish = settings.onFinish;
    for (var key in from) {
      if (to[key] === void 0) {
        to[key] = from[key];
      }
    }
    for (var key$1 in to) {
      if (from[key$1] === void 0) {
        from[key$1] = to[key$1];
      }
    }
    this.from = from;
    this.to = to;
    this.duration = duration || 500;
    this.delay = delay || 0;
    this.easing = easing2 || "linear";
    this.onStart = onStart;
    this.onUpdate = onUpdate || function() {
    };
    this.onFinish = onFinish;
    this.startTime = Date.now() + this.delay;
    this.started = false;
    this.finished = false;
    this.timer = null;
    this.keys = {};
  };
  Tween.prototype.update = function update() {
    this.time = Date.now();
    if (this.time < this.startTime) {
      return;
    }
    if (this.finished) {
      return;
    }
    if (this.elapsed === this.duration) {
      if (!this.finished) {
        this.finished = true;
        this.onFinish && this.onFinish(this.keys);
      }
      return;
    }
    this.elapsed = this.time - this.startTime;
    this.elapsed = this.elapsed > this.duration ? this.duration : this.elapsed;
    for (var key in this.to) {
      this.keys[key] = this.from[key] + (this.to[key] - this.from[key]) * easing[this.easing](this.elapsed / this.duration);
    }
    if (!this.started) {
      this.onStart && this.onStart(this.keys);
      this.started = true;
    }
    this.onUpdate(this.keys);
  };
  Tween.prototype.start = function start() {
    var this$1$1 = this;
    this.startTime = Date.now() + this.delay;
    var tick = function() {
      this$1$1.update();
      this$1$1.timer = requestAnimationFrame(tick);
      if (this$1$1.finished) {
        cancelAnimationFrame(this$1$1.timer);
        this$1$1.timer = null;
      }
    };
    tick();
  };
  Tween.prototype.stop = function stop() {
    cancelAnimationFrame(this.timer);
    this.timer = null;
  };
  function slide(el, top, cb) {
    const tween = new Tween({
      from: {
        scrollTop: el.scrollTop
      },
      to: {
        scrollTop: top
      },
      easing: "quartOut",
      duration: 300,
      onUpdate: (keys) => {
        el.scrollTop = keys.scrollTop;
      },
      onFinish: () => {
        if (isFunction$1(cb)) {
          cb();
        }
      }
    });
    tween.start();
  }
  const anchorInjectionKey = Symbol("ArcoAnchor");
  const BOUNDARY_POSITIONS = ["start", "end", "center", "nearest"];
  const _sfc_main$2U = vue.defineComponent({
    name: "Anchor",
    props: {
      boundary: {
        type: [Number, String],
        default: "start",
        validator: (value) => {
          return isNumber$1(value) || BOUNDARY_POSITIONS.includes(value);
        }
      },
      lineLess: {
        type: Boolean,
        default: false
      },
      scrollContainer: {
        type: [String, Object]
      },
      changeHash: {
        type: Boolean,
        default: true
      },
      smooth: {
        type: Boolean,
        default: true
      }
    },
    emits: {
      select: (hash, preHash) => true,
      change: (hash) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("anchor");
      const anchorRef = vue.ref();
      const lineSliderRef = vue.ref();
      const links = vue.reactive({});
      const currentLink = vue.ref("");
      const isScrolling = vue.ref(false);
      const scrollContainerEle = vue.ref();
      const containerEle = vue.ref();
      const addLink = (hash, node) => {
        if (!hash)
          return;
        links[hash] = node;
      };
      const removeLink = (hash) => {
        delete links[hash];
      };
      const handleClick = (e2, hash) => {
        if (!props.changeHash) {
          e2.preventDefault();
        }
        if (hash) {
          scrollIntoView2(hash);
          handleAnchorChange(hash);
        }
        emit("select", hash, currentLink.value);
      };
      const scrollIntoView2 = (hash) => {
        try {
          const element = getElement(hash);
          if (!element)
            return;
          let block;
          let diff = 0;
          if (isNumber$1(props.boundary)) {
            block = "start";
            diff = props.boundary;
          } else {
            block = props.boundary;
          }
          const actions = compute(element, { block });
          if (!actions.length)
            return;
          const { el, top } = actions[0];
          const targetTop = top - diff;
          slide(el, targetTop, () => {
            isScrolling.value = false;
          });
          isScrolling.value = true;
        } catch (e2) {
          console.error(e2);
        }
      };
      const handleScroll = throttleByRaf(() => {
        if (isScrolling.value)
          return;
        const element = getFirstInViewportEle();
        if (element && element.id) {
          const hash = `#${element.id}`;
          handleAnchorChange(hash);
        }
      });
      const handleAnchorChange = (hash) => {
        if (!links[hash] && anchorRef.value) {
          const element = getElement(`a[data-href='${hash}']`, anchorRef.value);
          if (!element)
            return;
          links[hash] = element;
        }
        if (hash !== currentLink.value) {
          currentLink.value = hash;
          vue.nextTick(() => {
            emit("change", hash);
          });
        }
      };
      const getFirstInViewportEle = () => {
        if (!scrollContainerEle.value || !containerEle.value) {
          return void 0;
        }
        const boundary = isNumber$1(props.boundary) ? props.boundary : 0;
        const containerRect = containerEle.value.getBoundingClientRect();
        for (const hash of Object.keys(links)) {
          const element = getElement(hash);
          if (element) {
            const { top } = element.getBoundingClientRect();
            const offsetTop = isWindow(scrollContainerEle.value) ? top - boundary : top - containerRect.top - boundary;
            if (offsetTop >= 0 && offsetTop <= containerRect.height / 2) {
              return element;
            }
          }
        }
        return void 0;
      };
      vue.watch(currentLink, () => {
        const link = links[currentLink.value];
        if (!props.lineLess && link && lineSliderRef.value) {
          lineSliderRef.value.style.top = `${link.offsetTop}px`;
        }
      });
      const bindScrollEvent = () => {
        if (scrollContainerEle.value) {
          on(scrollContainerEle.value, "scroll", handleScroll);
        }
      };
      const unbindScrollEvent = () => {
        if (scrollContainerEle.value) {
          off(scrollContainerEle.value, "scroll", handleScroll);
        }
      };
      const getContainer = () => {
        if (props.scrollContainer) {
          scrollContainerEle.value = isWindow(props.scrollContainer) ? window : getElement(props.scrollContainer);
          containerEle.value = isWindow(props.scrollContainer) ? document.documentElement : getElement(props.scrollContainer);
        } else {
          scrollContainerEle.value = window;
          containerEle.value = document.documentElement;
        }
      };
      vue.onMounted(() => {
        getContainer();
        const hash = decodeURIComponent(window.location.hash);
        if (hash) {
          scrollIntoView2(hash);
          handleAnchorChange(hash);
        } else {
          handleScroll();
        }
        bindScrollEvent();
      });
      vue.onBeforeUnmount(() => {
        unbindScrollEvent();
      });
      vue.provide(anchorInjectionKey, vue.reactive({
        currentLink,
        addLink,
        removeLink,
        handleClick
      }));
      const cls = vue.computed(() => [
        prefixCls,
        {
          [`${prefixCls}-line-less`]: props.lineLess
        }
      ]);
      return {
        prefixCls,
        cls,
        anchorRef,
        lineSliderRef
      };
    }
  });
  function _sfc_render$2T(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      ref: "anchorRef",
      class: vue.normalizeClass(_ctx.cls)
    }, [
      !_ctx.lineLess ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        ref: "lineSliderRef",
        class: vue.normalizeClass(`${_ctx.prefixCls}-line-slider`)
      }, null, 2)) : vue.createCommentVNode("v-if", true),
      vue.createElementVNode("ul", {
        class: vue.normalizeClass(`${_ctx.prefixCls}-list`)
      }, [
        vue.renderSlot(_ctx.$slots, "default")
      ], 2)
    ], 2);
  }
  var _Anchor = /* @__PURE__ */ _export_sfc(_sfc_main$2U, [["render", _sfc_render$2T]]);
  const _sfc_main$2T = vue.defineComponent({
    name: "AnchorLink",
    props: {
      title: String,
      href: String
    },
    setup(props) {
      const prefixCls = getPrefixCls("anchor");
      const linkCls = `${prefixCls}-link`;
      const linkRef = vue.ref();
      const context = vue.inject(anchorInjectionKey, void 0);
      vue.onMounted(() => {
        if (props.href && linkRef.value) {
          context == null ? void 0 : context.addLink(props.href, linkRef.value);
        }
      });
      const cls = vue.computed(() => [
        `${linkCls}-item`,
        {
          [`${linkCls}-active`]: (context == null ? void 0 : context.currentLink) === props.href
        }
      ]);
      const handleClick = (e2) => context == null ? void 0 : context.handleClick(e2, props.href);
      return {
        prefixCls,
        linkCls,
        cls,
        linkRef,
        handleClick
      };
    }
  });
  const _hoisted_1$1e = ["href"];
  function _sfc_render$2S(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("li", {
      ref: "linkRef",
      class: vue.normalizeClass(_ctx.cls)
    }, [
      vue.createElementVNode("a", {
        class: vue.normalizeClass(_ctx.linkCls),
        href: _ctx.href,
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
      }, [
        vue.renderSlot(_ctx.$slots, "default", {}, () => [
          vue.createTextVNode(vue.toDisplayString(_ctx.title), 1)
        ])
      ], 10, _hoisted_1$1e),
      _ctx.$slots.sublist ? (vue.openBlock(), vue.createElementBlock("ul", {
        key: 0,
        class: vue.normalizeClass(`${_ctx.prefixCls}-sublist`)
      }, [
        vue.renderSlot(_ctx.$slots, "sublist")
      ], 2)) : vue.createCommentVNode("v-if", true)
    ], 2);
  }
  var AnchorLink = /* @__PURE__ */ _export_sfc(_sfc_main$2T, [["render", _sfc_render$2S]]);
  const Anchor = Object.assign(_Anchor, {
    Link: AnchorLink,
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Anchor.name, _Anchor);
      app.component(componentPrefix + AnchorLink.name, AnchorLink);
    }
  });
  const MESSAGE_TYPES = ["info", "success", "warning", "error"];
  const INPUT_EVENTS = [
    "onFocus",
    "onFocusin",
    "onFocusout",
    "onBlur",
    "onChange",
    "onBeforeinput",
    "onInput",
    "onReset",
    "onSubmit",
    "onInvalid",
    "onKeydown",
    "onKeypress",
    "onKeyup",
    "onCopy",
    "onCut",
    "onPaste",
    "onCompositionstart",
    "onCompositionupdate",
    "onCompositionend",
    "onSelect",
    "autocomplete",
    "autofocus",
    "maxlength",
    "minlength",
    "name",
    "pattern",
    "readonly",
    "required"
  ];
  const _sfc_main$2S = vue.defineComponent({
    name: "IconLoading",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-loading`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$1d = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$Z = /* @__PURE__ */ vue.createElementVNode("path", { d: "M42 24c0 9.941-8.059 18-18 18S6 33.941 6 24 14.059 6 24 6" }, null, -1);
  const _hoisted_3$U = [
    _hoisted_2$Z
  ];
  function _sfc_render$2R(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$U, 14, _hoisted_1$1d);
  }
  var _IconLoading = /* @__PURE__ */ _export_sfc(_sfc_main$2S, [["render", _sfc_render$2R]]);
  const IconLoading = Object.assign(_IconLoading, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconLoading.name, _IconLoading);
    }
  });
  const _sfc_main$2R = vue.defineComponent({
    name: "FeedbackIcon",
    components: {
      IconLoading,
      IconCheckCircleFill,
      IconExclamationCircleFill,
      IconCloseCircleFill
    },
    props: {
      type: {
        type: String
      }
    },
    setup(props) {
      const prefixCls = getPrefixCls("feedback-icon");
      const cls = vue.computed(() => [
        prefixCls,
        `${prefixCls}-status-${props.type}`
      ]);
      return {
        cls
      };
    }
  });
  function _sfc_render$2Q(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_icon_loading = vue.resolveComponent("icon-loading");
    const _component_icon_check_circle_fill = vue.resolveComponent("icon-check-circle-fill");
    const _component_icon_exclamation_circle_fill = vue.resolveComponent("icon-exclamation-circle-fill");
    const _component_icon_close_circle_fill = vue.resolveComponent("icon-close-circle-fill");
    return vue.openBlock(), vue.createElementBlock("span", {
      class: vue.normalizeClass(_ctx.cls)
    }, [
      _ctx.type === "validating" ? (vue.openBlock(), vue.createBlock(_component_icon_loading, { key: 0 })) : _ctx.type === "success" ? (vue.openBlock(), vue.createBlock(_component_icon_check_circle_fill, { key: 1 })) : _ctx.type === "warning" ? (vue.openBlock(), vue.createBlock(_component_icon_exclamation_circle_fill, { key: 2 })) : _ctx.type === "error" ? (vue.openBlock(), vue.createBlock(_component_icon_close_circle_fill, { key: 3 })) : vue.createCommentVNode("v-if", true)
    ], 2);
  }
  var FeedbackIcon = /* @__PURE__ */ _export_sfc(_sfc_main$2R, [["render", _sfc_render$2Q]]);
  const Enter = {
    key: "Enter",
    code: "Enter"
  };
  const Backspace = {
    key: "Backspace",
    code: "Backspace"
  };
  const omit = (object, path) => {
    const result = __spreadValues({}, object);
    for (const item of path) {
      if (item in result) {
        delete result[item];
      }
    }
    return result;
  };
  function pick(obj, keys) {
    const clone = {};
    keys.forEach((key) => {
      const k = key;
      if (key in obj) {
        clone[k] = obj[k];
      }
    });
    return clone;
  }
  const formItemInjectionKey = Symbol("ArcoFormItemContext");
  const formInjectionKey = Symbol("ArcoFormContext");
  const useFormItem = ({
    size,
    disabled,
    error,
    uninject
  } = {}) => {
    const formItemCtx = !uninject ? vue.inject(formItemInjectionKey, {}) : {};
    const mergedSize = vue.computed(() => {
      var _a;
      return (_a = size == null ? void 0 : size.value) != null ? _a : formItemCtx.size;
    });
    const mergedDisabled = vue.computed(() => (disabled == null ? void 0 : disabled.value) || formItemCtx.disabled);
    const mergedError = vue.computed(() => (error == null ? void 0 : error.value) || formItemCtx.error);
    const feedback = vue.toRef(formItemCtx, "feedback");
    const eventHandlers = vue.toRef(formItemCtx, "eventHandlers");
    return {
      formItemCtx,
      mergedSize,
      mergedDisabled,
      mergedError,
      feedback,
      eventHandlers
    };
  };
  const useSize$1 = (size, { defaultValue = "medium" } = {}) => {
    const configProviderCtx = vue.inject(configProviderInjectionKey, void 0);
    const mergedSize = vue.computed(() => {
      var _a, _b;
      return (_b = (_a = size == null ? void 0 : size.value) != null ? _a : configProviderCtx == null ? void 0 : configProviderCtx.size) != null ? _b : defaultValue;
    });
    return {
      mergedSize
    };
  };
  function useCursor(input) {
    const selectionRef = vue.ref();
    function recordCursor() {
      if (!input.value)
        return;
      const { selectionStart, selectionEnd, value } = input.value;
      if (selectionStart == null || selectionEnd == null)
        return;
      const beforeTxt = value.slice(0, Math.max(0, selectionStart));
      const afterTxt = value.slice(Math.max(0, selectionEnd));
      selectionRef.value = {
        selectionStart,
        selectionEnd,
        value,
        beforeTxt,
        afterTxt
      };
    }
    function setCursor() {
      if (!input.value || !selectionRef.value)
        return;
      const { value } = input.value;
      const { beforeTxt, afterTxt, selectionStart } = selectionRef.value;
      if (!beforeTxt || !afterTxt || !selectionStart)
        return;
      let startPos = value.length;
      if (value.endsWith(afterTxt)) {
        startPos = value.length - afterTxt.length;
      } else if (value.startsWith(beforeTxt)) {
        startPos = beforeTxt.length;
      } else {
        const beforeLastChar = beforeTxt[selectionStart - 1];
        const newIndex = value.indexOf(beforeLastChar, selectionStart - 1);
        if (newIndex !== -1) {
          startPos = newIndex + 1;
        }
      }
      input.value.setSelectionRange(startPos, startPos);
    }
    return [recordCursor, setCursor];
  }
  var _Input = vue.defineComponent({
    name: "Input",
    inheritAttrs: false,
    props: {
      modelValue: String,
      defaultValue: {
        type: String,
        default: ""
      },
      size: {
        type: String
      },
      allowClear: {
        type: Boolean,
        default: false
      },
      disabled: {
        type: Boolean,
        default: false
      },
      readonly: {
        type: Boolean,
        default: false
      },
      error: {
        type: Boolean,
        default: false
      },
      placeholder: String,
      maxLength: {
        type: [Number, Object],
        default: 0
      },
      showWordLimit: {
        type: Boolean,
        default: false
      },
      wordLength: {
        type: Function
      },
      wordSlice: {
        type: Function
      },
      inputAttrs: {
        type: Object
      },
      type: {
        type: String,
        default: "text"
      }
    },
    emits: {
      "update:modelValue": (value) => true,
      "input": (value, ev) => true,
      "change": (value, ev) => true,
      "pressEnter": (ev) => true,
      "clear": (ev) => true,
      "focus": (ev) => true,
      "blur": (ev) => true
    },
    setup(props, {
      emit,
      slots,
      attrs
    }) {
      const {
        size,
        disabled,
        error,
        modelValue
      } = vue.toRefs(props);
      const prefixCls = getPrefixCls("input");
      const inputRef = vue.ref();
      const {
        mergedSize: _mergedSize,
        mergedDisabled,
        mergedError: _mergedError,
        feedback,
        eventHandlers
      } = useFormItem({
        size,
        disabled,
        error
      });
      const {
        mergedSize
      } = useSize$1(_mergedSize);
      const [recordCursor, setCursor] = useCursor(inputRef);
      const _value = vue.ref(props.defaultValue);
      const computedValue = vue.computed(() => {
        var _a;
        return (_a = props.modelValue) != null ? _a : _value.value;
      });
      vue.watch(modelValue, (value) => {
        if (isUndefined(value) || isNull(value)) {
          _value.value = "";
        }
      });
      let preValue = computedValue.value;
      const focused = vue.ref(false);
      const showClearBtn = vue.computed(() => props.allowClear && !mergedDisabled.value && Boolean(computedValue.value));
      const isComposition = vue.ref(false);
      const compositionValue = vue.ref("");
      const getValueLength = (value) => {
        var _a;
        if (isFunction$1(props.wordLength)) {
          return props.wordLength(value);
        }
        return (_a = value.length) != null ? _a : 0;
      };
      const valueLength = vue.computed(() => getValueLength(computedValue.value));
      const mergedError = vue.computed(() => _mergedError.value || Boolean(isObject$1(props.maxLength) && props.maxLength.errorOnly && valueLength.value > maxLength.value));
      const maxLengthErrorOnly = vue.computed(() => isObject$1(props.maxLength) && Boolean(props.maxLength.errorOnly));
      const maxLength = vue.computed(() => {
        if (isObject$1(props.maxLength)) {
          return props.maxLength.length;
        }
        return props.maxLength;
      });
      const defaultMaxLength = vue.computed(() => {
        const bytePerChar = getValueLength("a");
        return Math.floor(maxLength.value / bytePerChar);
      });
      const updateValue = (value) => {
        var _a, _b;
        if (maxLength.value && !maxLengthErrorOnly.value && getValueLength(value) > maxLength.value) {
          value = (_b = (_a = props.wordSlice) == null ? void 0 : _a.call(props, value, maxLength.value)) != null ? _b : value.slice(0, defaultMaxLength.value);
        }
        _value.value = value;
        emit("update:modelValue", value);
      };
      const handleMousedown = (e2) => {
        if (inputRef.value && e2.target !== inputRef.value) {
          e2.preventDefault();
          inputRef.value.focus();
        }
      };
      const emitChange = (value, ev) => {
        var _a, _b;
        if (value !== preValue) {
          preValue = value;
          emit("change", value, ev);
          (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a, ev);
        }
      };
      const handleFocus = (ev) => {
        var _a, _b;
        focused.value = true;
        preValue = computedValue.value;
        emit("focus", ev);
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onFocus) == null ? void 0 : _b.call(_a, ev);
      };
      const handleBlur = (ev) => {
        var _a, _b;
        focused.value = false;
        emitChange(computedValue.value, ev);
        emit("blur", ev);
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onBlur) == null ? void 0 : _b.call(_a, ev);
      };
      const handleComposition = (e2) => {
        var _a, _b, _c;
        const {
          value,
          selectionStart,
          selectionEnd
        } = e2.target;
        if (e2.type === "compositionend") {
          isComposition.value = false;
          compositionValue.value = "";
          if (maxLength.value && !maxLengthErrorOnly.value && valueLength.value >= maxLength.value && getValueLength(value) > maxLength.value && selectionStart === selectionEnd) {
            keepControl();
            return;
          }
          updateValue(value);
          emit("input", value, e2);
          (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onInput) == null ? void 0 : _b.call(_a, e2);
          keepControl();
        } else {
          isComposition.value = true;
          compositionValue.value = computedValue.value + ((_c = e2.data) != null ? _c : "");
        }
      };
      const keepControl = () => {
        recordCursor();
        vue.nextTick(() => {
          if (inputRef.value && computedValue.value !== inputRef.value.value) {
            inputRef.value.value = computedValue.value;
            setCursor();
          }
        });
      };
      const handleInput = (e2) => {
        var _a, _b;
        const {
          value
        } = e2.target;
        if (!isComposition.value) {
          if (maxLength.value && !maxLengthErrorOnly.value && valueLength.value >= maxLength.value && getValueLength(value) > maxLength.value && e2.inputType === "insertText") {
            keepControl();
            return;
          }
          updateValue(value);
          emit("input", value, e2);
          (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onInput) == null ? void 0 : _b.call(_a, e2);
          keepControl();
        }
      };
      const handleClear = (ev) => {
        updateValue("");
        emitChange("", ev);
        emit("clear", ev);
      };
      const handleKeyDown = (e2) => {
        const keyCode = e2.key || e2.code;
        if (!isComposition.value && keyCode === Enter.key) {
          emitChange(computedValue.value, e2);
          emit("pressEnter", e2);
        }
      };
      const outerCls = vue.computed(() => [`${prefixCls}-outer`, `${prefixCls}-outer-size-${mergedSize.value}`, {
        [`${prefixCls}-outer-has-suffix`]: Boolean(slots.suffix),
        [`${prefixCls}-outer-disabled`]: mergedDisabled.value
      }]);
      const wrapperCls = vue.computed(() => [`${prefixCls}-wrapper`, {
        [`${prefixCls}-error`]: mergedError.value,
        [`${prefixCls}-disabled`]: mergedDisabled.value,
        [`${prefixCls}-focus`]: focused.value
      }]);
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-size-${mergedSize.value}`]);
      const wrapperAttrs = vue.computed(() => omit(attrs, INPUT_EVENTS));
      const inputAttrs = vue.computed(() => pick(attrs, INPUT_EVENTS));
      const mergeInputAttrs = vue.computed(() => {
        const attrs2 = __spreadValues(__spreadValues({}, inputAttrs.value), props.inputAttrs);
        if (mergedError.value) {
          attrs2["aria-invalid"] = true;
        }
        return attrs2;
      });
      const renderInput = (hasOuter) => {
        var _a;
        return vue.createVNode("span", vue.mergeProps({
          "class": wrapperCls.value,
          "onMousedown": handleMousedown
        }, !hasOuter ? wrapperAttrs.value : void 0), [slots.prefix && vue.createVNode("span", {
          "class": `${prefixCls}-prefix`
        }, [slots.prefix()]), vue.createVNode("input", vue.mergeProps(mergeInputAttrs.value, {
          "ref": inputRef,
          "class": cls.value,
          "value": computedValue.value,
          "type": props.type,
          "placeholder": props.placeholder,
          "readonly": props.readonly,
          "disabled": mergedDisabled.value,
          "onInput": handleInput,
          "onKeydown": handleKeyDown,
          "onFocus": handleFocus,
          "onBlur": handleBlur,
          "onCompositionstart": handleComposition,
          "onCompositionupdate": handleComposition,
          "onCompositionend": handleComposition
        }), null), showClearBtn.value && vue.createVNode(IconHover, {
          "prefix": prefixCls,
          "class": `${prefixCls}-clear-btn`,
          "onClick": handleClear
        }, {
          default: () => [vue.createVNode(IconClose, null, null)]
        }), (slots.suffix || Boolean(props.maxLength) && props.showWordLimit || Boolean(feedback.value)) && vue.createVNode("span", {
          "class": [`${prefixCls}-suffix`, {
            [`${prefixCls}-suffix-has-feedback`]: feedback.value
          }]
        }, [Boolean(props.maxLength) && props.showWordLimit && vue.createVNode("span", {
          "class": `${prefixCls}-word-limit`
        }, [valueLength.value, vue.createTextVNode("/"), maxLength.value]), (_a = slots.suffix) == null ? void 0 : _a.call(slots), Boolean(feedback.value) && vue.createVNode(FeedbackIcon, {
          "type": feedback.value
        }, null)])]);
      };
      const render = () => {
        if (slots.prepend || slots.append) {
          return vue.createVNode("span", vue.mergeProps({
            "class": outerCls.value
          }, wrapperAttrs.value), [slots.prepend && vue.createVNode("span", {
            "class": `${prefixCls}-prepend`
          }, [slots.prepend()]), renderInput(true), slots.append && vue.createVNode("span", {
            "class": `${prefixCls}-append`
          }, [slots.append()])]);
        }
        return renderInput();
      };
      return {
        inputRef,
        render
      };
    },
    methods: {
      focus() {
        var _a;
        (_a = this.inputRef) == null ? void 0 : _a.focus();
      },
      blur() {
        var _a;
        (_a = this.inputRef) == null ? void 0 : _a.blur();
      }
    },
    render() {
      return this.render();
    }
  });
  const _sfc_main$2Q = vue.defineComponent({
    name: "IconSearch",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-search`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$1c = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$Y = /* @__PURE__ */ vue.createElementVNode("path", { d: "M33.072 33.071c6.248-6.248 6.248-16.379 0-22.627-6.249-6.249-16.38-6.249-22.628 0-6.248 6.248-6.248 16.379 0 22.627 6.248 6.248 16.38 6.248 22.628 0Zm0 0 8.485 8.485" }, null, -1);
  const _hoisted_3$T = [
    _hoisted_2$Y
  ];
  function _sfc_render$2P(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$T, 14, _hoisted_1$1c);
  }
  var _IconSearch = /* @__PURE__ */ _export_sfc(_sfc_main$2Q, [["render", _sfc_render$2P]]);
  const IconSearch = Object.assign(_IconSearch, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconSearch.name, _IconSearch);
    }
  });
  const buttonGroupInjectionKey = Symbol("ArcoButtonGroup");
  const _sfc_main$2P = vue.defineComponent({
    name: "Button",
    components: {
      IconLoading
    },
    props: {
      type: {
        type: String
      },
      shape: {
        type: String
      },
      status: {
        type: String
      },
      size: {
        type: String
      },
      long: {
        type: Boolean,
        default: false
      },
      loading: {
        type: Boolean,
        default: false
      },
      disabled: {
        type: Boolean
      },
      htmlType: {
        type: String,
        default: "button"
      },
      href: String
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const { size, disabled } = vue.toRefs(props);
      const prefixCls = getPrefixCls("btn");
      const groupContext = vue.inject(buttonGroupInjectionKey, void 0);
      const _size = vue.computed(() => {
        var _a;
        return (_a = size.value) != null ? _a : groupContext == null ? void 0 : groupContext.size;
      });
      const _disabled = vue.computed(() => Boolean(disabled.value || (groupContext == null ? void 0 : groupContext.disabled)));
      const { mergedSize: _mergedSize, mergedDisabled } = useFormItem({
        size: _size,
        disabled: _disabled
      });
      const { mergedSize } = useSize$1(_mergedSize);
      const cls = vue.computed(() => {
        var _a, _b, _c, _d, _e, _f;
        return [
          prefixCls,
          `${prefixCls}-${(_b = (_a = props.type) != null ? _a : groupContext == null ? void 0 : groupContext.type) != null ? _b : "secondary"}`,
          `${prefixCls}-shape-${(_d = (_c = props.shape) != null ? _c : groupContext == null ? void 0 : groupContext.shape) != null ? _d : "square"}`,
          `${prefixCls}-size-${mergedSize.value}`,
          `${prefixCls}-status-${(_f = (_e = props.status) != null ? _e : groupContext == null ? void 0 : groupContext.status) != null ? _f : "normal"}`,
          {
            [`${prefixCls}-long`]: props.long,
            [`${prefixCls}-loading`]: props.loading,
            [`${prefixCls}-disabled`]: mergedDisabled.value,
            [`${prefixCls}-link`]: isString$1(props.href)
          }
        ];
      });
      const handleClick = (ev) => {
        if (props.disabled || props.loading) {
          ev.preventDefault();
          return;
        }
        emit("click", ev);
      };
      return {
        prefixCls,
        cls,
        mergedDisabled,
        handleClick
      };
    }
  });
  const _hoisted_1$1b = ["href"];
  const _hoisted_2$X = ["type", "disabled"];
  function _sfc_render$2O(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_icon_loading = vue.resolveComponent("icon-loading");
    return _ctx.href ? (vue.openBlock(), vue.createElementBlock("a", {
      key: 0,
      class: vue.normalizeClass([
        _ctx.cls,
        { [`${_ctx.prefixCls}-only-icon`]: _ctx.$slots.icon && !_ctx.$slots.default }
      ]),
      href: _ctx.mergedDisabled || _ctx.loading ? void 0 : _ctx.href,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    }, [
      _ctx.loading || _ctx.$slots.icon ? (vue.openBlock(), vue.createElementBlock("span", {
        key: 0,
        class: vue.normalizeClass(`${_ctx.prefixCls}-icon`)
      }, [
        _ctx.loading ? (vue.openBlock(), vue.createBlock(_component_icon_loading, {
          key: 0,
          spin: "true"
        })) : vue.renderSlot(_ctx.$slots, "icon", { key: 1 })
      ], 2)) : vue.createCommentVNode("v-if", true),
      vue.renderSlot(_ctx.$slots, "default")
    ], 10, _hoisted_1$1b)) : (vue.openBlock(), vue.createElementBlock("button", {
      key: 1,
      class: vue.normalizeClass([
        _ctx.cls,
        { [`${_ctx.prefixCls}-only-icon`]: _ctx.$slots.icon && !_ctx.$slots.default }
      ]),
      type: _ctx.htmlType,
      disabled: _ctx.mergedDisabled,
      onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    }, [
      _ctx.loading || _ctx.$slots.icon ? (vue.openBlock(), vue.createElementBlock("span", {
        key: 0,
        class: vue.normalizeClass(`${_ctx.prefixCls}-icon`)
      }, [
        _ctx.loading ? (vue.openBlock(), vue.createBlock(_component_icon_loading, {
          key: 0,
          spin: true
        })) : vue.renderSlot(_ctx.$slots, "icon", { key: 1 })
      ], 2)) : vue.createCommentVNode("v-if", true),
      vue.renderSlot(_ctx.$slots, "default")
    ], 10, _hoisted_2$X));
  }
  var _Button = /* @__PURE__ */ _export_sfc(_sfc_main$2P, [["render", _sfc_render$2O]]);
  const _sfc_main$2O = vue.defineComponent({
    name: "ButtonGroup",
    props: {
      type: {
        type: String
      },
      status: {
        type: String
      },
      shape: {
        type: String
      },
      size: {
        type: String
      },
      disabled: {
        type: Boolean
      }
    },
    setup(props) {
      const { type, size, status, disabled, shape } = vue.toRefs(props);
      const prefixCls = getPrefixCls("btn-group");
      vue.provide(buttonGroupInjectionKey, vue.reactive({
        type,
        size,
        shape,
        status,
        disabled
      }));
      return {
        prefixCls
      };
    }
  });
  function _sfc_render$2N(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.prefixCls)
    }, [
      vue.renderSlot(_ctx.$slots, "default")
    ], 2);
  }
  var ButtonGroup = /* @__PURE__ */ _export_sfc(_sfc_main$2O, [["render", _sfc_render$2N]]);
  const Button = Object.assign(_Button, {
    Group: ButtonGroup,
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Button.name, _Button);
      app.component(componentPrefix + ButtonGroup.name, ButtonGroup);
    }
  });
  var InputSearch = vue.defineComponent({
    name: "InputSearch",
    props: {
      searchButton: {
        type: Boolean,
        default: false
      },
      loading: {
        type: Boolean,
        default: false
      },
      disabled: {
        type: Boolean,
        default: false
      },
      size: {
        type: String
      },
      buttonText: {
        type: String
      },
      buttonProps: {
        type: Object
      }
    },
    emits: {
      search: (value, ev) => true
    },
    setup(props, {
      emit,
      slots
    }) {
      const {
        size
      } = vue.toRefs(props);
      const prefixCls = getPrefixCls("input-search");
      const {
        mergedSize
      } = useSize$1(size);
      const inputRef = vue.ref();
      const handleClick = (e2) => {
        if (inputRef.value.inputRef) {
          emit("search", inputRef.value.inputRef.value, e2);
        }
      };
      const renderSuffix = () => {
        var _a;
        return vue.createVNode(vue.Fragment, null, [props.loading ? vue.createVNode(IconLoading, null, null) : vue.createVNode(IconHover, {
          "onClick": handleClick
        }, {
          default: () => [vue.createVNode(IconSearch, null, null)]
        }), (_a = slots.suffix) == null ? void 0 : _a.call(slots)]);
      };
      const renderButton = () => {
        var _a;
        let _slots = {};
        if (props.buttonText || slots["button-default"] || slots["button-icon"]) {
          _slots = {
            default: (_a = slots["button-default"]) != null ? _a : props.buttonText ? () => props.buttonText : void 0,
            icon: slots["button-icon"]
          };
        } else {
          _slots = {
            icon: () => vue.createVNode(IconSearch, null, null)
          };
        }
        return vue.createVNode(Button, vue.mergeProps({
          "type": "primary",
          "class": `${prefixCls}-btn`,
          "disabled": props.disabled,
          "size": mergedSize.value,
          "loading": props.loading
        }, props.buttonProps, {
          "onClick": handleClick
        }), _slots);
      };
      const render = () => vue.createVNode(_Input, {
        "ref": inputRef,
        "class": prefixCls,
        "size": mergedSize.value,
        "disabled": props.disabled
      }, {
        prepend: slots.prepend,
        prefix: slots.prefix,
        suffix: props.searchButton ? slots.suffix : renderSuffix,
        append: props.searchButton ? renderButton : slots.append
      });
      return {
        inputRef,
        render
      };
    },
    methods: {
      focus() {
        var _a;
        (_a = this.inputRef) == null ? void 0 : _a.focus();
      },
      blur() {
        var _a;
        (_a = this.inputRef) == null ? void 0 : _a.blur();
      }
    },
    render() {
      return this.render();
    }
  });
  const _sfc_main$2N = vue.defineComponent({
    name: "IconEye",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-eye`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$1a = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$W = /* @__PURE__ */ vue.createElementVNode("path", {
    "clip-rule": "evenodd",
    d: "M24 37c6.627 0 12.627-4.333 18-13-5.373-8.667-11.373-13-18-13-6.627 0-12.627 4.333-18 13 5.373 8.667 11.373 13 18 13Z"
  }, null, -1);
  const _hoisted_3$S = /* @__PURE__ */ vue.createElementVNode("path", { d: "M29 24a5 5 0 1 1-10 0 5 5 0 0 1 10 0Z" }, null, -1);
  const _hoisted_4$g = [
    _hoisted_2$W,
    _hoisted_3$S
  ];
  function _sfc_render$2M(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_4$g, 14, _hoisted_1$1a);
  }
  var _IconEye = /* @__PURE__ */ _export_sfc(_sfc_main$2N, [["render", _sfc_render$2M]]);
  const IconEye = Object.assign(_IconEye, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconEye.name, _IconEye);
    }
  });
  const _sfc_main$2M = vue.defineComponent({
    name: "IconEyeInvisible",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-eye-invisible`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$19 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$V = /* @__PURE__ */ vue.createElementVNode("path", { d: "M14 14.5c-2.69 2-5.415 5.33-8 9.5 5.373 8.667 11.373 13 18 13 3.325 0 6.491-1.09 9.5-3.271M17.463 12.5C19 11 21.75 11 24 11c6.627 0 12.627 4.333 18 13-1.766 2.848-3.599 5.228-5.5 7.14" }, null, -1);
  const _hoisted_3$R = /* @__PURE__ */ vue.createElementVNode("path", { d: "M29 24a5 5 0 1 1-10 0 5 5 0 0 1 10 0ZM6.852 7.103l34.294 34.294" }, null, -1);
  const _hoisted_4$f = [
    _hoisted_2$V,
    _hoisted_3$R
  ];
  function _sfc_render$2L(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_4$f, 14, _hoisted_1$19);
  }
  var _IconEyeInvisible = /* @__PURE__ */ _export_sfc(_sfc_main$2M, [["render", _sfc_render$2L]]);
  const IconEyeInvisible = Object.assign(_IconEyeInvisible, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconEyeInvisible.name, _IconEyeInvisible);
    }
  });
  const _sfc_main$2L = vue.defineComponent({
    name: "InputPassword",
    components: {
      IconEye,
      IconEyeInvisible,
      AIconHover: IconHover,
      AInput: _Input
    },
    props: {
      invisibleButton: {
        type: Boolean,
        default: true
      }
    },
    setup() {
      const inputRef = vue.ref();
      const invisible = vue.ref(true);
      const handleInvisible = () => {
        invisible.value = !invisible.value;
      };
      return {
        inputRef,
        invisible,
        handleInvisible
      };
    },
    methods: {
      focus() {
        var _a;
        (_a = this.inputRef) == null ? void 0 : _a.focus();
      },
      blur() {
        var _a;
        (_a = this.inputRef) == null ? void 0 : _a.blur();
      }
    }
  });
  function _sfc_render$2K(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_icon_eye = vue.resolveComponent("icon-eye");
    const _component_icon_eye_invisible = vue.resolveComponent("icon-eye-invisible");
    const _component_a_icon_hover = vue.resolveComponent("a-icon-hover");
    const _component_a_input = vue.resolveComponent("a-input");
    return vue.openBlock(), vue.createBlock(_component_a_input, {
      ref: "inputRef",
      type: _ctx.invisible ? "password" : "text"
    }, vue.createSlots({ _: 2 }, [
      _ctx.$slots.prepend ? {
        name: "prepend",
        fn: vue.withCtx(() => [
          vue.renderSlot(_ctx.$slots, "prepend")
        ])
      } : void 0,
      _ctx.$slots.prefix ? {
        name: "prefix",
        fn: vue.withCtx(() => [
          vue.renderSlot(_ctx.$slots, "prefix")
        ])
      } : void 0,
      _ctx.invisibleButton || _ctx.$slots.suffix ? {
        name: "suffix",
        fn: vue.withCtx(() => [
          _ctx.invisibleButton ? (vue.openBlock(), vue.createBlock(_component_a_icon_hover, {
            key: 0,
            onClick: _ctx.handleInvisible,
            onMousedown: _cache[0] || (_cache[0] = vue.withModifiers(() => {
            }, ["prevent"])),
            onMouseup: _cache[1] || (_cache[1] = vue.withModifiers(() => {
            }, ["prevent"]))
          }, {
            default: vue.withCtx(() => [
              !_ctx.invisible ? (vue.openBlock(), vue.createBlock(_component_icon_eye, { key: 0 })) : (vue.openBlock(), vue.createBlock(_component_icon_eye_invisible, { key: 1 }))
            ]),
            _: 1
          }, 8, ["onClick"])) : vue.createCommentVNode("v-if", true),
          vue.renderSlot(_ctx.$slots, "suffix")
        ])
      } : void 0,
      _ctx.$slots.append ? {
        name: "append",
        fn: vue.withCtx(() => [
          vue.renderSlot(_ctx.$slots, "append")
        ])
      } : void 0
    ]), 1032, ["type"]);
  }
  var InputPassword = /* @__PURE__ */ _export_sfc(_sfc_main$2L, [["render", _sfc_render$2K]]);
  const _sfc_main$2K = vue.defineComponent({
    name: "InputGroup",
    setup() {
      const prefixCls = getPrefixCls("input-group");
      return {
        prefixCls
      };
    }
  });
  function _sfc_render$2J(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.prefixCls)
    }, [
      vue.renderSlot(_ctx.$slots, "default")
    ], 2);
  }
  var InputGroup = /* @__PURE__ */ _export_sfc(_sfc_main$2K, [["render", _sfc_render$2J]]);
  const Input = Object.assign(_Input, {
    Search: InputSearch,
    Password: InputPassword,
    Group: InputGroup,
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Input.name, _Input);
      app.component(componentPrefix + InputGroup.name, InputGroup);
      app.component(componentPrefix + InputSearch.name, InputSearch);
      app.component(componentPrefix + InputPassword.name, InputPassword);
    }
  });
  const getDocumentSize = () => {
    const { body } = document;
    const html = document.documentElement;
    let topBody;
    try {
      const topWindow = window.top || window.self || window;
      topBody = topWindow.document.body;
    } catch {
    }
    const size = {
      height: Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight, (topBody == null ? void 0 : topBody.scrollHeight) || 0, (topBody == null ? void 0 : topBody.clientHeight) || 0),
      width: Math.max(body.scrollWidth, body.offsetWidth, html.clientWidth, html.scrollWidth, html.offsetWidth, (topBody == null ? void 0 : topBody.scrollWidth) || 0, (topBody == null ? void 0 : topBody.clientWidth) || 0)
    };
    return size;
  };
  const getViewPortSize = () => {
    const { height, width } = getDocumentSize();
    return {
      width: Math.min(width, window.innerWidth),
      height: Math.min(height, window.innerHeight)
    };
  };
  const getElementScrollRect = (element, containerRect) => {
    var _a, _b;
    const rect = element.getBoundingClientRect();
    return {
      top: rect.top,
      bottom: rect.bottom,
      left: rect.left,
      right: rect.right,
      scrollTop: rect.top - containerRect.top,
      scrollBottom: rect.bottom - containerRect.top,
      scrollLeft: rect.left - containerRect.left,
      scrollRight: rect.right - containerRect.left,
      width: (_a = element.offsetWidth) != null ? _a : element.clientWidth,
      height: (_b = element.offsetHeight) != null ? _b : element.clientHeight
    };
  };
  const getBoundaryPosition = (position) => {
    switch (position) {
      case "top":
      case "tl":
      case "tr":
        return "top";
      case "bottom":
      case "bl":
      case "br":
        return "bottom";
      case "left":
      case "lt":
      case "lb":
        return "left";
      case "right":
      case "rt":
      case "rb":
        return "right";
      default:
        return "top";
    }
  };
  const changePosition = (position, direction) => {
    switch (direction) {
      case "top":
        switch (position) {
          case "bottom":
            return "top";
          case "bl":
            return "tl";
          case "br":
            return "tr";
          default:
            return position;
        }
      case "bottom":
        switch (position) {
          case "top":
            return "bottom";
          case "tl":
            return "bl";
          case "tr":
            return "br";
          default:
            return position;
        }
      case "left":
        switch (position) {
          case "right":
            return "left";
          case "rt":
            return "lt";
          case "rb":
            return "lb";
          default:
            return position;
        }
      case "right":
        switch (position) {
          case "left":
            return "right";
          case "lt":
            return "rt";
          case "lb":
            return "rb";
          default:
            return position;
        }
      default:
        return position;
    }
  };
  const getFitPosition = (position, popupPosition, {
    containerRect,
    triggerRect,
    popupRect,
    offset,
    translate
  }) => {
    const direction = getBoundaryPosition(position);
    const viewPortSize = getViewPortSize();
    const viewPortBoundary = {
      top: containerRect.top + popupPosition.top,
      bottom: viewPortSize.height - (containerRect.top + popupPosition.top + popupRect.height),
      left: containerRect.left + popupPosition.left,
      right: viewPortSize.width - (containerRect.left + popupPosition.left + popupRect.width)
    };
    let finalPosition = position;
    if (direction === "top" && viewPortBoundary.top < 0) {
      if (triggerRect.top > popupRect.height) {
        popupPosition.top = -containerRect.top;
      } else {
        const fitPosition = getPopupOffset("bottom", triggerRect, popupRect, {
          offset,
          translate
        });
        if (viewPortSize.height - (containerRect.top + fitPosition.top + popupRect.height) > 0) {
          finalPosition = changePosition(position, "bottom");
          popupPosition.top = fitPosition.top;
        }
      }
    }
    if (direction === "bottom" && viewPortBoundary.bottom < 0) {
      if (viewPortSize.height - triggerRect.bottom > popupRect.height) {
        popupPosition.top = -containerRect.top + (viewPortSize.height - popupRect.height);
      } else {
        const fitPosition = getPopupOffset("top", triggerRect, popupRect, {
          offset,
          translate
        });
        if (containerRect.top + fitPosition.top > 0) {
          finalPosition = changePosition(position, "top");
          popupPosition.top = fitPosition.top;
        }
      }
    }
    if (direction === "left" && viewPortBoundary.left < 0) {
      if (triggerRect.left > popupRect.width) {
        popupPosition.left = -containerRect.left;
      } else {
        const fitPosition = getPopupOffset("right", triggerRect, popupRect, {
          offset,
          translate
        });
        if (viewPortSize.width - (containerRect.left + fitPosition.left + popupRect.width) > 0) {
          finalPosition = changePosition(position, "right");
          popupPosition.left = fitPosition.left;
        }
      }
    }
    if (direction === "right" && viewPortBoundary.right < 0) {
      if (viewPortSize.width - triggerRect.right > popupRect.width) {
        popupPosition.left = -containerRect.left + (viewPortSize.width - popupRect.width);
      } else {
        const fitPosition = getPopupOffset("left", triggerRect, popupRect, {
          offset,
          translate
        });
        if (containerRect.left + fitPosition.left > 0) {
          finalPosition = changePosition(position, "left");
          popupPosition.left = fitPosition.left;
        }
      }
    }
    if (direction === "top" || direction === "bottom") {
      if (viewPortBoundary.left < 0) {
        popupPosition.left = -containerRect.left;
      } else if (viewPortBoundary.right < 0) {
        popupPosition.left = -containerRect.left + (viewPortSize.width - popupRect.width);
      }
    }
    if (direction === "left" || direction === "right") {
      if (viewPortBoundary.top < 0) {
        popupPosition.top = -containerRect.top;
      } else if (viewPortBoundary.bottom < 0) {
        popupPosition.top = -containerRect.top + (viewPortSize.height - popupRect.height);
      }
    }
    return {
      popupPosition,
      position: finalPosition
    };
  };
  const getPopupOffset = (position, triggerRect, popupRect, {
    offset = 0,
    translate = [0, 0]
  } = {}) => {
    var _a;
    const _translate = (_a = isArray$1(translate) ? translate : translate[position]) != null ? _a : [0, 0];
    switch (position) {
      case "top":
        return {
          left: triggerRect.scrollLeft + Math.round(triggerRect.width / 2) - Math.round(popupRect.width / 2) + _translate[0],
          top: triggerRect.scrollTop - popupRect.height - offset + _translate[1]
        };
      case "tl":
        return {
          left: triggerRect.scrollLeft + _translate[0],
          top: triggerRect.scrollTop - popupRect.height - offset + _translate[1]
        };
      case "tr":
        return {
          left: triggerRect.scrollRight - popupRect.width + _translate[0],
          top: triggerRect.scrollTop - popupRect.height - offset + _translate[1]
        };
      case "bottom":
        return {
          left: triggerRect.scrollLeft + Math.round(triggerRect.width / 2) - Math.round(popupRect.width / 2) + _translate[0],
          top: triggerRect.scrollBottom + offset + _translate[1]
        };
      case "bl":
        return {
          left: triggerRect.scrollLeft + _translate[0],
          top: triggerRect.scrollBottom + offset + _translate[1]
        };
      case "br":
        return {
          left: triggerRect.scrollRight - popupRect.width + _translate[0],
          top: triggerRect.scrollBottom + offset + _translate[1]
        };
      case "left":
        return {
          left: triggerRect.scrollLeft - popupRect.width - offset + _translate[0],
          top: triggerRect.scrollTop + Math.round(triggerRect.height / 2) - Math.round(popupRect.height / 2) + _translate[1]
        };
      case "lt":
        return {
          left: triggerRect.scrollLeft - popupRect.width - offset + _translate[0],
          top: triggerRect.scrollTop + _translate[1]
        };
      case "lb":
        return {
          left: triggerRect.scrollLeft - popupRect.width - offset + _translate[0],
          top: triggerRect.scrollBottom - popupRect.height + _translate[1]
        };
      case "right":
        return {
          left: triggerRect.scrollRight + offset + _translate[0],
          top: triggerRect.scrollTop + Math.round(triggerRect.height / 2) - Math.round(popupRect.height / 2) + _translate[1]
        };
      case "rt":
        return {
          left: triggerRect.scrollRight + offset + _translate[0],
          top: triggerRect.scrollTop + _translate[1]
        };
      case "rb":
        return {
          left: triggerRect.scrollRight + offset + _translate[0],
          top: triggerRect.scrollBottom - popupRect.height + _translate[1]
        };
      default:
        return {
          left: 0,
          top: 0
        };
    }
  };
  const getTransformOrigin = (position) => {
    let originX = "0";
    if (["top", "bottom"].includes(position)) {
      originX = "50%";
    } else if (["left", "lt", "lb", "tr", "br"].includes(position)) {
      originX = "100%";
    }
    let originY = "0";
    if (["left", "right"].includes(position)) {
      originY = "50%";
    } else if (["top", "tl", "tr", "lt", "rt"].includes(position)) {
      originY = "100%";
    }
    return `${originX} ${originY}`;
  };
  const getPopupStyle = (position, containerRect, triggerRect, popupRect, {
    offset = 0,
    translate = [0, 0],
    customStyle = {},
    autoFitPosition = false
  } = {}) => {
    let finalPosition = position;
    let popupPosition = getPopupOffset(position, triggerRect, popupRect, {
      offset,
      translate
    });
    if (autoFitPosition) {
      const result = getFitPosition(position, popupPosition, {
        containerRect,
        popupRect,
        triggerRect,
        offset,
        translate
      });
      popupPosition = result.popupPosition;
      finalPosition = result.position;
    }
    const style = __spreadValues({
      left: `${popupPosition.left}px`,
      top: `${popupPosition.top}px`
    }, customStyle);
    return {
      style,
      position: finalPosition
    };
  };
  const getArrowStyle = (position, triggerRect, popupRect, {
    customStyle = {}
  }) => {
    if (["top", "tl", "tr", "bottom", "bl", "br"].includes(position)) {
      let offsetLeft = Math.abs(triggerRect.scrollLeft + triggerRect.width / 2 - popupRect.scrollLeft);
      if (offsetLeft > popupRect.width - 8) {
        if (triggerRect.width > popupRect.width) {
          offsetLeft = popupRect.width / 2;
        } else {
          offsetLeft = popupRect.width - 8;
        }
      }
      if (["top", "tl", "tr"].includes(position)) {
        return __spreadValues({
          left: `${offsetLeft}px`,
          bottom: "0",
          transform: "translate(-50%,50%) rotate(45deg)"
        }, customStyle);
      }
      return __spreadValues({
        left: `${offsetLeft}px`,
        top: "0",
        transform: "translate(-50%,-50%) rotate(45deg)"
      }, customStyle);
    }
    let offsetTop = Math.abs(triggerRect.scrollTop + triggerRect.height / 2 - popupRect.scrollTop);
    if (offsetTop > popupRect.height - 8) {
      if (triggerRect.height > popupRect.height) {
        offsetTop = popupRect.height / 2;
      } else {
        offsetTop = popupRect.height - 8;
      }
    }
    if (["left", "lt", "lb"].includes(position)) {
      return __spreadValues({
        top: `${offsetTop}px`,
        right: "0",
        transform: "translate(50%,-50%) rotate(45deg)"
      }, customStyle);
    }
    return __spreadValues({
      top: `${offsetTop}px`,
      left: "0",
      transform: "translate(-50%,-50%) rotate(45deg)"
    }, customStyle);
  };
  const isScrollElement = (element) => {
    return element.scrollHeight > element.offsetHeight || element.scrollWidth > element.offsetWidth;
  };
  const getScrollElements = (container2) => {
    var _a;
    const scrollElements = [];
    let element = container2;
    while (element && element !== document.documentElement) {
      if (isScrollElement(element)) {
        scrollElements.push(element);
      }
      element = (_a = element.parentElement) != null ? _a : void 0;
    }
    return scrollElements;
  };
  const useFirstElement = () => {
    const children = {};
    const firstElement = vue.ref();
    const getFirstElement = () => {
      const element = getFirstElementFromChildren(children.value);
      if (element !== firstElement.value) {
        firstElement.value = element;
      }
    };
    vue.onMounted(() => getFirstElement());
    vue.onUpdated(() => getFirstElement());
    return {
      children,
      firstElement
    };
  };
  var ResizeObserver = vue.defineComponent({
    name: "ResizeObserver",
    props: {
      watchOnUpdated: Boolean
    },
    emits: [
      "resize"
    ],
    setup(props, { emit, slots }) {
      const { children, firstElement } = useFirstElement();
      let resizeObserver;
      const createResizeObserver = (target2) => {
        if (!target2)
          return;
        resizeObserver = new index$1((entries) => {
          const entry = entries[0];
          emit("resize", entry);
        });
        resizeObserver.observe(target2);
      };
      const destroyResizeObserver = () => {
        if (resizeObserver) {
          resizeObserver.disconnect();
          resizeObserver = null;
        }
      };
      vue.watch(firstElement, (element) => {
        if (resizeObserver)
          destroyResizeObserver();
        if (element) {
          createResizeObserver(element);
        }
      });
      vue.onBeforeUnmount(() => {
        if (resizeObserver)
          destroyResizeObserver();
      });
      return () => {
        var _a;
        children.value = (_a = slots.default) == null ? void 0 : _a.call(slots);
        return children.value;
      };
    }
  });
  function usePickSlots(slots, slotName) {
    const slot = vue.ref(slots[slotName]);
    vue.onUpdated(() => {
      const newSlot = slots[slotName];
      if (slot.value !== newSlot) {
        slot.value = newSlot;
      }
    });
    return slot;
  }
  const triggerInjectionKey = Symbol("ArcoTrigger");
  const POPUP_BASE_Z_INDEX = 1e3;
  const MESSAGE_BASE_Z_INDEX = 5e3;
  const Z_INDEX_STEP = 1;
  class PopupManager {
    constructor() {
      this.popupStack = {
        popup: new Set(),
        dialog: new Set(),
        message: new Set()
      };
      this.getNextZIndex = (type) => {
        const current = type === "message" ? Array.from(this.popupStack.message).pop() || MESSAGE_BASE_Z_INDEX : Array.from(this.popupStack.popup).pop() || POPUP_BASE_Z_INDEX;
        return current + Z_INDEX_STEP;
      };
      this.add = (type) => {
        const zIndex = this.getNextZIndex(type);
        this.popupStack[type].add(zIndex);
        if (type === "dialog") {
          this.popupStack.popup.add(zIndex);
        }
        return zIndex;
      };
      this.delete = (zIndex, type) => {
        this.popupStack[type].delete(zIndex);
        if (type === "dialog") {
          this.popupStack.popup.delete(zIndex);
        }
      };
      this.isLastDialog = (zIndex) => {
        if (this.popupStack.dialog.size > 1) {
          return zIndex === Array.from(this.popupStack.dialog).pop();
        }
        return true;
      };
    }
  }
  const popupManager = new PopupManager();
  function usePopupManager(type, {
    visible,
    runOnMounted
  } = {}) {
    const zIndex = vue.ref(0);
    const open2 = () => {
      zIndex.value = popupManager.add(type);
    };
    const close = () => {
      popupManager.delete(zIndex.value, type);
    };
    const isLastDialog = () => {
      if (type === "dialog") {
        return popupManager.isLastDialog(zIndex.value);
      }
      return false;
    };
    vue.watch(() => visible == null ? void 0 : visible.value, (visible2) => {
      if (visible2) {
        open2();
      } else {
        close();
      }
    }, {
      immediate: true
    });
    if (runOnMounted) {
      vue.onMounted(() => {
        open2();
      });
      vue.onBeforeUnmount(() => {
        close();
      });
    }
    return {
      zIndex: vue.readonly(zIndex),
      open: open2,
      close,
      isLastDialog
    };
  }
  const useResizeObserver = ({
    elementRef,
    onResize
  }) => {
    let resizeObserver;
    const createResizeObserver = () => {
      if (!elementRef.value)
        return;
      resizeObserver = new index$1((entries) => {
        const entry = entries[0];
        isFunction$1(onResize) && onResize(entry);
      });
      resizeObserver.observe(elementRef.value);
    };
    const destroyResizeObserver = () => {
      if (resizeObserver) {
        resizeObserver.disconnect();
        resizeObserver = null;
      }
    };
    return {
      createResizeObserver,
      destroyResizeObserver
    };
  };
  var ClientOnly = vue.defineComponent({
    name: "ClientOnly",
    setup(_, {
      slots
    }) {
      const mounted = vue.ref(false);
      vue.onMounted(() => mounted.value = true);
      return () => {
        var _a;
        if (mounted.value) {
          return (_a = slots.default) == null ? void 0 : _a.call(slots);
        }
        return null;
      };
    }
  });
  const useTeleportContainer = ({
    popupContainer,
    visible,
    defaultContainer = "body",
    documentContainer
  }) => {
    const teleportContainer = vue.ref(popupContainer.value);
    const containerRef = vue.ref();
    const getContainer = () => {
      const element = getElement(popupContainer.value);
      const _teleportContainer = element ? popupContainer.value : defaultContainer;
      const _containerElement = element != null ? element : documentContainer ? document.documentElement : getElement(defaultContainer);
      if (_teleportContainer !== teleportContainer.value) {
        teleportContainer.value = _teleportContainer;
      }
      if (_containerElement !== containerRef.value) {
        containerRef.value = _containerElement;
      }
    };
    vue.onMounted(() => getContainer());
    vue.watch(visible, (visible2) => {
      if (teleportContainer.value !== popupContainer.value && visible2) {
        getContainer();
      }
    });
    return {
      teleportContainer,
      containerRef
    };
  };
  const TRIGGER_EVENTS = ["onClick", "onMouseenter", "onMouseleave", "onFocusin", "onFocusout", "onContextmenu"];
  var _Trigger = vue.defineComponent({
    name: "Trigger",
    inheritAttrs: false,
    props: {
      popupVisible: {
        type: Boolean,
        default: void 0
      },
      defaultPopupVisible: {
        type: Boolean,
        default: false
      },
      trigger: {
        type: [String, Array],
        default: "hover"
      },
      position: {
        type: String,
        default: "bottom"
      },
      disabled: {
        type: Boolean,
        default: false
      },
      popupOffset: {
        type: Number,
        default: 0
      },
      popupTranslate: {
        type: [Array, Object]
      },
      showArrow: {
        type: Boolean,
        default: false
      },
      alignPoint: {
        type: Boolean,
        default: false
      },
      popupHoverStay: {
        type: Boolean,
        default: true
      },
      blurToClose: {
        type: Boolean,
        default: true
      },
      clickToClose: {
        type: Boolean,
        default: true
      },
      clickOutsideToClose: {
        type: Boolean,
        default: true
      },
      unmountOnClose: {
        type: Boolean,
        default: true
      },
      contentClass: {
        type: [String, Array, Object]
      },
      contentStyle: {
        type: Object
      },
      arrowClass: {
        type: [String, Array, Object]
      },
      arrowStyle: {
        type: Object
      },
      popupStyle: {
        type: Object
      },
      animationName: {
        type: String,
        default: "fade-in"
      },
      duration: {
        type: [Number, Object]
      },
      mouseEnterDelay: {
        type: Number,
        default: 100
      },
      mouseLeaveDelay: {
        type: Number,
        default: 100
      },
      focusDelay: {
        type: Number,
        default: 0
      },
      autoFitPopupWidth: {
        type: Boolean,
        default: false
      },
      autoFitPopupMinWidth: {
        type: Boolean,
        default: false
      },
      autoFixPosition: {
        type: Boolean,
        default: true
      },
      popupContainer: {
        type: [String, Object]
      },
      updateAtScroll: {
        type: Boolean,
        default: false
      },
      autoFitTransformOrigin: {
        type: Boolean,
        default: false
      },
      hideEmpty: {
        type: Boolean,
        default: false
      },
      openedClass: {
        type: [String, Array, Object]
      },
      autoFitPosition: {
        type: Boolean,
        default: true
      },
      renderToBody: {
        type: Boolean,
        default: true
      },
      preventFocus: {
        type: Boolean,
        default: false
      },
      scrollToClose: {
        type: Boolean,
        default: false
      }
    },
    emits: {
      "update:popupVisible": (visible) => true,
      "popupVisibleChange": (visible) => true,
      "show": () => true,
      "hide": () => true,
      "resize": () => true
    },
    setup(props, {
      emit,
      slots,
      attrs
    }) {
      const {
        popupContainer
      } = vue.toRefs(props);
      const prefixCls = getPrefixCls("trigger");
      const popupAttrs = vue.computed(() => omit(attrs, TRIGGER_EVENTS));
      const configCtx = vue.inject(configProviderInjectionKey, void 0);
      const triggerMethods = vue.computed(() => [].concat(props.trigger));
      const childrenRefs = new Set();
      const triggerCtx = vue.inject(triggerInjectionKey, void 0);
      const {
        children,
        firstElement
      } = useFirstElement();
      const popupRef = vue.ref();
      const popupVisible = vue.ref(props.defaultPopupVisible);
      const popupPosition = vue.ref(props.position);
      const popupStyle = vue.ref({});
      const transformStyle = vue.ref({});
      const arrowStyle = vue.ref({});
      const arrowRef = vue.ref();
      const mousePosition = vue.ref({
        top: 0,
        left: 0
      });
      const computedVisible = vue.computed(() => {
        var _a;
        return (_a = props.popupVisible) != null ? _a : popupVisible.value;
      });
      const {
        teleportContainer,
        containerRef
      } = useTeleportContainer({
        popupContainer,
        visible: computedVisible,
        documentContainer: true
      });
      const {
        zIndex
      } = usePopupManager("popup", {
        visible: computedVisible
      });
      let delayTimer = 0;
      let outsideListener = false;
      let windowListener = false;
      const cleanDelayTimer = () => {
        if (delayTimer) {
          window.clearTimeout(delayTimer);
          delayTimer = 0;
        }
      };
      const updateMousePosition = (e2) => {
        if (props.alignPoint) {
          const {
            pageX,
            pageY
          } = e2;
          mousePosition.value = {
            top: pageY,
            left: pageX
          };
        }
      };
      const updatePopupStyle = () => {
        if (!firstElement.value || !popupRef.value || !containerRef.value) {
          return;
        }
        const containerRect = containerRef.value.getBoundingClientRect();
        const triggerRect = props.alignPoint ? {
          top: mousePosition.value.top,
          bottom: mousePosition.value.top,
          left: mousePosition.value.left,
          right: mousePosition.value.left,
          scrollTop: mousePosition.value.top,
          scrollBottom: mousePosition.value.top,
          scrollLeft: mousePosition.value.left,
          scrollRight: mousePosition.value.left,
          width: 0,
          height: 0
        } : getElementScrollRect(firstElement.value, containerRect);
        const getPopupRect = () => getElementScrollRect(popupRef.value, containerRect);
        const popupRect = getPopupRect();
        const {
          style,
          position
        } = getPopupStyle(props.position, containerRect, triggerRect, popupRect, {
          offset: props.popupOffset,
          translate: props.popupTranslate,
          customStyle: props.popupStyle,
          autoFitPosition: props.autoFitPosition
        });
        if (props.autoFitTransformOrigin) {
          transformStyle.value = {
            transformOrigin: getTransformOrigin(position)
          };
        }
        if (props.autoFitPopupMinWidth) {
          style.minWidth = `${triggerRect.width}px`;
        } else if (props.autoFitPopupWidth) {
          style.width = `${triggerRect.width}px`;
        }
        if (popupPosition.value !== position) {
          popupPosition.value = position;
        }
        popupStyle.value = style;
        if (props.showArrow) {
          vue.nextTick(() => {
            arrowStyle.value = getArrowStyle(position, triggerRect, getPopupRect(), {
              customStyle: props.arrowStyle
            });
          });
        }
      };
      const changeVisible = (visible, delay) => {
        if (visible === computedVisible.value && delayTimer === 0) {
          return;
        }
        const update = () => {
          popupVisible.value = visible;
          emit("update:popupVisible", visible);
          emit("popupVisibleChange", visible);
          if (visible) {
            vue.nextTick(() => {
              updatePopupStyle();
            });
          }
        };
        if (delay) {
          cleanDelayTimer();
          if (visible !== computedVisible.value) {
            delayTimer = window.setTimeout(update, delay);
          }
        } else {
          update();
        }
      };
      const handleClick = (e2) => {
        var _a;
        (_a = attrs.onClick) == null ? void 0 : _a.call(attrs, e2);
        if (props.disabled || computedVisible.value && !props.clickToClose) {
          return;
        }
        if (triggerMethods.value.includes("click")) {
          updateMousePosition(e2);
          changeVisible(!computedVisible.value);
        } else if (triggerMethods.value.includes("contextMenu") && computedVisible.value) {
          changeVisible(false);
        }
      };
      const handleMouseEnter = (e2) => {
        var _a;
        (_a = attrs.onMouseenter) == null ? void 0 : _a.call(attrs, e2);
        if (props.disabled || !triggerMethods.value.includes("hover")) {
          return;
        }
        updateMousePosition(e2);
        changeVisible(true, props.mouseEnterDelay);
      };
      const handleMouseEnterWithContext = (e2) => {
        triggerCtx == null ? void 0 : triggerCtx.onMouseenter(e2);
        handleMouseEnter(e2);
      };
      const handleMouseLeave = (e2) => {
        var _a;
        (_a = attrs.onMouseleave) == null ? void 0 : _a.call(attrs, e2);
        if (props.disabled || !triggerMethods.value.includes("hover")) {
          return;
        }
        changeVisible(false, props.mouseLeaveDelay);
      };
      const handleMouseLeaveWithContext = (e2) => {
        triggerCtx == null ? void 0 : triggerCtx.onMouseleave(e2);
        handleMouseLeave(e2);
      };
      const handleFocusin = (e2) => {
        var _a;
        (_a = attrs.onFocusin) == null ? void 0 : _a.call(attrs, e2);
        if (props.disabled || !triggerMethods.value.includes("focus")) {
          return;
        }
        changeVisible(true, props.focusDelay);
      };
      const handleFocusout = (e2) => {
        var _a;
        (_a = attrs.onFocusout) == null ? void 0 : _a.call(attrs, e2);
        if (props.disabled || !triggerMethods.value.includes("focus")) {
          return;
        }
        if (!props.blurToClose) {
          return;
        }
        changeVisible(false);
      };
      const handleContextmenu = (e2) => {
        var _a;
        (_a = attrs.onContextmenu) == null ? void 0 : _a.call(attrs, e2);
        if (props.disabled || !triggerMethods.value.includes("contextMenu") || computedVisible.value && !props.clickToClose) {
          return;
        }
        updateMousePosition(e2);
        changeVisible(!computedVisible.value);
        e2.preventDefault();
      };
      const addChildRef = (ref) => {
        childrenRefs.add(ref);
        triggerCtx == null ? void 0 : triggerCtx.addChildRef(ref);
      };
      const removeChildRef = (ref) => {
        childrenRefs.delete(ref);
        triggerCtx == null ? void 0 : triggerCtx.removeChildRef(ref);
      };
      vue.provide(triggerInjectionKey, vue.reactive({
        onMouseenter: handleMouseEnterWithContext,
        onMouseleave: handleMouseLeaveWithContext,
        addChildRef,
        removeChildRef
      }));
      const removeOutsideListener = () => {
        off(document.documentElement, "mousedown", handleOutsideClick);
        outsideListener = false;
      };
      const contentSlot = usePickSlots(slots, "content");
      const hidePopup = vue.computed(() => {
        var _a;
        return props.hideEmpty && isEmptyChildren((_a = contentSlot.value) == null ? void 0 : _a.call(contentSlot));
      });
      const handleOutsideClick = (e2) => {
        var _a, _b, _c;
        if (((_a = firstElement.value) == null ? void 0 : _a.contains(e2.target)) || ((_b = popupRef.value) == null ? void 0 : _b.contains(e2.target))) {
          return;
        }
        for (const item of childrenRefs) {
          if ((_c = item.value) == null ? void 0 : _c.contains(e2.target)) {
            return;
          }
        }
        removeOutsideListener();
        changeVisible(false);
      };
      const handleScroll = throttleByRaf(() => {
        if (computedVisible.value) {
          if (props.scrollToClose || (configCtx == null ? void 0 : configCtx.scrollToClose)) {
            changeVisible(false);
          } else {
            updatePopupStyle();
          }
        }
      });
      const removeWindowScroll = () => {
        off(window, "scroll", onWindowScroll);
        windowListener = false;
      };
      const onWindowScroll = throttleByRaf(() => {
        changeVisible(false);
        removeWindowScroll();
      });
      const handleResize = () => {
        if (computedVisible.value) {
          updatePopupStyle();
        }
      };
      const onTargetResize = () => {
        handleResize();
        emit("resize");
      };
      const handlePopupMouseDown = (e2) => {
        if (props.preventFocus) {
          e2.preventDefault();
        }
      };
      triggerCtx == null ? void 0 : triggerCtx.addChildRef(popupRef);
      const triggerCls = vue.computed(() => {
        return computedVisible.value ? props.openedClass : void 0;
      });
      let scrollElements;
      vue.watch(computedVisible, (value) => {
        if (props.clickOutsideToClose) {
          if (!value && outsideListener) {
            removeOutsideListener();
          } else if (value && !outsideListener) {
            on(document.documentElement, "mousedown", handleOutsideClick);
            outsideListener = true;
          }
        }
        if (props.scrollToClose || (configCtx == null ? void 0 : configCtx.scrollToClose)) {
          on(window, "scroll", onWindowScroll);
          windowListener = true;
        }
        if (props.updateAtScroll || (configCtx == null ? void 0 : configCtx.updateAtScroll)) {
          if (value) {
            scrollElements = getScrollElements(firstElement.value);
            for (const item of scrollElements) {
              item.addEventListener("scroll", handleScroll);
            }
          } else if (scrollElements) {
            for (const item of scrollElements) {
              item.removeEventListener("scroll", handleScroll);
            }
            scrollElements = void 0;
          }
        }
        if (value) {
          mounted.value = true;
        }
      });
      vue.watch(() => [props.autoFitPopupWidth, props.autoFitPopupMinWidth], () => {
        if (computedVisible.value) {
          updatePopupStyle();
        }
      });
      const {
        createResizeObserver,
        destroyResizeObserver
      } = useResizeObserver({
        elementRef: containerRef,
        onResize: handleResize
      });
      vue.onMounted(() => {
        createResizeObserver();
        if (computedVisible.value) {
          updatePopupStyle();
          if (props.clickOutsideToClose && !outsideListener) {
            on(document.documentElement, "mousedown", handleOutsideClick);
            outsideListener = true;
          }
          if (props.updateAtScroll || (configCtx == null ? void 0 : configCtx.updateAtScroll)) {
            scrollElements = getScrollElements(firstElement.value);
            for (const item of scrollElements) {
              item.addEventListener("scroll", handleScroll);
            }
          }
        }
      });
      vue.onUpdated(() => {
        if (computedVisible.value) {
          updatePopupStyle();
        }
      });
      vue.onDeactivated(() => {
        changeVisible(false);
      });
      vue.onBeforeUnmount(() => {
        triggerCtx == null ? void 0 : triggerCtx.removeChildRef(popupRef);
        destroyResizeObserver();
        if (outsideListener) {
          removeOutsideListener();
        }
        if (windowListener) {
          removeWindowScroll();
        }
        if (scrollElements) {
          for (const item of scrollElements) {
            item.removeEventListener("scroll", handleScroll);
          }
          scrollElements = void 0;
        }
      });
      const mounted = vue.ref(computedVisible.value);
      const isAnimation = vue.ref(false);
      const onAnimationStart = () => {
        isAnimation.value = true;
      };
      const handleShow = () => {
        isAnimation.value = false;
        if (computedVisible.value) {
          emit("show");
        }
      };
      const handleHide = () => {
        isAnimation.value = false;
        if (!computedVisible.value) {
          mounted.value = false;
          emit("hide");
        }
      };
      return () => {
        var _a, _b;
        children.value = (_b = (_a = slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : [];
        mergeFirstChild(children.value, {
          class: triggerCls.value,
          onClick: handleClick,
          onMouseenter: handleMouseEnter,
          onMouseleave: handleMouseLeave,
          onFocusin: handleFocusin,
          onFocusout: handleFocusout,
          onContextmenu: handleContextmenu
        });
        return vue.createVNode(vue.Fragment, null, [props.autoFixPosition ? vue.createVNode(ResizeObserver, {
          "onResize": onTargetResize
        }, {
          default: () => [children.value]
        }) : children.value, vue.createVNode(ClientOnly, null, {
          default: () => [vue.createVNode(vue.Teleport, {
            "to": teleportContainer.value,
            "disabled": !props.renderToBody
          }, {
            default: () => [(!props.unmountOnClose || computedVisible.value || mounted.value) && !hidePopup.value && vue.createVNode(ResizeObserver, {
              "onResize": handleResize
            }, {
              default: () => [vue.createVNode("div", vue.mergeProps({
                "ref": popupRef,
                "class": [`${prefixCls}-popup`, `${prefixCls}-position-${popupPosition.value}`],
                "style": __spreadProps(__spreadValues({}, popupStyle.value), {
                  zIndex: zIndex.value,
                  pointerEvents: isAnimation.value ? "none" : "auto"
                }),
                "trigger-placement": popupPosition.value,
                "onMouseenter": handleMouseEnterWithContext,
                "onMouseleave": handleMouseLeaveWithContext,
                "onMousedown": handlePopupMouseDown
              }, popupAttrs.value), [vue.createVNode(vue.Transition, {
                "name": props.animationName,
                "duration": props.duration,
                "appear": true,
                "onBeforeEnter": onAnimationStart,
                "onAfterEnter": handleShow,
                "onBeforeLeave": onAnimationStart,
                "onAfterLeave": handleHide
              }, {
                default: () => {
                  var _a2;
                  return [vue.withDirectives(vue.createVNode("div", {
                    "class": `${prefixCls}-popup-wrapper`,
                    "style": transformStyle.value
                  }, [vue.createVNode("div", {
                    "class": [`${prefixCls}-content`, props.contentClass],
                    "style": props.contentStyle
                  }, [(_a2 = slots.content) == null ? void 0 : _a2.call(slots)]), props.showArrow && vue.createVNode("div", {
                    "ref": arrowRef,
                    "class": [`${prefixCls}-arrow`, props.arrowClass],
                    "style": arrowStyle.value
                  }, null)]), [[vue.vShow, computedVisible.value]])];
                }
              })])]
            })]
          })]
        })]);
      };
    }
  });
  const Trigger = Object.assign(_Trigger, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Trigger.name, _Trigger);
    }
  });
  const _sfc_main$2J = vue.defineComponent({
    name: "IconEmpty",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-empty`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$18 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$U = /* @__PURE__ */ vue.createElementVNode("path", { d: "M24 5v6m7 1 4-4m-18 4-4-4m28.5 22H28s-1 3-4 3-4-3-4-3H6.5M40 41H8a2 2 0 0 1-2-2v-8.46a2 2 0 0 1 .272-1.007l6.15-10.54A2 2 0 0 1 14.148 18H33.85a2 2 0 0 1 1.728.992l6.149 10.541A2 2 0 0 1 42 30.541V39a2 2 0 0 1-2 2Z" }, null, -1);
  const _hoisted_3$Q = [
    _hoisted_2$U
  ];
  function _sfc_render$2I(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$Q, 14, _hoisted_1$18);
  }
  var _IconEmpty = /* @__PURE__ */ _export_sfc(_sfc_main$2J, [["render", _sfc_render$2I]]);
  const IconEmpty = Object.assign(_IconEmpty, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconEmpty.name, _IconEmpty);
    }
  });
  var Empty$1 = vue.defineComponent({
    name: "Empty",
    props: {
      description: String,
      imgSrc: String,
      inConfigProvider: {
        type: Boolean,
        default: false
      }
    },
    setup(props, {
      slots
    }) {
      const prefixCls = getPrefixCls("empty");
      const {
        t: t2
      } = useI18n();
      const configCtx = vue.inject(configProviderInjectionKey, void 0);
      return () => {
        var _a, _b, _c, _d;
        if (!props.inConfigProvider && (configCtx == null ? void 0 : configCtx.slots.empty) && !(slots.image || props.imgSrc || props.description)) {
          return configCtx.slots.empty({
            component: "empty"
          });
        }
        return vue.createVNode("div", {
          "class": prefixCls
        }, [vue.createVNode("div", {
          "class": `${prefixCls}-image`
        }, [(_b = (_a = slots.image) == null ? void 0 : _a.call(slots)) != null ? _b : props.imgSrc ? vue.createVNode("img", {
          "src": props.imgSrc,
          "alt": props.description || "empty"
        }, null) : vue.createVNode(IconEmpty, null, null)]), vue.createVNode("div", {
          "class": `${prefixCls}-description`
        }, [(_d = (_c = slots.default) == null ? void 0 : _c.call(slots)) != null ? _d : props.description || t2("empty.description")])]);
      };
    }
  });
  const Empty = Object.assign(Empty$1, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + Empty$1.name, Empty$1);
    }
  });
  const DOT_NUMBER = 5;
  var DotLoading = vue.defineComponent({
    name: "DotLoading",
    props: {
      size: {
        type: Number
      }
    },
    setup(props) {
      const prefixCls = getPrefixCls("dot-loading");
      return () => {
        const style = props.size ? {
          width: `${props.size}px`,
          height: `${props.size}px`
        } : {};
        return vue.createVNode("div", {
          "class": prefixCls,
          "style": {
            width: props.size ? `${props.size * 7}px` : void 0,
            height: props.size ? `${props.size}px` : void 0
          }
        }, [Array(DOT_NUMBER).fill(1).map((_, index2) => vue.createVNode("div", {
          "class": `${prefixCls}-item`,
          "key": index2,
          "style": style
        }, null))]);
      };
    }
  });
  var _Spin = vue.defineComponent({
    name: "Spin",
    props: {
      size: {
        type: Number
      },
      loading: Boolean,
      dot: Boolean,
      tip: String,
      hideIcon: {
        type: Boolean,
        default: false
      }
    },
    setup(props, {
      slots
    }) {
      const prefixCls = getPrefixCls("spin");
      const configCtx = vue.inject(configProviderInjectionKey, void 0);
      const cls = vue.computed(() => [prefixCls, {
        [`${prefixCls}-loading`]: props.loading,
        [`${prefixCls}-with-tip`]: props.tip && !slots.default
      }]);
      const renderIcon = () => {
        if (slots.icon) {
          const iconVNode = getFirstComponent(slots.icon());
          if (iconVNode) {
            return vue.cloneVNode(iconVNode, {
              spin: true
            });
          }
        }
        if (slots.element) {
          return slots.element();
        }
        if (props.dot) {
          return vue.createVNode(DotLoading, {
            "size": props.size
          }, null);
        }
        if (configCtx == null ? void 0 : configCtx.slots.loading) {
          return configCtx.slots.loading();
        }
        return vue.createVNode(IconLoading, {
          "spin": true,
          "size": props.size
        }, null);
      };
      const renderSpinIcon = () => {
        var _a, _b, _c;
        const style = props.size ? {
          fontSize: `${props.size}px`
        } : void 0;
        const hasTip = Boolean((_a = slots.tip) != null ? _a : props.tip);
        return vue.createVNode(vue.Fragment, null, [!props.hideIcon && vue.createVNode("div", {
          "class": `${prefixCls}-icon`,
          "style": style
        }, [renderIcon()]), hasTip && vue.createVNode("div", {
          "class": `${prefixCls}-tip`
        }, [(_c = (_b = slots.tip) == null ? void 0 : _b.call(slots)) != null ? _c : props.tip])]);
      };
      return () => vue.createVNode("div", {
        "class": cls.value
      }, [slots.default ? vue.createVNode(vue.Fragment, null, [slots.default(), props.loading && vue.createVNode("div", {
        "class": `${prefixCls}-mask`
      }, [vue.createVNode("div", {
        "class": `${prefixCls}-mask-icon`
      }, [renderSpinIcon()])])]) : renderSpinIcon()]);
    }
  });
  const Spin = Object.assign(_Spin, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Spin.name, _Spin);
    }
  });
  const _sfc_main$2I = vue.defineComponent({
    name: "Thumb",
    props: {
      data: {
        type: Object
      },
      direction: {
        type: String,
        default: "horizontal"
      },
      alwaysShow: {
        type: Boolean,
        default: false
      },
      both: {
        type: Boolean,
        default: false
      }
    },
    emits: ["scroll"],
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("scrollbar");
      const visible = vue.ref(false);
      const trackRef = vue.ref();
      const thumbRef = vue.ref();
      const thumbMap = vue.computed(() => {
        if (props.direction === "horizontal") {
          return {
            size: "width",
            direction: "left",
            offset: "offsetWidth",
            client: "clientX"
          };
        }
        return {
          size: "height",
          direction: "top",
          offset: "offsetHeight",
          client: "clientY"
        };
      });
      const offset = vue.ref(0);
      const isDragging = vue.ref(false);
      const mouseOffset = vue.ref(0);
      const thumbStyle = vue.computed(() => {
        var _a, _b;
        return {
          [thumbMap.value.size]: `${(_b = (_a = props.data) == null ? void 0 : _a.thumbSize) != null ? _b : 0}px`,
          [thumbMap.value.direction]: `${offset.value}px`
        };
      });
      const handleThumbMouseDown = (ev) => {
        ev.preventDefault();
        if (thumbRef.value) {
          mouseOffset.value = ev[thumbMap.value.client] - thumbRef.value.getBoundingClientRect()[thumbMap.value.direction];
          isDragging.value = true;
          on(window, "mousemove", handleMouseMove);
          on(window, "mouseup", handleMouseUp);
          on(window, "contextmenu", handleMouseUp);
        }
      };
      const handleTrackClick = (ev) => {
        var _a, _b, _c, _d;
        ev.preventDefault();
        if (thumbRef.value) {
          const _offset = getLegalOffset(ev[thumbMap.value.client] > thumbRef.value.getBoundingClientRect()[thumbMap.value.direction] ? offset.value + ((_b = (_a = props.data) == null ? void 0 : _a.thumbSize) != null ? _b : 0) : offset.value - ((_d = (_c = props.data) == null ? void 0 : _c.thumbSize) != null ? _d : 0));
          if (_offset !== offset.value) {
            offset.value = _offset;
            emit("scroll", _offset);
          }
        }
      };
      const getLegalOffset = (offset2) => {
        if (offset2 < 0) {
          return 0;
        }
        if (props.data && offset2 > props.data.max) {
          return props.data.max;
        }
        return offset2;
      };
      const handleMouseMove = (ev) => {
        if (trackRef.value && thumbRef.value) {
          const _offset = getLegalOffset(ev[thumbMap.value.client] - trackRef.value.getBoundingClientRect()[thumbMap.value.direction] - mouseOffset.value);
          if (_offset !== offset.value) {
            offset.value = _offset;
            emit("scroll", _offset);
          }
        }
      };
      const handleMouseUp = () => {
        isDragging.value = false;
        off(window, "mousemove", handleMouseMove);
        off(window, "mouseup", handleMouseUp);
      };
      const setOffset = (_offset) => {
        if (!isDragging.value) {
          _offset = getLegalOffset(_offset);
          if (_offset !== offset.value) {
            offset.value = _offset;
          }
        }
      };
      const thumbCls = vue.computed(() => [
        `${prefixCls}-thumb`,
        `${prefixCls}-thumb-direction-${props.direction}`,
        {
          [`${prefixCls}-thumb-dragging`]: isDragging.value
        }
      ]);
      return {
        visible,
        trackRef,
        thumbRef,
        prefixCls,
        thumbCls,
        thumbStyle,
        handleThumbMouseDown,
        handleTrackClick,
        setOffset
      };
    }
  });
  function _sfc_render$2H(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createBlock(vue.Transition, null, {
      default: vue.withCtx(() => [
        vue.createElementVNode("div", {
          ref: "trackRef",
          class: vue.normalizeClass([
            `${_ctx.prefixCls}-track`,
            `${_ctx.prefixCls}-track-direction-${_ctx.direction}`
          ]),
          onMousedown: _cache[1] || (_cache[1] = vue.withModifiers((...args) => _ctx.handleTrackClick && _ctx.handleTrackClick(...args), ["self"]))
        }, [
          vue.createElementVNode("div", {
            ref: "thumbRef",
            class: vue.normalizeClass(_ctx.thumbCls),
            style: vue.normalizeStyle(_ctx.thumbStyle),
            onMousedown: _cache[0] || (_cache[0] = (...args) => _ctx.handleThumbMouseDown && _ctx.handleThumbMouseDown(...args))
          }, [
            vue.createElementVNode("div", {
              class: vue.normalizeClass(`${_ctx.prefixCls}-thumb-bar`)
            }, null, 2)
          ], 38)
        ], 34)
      ]),
      _: 1
    });
  }
  var Thumb = /* @__PURE__ */ _export_sfc(_sfc_main$2I, [["render", _sfc_render$2H]]);
  const THUMB_MIN_SIZE = 20;
  const TRACK_SIZE = 15;
  const _sfc_main$2H = vue.defineComponent({
    name: "Scrollbar",
    components: {
      ResizeObserver,
      Thumb
    },
    inheritAttrs: false,
    props: {
      type: {
        type: String,
        default: "embed"
      },
      outerClass: [String, Object, Array],
      outerStyle: {
        type: [String, Object, Array]
      },
      hide: {
        type: Boolean,
        default: false
      },
      disableHorizontal: {
        type: Boolean,
        default: false
      },
      disableVertical: {
        type: Boolean,
        default: false
      }
    },
    emits: {
      scroll: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("scrollbar");
      const containerRef = vue.ref();
      const horizontalData = vue.ref();
      const verticalData = vue.ref();
      const horizontalThumbRef = vue.ref();
      const verticalThumbRef = vue.ref();
      const _hasHorizontalScrollbar = vue.ref(false);
      const _hasVerticalScrollbar = vue.ref(false);
      const hasHorizontalScrollbar = vue.computed(() => _hasHorizontalScrollbar.value && !props.disableHorizontal);
      const hasVerticalScrollbar = vue.computed(() => _hasVerticalScrollbar.value && !props.disableVertical);
      const isBoth = vue.ref(false);
      const getContainerSize = () => {
        var _a, _b, _c, _d, _e, _f;
        if (containerRef.value) {
          const {
            clientWidth,
            clientHeight,
            offsetWidth,
            offsetHeight,
            scrollWidth,
            scrollHeight,
            scrollTop,
            scrollLeft
          } = containerRef.value;
          _hasHorizontalScrollbar.value = scrollWidth > clientWidth;
          _hasVerticalScrollbar.value = scrollHeight > clientHeight;
          isBoth.value = hasHorizontalScrollbar.value && hasVerticalScrollbar.value;
          const horizontalTrackWidth = props.type === "embed" && isBoth.value ? offsetWidth - TRACK_SIZE : offsetWidth;
          const verticalTrackHeight = props.type === "embed" && isBoth.value ? offsetHeight - TRACK_SIZE : offsetHeight;
          const horizontalThumbWidth = Math.round(horizontalTrackWidth / Math.min(scrollWidth / clientWidth, horizontalTrackWidth / THUMB_MIN_SIZE));
          const maxHorizontalOffset = horizontalTrackWidth - horizontalThumbWidth;
          const horizontalRatio = (scrollWidth - clientWidth) / maxHorizontalOffset;
          const verticalThumbHeight = Math.round(verticalTrackHeight / Math.min(scrollHeight / clientHeight, verticalTrackHeight / THUMB_MIN_SIZE));
          const maxVerticalOffset = verticalTrackHeight - verticalThumbHeight;
          const verticalRatio = (scrollHeight - clientHeight) / maxVerticalOffset;
          horizontalData.value = {
            ratio: horizontalRatio,
            thumbSize: horizontalThumbWidth,
            max: maxHorizontalOffset
          };
          verticalData.value = {
            ratio: verticalRatio,
            thumbSize: verticalThumbHeight,
            max: maxVerticalOffset
          };
          if (scrollTop > 0) {
            const verticalOffset = Math.round(scrollTop / ((_b = (_a = verticalData.value) == null ? void 0 : _a.ratio) != null ? _b : 1));
            (_c = verticalThumbRef.value) == null ? void 0 : _c.setOffset(verticalOffset);
          }
          if (scrollLeft > 0) {
            const horizontalOffset = Math.round(scrollLeft / ((_e = (_d = verticalData.value) == null ? void 0 : _d.ratio) != null ? _e : 1));
            (_f = horizontalThumbRef.value) == null ? void 0 : _f.setOffset(horizontalOffset);
          }
        }
      };
      vue.onMounted(() => {
        getContainerSize();
      });
      const handleResize = () => {
        getContainerSize();
      };
      const handleScroll = (ev) => {
        var _a, _b, _c, _d, _e, _f;
        if (containerRef.value) {
          if (hasHorizontalScrollbar.value && !props.disableHorizontal) {
            const horizontalOffset = Math.round(containerRef.value.scrollLeft / ((_b = (_a = horizontalData.value) == null ? void 0 : _a.ratio) != null ? _b : 1));
            (_c = horizontalThumbRef.value) == null ? void 0 : _c.setOffset(horizontalOffset);
          }
          if (hasVerticalScrollbar.value && !props.disableVertical) {
            const verticalOffset = Math.round(containerRef.value.scrollTop / ((_e = (_d = verticalData.value) == null ? void 0 : _d.ratio) != null ? _e : 1));
            (_f = verticalThumbRef.value) == null ? void 0 : _f.setOffset(verticalOffset);
          }
        }
        emit("scroll", ev);
      };
      const handleHorizontalScroll = (offset) => {
        var _a, _b;
        if (containerRef.value) {
          containerRef.value.scrollTo({
            left: offset * ((_b = (_a = horizontalData.value) == null ? void 0 : _a.ratio) != null ? _b : 1)
          });
        }
      };
      const handleVerticalScroll = (offset) => {
        var _a, _b;
        if (containerRef.value) {
          containerRef.value.scrollTo({
            top: offset * ((_b = (_a = verticalData.value) == null ? void 0 : _a.ratio) != null ? _b : 1)
          });
        }
      };
      const style = vue.computed(() => {
        const style2 = {};
        if (props.type === "track") {
          if (hasHorizontalScrollbar.value) {
            style2.paddingBottom = `${TRACK_SIZE}px`;
          }
          if (hasVerticalScrollbar.value) {
            style2.paddingRight = `${TRACK_SIZE}px`;
          }
        }
        return [style2, props.outerStyle];
      });
      const cls = vue.computed(() => [
        `${prefixCls}`,
        `${prefixCls}-type-${props.type}`,
        {
          [`${prefixCls}-both`]: isBoth.value
        },
        props.outerClass
      ]);
      return {
        prefixCls,
        cls,
        style,
        containerRef,
        horizontalThumbRef,
        verticalThumbRef,
        horizontalData,
        verticalData,
        isBoth,
        hasHorizontalScrollbar,
        hasVerticalScrollbar,
        handleResize,
        handleScroll,
        handleHorizontalScroll,
        handleVerticalScroll
      };
    },
    methods: {
      scrollTo(options, y) {
        var _a, _b;
        if (isObject$1(options)) {
          (_a = this.$refs.containerRef) == null ? void 0 : _a.scrollTo(options);
        } else if (options || y) {
          (_b = this.$refs.containerRef) == null ? void 0 : _b.scrollTo(options, y);
        }
      },
      scrollTop(top) {
        var _a;
        (_a = this.$refs.containerRef) == null ? void 0 : _a.scrollTo({
          top
        });
      },
      scrollLeft(left) {
        var _a;
        (_a = this.$refs.containerRef) == null ? void 0 : _a.scrollTo({
          left
        });
      }
    }
  });
  function _sfc_render$2G(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_ResizeObserver = vue.resolveComponent("ResizeObserver");
    const _component_thumb = vue.resolveComponent("thumb");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.style)
    }, [
      vue.createVNode(_component_ResizeObserver, { onResize: _ctx.handleResize }, {
        default: vue.withCtx(() => [
          vue.createElementVNode("div", vue.mergeProps({
            ref: "containerRef",
            class: `${_ctx.prefixCls}-container`
          }, _ctx.$attrs, {
            onScroll: _cache[0] || (_cache[0] = (...args) => _ctx.handleScroll && _ctx.handleScroll(...args))
          }), [
            vue.createVNode(_component_ResizeObserver, { onResize: _ctx.handleResize }, {
              default: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["onResize"])
          ], 16)
        ]),
        _: 3
      }, 8, ["onResize"]),
      !_ctx.hide && _ctx.hasHorizontalScrollbar ? (vue.openBlock(), vue.createBlock(_component_thumb, {
        key: 0,
        ref: "horizontalThumbRef",
        data: _ctx.horizontalData,
        direction: "horizontal",
        both: _ctx.isBoth,
        onScroll: _ctx.handleHorizontalScroll
      }, null, 8, ["data", "both", "onScroll"])) : vue.createCommentVNode("v-if", true),
      !_ctx.hide && _ctx.hasVerticalScrollbar ? (vue.openBlock(), vue.createBlock(_component_thumb, {
        key: 1,
        ref: "verticalThumbRef",
        data: _ctx.verticalData,
        direction: "vertical",
        both: _ctx.isBoth,
        onScroll: _ctx.handleVerticalScroll
      }, null, 8, ["data", "both", "onScroll"])) : vue.createCommentVNode("v-if", true)
    ], 6);
  }
  var _Scrollbar = /* @__PURE__ */ _export_sfc(_sfc_main$2H, [["render", _sfc_render$2G]]);
  const Scrollbar = Object.assign(_Scrollbar, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Scrollbar.name, _Scrollbar);
    }
  });
  const useComponentRef = (name) => {
    const componentRef = vue.ref();
    const getElement2 = () => {
      if (isComponentInstance(componentRef.value)) {
        return componentRef.value.$refs[name];
      }
      return componentRef.value;
    };
    const elementRef = vue.ref();
    vue.onMounted(() => {
      elementRef.value = getElement2();
    });
    vue.watch([componentRef], () => {
      elementRef.value = getElement2();
    });
    return {
      componentRef,
      elementRef
    };
  };
  const useScrollbar = (scrollbar) => {
    const displayScrollbar = vue.computed(() => Boolean(scrollbar.value));
    const scrollbarProps = vue.computed(() => {
      if (!scrollbar.value)
        return void 0;
      return __spreadValues({
        type: "embed"
      }, isBoolean$1(scrollbar.value) ? void 0 : scrollbar.value);
    });
    return {
      displayScrollbar,
      scrollbarProps
    };
  };
  const _sfc_main$2G = vue.defineComponent({
    name: "SelectDropdown",
    components: {
      ScrollbarComponent: Scrollbar,
      Empty,
      Spin
    },
    props: {
      loading: Boolean,
      empty: Boolean,
      virtualList: Boolean,
      bottomOffset: {
        type: Number,
        default: 0
      },
      scrollbar: {
        type: [Boolean, Object],
        default: true
      },
      onScroll: {
        type: [Function, Array]
      },
      onReachBottom: {
        type: [Function, Array]
      },
      showHeaderOnEmpty: {
        type: Boolean,
        default: false
      },
      showFooterOnEmpty: {
        type: Boolean,
        default: false
      }
    },
    emits: ["scroll", "reachBottom"],
    setup(props, { emit, slots }) {
      var _a, _b, _c;
      const { scrollbar } = vue.toRefs(props);
      const prefixCls = getPrefixCls("select-dropdown");
      const configCtx = vue.inject(configProviderInjectionKey, void 0);
      const SelectEmpty = (_c = (_b = configCtx == null ? void 0 : (_a = configCtx.slots).empty) == null ? void 0 : _b.call(_a, { component: "select" })) == null ? void 0 : _c[0];
      const { componentRef: wrapperComRef, elementRef: wrapperRef } = useComponentRef("containerRef");
      const { displayScrollbar, scrollbarProps } = useScrollbar(scrollbar);
      const handleScroll = (e2) => {
        const { scrollTop, scrollHeight, offsetHeight } = e2.target;
        const bottom = scrollHeight - (scrollTop + offsetHeight);
        if (bottom <= props.bottomOffset) {
          emit("reachBottom", e2);
        }
        emit("scroll", e2);
      };
      const cls = vue.computed(() => [
        prefixCls,
        {
          [`${prefixCls}-has-header`]: Boolean(slots.header),
          [`${prefixCls}-has-footer`]: Boolean(slots.footer)
        }
      ]);
      return {
        prefixCls,
        SelectEmpty,
        cls,
        wrapperRef,
        wrapperComRef,
        handleScroll,
        displayScrollbar,
        scrollbarProps
      };
    }
  });
  function _sfc_render$2F(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_spin = vue.resolveComponent("spin");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.cls)
    }, [
      _ctx.$slots.header && (!_ctx.empty || _ctx.showHeaderOnEmpty) ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: vue.normalizeClass(`${_ctx.prefixCls}-header`)
      }, [
        vue.renderSlot(_ctx.$slots, "header")
      ], 2)) : vue.createCommentVNode("v-if", true),
      _ctx.loading ? (vue.openBlock(), vue.createBlock(_component_spin, {
        key: 1,
        class: vue.normalizeClass(`${_ctx.prefixCls}-loading`)
      }, null, 8, ["class"])) : _ctx.empty ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 2,
        class: vue.normalizeClass(`${_ctx.prefixCls}-empty`)
      }, [
        vue.renderSlot(_ctx.$slots, "empty", {}, () => [
          (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.SelectEmpty ? _ctx.SelectEmpty : "Empty")))
        ])
      ], 2)) : vue.createCommentVNode("v-if", true),
      _ctx.virtualList && !_ctx.loading && !_ctx.empty ? vue.renderSlot(_ctx.$slots, "virtual-list", { key: 3 }) : vue.createCommentVNode("v-if", true),
      !_ctx.virtualList ? vue.withDirectives((vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.displayScrollbar ? "ScrollbarComponent" : "div"), vue.mergeProps({
        key: 4,
        ref: "wrapperComRef",
        class: `${_ctx.prefixCls}-list-wrapper`
      }, _ctx.scrollbarProps, { onScroll: _ctx.handleScroll }), {
        default: vue.withCtx(() => [
          vue.createElementVNode("ul", {
            class: vue.normalizeClass(`${_ctx.prefixCls}-list`)
          }, [
            vue.renderSlot(_ctx.$slots, "default")
          ], 2)
        ]),
        _: 3
      }, 16, ["class", "onScroll"])), [
        [vue.vShow, !_ctx.loading && !_ctx.empty]
      ]) : vue.createCommentVNode("v-if", true),
      _ctx.$slots.footer && (!_ctx.empty || _ctx.showFooterOnEmpty) ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 5,
        class: vue.normalizeClass(`${_ctx.prefixCls}-footer`)
      }, [
        vue.renderSlot(_ctx.$slots, "footer")
      ], 2)) : vue.createCommentVNode("v-if", true)
    ], 2);
  }
  var SelectDropdown = /* @__PURE__ */ _export_sfc(_sfc_main$2G, [["render", _sfc_render$2F]]);
  var IconCheck$1 = vue.defineComponent({
    name: "IconCheck",
    render() {
      return vue.createVNode("svg", {
        "aria-hidden": "true",
        "focusable": "false",
        "viewBox": "0 0 1024 1024",
        "width": "200",
        "height": "200",
        "fill": "currentColor"
      }, [vue.createVNode("path", {
        "d": "M877.44815445 206.10060629a64.72691371 64.72691371 0 0 0-95.14856334 4.01306852L380.73381888 685.46812814 235.22771741 533.48933518a64.72691371 64.72691371 0 0 0-92.43003222-1.03563036l-45.82665557 45.82665443a64.72691371 64.72691371 0 0 0-0.90617629 90.61767965l239.61903446 250.10479331a64.72691371 64.72691371 0 0 0 71.19960405 15.14609778 64.33855261 64.33855261 0 0 0 35.08198741-21.23042702l36.24707186-42.71976334 40.5190474-40.77795556-3.36579926-3.49525333 411.40426297-486.74638962a64.72691371 64.72691371 0 0 0-3.88361443-87.64024149l-45.3088404-45.43829334z",
        "p-id": "840"
      }, null)]);
    }
  });
  const checkboxGroupKey = Symbol("ArcoCheckboxGroup");
  var _Checkbox = vue.defineComponent({
    name: "Checkbox",
    components: {
      IconCheck: IconCheck$1,
      IconHover
    },
    props: {
      modelValue: {
        type: [Boolean, Array],
        default: void 0
      },
      defaultChecked: {
        type: Boolean,
        default: false
      },
      value: {
        type: [String, Number, Boolean]
      },
      disabled: {
        type: Boolean,
        default: false
      },
      indeterminate: {
        type: Boolean,
        default: false
      },
      uninjectGroupContext: {
        type: Boolean,
        default: false
      }
    },
    emits: {
      "update:modelValue": (value) => true,
      "change": (value, ev) => true
    },
    setup(props, {
      emit,
      slots
    }) {
      const {
        disabled,
        modelValue
      } = vue.toRefs(props);
      const prefixCls = getPrefixCls("checkbox");
      const checkboxRef = vue.ref();
      const checkboxGroupCtx = !props.uninjectGroupContext ? vue.inject(checkboxGroupKey, void 0) : void 0;
      const isGroup = (checkboxGroupCtx == null ? void 0 : checkboxGroupCtx.name) === "ArcoCheckboxGroup";
      const {
        mergedDisabled: _mergedDisabled,
        eventHandlers
      } = useFormItem({
        disabled
      });
      const _checked = vue.ref(props.defaultChecked);
      const computedValue = vue.computed(() => {
        var _a;
        return isGroup ? checkboxGroupCtx == null ? void 0 : checkboxGroupCtx.computedValue : (_a = props.modelValue) != null ? _a : _checked.value;
      });
      const computedChecked = vue.computed(() => {
        var _a;
        return isArray$1(computedValue.value) ? computedValue.value.includes((_a = props.value) != null ? _a : true) : computedValue.value;
      });
      const mergedDisabled = vue.computed(() => (checkboxGroupCtx == null ? void 0 : checkboxGroupCtx.disabled) || (_mergedDisabled == null ? void 0 : _mergedDisabled.value) || !computedChecked.value && (checkboxGroupCtx == null ? void 0 : checkboxGroupCtx.isMaxed));
      const handleClick = (ev) => {
        ev.stopPropagation();
      };
      const handleChange = (e2) => {
        var _a, _b, _c, _d;
        const {
          checked
        } = e2.target;
        let newValue = checked;
        if (isArray$1(computedValue.value)) {
          const set = new Set(computedValue.value);
          if (checked) {
            set.add((_a = props.value) != null ? _a : true);
          } else {
            set.delete((_b = props.value) != null ? _b : true);
          }
          newValue = Array.from(set);
        }
        _checked.value = checked;
        if (isGroup && isArray$1(newValue)) {
          checkboxGroupCtx == null ? void 0 : checkboxGroupCtx.handleChange(newValue, e2);
        } else {
          emit("update:modelValue", newValue);
          emit("change", newValue, e2);
          (_d = (_c = eventHandlers.value) == null ? void 0 : _c.onChange) == null ? void 0 : _d.call(_c, e2);
        }
        vue.nextTick(() => {
          if (checkboxRef.value && checkboxRef.value.checked !== computedChecked.value) {
            checkboxRef.value.checked = computedChecked.value;
          }
        });
      };
      const cls = vue.computed(() => [prefixCls, {
        [`${prefixCls}-checked`]: computedChecked.value,
        [`${prefixCls}-indeterminate`]: props.indeterminate,
        [`${prefixCls}-disabled`]: mergedDisabled.value
      }]);
      const handleFocus = (ev) => {
        var _a, _b;
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onFocus) == null ? void 0 : _b.call(_a, ev);
      };
      const handleBlur = (ev) => {
        var _a, _b;
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onBlur) == null ? void 0 : _b.call(_a, ev);
      };
      vue.watch(modelValue, (value) => {
        if (isUndefined(value) || isNull(value)) {
          _checked.value = false;
        }
      });
      vue.watch(computedValue, (value) => {
        var _a;
        let checked;
        if (isArray$1(value)) {
          checked = value.includes((_a = props.value) != null ? _a : true);
        } else {
          checked = value;
        }
        if (_checked.value !== checked) {
          _checked.value = checked;
        }
        if (checkboxRef.value && checkboxRef.value.checked !== checked) {
          checkboxRef.value.checked = checked;
        }
      });
      return () => {
        var _a, _b, _c, _d;
        return vue.createVNode("label", {
          "aria-disabled": mergedDisabled.value,
          "class": cls.value
        }, [vue.createVNode("input", {
          "ref": checkboxRef,
          "type": "checkbox",
          "checked": computedChecked.value,
          "value": props.value,
          "class": `${prefixCls}-target`,
          "disabled": mergedDisabled.value,
          "onClick": handleClick,
          "onChange": handleChange,
          "onFocus": handleFocus,
          "onBlur": handleBlur
        }, null), (_d = (_c = (_b = slots.checkbox) != null ? _b : (_a = checkboxGroupCtx == null ? void 0 : checkboxGroupCtx.slots) == null ? void 0 : _a.checkbox) == null ? void 0 : _c({
          checked: computedChecked.value,
          disabled: mergedDisabled.value
        })) != null ? _d : vue.createVNode(IconHover, {
          "class": `${prefixCls}-icon-hover`,
          "disabled": mergedDisabled.value || computedChecked.value
        }, {
          default: () => [vue.createVNode("div", {
            "class": `${prefixCls}-icon`
          }, [computedChecked.value && vue.createVNode(IconCheck$1, {
            "class": `${prefixCls}-icon-check`
          }, null)])]
        }), slots.default && vue.createVNode("span", {
          "class": `${prefixCls}-label`
        }, [slots.default()])]);
      };
    }
  });
  var CheckboxGroup = vue.defineComponent({
    name: "CheckboxGroup",
    props: {
      modelValue: {
        type: Array,
        default: void 0
      },
      defaultValue: {
        type: Array,
        default: () => []
      },
      max: {
        type: Number
      },
      options: {
        type: Array
      },
      direction: {
        type: String,
        default: "horizontal"
      },
      disabled: {
        type: Boolean,
        default: false
      }
    },
    emits: {
      "update:modelValue": (value) => true,
      "change": (value, ev) => true
    },
    setup(props, {
      emit,
      slots
    }) {
      const {
        disabled
      } = vue.toRefs(props);
      const prefixCls = getPrefixCls("checkbox-group");
      const {
        mergedDisabled,
        eventHandlers
      } = useFormItem({
        disabled
      });
      const _value = vue.ref(props.defaultValue);
      const computedValue = vue.computed(() => isArray$1(props.modelValue) ? props.modelValue : _value.value);
      const isMaxed = vue.computed(() => props.max === void 0 ? false : computedValue.value.length >= props.max);
      const options = vue.computed(() => {
        var _a;
        return ((_a = props.options) != null ? _a : []).map((option) => {
          if (isString$1(option) || isNumber$1(option)) {
            return {
              label: option,
              value: option
            };
          }
          return option;
        });
      });
      const handleChange = (value, e2) => {
        var _a, _b;
        _value.value = value;
        emit("update:modelValue", value);
        emit("change", value, e2);
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a, e2);
      };
      vue.provide(checkboxGroupKey, vue.reactive({
        name: "ArcoCheckboxGroup",
        computedValue,
        disabled: mergedDisabled,
        isMaxed,
        slots,
        handleChange
      }));
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-direction-${props.direction}`]);
      vue.watch(() => props.modelValue, (curValue) => {
        if (isArray$1(curValue)) {
          _value.value = [...curValue];
        } else {
          _value.value = [];
        }
      });
      const renderOptions = () => {
        return options.value.map((option) => {
          const checked = computedValue.value.includes(option.value);
          return vue.createVNode(_Checkbox, {
            "key": option.value,
            "value": option.value,
            "disabled": option.disabled || !checked && isMaxed.value,
            "indeterminate": option.indeterminate,
            "modelValue": checked
          }, {
            default: () => [slots.label ? slots.label({
              data: option
            }) : isFunction$1(option.label) ? option.label() : option.label]
          });
        });
      };
      return () => {
        var _a;
        return vue.createVNode("span", {
          "class": cls.value
        }, [options.value.length > 0 ? renderOptions() : (_a = slots.default) == null ? void 0 : _a.call(slots)]);
      };
    }
  });
  const Checkbox = Object.assign(_Checkbox, {
    Group: CheckboxGroup,
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Checkbox.name, _Checkbox);
      app.component(componentPrefix + CheckboxGroup.name, CheckboxGroup);
    }
  });
  const selectInjectionKey = Symbol("ArcoSelectContext");
  const isGroupOption = (option) => {
    return isObject$1(option) && "isGroup" in option;
  };
  const isGroupOptionInfo = (option) => {
    return isObject$1(option) && "isGroup" in option;
  };
  const getValueString = (value, valueKey = "value") => String(isObject$1(value) ? value[valueKey] : value);
  const getKeyFromValue = (value, valueKey = "value") => {
    if (isObject$1(value)) {
      return `__arco__option__object__${value[valueKey]}`;
    }
    if (value || isNumber$1(value) || isString$1(value)) {
      return `__arco__option__${typeof value}-${value}`;
    }
    return "";
  };
  const hasEmptyStringKey = (optionInfoMap) => {
    return optionInfoMap.has(`__arco__option__string-`);
  };
  const createOptionInfo = (option, {
    valueKey,
    fieldNames,
    origin,
    index: index2 = -1
  }) => {
    var _a;
    if (isObject$1(option)) {
      const value = option[fieldNames.value];
      return {
        raw: option,
        index: index2,
        key: getKeyFromValue(value, valueKey),
        origin,
        value,
        label: (_a = option[fieldNames.label]) != null ? _a : getValueString(value, valueKey),
        render: option[fieldNames.render],
        disabled: Boolean(option[fieldNames.disabled]),
        tagProps: option[fieldNames.tagProps]
      };
    }
    const raw = {
      value: option,
      label: String(option),
      disabled: false
    };
    return __spreadValues({
      raw,
      index: index2,
      key: getKeyFromValue(option, valueKey),
      origin
    }, raw);
  };
  const getOptionInfos$1 = (options, {
    valueKey,
    fieldNames,
    origin,
    optionInfoMap
  }) => {
    var _a;
    const infos = [];
    for (const item of options) {
      if (isGroupOption(item)) {
        const options2 = getOptionInfos$1((_a = item.options) != null ? _a : [], {
          valueKey,
          fieldNames,
          origin,
          optionInfoMap
        });
        if (options2.length > 0) {
          infos.push(__spreadProps(__spreadValues({}, item), {
            key: `__arco__group__${item.label}`,
            options: options2
          }));
        }
      } else {
        const optionInfo = createOptionInfo(item, {
          valueKey,
          fieldNames,
          origin
        });
        infos.push(optionInfo);
        if (!optionInfoMap.get(optionInfo.key)) {
          optionInfoMap.set(optionInfo.key, optionInfo);
        }
      }
    }
    return infos;
  };
  const getValidOptions = (optionInfos, {
    inputValue,
    filterOption
  }) => {
    const travel = (optionInfos2) => {
      var _a;
      const options = [];
      for (const item of optionInfos2) {
        if (isGroupOptionInfo(item)) {
          const _options = travel((_a = item.options) != null ? _a : []);
          if (_options.length > 0) {
            options.push(__spreadProps(__spreadValues({}, item), { options: _options }));
          }
        } else if (isValidOption(item, { inputValue, filterOption })) {
          options.push(item);
        }
      }
      return options;
    };
    return travel(optionInfos);
  };
  const isValidOption = (optionInfo, {
    inputValue,
    filterOption
  }) => {
    if (isFunction$1(filterOption)) {
      return !inputValue || filterOption(inputValue, optionInfo.raw);
    }
    if (filterOption) {
      return optionInfo.label.toLowerCase().includes((inputValue != null ? inputValue : "").toLowerCase());
    }
    return true;
  };
  const isEqualObject = (obj, other) => {
    if (!obj || !other) {
      return false;
    }
    if (obj.length !== other.length) {
      return false;
    }
    for (const key of Object.keys(obj)) {
      const result = isEqual$1(obj[key], other[key]);
      if (!result)
        return false;
    }
    return true;
  };
  const isEqualArray = (arr, other) => {
    if (!arr || !other) {
      return false;
    }
    const { length } = arr;
    if (length !== other.length) {
      return false;
    }
    for (let i = 0; i < length; i++) {
      const result = isEqual$1(arr[i], other[i]);
      if (!result)
        return false;
    }
    return true;
  };
  const isEqual$1 = (a, b) => {
    const type = Object.prototype.toString.call(a);
    if (type !== Object.prototype.toString.call(b)) {
      return false;
    }
    if (type === "[object Object]") {
      return isEqualObject(a, b);
    }
    if (type === "[object Array]") {
      return isEqualArray(a, b);
    }
    if (type === "[object Function]") {
      if (a === b) {
        return true;
      }
      return a.toString() === b.toString();
    }
    return a === b;
  };
  const _sfc_main$2F = vue.defineComponent({
    name: "Option",
    components: {
      Checkbox
    },
    props: {
      value: [String, Number, Object],
      label: String,
      disabled: Boolean,
      tagProps: {
        type: Object
      },
      extra: {
        type: Object
      },
      index: {
        type: Number
      },
      internal: Boolean
    },
    setup(props) {
      const { disabled, tagProps: _tagProps, index: index2 } = vue.toRefs(props);
      const prefixCls = getPrefixCls("select-option");
      const selectCtx = vue.inject(selectInjectionKey, void 0);
      const instance = vue.getCurrentInstance();
      const itemRef = vue.ref();
      const tagProps = vue.ref(_tagProps.value);
      vue.watch(_tagProps, (cur, pre) => {
        if (!isEqual$1(cur, pre)) {
          tagProps.value = cur;
        }
      });
      const textContent = vue.ref("");
      const value = vue.computed(() => {
        var _a, _b;
        return (_b = (_a = props.value) != null ? _a : props.label) != null ? _b : textContent.value;
      });
      const label = vue.computed(() => {
        var _a;
        return (_a = props.label) != null ? _a : textContent.value;
      });
      const key = vue.computed(() => getKeyFromValue(value.value, selectCtx == null ? void 0 : selectCtx.valueKey));
      const component = vue.computed(() => {
        var _a;
        return (_a = selectCtx == null ? void 0 : selectCtx.component) != null ? _a : "li";
      });
      const setTextContent = () => {
        var _a;
        if (!props.label && itemRef.value) {
          const text = (_a = itemRef.value.textContent) != null ? _a : "";
          if (textContent.value !== text) {
            textContent.value = text;
          }
        }
      };
      vue.onMounted(() => setTextContent());
      vue.onUpdated(() => setTextContent());
      const isSelected = vue.computed(() => {
        var _a;
        return (_a = selectCtx == null ? void 0 : selectCtx.valueKeys.includes(key.value)) != null ? _a : false;
      });
      const isActive = vue.computed(() => (selectCtx == null ? void 0 : selectCtx.activeKey) === key.value);
      let isValid = vue.ref(true);
      if (!props.internal) {
        const optionInfo = vue.reactive({
          raw: {
            value,
            label,
            disabled,
            tagProps
          },
          ref: itemRef,
          index: index2,
          key,
          origin: "slot",
          value,
          label,
          disabled,
          tagProps
        });
        isValid = vue.computed(() => isValidOption(optionInfo, {
          inputValue: selectCtx == null ? void 0 : selectCtx.inputValue,
          filterOption: selectCtx == null ? void 0 : selectCtx.filterOption
        }));
        if (instance) {
          selectCtx == null ? void 0 : selectCtx.addSlotOptionInfo(instance.uid, optionInfo);
        }
        vue.onBeforeUnmount(() => {
          if (instance) {
            selectCtx == null ? void 0 : selectCtx.removeSlotOptionInfo(instance.uid);
          }
        });
      }
      const handleClick = (ev) => {
        if (!props.disabled) {
          selectCtx == null ? void 0 : selectCtx.onSelect(key.value, ev);
        }
      };
      const handleMouseEnter = () => {
        if (!props.disabled) {
          selectCtx == null ? void 0 : selectCtx.setActiveKey(key.value);
        }
      };
      const handleMouseLeave = () => {
        if (!props.disabled) {
          selectCtx == null ? void 0 : selectCtx.setActiveKey();
        }
      };
      const cls = vue.computed(() => [
        prefixCls,
        {
          [`${prefixCls}-disabled`]: props.disabled,
          [`${prefixCls}-active`]: isActive.value,
          [`${prefixCls}-multiple`]: selectCtx == null ? void 0 : selectCtx.multiple
        }
      ]);
      return {
        prefixCls,
        cls,
        selectCtx,
        itemRef,
        component,
        isSelected,
        isValid,
        handleClick,
        handleMouseEnter,
        handleMouseLeave
      };
    }
  });
  function _sfc_render$2E(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_checkbox = vue.resolveComponent("checkbox");
    return vue.withDirectives((vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.component), {
      ref: "itemRef",
      class: vue.normalizeClass([_ctx.cls, { [`${_ctx.prefixCls}-has-suffix`]: Boolean(_ctx.$slots.suffix) }]),
      onClick: _ctx.handleClick,
      onMouseenter: _ctx.handleMouseEnter,
      onMouseleave: _ctx.handleMouseLeave
    }, {
      default: vue.withCtx(() => [
        _ctx.$slots.icon ? (vue.openBlock(), vue.createElementBlock("span", {
          key: 0,
          class: vue.normalizeClass(`${_ctx.prefixCls}-icon`)
        }, [
          vue.renderSlot(_ctx.$slots, "icon")
        ], 2)) : vue.createCommentVNode("v-if", true),
        _ctx.selectCtx && _ctx.selectCtx.multiple ? (vue.openBlock(), vue.createBlock(_component_checkbox, {
          key: 1,
          class: vue.normalizeClass(`${_ctx.prefixCls}-checkbox`),
          "model-value": _ctx.isSelected,
          disabled: _ctx.disabled,
          "uninject-group-context": ""
        }, {
          default: vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "default", {}, () => [
              vue.createTextVNode(vue.toDisplayString(_ctx.label), 1)
            ])
          ]),
          _: 3
        }, 8, ["class", "model-value", "disabled"])) : (vue.openBlock(), vue.createElementBlock("span", {
          key: 2,
          class: vue.normalizeClass(`${_ctx.prefixCls}-content`)
        }, [
          vue.renderSlot(_ctx.$slots, "default", {}, () => [
            vue.createTextVNode(vue.toDisplayString(_ctx.label), 1)
          ])
        ], 2)),
        _ctx.$slots.suffix ? (vue.openBlock(), vue.createElementBlock("span", {
          key: 3,
          class: vue.normalizeClass(`${_ctx.prefixCls}-suffix`)
        }, [
          vue.renderSlot(_ctx.$slots, "suffix")
        ], 2)) : vue.createCommentVNode("v-if", true)
      ]),
      _: 3
    }, 8, ["class", "onClick", "onMouseenter", "onMouseleave"])), [
      [vue.vShow, _ctx.isValid]
    ]);
  }
  var Option = /* @__PURE__ */ _export_sfc(_sfc_main$2F, [["render", _sfc_render$2E]]);
  const DEFAULT_FIELD_NAMES$2 = {
    value: "value",
    label: "label",
    disabled: "disabled",
    tagProps: "tagProps",
    render: "render"
  };
  const useOptions = ({
    options,
    extraOptions,
    inputValue,
    filterOption,
    showExtraOptions,
    valueKey,
    fieldNames
  }) => {
    const mergedFieldNames = vue.computed(() => __spreadValues(__spreadValues({}, DEFAULT_FIELD_NAMES$2), fieldNames == null ? void 0 : fieldNames.value));
    const slotOptionInfoMap = vue.reactive(new Map());
    const sortedSlotOptionInfos = vue.computed(() => Array.from(slotOptionInfoMap.values()).sort((a, b) => {
      if (isNumber$1(a.index) && isNumber$1(b.index)) {
        return a.index - b.index;
      }
      return 0;
    }));
    const propOptionData = vue.computed(() => {
      var _a, _b;
      const optionInfoMap2 = new Map();
      const optionInfos = getOptionInfos$1((_a = options == null ? void 0 : options.value) != null ? _a : [], {
        valueKey: (_b = valueKey == null ? void 0 : valueKey.value) != null ? _b : "value",
        fieldNames: mergedFieldNames.value,
        origin: "options",
        optionInfoMap: optionInfoMap2
      });
      return {
        optionInfos,
        optionInfoMap: optionInfoMap2
      };
    });
    const extraOptionData = vue.computed(() => {
      var _a, _b;
      const optionInfoMap2 = new Map();
      const optionInfos = getOptionInfos$1((_a = extraOptions == null ? void 0 : extraOptions.value) != null ? _a : [], {
        valueKey: (_b = valueKey == null ? void 0 : valueKey.value) != null ? _b : "value",
        fieldNames: mergedFieldNames.value,
        origin: "extraOptions",
        optionInfoMap: optionInfoMap2
      });
      return {
        optionInfos,
        optionInfoMap: optionInfoMap2
      };
    });
    const optionInfoMap = vue.reactive(new Map());
    vue.watch([
      sortedSlotOptionInfos,
      options != null ? options : vue.ref([]),
      extraOptions != null ? extraOptions : vue.ref([]),
      valueKey != null ? valueKey : vue.ref("value")
    ], () => {
      optionInfoMap.clear();
      sortedSlotOptionInfos.value.forEach((info, index2) => {
        optionInfoMap.set(info.key, __spreadProps(__spreadValues({}, info), { index: index2 }));
      });
      propOptionData.value.optionInfoMap.forEach((info) => {
        if (!optionInfoMap.has(info.key)) {
          info.index = optionInfoMap.size;
          optionInfoMap.set(info.key, info);
        }
      });
      extraOptionData.value.optionInfoMap.forEach((info) => {
        if (!optionInfoMap.has(info.key)) {
          info.index = optionInfoMap.size;
          optionInfoMap.set(info.key, info);
        }
      });
    }, { immediate: true, deep: true });
    const validOptions = vue.computed(() => {
      var _a;
      const options2 = getValidOptions(propOptionData.value.optionInfos, {
        inputValue: inputValue == null ? void 0 : inputValue.value,
        filterOption: filterOption == null ? void 0 : filterOption.value
      });
      if ((_a = showExtraOptions == null ? void 0 : showExtraOptions.value) != null ? _a : true) {
        options2.push(...getValidOptions(extraOptionData.value.optionInfos, {
          inputValue: inputValue == null ? void 0 : inputValue.value,
          filterOption: filterOption == null ? void 0 : filterOption.value
        }));
      }
      return options2;
    });
    const validOptionInfos = vue.computed(() => Array.from(optionInfoMap.values()).filter((optionInfo) => {
      if (optionInfo.origin === "extraOptions" && (showExtraOptions == null ? void 0 : showExtraOptions.value) === false) {
        return false;
      }
      return isValidOption(optionInfo, {
        inputValue: inputValue == null ? void 0 : inputValue.value,
        filterOption: filterOption == null ? void 0 : filterOption.value
      });
    }));
    const enabledOptionKeys = vue.computed(() => validOptionInfos.value.filter((optionInfo) => !optionInfo.disabled).map((info) => info.key));
    const getNextSlotOptionIndex = () => slotOptionInfoMap.size;
    const addSlotOptionInfo = (id, optionInfo) => {
      slotOptionInfoMap.set(id, optionInfo);
    };
    const removeSlotOptionInfo = (id) => {
      slotOptionInfoMap.delete(id);
    };
    return {
      validOptions,
      optionInfoMap,
      validOptionInfos,
      enabledOptionKeys,
      getNextSlotOptionIndex,
      addSlotOptionInfo,
      removeSlotOptionInfo
    };
  };
  const KEYBOARD_KEY = {
    ENTER: "Enter",
    ESC: "Escape",
    BACKSPACE: "Backspace",
    TAB: "Tab",
    SPACE: " ",
    ARROW_UP: "ArrowUp",
    ARROW_DOWN: "ArrowDown",
    ARROW_LEFT: "ArrowLeft",
    ARROW_RIGHT: "ArrowRight"
  };
  const stringifyCodeKey = (k) => {
    return JSON.stringify({
      key: k.key,
      ctrl: Boolean(k.ctrl),
      shift: Boolean(k.shift),
      alt: Boolean(k.alt),
      meta: Boolean(k.meta)
    });
  };
  const getKeyDownHandler = (codeKeyMap) => {
    const map = {};
    codeKeyMap.forEach((callback, codeKey) => {
      const _codeKey = isString$1(codeKey) ? { key: codeKey } : codeKey;
      map[stringifyCodeKey(_codeKey)] = callback;
    });
    return (event) => {
      const key = stringifyCodeKey({
        key: event.key,
        ctrl: event.ctrlKey,
        shift: event.shiftKey,
        alt: event.altKey,
        meta: event.metaKey
      });
      const callback = map[key];
      if (callback) {
        event.stopPropagation();
        callback(event);
      }
    };
  };
  const useSelect = ({
    multiple,
    options,
    extraOptions,
    inputValue,
    filterOption,
    showExtraOptions,
    component,
    valueKey,
    fieldNames,
    loading,
    popupVisible,
    valueKeys,
    dropdownRef,
    optionRefs,
    virtualListRef,
    onSelect,
    onPopupVisibleChange,
    enterToOpen = true,
    defaultActiveFirstOption
  }) => {
    const {
      validOptions,
      optionInfoMap,
      validOptionInfos,
      enabledOptionKeys,
      getNextSlotOptionIndex,
      addSlotOptionInfo,
      removeSlotOptionInfo
    } = useOptions({
      options,
      extraOptions,
      inputValue,
      filterOption,
      showExtraOptions,
      valueKey,
      fieldNames
    });
    const activeKey = vue.ref();
    vue.watch(enabledOptionKeys, (enabledKeys) => {
      if (!activeKey.value || !enabledKeys.includes(activeKey.value)) {
        activeKey.value = enabledKeys[0];
      }
    });
    const setActiveKey = (key) => {
      activeKey.value = key;
    };
    const getNextActiveKey = (direction) => {
      const _length = enabledOptionKeys.value.length;
      if (_length === 0) {
        return void 0;
      }
      if (!activeKey.value) {
        if (direction === "down") {
          return enabledOptionKeys.value[0];
        }
        return enabledOptionKeys.value[_length - 1];
      }
      const activeIndex = enabledOptionKeys.value.indexOf(activeKey.value);
      const nextIndex = (_length + activeIndex + (direction === "up" ? -1 : 1)) % _length;
      return enabledOptionKeys.value[nextIndex];
    };
    const scrollIntoView2 = (key) => {
      var _a, _b;
      if (virtualListRef == null ? void 0 : virtualListRef.value) {
        virtualListRef.value.scrollTo({ key });
      }
      const optionInfo = optionInfoMap.get(key);
      const wrapperEle = (_a = dropdownRef == null ? void 0 : dropdownRef.value) == null ? void 0 : _a.wrapperRef;
      const optionEle = (_b = optionRefs == null ? void 0 : optionRefs.value[key]) != null ? _b : optionInfo == null ? void 0 : optionInfo.ref;
      if (!wrapperEle || !optionEle) {
        return;
      }
      if (wrapperEle.scrollHeight === wrapperEle.offsetHeight) {
        return;
      }
      const optionRect = getRelativeRect(optionEle, wrapperEle);
      const wrapperScrollTop = wrapperEle.scrollTop;
      if (optionRect.top < 0) {
        wrapperEle.scrollTo(0, wrapperScrollTop + optionRect.top);
      } else if (optionRect.bottom < 0) {
        wrapperEle.scrollTo(0, wrapperScrollTop - optionRect.bottom);
      }
    };
    vue.watch(popupVisible, (visible) => {
      var _a;
      if (visible) {
        const current = valueKeys.value[valueKeys.value.length - 1];
        let _activeKey = ((_a = defaultActiveFirstOption == null ? void 0 : defaultActiveFirstOption.value) != null ? _a : true) ? enabledOptionKeys.value[0] : void 0;
        if (enabledOptionKeys.value.includes(current)) {
          _activeKey = current;
        }
        if (_activeKey !== activeKey.value) {
          activeKey.value = _activeKey;
        }
        vue.nextTick(() => {
          if (activeKey.value) {
            scrollIntoView2(activeKey.value);
          }
        });
      }
    });
    const handleKeyDown = getKeyDownHandler(new Map([
      [
        KEYBOARD_KEY.ENTER,
        (e2) => {
          if (!(loading == null ? void 0 : loading.value) && !e2.isComposing) {
            if (popupVisible.value) {
              if (activeKey.value) {
                onSelect(activeKey.value, e2);
                e2.preventDefault();
              }
            } else if (enterToOpen) {
              onPopupVisibleChange(true);
              e2.preventDefault();
            }
          }
        }
      ],
      [
        KEYBOARD_KEY.ESC,
        (e2) => {
          if (popupVisible.value) {
            onPopupVisibleChange(false);
            e2.preventDefault();
          }
        }
      ],
      [
        KEYBOARD_KEY.ARROW_DOWN,
        (e2) => {
          if (popupVisible.value) {
            const next = getNextActiveKey("down");
            if (next) {
              activeKey.value = next;
              scrollIntoView2(next);
            }
            e2.preventDefault();
          }
        }
      ],
      [
        KEYBOARD_KEY.ARROW_UP,
        (e2) => {
          if (popupVisible.value) {
            const next = getNextActiveKey("up");
            if (next) {
              activeKey.value = next;
              scrollIntoView2(next);
            }
            e2.preventDefault();
          }
        }
      ]
    ]));
    vue.provide(selectInjectionKey, vue.reactive({
      multiple,
      valueKey,
      inputValue,
      filterOption,
      component,
      valueKeys,
      activeKey,
      setActiveKey,
      onSelect,
      getNextSlotOptionIndex,
      addSlotOptionInfo,
      removeSlotOptionInfo
    }));
    return {
      validOptions,
      optionInfoMap,
      validOptionInfos,
      enabledOptionKeys,
      activeKey,
      setActiveKey,
      addSlotOptionInfo,
      removeSlotOptionInfo,
      getNextActiveKey,
      scrollIntoView: scrollIntoView2,
      handleKeyDown
    };
  };
  var _AutoComplete = vue.defineComponent({
    name: "AutoComplete",
    inheritAttrs: false,
    props: {
      modelValue: {
        type: String,
        default: void 0
      },
      defaultValue: {
        type: String,
        default: ""
      },
      disabled: {
        type: Boolean,
        default: false
      },
      data: {
        type: Array,
        default: () => []
      },
      popupContainer: {
        type: [String, Object]
      },
      strict: {
        type: Boolean,
        default: false
      },
      filterOption: {
        type: [Boolean, Function],
        default: true
      },
      triggerProps: {
        type: Object
      },
      allowClear: {
        type: Boolean,
        default: false
      }
    },
    emits: {
      "update:modelValue": (value) => true,
      "change": (value) => true,
      "search": (value) => true,
      "select": (value) => true,
      "clear": (ev) => true
    },
    setup(props, {
      emit,
      attrs,
      slots
    }) {
      const {
        modelValue
      } = vue.toRefs(props);
      const prefixCls = getPrefixCls("auto-complete");
      const {
        mergedDisabled,
        eventHandlers
      } = useFormItem({
        disabled: vue.toRef(props, "disabled")
      });
      const _value = vue.ref(props.defaultValue);
      const inputRef = vue.ref();
      const computedValue = vue.computed(() => {
        var _a;
        return (_a = props.modelValue) != null ? _a : _value.value;
      });
      vue.watch(modelValue, (value) => {
        if (isUndefined(value) || isNull(value)) {
          _value.value = "";
        }
      });
      const computedValueKeys = vue.computed(() => computedValue.value ? [getKeyFromValue(computedValue.value)] : []);
      const {
        data
      } = vue.toRefs(props);
      const dropdownRef = vue.ref();
      const optionRefs = vue.ref({});
      const _popupVisible = vue.ref(false);
      const computedPopupVisible = vue.computed(() => _popupVisible.value && validOptionInfos.value.length > 0);
      const handlePopupVisibleChange = (popupVisible) => {
        _popupVisible.value = popupVisible;
      };
      const strictFilterOption = (inputValue, option) => {
        var _a;
        return Boolean((_a = option.label) == null ? void 0 : _a.includes(inputValue));
      };
      const mergedFilterOption = vue.computed(() => {
        if (isFunction$1(props.filterOption)) {
          return props.filterOption;
        }
        if (props.filterOption && props.strict) {
          return strictFilterOption;
        }
        return props.filterOption;
      });
      const handleChange = (value) => {
        var _a, _b;
        _value.value = value;
        emit("update:modelValue", value);
        emit("change", value);
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a);
      };
      const handleClear = (ev) => {
        var _a, _b;
        _value.value = "";
        emit("update:modelValue", "");
        emit("change", "");
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a);
        emit("clear", ev);
      };
      const handleSelect = (key, ev) => {
        var _a, _b;
        const value = (_a = optionInfoMap.get(key)) == null ? void 0 : _a.value;
        emit("select", value);
        handleChange(value);
        (_b = inputRef.value) == null ? void 0 : _b.blur();
      };
      const handleInputValueChange = (value) => {
        emit("search", value);
        handleChange(value);
      };
      const {
        validOptions,
        optionInfoMap,
        validOptionInfos,
        handleKeyDown
      } = useSelect({
        options: data,
        inputValue: computedValue,
        filterOption: mergedFilterOption,
        popupVisible: computedPopupVisible,
        valueKeys: computedValueKeys,
        dropdownRef,
        optionRefs,
        onSelect: handleSelect,
        onPopupVisibleChange: handlePopupVisibleChange
      });
      const getOptionContentFunc = (item) => {
        if (isFunction$1(slots.option) && item.value) {
          const optionInfo = optionInfoMap.get(item.key);
          const optionSlot = slots.option;
          return () => optionSlot({
            data: optionInfo
          });
        }
        return () => item.label;
      };
      const renderOption = (item) => {
        return vue.createVNode(Option, {
          "ref": (ref) => {
            if (ref == null ? void 0 : ref.$el) {
              optionRefs.value[item.key] = ref.$el;
            }
          },
          "key": item.key,
          "value": item.value,
          "disabled": item.disabled,
          "internal": true
        }, {
          default: getOptionContentFunc(item)
        });
      };
      const renderDropdown = () => {
        return vue.createVNode(SelectDropdown, {
          "ref": dropdownRef,
          "class": `${prefixCls}-dropdown`
        }, {
          default: () => [validOptions.value.map((info) => renderOption(info))],
          footer: slots.footer
        });
      };
      const render = () => vue.createVNode(Trigger, vue.mergeProps({
        "trigger": "focus",
        "position": "bl",
        "animationName": "slide-dynamic-origin",
        "autoFitTransformOrigin": true,
        "popupVisible": computedPopupVisible.value,
        "clickToClose": false,
        "preventFocus": true,
        "popupOffset": 4,
        "disabled": mergedDisabled.value,
        "autoFitPopupWidth": true
      }, props.triggerProps, {
        "onPopupVisibleChange": handlePopupVisibleChange
      }), {
        default: () => [vue.createVNode(Input, vue.mergeProps({
          "ref": inputRef
        }, attrs, {
          "allowClear": props.allowClear,
          "modelValue": computedValue.value,
          "disabled": mergedDisabled.value,
          "onInput": handleInputValueChange,
          "onClear": handleClear,
          "onKeydown": handleKeyDown
        }), slots)],
        content: renderDropdown
      });
      return {
        inputRef,
        render
      };
    },
    methods: {
      focus() {
        var _a;
        (_a = this.inputRef) == null ? void 0 : _a.focus();
      },
      blur() {
        var _a;
        (_a = this.inputRef) == null ? void 0 : _a.blur();
      }
    },
    render() {
      return this.render();
    }
  });
  const AutoComplete = Object.assign(_AutoComplete, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _AutoComplete.name, _AutoComplete);
    }
  });
  const useIndex = ({
    itemRef,
    selector,
    index: index2,
    parentClassName
  }) => {
    const _index = vue.ref(-1);
    const computedIndex = vue.computed(() => {
      var _a;
      return (_a = index2 == null ? void 0 : index2.value) != null ? _a : _index.value;
    });
    const parent = vue.ref();
    const getParent = () => {
      var _a, _b, _c;
      let parent2 = (_b = (_a = itemRef.value) == null ? void 0 : _a.parentElement) != null ? _b : void 0;
      if (parentClassName) {
        while (parent2 && !parent2.className.includes(parentClassName)) {
          parent2 = (_c = parent2.parentElement) != null ? _c : void 0;
        }
      }
      return parent2;
    };
    const getIndex = () => {
      if (isUndefined(index2 == null ? void 0 : index2.value) && parent.value && itemRef.value) {
        const index22 = Array.from(parent.value.querySelectorAll(selector)).indexOf(itemRef.value);
        if (index22 !== _index.value) {
          _index.value = index22;
        }
      }
    };
    vue.watch(itemRef, () => {
      if (itemRef.value && !parent.value) {
        parent.value = getParent();
      }
    });
    vue.onMounted(() => {
      if (itemRef.value) {
        parent.value = getParent();
      }
      getIndex();
    });
    vue.onUpdated(() => getIndex());
    return {
      computedIndex
    };
  };
  const avatarGroupInjectionKey = Symbol("ArcoAvatarGroup");
  const _sfc_main$2E = vue.defineComponent({
    name: "IconImageClose",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-image-close`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$17 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$T = /* @__PURE__ */ vue.createStaticVNode('<path d="M41 26V9a2 2 0 0 0-2-2H9a2 2 0 0 0-2 2v30a2 2 0 0 0 2 2h17"></path><path d="m24 33 9-8.5V27s-2 1-3.5 2.5C27.841 31.159 27 33 27 33h-3Zm0 0-3.5-4.5L17 33h7Z"></path><path d="M20.5 28.5 17 33h7l-3.5-4.5ZM33 24.5 24 33h3s.841-1.841 2.5-3.5C31 28 33 27 33 27v-2.5Z" fill="currentColor" stroke="none"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M46 38a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-4.95-4.782 1.74 1.74-3.045 3.046 3.046 3.046-1.74 1.74-3.047-3.045-3.046 3.046-1.74-1.74 3.046-3.047-3.046-3.046 1.74-1.74 3.046 3.046 3.046-3.046Z" fill="currentColor" stroke="none"></path><path d="M17 15h-2v2h2v-2Z"></path>', 5);
  const _hoisted_7$1 = [
    _hoisted_2$T
  ];
  function _sfc_render$2D(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_7$1, 14, _hoisted_1$17);
  }
  var _IconImageClose = /* @__PURE__ */ _export_sfc(_sfc_main$2E, [["render", _sfc_render$2D]]);
  const IconImageClose = Object.assign(_IconImageClose, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconImageClose.name, _IconImageClose);
    }
  });
  const _sfc_main$2D = vue.defineComponent({
    name: "Avatar",
    components: {
      ResizeObserver,
      IconImageClose,
      IconLoading
    },
    props: {
      shape: {
        type: String,
        default: "circle"
      },
      imageUrl: String,
      size: Number,
      autoFixFontSize: {
        type: Boolean,
        default: true
      },
      triggerType: {
        type: String,
        default: "button"
      },
      triggerIconStyle: {
        type: Object
      }
    },
    emits: {
      click: (ev) => true,
      error: () => true,
      load: () => true
    },
    setup(props, { slots, emit, attrs }) {
      const { shape, size, autoFixFontSize, triggerType, triggerIconStyle } = vue.toRefs(props);
      const prefixCls = getPrefixCls("avatar");
      const groupCtx = vue.inject(avatarGroupInjectionKey, void 0);
      const itemRef = vue.ref();
      const wrapperRef = vue.ref();
      const mergedShape = vue.computed(() => {
        var _a;
        return (_a = groupCtx == null ? void 0 : groupCtx.shape) != null ? _a : shape.value;
      });
      const mergedSize = vue.computed(() => {
        var _a;
        return (_a = groupCtx == null ? void 0 : groupCtx.size) != null ? _a : size.value;
      });
      const mergedAutoFixFontSize = vue.computed(() => {
        var _a;
        return (_a = groupCtx == null ? void 0 : groupCtx.autoFixFontSize) != null ? _a : autoFixFontSize.value;
      });
      const isImage2 = vue.ref(false);
      const hasError = vue.ref(false);
      const shouldLoad = vue.ref(true);
      const isLoaded = vue.ref(false);
      const index2 = groupCtx ? useIndex({
        itemRef,
        selector: `.${prefixCls}`
      }).computedIndex : vue.ref(-1);
      const outerStyle = vue.computed(() => {
        var _a;
        const style = isNumber$1(mergedSize.value) ? {
          width: `${mergedSize.value}px`,
          height: `${mergedSize.value}px`,
          fontSize: `${mergedSize.value / 2}px`
        } : {};
        if (groupCtx) {
          style.zIndex = groupCtx.zIndexAscend ? index2.value + 1 : groupCtx.total - index2.value;
          style.marginLeft = index2.value !== 0 ? `-${((_a = mergedSize.value) != null ? _a : 40) / 4}px` : "0";
        }
        return style;
      });
      const computedTriggerIconStyle = useTriggerIconStyle({
        triggerIconStyle: triggerIconStyle == null ? void 0 : triggerIconStyle.value,
        inlineStyle: attrs.style,
        triggerType: triggerType.value
      });
      const autoFixFontSizeHandler = () => {
        if (!isImage2.value && !props.imageUrl) {
          vue.nextTick(() => {
            var _a;
            if (!wrapperRef.value || !itemRef.value) {
              return;
            }
            const textWidth = wrapperRef.value.clientWidth;
            const avatarWidth = (_a = mergedSize.value) != null ? _a : itemRef.value.offsetWidth;
            const scale = avatarWidth / (textWidth + 8);
            if (avatarWidth && scale < 1) {
              wrapperRef.value.style.transform = `scale(${scale}) translateX(-50%)`;
            }
            shouldLoad.value = true;
          });
        }
      };
      vue.onMounted(() => {
        var _a;
        if (((_a = wrapperRef.value) == null ? void 0 : _a.firstElementChild) && ["IMG", "PICTURE"].includes(wrapperRef.value.firstElementChild.tagName)) {
          isImage2.value = true;
        }
        if (mergedAutoFixFontSize.value) {
          autoFixFontSizeHandler();
        }
      });
      vue.watch(size, () => {
        if (mergedAutoFixFontSize.value) {
          autoFixFontSizeHandler();
        }
      });
      const cls = vue.computed(() => [
        prefixCls,
        `${prefixCls}-${mergedShape.value}`
      ]);
      const wrapperCls = vue.computed(() => isImage2.value || props.imageUrl ? `${prefixCls}-image` : `${prefixCls}-text`);
      const onClick = (e2) => {
        emit("click", e2);
      };
      const handleResize = () => {
        if (mergedAutoFixFontSize.value) {
          autoFixFontSizeHandler();
        }
      };
      const handleImgLoad = () => {
        isLoaded.value = true;
        emit("load");
      };
      const handleImgError = () => {
        hasError.value = true;
        emit("error");
      };
      return {
        prefixCls,
        itemRef,
        cls,
        outerStyle,
        wrapperRef,
        wrapperCls,
        computedTriggerIconStyle,
        isImage: isImage2,
        shouldLoad,
        isLoaded,
        hasError,
        onClick,
        handleResize,
        handleImgLoad,
        handleImgError
      };
    }
  });
  const useTriggerIconStyle = ({
    triggerType,
    inlineStyle = {},
    triggerIconStyle = {}
  }) => {
    let addon = {};
    if (triggerType === "button" && (!triggerIconStyle || triggerIconStyle && !triggerIconStyle.color) && inlineStyle && inlineStyle.backgroundColor) {
      addon = { color: inlineStyle.backgroundColor };
    }
    return __spreadValues(__spreadValues({}, triggerIconStyle), addon);
  };
  const _hoisted_1$16 = ["src"];
  function _sfc_render$2C(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_IconImageClose = vue.resolveComponent("IconImageClose");
    const _component_IconLoading = vue.resolveComponent("IconLoading");
    const _component_resize_observer = vue.resolveComponent("resize-observer");
    return vue.openBlock(), vue.createElementBlock("div", {
      ref: "itemRef",
      style: vue.normalizeStyle(_ctx.outerStyle),
      class: vue.normalizeClass([
        _ctx.cls,
        {
          [`${_ctx.prefixCls}-with-trigger-icon`]: Boolean(_ctx.$slots["trigger-icon"])
        }
      ]),
      onClick: _cache[2] || (_cache[2] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, [
      vue.createVNode(_component_resize_observer, { onResize: _ctx.handleResize }, {
        default: vue.withCtx(() => [
          vue.createElementVNode("span", {
            ref: "wrapperRef",
            class: vue.normalizeClass(_ctx.wrapperCls)
          }, [
            _ctx.imageUrl ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
              _ctx.hasError ? vue.renderSlot(_ctx.$slots, "error", { key: 0 }, () => [
                vue.createElementVNode("div", {
                  class: vue.normalizeClass(`${_ctx.prefixCls}-image-icon`)
                }, [
                  vue.createVNode(_component_IconImageClose)
                ], 2)
              ]) : vue.createCommentVNode("v-if", true),
              !(_ctx.hasError || !_ctx.shouldLoad) && !_ctx.isLoaded ? vue.renderSlot(_ctx.$slots, "default", { key: 1 }, () => [
                vue.createElementVNode("div", {
                  class: vue.normalizeClass(`${_ctx.prefixCls}-image-icon`)
                }, [
                  vue.createVNode(_component_IconLoading)
                ], 2)
              ]) : vue.createCommentVNode("v-if", true),
              !(_ctx.hasError || !_ctx.shouldLoad) ? (vue.openBlock(), vue.createElementBlock("img", {
                key: 2,
                src: _ctx.imageUrl,
                style: vue.normalizeStyle({ width: _ctx.size + "px", height: _ctx.size + "px" }),
                alt: "avatar",
                onLoad: _cache[0] || (_cache[0] = (...args) => _ctx.handleImgLoad && _ctx.handleImgLoad(...args)),
                onError: _cache[1] || (_cache[1] = (...args) => _ctx.handleImgError && _ctx.handleImgError(...args))
              }, null, 44, _hoisted_1$16)) : vue.createCommentVNode("v-if", true)
            ], 64)) : vue.renderSlot(_ctx.$slots, "default", { key: 1 })
          ], 2)
        ]),
        _: 3
      }, 8, ["onResize"]),
      _ctx.$slots["trigger-icon"] ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: vue.normalizeClass(`${_ctx.prefixCls}-trigger-icon-${_ctx.triggerType}`),
        style: vue.normalizeStyle(_ctx.computedTriggerIconStyle)
      }, [
        vue.renderSlot(_ctx.$slots, "trigger-icon")
      ], 6)) : vue.createCommentVNode("v-if", true)
    ], 6);
  }
  var _Avatar = /* @__PURE__ */ _export_sfc(_sfc_main$2D, [["render", _sfc_render$2C]]);
  const _sfc_main$2C = vue.defineComponent({
    name: "Popover",
    components: {
      Trigger
    },
    props: {
      popupVisible: {
        type: Boolean,
        default: void 0
      },
      defaultPopupVisible: {
        type: Boolean,
        default: false
      },
      title: String,
      content: String,
      trigger: {
        type: [String, Array],
        default: "hover"
      },
      position: {
        type: String,
        default: "top"
      },
      contentClass: {
        type: [String, Array, Object]
      },
      contentStyle: {
        type: Object
      },
      arrowClass: {
        type: [String, Array, Object]
      },
      arrowStyle: {
        type: Object
      },
      popupContainer: {
        type: [String, Object]
      }
    },
    emits: {
      "update:popupVisible": (visible) => true,
      "popupVisibleChange": (visible) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("popover");
      const _popupVisible = vue.ref(props.defaultPopupVisible);
      const computedPopupVisible = vue.computed(() => {
        var _a;
        return (_a = props.popupVisible) != null ? _a : _popupVisible.value;
      });
      const handlePopupVisibleChange = (visible) => {
        _popupVisible.value = visible;
        emit("update:popupVisible", visible);
        emit("popupVisibleChange", visible);
      };
      const contentCls = vue.computed(() => [
        `${prefixCls}-popup-content`,
        props.contentClass
      ]);
      const arrowCls = vue.computed(() => [
        `${prefixCls}-popup-arrow`,
        props.arrowClass
      ]);
      return {
        prefixCls,
        computedPopupVisible,
        contentCls,
        arrowCls,
        handlePopupVisibleChange
      };
    }
  });
  function _sfc_render$2B(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_trigger = vue.resolveComponent("trigger");
    return vue.openBlock(), vue.createBlock(_component_trigger, {
      class: vue.normalizeClass(_ctx.prefixCls),
      trigger: _ctx.trigger,
      position: _ctx.position,
      "popup-visible": _ctx.computedPopupVisible,
      "popup-offset": 10,
      "content-class": _ctx.contentCls,
      "content-style": _ctx.contentStyle,
      "arrow-class": _ctx.arrowCls,
      "arrow-style": _ctx.arrowStyle,
      "show-arrow": "",
      "popup-container": _ctx.popupContainer,
      "animation-name": "zoom-in-fade-out",
      "auto-fit-transform-origin": "",
      onPopupVisibleChange: _ctx.handlePopupVisibleChange
    }, {
      content: vue.withCtx(() => [
        vue.createElementVNode("div", {
          class: vue.normalizeClass(`${_ctx.prefixCls}-title`)
        }, [
          vue.renderSlot(_ctx.$slots, "title", {}, () => [
            vue.createTextVNode(vue.toDisplayString(_ctx.title), 1)
          ])
        ], 2),
        vue.createElementVNode("div", {
          class: vue.normalizeClass(`${_ctx.prefixCls}-content`)
        }, [
          vue.renderSlot(_ctx.$slots, "content", {}, () => [
            vue.createTextVNode(vue.toDisplayString(_ctx.content), 1)
          ])
        ], 2)
      ]),
      default: vue.withCtx(() => [
        vue.renderSlot(_ctx.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "trigger", "position", "popup-visible", "content-class", "content-style", "arrow-class", "arrow-style", "popup-container", "onPopupVisibleChange"]);
  }
  var _Popover = /* @__PURE__ */ _export_sfc(_sfc_main$2C, [["render", _sfc_render$2B]]);
  const Popover = Object.assign(_Popover, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Popover.name, _Popover);
    }
  });
  const AvatarGroup = vue.defineComponent({
    name: "AvatarGroup",
    props: {
      shape: {
        type: String,
        default: "circle"
      },
      size: Number,
      autoFixFontSize: {
        type: Boolean,
        default: true
      },
      maxCount: {
        type: Number,
        default: 0
      },
      zIndexAscend: {
        type: Boolean,
        default: false
      },
      maxStyle: {
        type: Object
      },
      maxPopoverTriggerProps: {
        type: Object
      }
    },
    setup(props, {
      slots
    }) {
      const {
        shape,
        size,
        autoFixFontSize,
        zIndexAscend
      } = vue.toRefs(props);
      const prefixCls = getPrefixCls("avatar-group");
      const total = vue.ref(0);
      vue.provide(avatarGroupInjectionKey, vue.reactive({
        shape,
        size,
        autoFixFontSize,
        zIndexAscend,
        total
      }));
      return () => {
        var _a, _b;
        const children = getAllElements((_b = (_a = slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : []);
        const avatarsToRender = props.maxCount > 0 ? children.slice(0, props.maxCount) : children;
        const avatarsInPopover = props.maxCount > 0 ? children.slice(props.maxCount) : [];
        if (total.value !== avatarsToRender.length) {
          total.value = avatarsToRender.length;
        }
        return vue.createVNode("div", {
          "class": prefixCls
        }, [avatarsToRender, avatarsInPopover.length > 0 && vue.createVNode(Popover, props.maxPopoverTriggerProps, {
          default: () => [vue.createVNode(_Avatar, {
            "class": `${prefixCls}-max-count-avatar`,
            "style": props.maxStyle
          }, {
            default: () => [vue.createTextVNode("+"), avatarsInPopover.length]
          })],
          content: () => vue.createVNode("div", null, [avatarsInPopover])
        })]);
      };
    }
  });
  const Avatar = Object.assign(_Avatar, {
    Group: AvatarGroup,
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Avatar.name, _Avatar);
      app.component(componentPrefix + AvatarGroup.name, AvatarGroup);
    }
  });
  const _sfc_main$2B = vue.defineComponent({
    name: "IconToTop",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-to-top`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$15 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$S = /* @__PURE__ */ vue.createElementVNode("path", { d: "M43 7H5M24 20v23M24 13.96 30.453 21H17.546L24 13.96Zm.736-.804Z" }, null, -1);
  const _hoisted_3$P = /* @__PURE__ */ vue.createElementVNode("path", {
    d: "m24 14-6 7h12l-6-7Z",
    fill: "currentColor",
    stroke: "none"
  }, null, -1);
  const _hoisted_4$e = [
    _hoisted_2$S,
    _hoisted_3$P
  ];
  function _sfc_render$2A(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_4$e, 14, _hoisted_1$15);
  }
  var _IconToTop = /* @__PURE__ */ _export_sfc(_sfc_main$2B, [["render", _sfc_render$2A]]);
  const IconToTop = Object.assign(_IconToTop, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconToTop.name, _IconToTop);
    }
  });
  const _sfc_main$2A = vue.defineComponent({
    name: "BackTop",
    components: {
      IconToTop
    },
    props: {
      visibleHeight: {
        type: Number,
        default: 200
      },
      targetContainer: {
        type: [String, Object]
      },
      easing: {
        type: String,
        default: "quartOut"
      },
      duration: {
        type: Number,
        default: 200
      }
    },
    setup(props) {
      const prefixCls = getPrefixCls("back-top");
      const visible = vue.ref(false);
      const target2 = vue.ref();
      const isWindow2 = !props.targetContainer;
      const scrollHandler = throttleByRaf(() => {
        if (target2.value) {
          const { visibleHeight } = props;
          const { scrollTop } = target2.value;
          visible.value = scrollTop >= visibleHeight;
        }
      });
      const getContainer = (container2) => {
        if (isString$1(container2)) {
          return document.querySelector(container2);
        }
        return container2;
      };
      vue.onMounted(() => {
        target2.value = isWindow2 ? document == null ? void 0 : document.documentElement : getContainer(props.targetContainer);
        if (target2.value) {
          on(isWindow2 ? window : target2.value, "scroll", scrollHandler);
          scrollHandler();
        }
      });
      vue.onUnmounted(() => {
        scrollHandler.cancel();
        if (target2.value) {
          off(isWindow2 ? window : target2.value, "scroll", scrollHandler);
        }
      });
      const scrollToTop = () => {
        if (target2.value) {
          const { scrollTop } = target2.value;
          const tween = new Tween({
            from: { scrollTop },
            to: { scrollTop: 0 },
            easing: props.easing,
            duration: props.duration,
            onUpdate: (keys) => {
              if (target2.value) {
                target2.value.scrollTop = keys.scrollTop;
              }
            }
          });
          tween.start();
        }
      };
      return {
        prefixCls,
        visible,
        scrollToTop
      };
    }
  });
  function _sfc_render$2z(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_icon_to_top = vue.resolveComponent("icon-to-top");
    return vue.openBlock(), vue.createBlock(vue.Transition, { name: "fade-in" }, {
      default: vue.withCtx(() => [
        _ctx.visible ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 0,
          class: vue.normalizeClass(_ctx.prefixCls),
          onClick: _cache[0] || (_cache[0] = (...args) => _ctx.scrollToTop && _ctx.scrollToTop(...args))
        }, [
          vue.renderSlot(_ctx.$slots, "default", {}, () => [
            vue.createElementVNode("button", {
              class: vue.normalizeClass(`${_ctx.prefixCls}-btn`)
            }, [
              vue.createVNode(_component_icon_to_top)
            ], 2)
          ])
        ], 2)) : vue.createCommentVNode("v-if", true)
      ]),
      _: 3
    });
  }
  var _BackTop = /* @__PURE__ */ _export_sfc(_sfc_main$2A, [["render", _sfc_render$2z]]);
  const BackTop = Object.assign(_BackTop, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _BackTop.name, _BackTop);
    }
  });
  const COLORS = ["red", "orangered", "orange", "gold", "lime", "green", "cyan", "arcoblue", "purple", "pinkpurple", "magenta", "gray"];
  const BADGE_STATUSES = ["normal", "processing", "success", "warning", "danger"];
  var _Badge = vue.defineComponent({
    name: "Badge",
    props: {
      text: {
        type: String
      },
      dot: {
        type: Boolean
      },
      dotStyle: {
        type: Object
      },
      maxCount: {
        type: Number,
        default: 99
      },
      offset: {
        type: Array,
        default: () => []
      },
      color: {
        type: String
      },
      status: {
        type: String,
        validator: (value) => {
          return BADGE_STATUSES.includes(value);
        }
      },
      count: {
        type: Number
      }
    },
    setup(props, {
      slots
    }) {
      const {
        status,
        color,
        dotStyle,
        offset,
        text,
        dot,
        maxCount,
        count
      } = vue.toRefs(props);
      const prefixCls = getPrefixCls("badge");
      const wrapperClassName = useWrapperClass(prefixCls, status == null ? void 0 : status.value, slots == null ? void 0 : slots.default);
      const computedStyleRef = vue.computed(() => {
        const computedDotStyle = __spreadValues({}, (dotStyle == null ? void 0 : dotStyle.value) || {});
        const [leftOffset, topOffset] = (offset == null ? void 0 : offset.value) || [];
        if (leftOffset) {
          computedDotStyle.marginRight = `${-leftOffset}px`;
        }
        if (topOffset) {
          computedDotStyle.marginTop = `${topOffset}px`;
        }
        const computedColorStyle = !(color == null ? void 0 : color.value) || COLORS.includes(color == null ? void 0 : color.value) ? {} : {
          backgroundColor: color.value
        };
        const mergedStyle = __spreadValues(__spreadValues({}, computedColorStyle), computedDotStyle);
        return {
          mergedStyle,
          computedDotStyle,
          computedColorStyle
        };
      });
      const getDot = () => {
        const textValue = text == null ? void 0 : text.value;
        const colorValue = color == null ? void 0 : color.value;
        const statusValue = status == null ? void 0 : status.value;
        const dotValue = dot == null ? void 0 : dot.value;
        const countValue = Number(count == null ? void 0 : count.value);
        const hasCount = (count == null ? void 0 : count.value) != null;
        const {
          computedDotStyle,
          mergedStyle
        } = computedStyleRef.value;
        if (slots.content) {
          return vue.createVNode("span", {
            "class": `${prefixCls}-custom-dot`,
            "style": computedDotStyle
          }, [slots.content()]);
        }
        if (textValue && !colorValue && !statusValue) {
          return vue.createVNode("span", {
            "class": `${prefixCls}-text`,
            "style": computedDotStyle
          }, [textValue]);
        }
        if (statusValue || colorValue && !hasCount) {
          return vue.createVNode("span", {
            "class": `${prefixCls}-status-wrapper`
          }, [vue.createVNode("span", {
            "class": [`${prefixCls}-status-dot`, {
              [`${prefixCls}-status-${statusValue}`]: statusValue,
              [`${prefixCls}-color-${colorValue}`]: colorValue
            }],
            "style": mergedStyle
          }, null), textValue && vue.createVNode("span", {
            "class": `${prefixCls}-status-text`
          }, [textValue])]);
        }
        if ((dotValue || colorValue) && countValue > 0) {
          return vue.createVNode("span", {
            "class": [`${prefixCls}-dot`, {
              [`${prefixCls}-color-${colorValue}`]: colorValue
            }],
            "style": mergedStyle
          }, null);
        }
        if (countValue === 0) {
          return null;
        }
        return vue.createVNode("span", {
          "class": `${prefixCls}-number`,
          "style": mergedStyle
        }, [vue.createVNode("span", null, [maxCount.value && countValue > maxCount.value ? `${maxCount.value}+` : countValue])]);
      };
      return () => {
        return vue.createVNode("span", {
          "class": wrapperClassName.value
        }, [slots.default && slots.default(), getDot()]);
      };
    }
  });
  const useWrapperClass = (prefixCls, status, children) => {
    return vue.computed(() => [prefixCls, {
      [`${prefixCls}-status`]: status,
      [`${prefixCls}-no-children`]: !children
    }]);
  };
  const Badge = Object.assign(_Badge, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Badge.name, _Badge);
    }
  });
  const breadcrumbInjectKey = Symbol("ArcoBreadcrumb");
  const _sfc_main$2z = vue.defineComponent({
    name: "IconMore",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-more`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$14 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$R = /* @__PURE__ */ vue.createElementVNode("path", {
    d: "M38 25v-2h2v2h-2ZM23 25v-2h2v2h-2ZM8 25v-2h2v2H8Z",
    fill: "currentColor",
    stroke: "none"
  }, null, -1);
  const _hoisted_3$O = /* @__PURE__ */ vue.createElementVNode("path", { d: "M38 25v-2h2v2h-2ZM23 25v-2h2v2h-2ZM8 25v-2h2v2H8Z" }, null, -1);
  const _hoisted_4$d = [
    _hoisted_2$R,
    _hoisted_3$O
  ];
  function _sfc_render$2y(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_4$d, 14, _hoisted_1$14);
  }
  var _IconMore = /* @__PURE__ */ _export_sfc(_sfc_main$2z, [["render", _sfc_render$2y]]);
  const IconMore = Object.assign(_IconMore, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconMore.name, _IconMore);
    }
  });
  const _sfc_main$2y = vue.defineComponent({
    name: "IconDown",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-down`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$13 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$Q = /* @__PURE__ */ vue.createElementVNode("path", { d: "M39.6 17.443 24.043 33 8.487 17.443" }, null, -1);
  const _hoisted_3$N = [
    _hoisted_2$Q
  ];
  function _sfc_render$2x(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$N, 14, _hoisted_1$13);
  }
  var _IconDown = /* @__PURE__ */ _export_sfc(_sfc_main$2y, [["render", _sfc_render$2x]]);
  const IconDown = Object.assign(_IconDown, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconDown.name, _IconDown);
    }
  });
  const _sfc_main$2x = vue.defineComponent({
    name: "IconObliqueLine",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-oblique-line`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$12 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$P = /* @__PURE__ */ vue.createElementVNode("path", { d: "M29.506 6.502 18.493 41.498" }, null, -1);
  const _hoisted_3$M = [
    _hoisted_2$P
  ];
  function _sfc_render$2w(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$M, 14, _hoisted_1$12);
  }
  var _IconObliqueLine = /* @__PURE__ */ _export_sfc(_sfc_main$2x, [["render", _sfc_render$2w]]);
  const IconObliqueLine = Object.assign(_IconObliqueLine, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconObliqueLine.name, _IconObliqueLine);
    }
  });
  const dropdownInjectionKey = Symbol("ArcoDropdown");
  const _sfc_main$2w = vue.defineComponent({
    name: "DropdownPanel",
    components: {
      Scrollbar,
      Empty
    },
    props: {
      loading: {
        type: Boolean,
        default: false
      },
      isEmpty: {
        type: Boolean,
        default: false
      },
      bottomOffset: {
        type: Number,
        default: 0
      },
      onScroll: {
        type: [Function, Array]
      },
      onReachBottom: {
        type: [Function, Array]
      }
    },
    emits: ["scroll", "reachBottom"],
    setup(props, { emit, slots }) {
      const prefixCls = getPrefixCls("dropdown");
      const dropdownCtx = vue.inject(dropdownInjectionKey, {});
      const wrapperRef = vue.ref();
      const handleScroll = (e2) => {
        const { scrollTop, scrollHeight, offsetHeight } = e2.target;
        const bottom = scrollHeight - (scrollTop + offsetHeight);
        if (bottom <= props.bottomOffset) {
          emit("reachBottom", e2);
        }
        emit("scroll", e2);
      };
      const style = vue.computed(() => {
        if (isNumber$1(dropdownCtx.popupMaxHeight)) {
          return {
            maxHeight: `${dropdownCtx.popupMaxHeight}px`
          };
        }
        if (!dropdownCtx.popupMaxHeight) {
          return {
            maxHeight: "none",
            overflowY: "hidden"
          };
        }
        return void 0;
      });
      const cls = vue.computed(() => [
        prefixCls,
        {
          [`${prefixCls}-has-footer`]: Boolean(slots.footer)
        }
      ]);
      return {
        prefixCls,
        cls,
        style,
        wrapperRef,
        handleScroll
      };
    }
  });
  function _sfc_render$2v(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_empty = vue.resolveComponent("empty");
    const _component_Scrollbar = vue.resolveComponent("Scrollbar");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.cls)
    }, [
      _ctx.isEmpty ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: vue.normalizeClass(`${_ctx.prefixCls}-empty`)
      }, [
        vue.renderSlot(_ctx.$slots, "empty", {}, () => [
          vue.createVNode(_component_empty)
        ])
      ], 2)) : vue.createCommentVNode("v-if", true),
      vue.createVNode(_component_Scrollbar, {
        ref: "wrapperRef",
        class: vue.normalizeClass(`${_ctx.prefixCls}-list-wrapper`),
        style: vue.normalizeStyle(_ctx.style),
        onScroll: _ctx.handleScroll
      }, {
        default: vue.withCtx(() => [
          vue.createElementVNode("ul", {
            class: vue.normalizeClass(`${_ctx.prefixCls}-list`)
          }, [
            vue.renderSlot(_ctx.$slots, "default")
          ], 2)
        ]),
        _: 3
      }, 8, ["class", "style", "onScroll"]),
      _ctx.$slots.footer && !_ctx.isEmpty ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 1,
        class: vue.normalizeClass(`${_ctx.prefixCls}-footer`)
      }, [
        vue.renderSlot(_ctx.$slots, "footer")
      ], 2)) : vue.createCommentVNode("v-if", true)
    ], 2);
  }
  var DropdownPanel = /* @__PURE__ */ _export_sfc(_sfc_main$2w, [["render", _sfc_render$2v]]);
  const useTrigger = ({
    popupVisible,
    defaultPopupVisible,
    emit
  }) => {
    var _a;
    const _popupVisible = vue.ref((_a = defaultPopupVisible == null ? void 0 : defaultPopupVisible.value) != null ? _a : false);
    const computedPopupVisible = vue.computed(() => {
      var _a2;
      return (_a2 = popupVisible == null ? void 0 : popupVisible.value) != null ? _a2 : _popupVisible.value;
    });
    const handlePopupVisibleChange = (visible) => {
      if (visible !== computedPopupVisible.value) {
        _popupVisible.value = visible;
        emit("update:popupVisible", visible);
        emit("popupVisibleChange", visible);
      }
    };
    vue.watch(computedPopupVisible, (visible) => {
      if (_popupVisible.value !== visible) {
        _popupVisible.value = visible;
      }
    });
    return {
      computedPopupVisible,
      handlePopupVisibleChange
    };
  };
  const _sfc_main$2v = vue.defineComponent({
    name: "Dropdown",
    components: {
      Trigger,
      DropdownPanel
    },
    props: {
      popupVisible: {
        type: Boolean,
        default: void 0
      },
      defaultPopupVisible: {
        type: Boolean,
        default: false
      },
      trigger: {
        type: [String, Array],
        default: "click"
      },
      position: {
        type: String,
        default: "bottom"
      },
      popupContainer: {
        type: [String, Object]
      },
      popupMaxHeight: {
        type: [Boolean, Number],
        default: true
      },
      hideOnSelect: {
        type: Boolean,
        default: true
      }
    },
    emits: {
      "update:popupVisible": (visible) => true,
      "popupVisibleChange": (visible) => true,
      "select": (value, ev) => true
    },
    setup(props, { emit }) {
      const { defaultPopupVisible, popupVisible, popupMaxHeight } = vue.toRefs(props);
      const prefixCls = getPrefixCls("dropdown");
      const { computedPopupVisible, handlePopupVisibleChange } = useTrigger({
        defaultPopupVisible,
        popupVisible,
        emit
      });
      const handleOptionClick = (value, ev) => {
        emit("select", value, ev);
        props.hideOnSelect && handlePopupVisibleChange(false);
      };
      vue.provide(dropdownInjectionKey, vue.reactive({
        popupMaxHeight,
        onOptionClick: handleOptionClick
      }));
      return {
        prefixCls,
        computedPopupVisible,
        handlePopupVisibleChange
      };
    }
  });
  function _sfc_render$2u(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_DropdownPanel = vue.resolveComponent("DropdownPanel");
    const _component_Trigger = vue.resolveComponent("Trigger");
    return vue.openBlock(), vue.createBlock(_component_Trigger, {
      "popup-visible": _ctx.computedPopupVisible,
      "animation-name": "slide-dynamic-origin",
      "auto-fit-transform-origin": "",
      trigger: _ctx.trigger,
      position: _ctx.position,
      "popup-offset": 4,
      "popup-container": _ctx.popupContainer,
      "opened-class": `${_ctx.prefixCls}-open`,
      onPopupVisibleChange: _ctx.handlePopupVisibleChange
    }, {
      content: vue.withCtx(() => [
        vue.createVNode(_component_DropdownPanel, null, vue.createSlots({
          default: vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "content")
          ]),
          _: 2
        }, [
          _ctx.$slots.footer ? {
            name: "footer",
            fn: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "footer")
            ])
          } : void 0
        ]), 1024)
      ]),
      default: vue.withCtx(() => [
        vue.renderSlot(_ctx.$slots, "default")
      ]),
      _: 3
    }, 8, ["popup-visible", "trigger", "position", "popup-container", "opened-class", "onPopupVisibleChange"]);
  }
  var _Dropdown = /* @__PURE__ */ _export_sfc(_sfc_main$2v, [["render", _sfc_render$2u]]);
  const _sfc_main$2u = vue.defineComponent({
    name: "Doption",
    props: {
      value: {
        type: [String, Number, Object]
      },
      disabled: {
        type: Boolean,
        default: false
      },
      active: Boolean,
      uninjectContext: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("dropdown-option");
      const liRef = vue.ref();
      const computedValue = vue.computed(() => {
        var _a, _b, _c;
        return (_c = (_b = props.value) != null ? _b : (_a = liRef.value) == null ? void 0 : _a.textContent) != null ? _c : void 0;
      });
      const dropdownCtx = !props.uninjectContext ? vue.inject(dropdownInjectionKey, void 0) : void 0;
      const handleClick = (ev) => {
        if (!props.disabled) {
          emit("click", ev);
          dropdownCtx == null ? void 0 : dropdownCtx.onOptionClick(computedValue.value, ev);
        }
      };
      const cls = vue.computed(() => [
        prefixCls,
        {
          [`${prefixCls}-disabled`]: props.disabled,
          [`${prefixCls}-active`]: props.active
        }
      ]);
      return {
        prefixCls,
        cls,
        liRef,
        handleClick
      };
    }
  });
  function _sfc_render$2t(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("li", {
      ref: "liRef",
      class: vue.normalizeClass([_ctx.cls, { [`${_ctx.prefixCls}-has-suffix`]: Boolean(_ctx.$slots.suffix) }]),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    }, [
      _ctx.$slots.icon ? (vue.openBlock(), vue.createElementBlock("span", {
        key: 0,
        class: vue.normalizeClass(`${_ctx.prefixCls}-icon`)
      }, [
        vue.renderSlot(_ctx.$slots, "icon")
      ], 2)) : vue.createCommentVNode("v-if", true),
      vue.createElementVNode("span", {
        class: vue.normalizeClass(`${_ctx.prefixCls}-content`)
      }, [
        vue.renderSlot(_ctx.$slots, "default")
      ], 2),
      _ctx.$slots.suffix ? (vue.openBlock(), vue.createElementBlock("span", {
        key: 1,
        class: vue.normalizeClass(`${_ctx.prefixCls}-suffix`)
      }, [
        vue.renderSlot(_ctx.$slots, "suffix")
      ], 2)) : vue.createCommentVNode("v-if", true)
    ], 2);
  }
  var Doption = /* @__PURE__ */ _export_sfc(_sfc_main$2u, [["render", _sfc_render$2t]]);
  const _sfc_main$2t = vue.defineComponent({
    name: "Dgroup",
    props: {
      title: String
    },
    setup() {
      const prefixCls = getPrefixCls("dropdown-group");
      return {
        prefixCls
      };
    }
  });
  function _sfc_render$2s(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock(vue.Fragment, null, [
      vue.createElementVNode("li", {
        class: vue.normalizeClass(`${_ctx.prefixCls}-title`)
      }, [
        vue.renderSlot(_ctx.$slots, "title", {}, () => [
          vue.createTextVNode(vue.toDisplayString(_ctx.title), 1)
        ])
      ], 2),
      vue.renderSlot(_ctx.$slots, "default")
    ], 64);
  }
  var Dgroup = /* @__PURE__ */ _export_sfc(_sfc_main$2t, [["render", _sfc_render$2s]]);
  const _sfc_main$2s = vue.defineComponent({
    name: "IconRight",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-right`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$11 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$O = /* @__PURE__ */ vue.createElementVNode("path", { d: "m16 39.513 15.556-15.557L16 8.4" }, null, -1);
  const _hoisted_3$L = [
    _hoisted_2$O
  ];
  function _sfc_render$2r(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$L, 14, _hoisted_1$11);
  }
  var _IconRight = /* @__PURE__ */ _export_sfc(_sfc_main$2s, [["render", _sfc_render$2r]]);
  const IconRight = Object.assign(_IconRight, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconRight.name, _IconRight);
    }
  });
  const _sfc_main$2r = vue.defineComponent({
    name: "Dsubmenu",
    components: {
      Trigger,
      DropdownPanel,
      DropdownOption: Doption,
      IconRight
    },
    props: {
      value: {
        type: [String, Number]
      },
      disabled: {
        type: Boolean,
        default: false
      },
      trigger: {
        type: [String, Array],
        default: "click"
      },
      position: {
        type: String,
        default: "rt"
      },
      popupVisible: {
        type: Boolean,
        default: void 0
      },
      defaultPopupVisible: {
        type: Boolean,
        default: false
      },
      optionProps: {
        type: Object
      }
    },
    emits: {
      "update:popupVisible": (visible) => true,
      "popupVisibleChange": (visible) => true
    },
    setup(props, { emit }) {
      const { defaultPopupVisible, popupVisible } = vue.toRefs(props);
      const prefixCls = getPrefixCls("dropdown");
      const { computedPopupVisible, handlePopupVisibleChange } = useTrigger({
        defaultPopupVisible,
        popupVisible,
        emit
      });
      return {
        prefixCls,
        computedPopupVisible,
        handlePopupVisibleChange
      };
    }
  });
  function _sfc_render$2q(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_IconRight = vue.resolveComponent("IconRight");
    const _component_dropdown_option = vue.resolveComponent("dropdown-option");
    const _component_dropdown_panel = vue.resolveComponent("dropdown-panel");
    const _component_Trigger = vue.resolveComponent("Trigger");
    return vue.openBlock(), vue.createBlock(_component_Trigger, {
      "popup-visible": _ctx.computedPopupVisible,
      trigger: _ctx.trigger,
      position: _ctx.position,
      disabled: _ctx.disabled,
      "popup-offset": 4,
      onPopupVisibleChange: _ctx.handlePopupVisibleChange
    }, {
      content: vue.withCtx(() => [
        vue.createVNode(_component_dropdown_panel, {
          class: vue.normalizeClass(`${_ctx.prefixCls}-submenu`)
        }, vue.createSlots({
          default: vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "content")
          ]),
          _: 2
        }, [
          _ctx.$slots.footer ? {
            name: "footer",
            fn: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "footer")
            ])
          } : void 0
        ]), 1032, ["class"])
      ]),
      default: vue.withCtx(() => [
        vue.createVNode(_component_dropdown_option, vue.mergeProps(_ctx.optionProps, {
          active: _ctx.computedPopupVisible,
          "uninject-context": ""
        }), vue.createSlots({
          suffix: vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "suffix", {}, () => [
              vue.createVNode(_component_IconRight)
            ])
          ]),
          default: vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "default")
          ]),
          _: 2
        }, [
          _ctx.$slots.icon ? {
            name: "icon",
            fn: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "icon")
            ])
          } : void 0
        ]), 1040, ["active"])
      ]),
      _: 3
    }, 8, ["popup-visible", "trigger", "position", "disabled", "onPopupVisibleChange"]);
  }
  var Dsubmenu = /* @__PURE__ */ _export_sfc(_sfc_main$2r, [["render", _sfc_render$2q]]);
  const _sfc_main$2q = vue.defineComponent({
    name: "DropdownButton",
    components: {
      IconMore,
      Button,
      ButtonGroup,
      Dropdown: _Dropdown
    },
    props: {
      popupVisible: {
        type: Boolean,
        default: void 0
      },
      defaultPopupVisible: {
        type: Boolean,
        default: false
      },
      trigger: {
        type: [String, Array],
        default: "click"
      },
      position: {
        type: String,
        default: "br"
      },
      popupContainer: {
        type: [String, Object]
      },
      disabled: {
        type: Boolean,
        default: false
      },
      type: {
        type: String
      },
      size: {
        type: String
      },
      buttonProps: {
        type: Object
      },
      hideOnSelect: {
        type: Boolean,
        default: true
      }
    },
    emits: {
      "update:popupVisible": (visible) => true,
      "popupVisibleChange": (visible) => true,
      "click": (ev) => true,
      "select": (value, ev) => true
    },
    setup(props, { emit }) {
      const { defaultPopupVisible, popupVisible } = vue.toRefs(props);
      const prefixCls = getPrefixCls("dropdown");
      const { computedPopupVisible, handlePopupVisibleChange } = useTrigger({
        defaultPopupVisible,
        popupVisible,
        emit
      });
      const handleClick = (ev) => {
        emit("click", ev);
      };
      const handleSelect = (value, ev) => {
        emit("select", value, ev);
      };
      return {
        prefixCls,
        computedPopupVisible,
        handleClick,
        handleSelect,
        handlePopupVisibleChange
      };
    }
  });
  function _sfc_render$2p(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Button = vue.resolveComponent("Button");
    const _component_IconMore = vue.resolveComponent("IconMore");
    const _component_Dropdown = vue.resolveComponent("Dropdown");
    const _component_ButtonGroup = vue.resolveComponent("ButtonGroup");
    return vue.openBlock(), vue.createBlock(_component_ButtonGroup, null, {
      default: vue.withCtx(() => [
        vue.createVNode(_component_Button, vue.mergeProps({
          size: _ctx.size,
          type: _ctx.type,
          disabled: _ctx.disabled
        }, _ctx.buttonProps, { onClick: _ctx.handleClick }), {
          default: vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16, ["size", "type", "disabled", "onClick"]),
        vue.createVNode(_component_Dropdown, {
          "popup-visible": _ctx.computedPopupVisible,
          trigger: _ctx.trigger,
          position: _ctx.position,
          "popup-container": _ctx.popupContainer,
          "hide-on-select": _ctx.hideOnSelect,
          onSelect: _ctx.handleSelect,
          onPopupVisibleChange: _ctx.handlePopupVisibleChange
        }, {
          content: vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "content")
          ]),
          default: vue.withCtx(() => [
            vue.createVNode(_component_Button, {
              size: _ctx.size,
              type: _ctx.type,
              disabled: _ctx.disabled
            }, {
              icon: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "icon", { popupVisible: _ctx.computedPopupVisible }, () => [
                  vue.createVNode(_component_IconMore)
                ])
              ]),
              _: 3
            }, 8, ["size", "type", "disabled"])
          ]),
          _: 3
        }, 8, ["popup-visible", "trigger", "position", "popup-container", "hide-on-select", "onSelect", "onPopupVisibleChange"])
      ]),
      _: 3
    });
  }
  var DropdownButton = /* @__PURE__ */ _export_sfc(_sfc_main$2q, [["render", _sfc_render$2p]]);
  const Dropdown = Object.assign(_Dropdown, {
    Option: Doption,
    Group: Dgroup,
    Submenu: Dsubmenu,
    Button: DropdownButton,
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Dropdown.name, _Dropdown);
      app.component(componentPrefix + Doption.name, Doption);
      app.component(componentPrefix + Dgroup.name, Dgroup);
      app.component(componentPrefix + Dsubmenu.name, Dsubmenu);
      app.component(componentPrefix + DropdownButton.name, DropdownButton);
    }
  });
  var BreadcrumbItem = vue.defineComponent({
    name: "BreadcrumbItem",
    inheritAttrs: false,
    props: {
      separator: {
        type: [String, Number]
      },
      droplist: {
        type: Array
      },
      dropdownProps: {
        type: Object
      },
      index: {
        type: Number,
        default: 0
      }
    },
    setup(props, {
      slots,
      attrs
    }) {
      const prefixCls = getPrefixCls("breadcrumb-item");
      const breadcrumbCtx = vue.inject(breadcrumbInjectKey, void 0);
      const dropdownVisible = vue.ref(false);
      const show = vue.computed(() => {
        if (breadcrumbCtx && breadcrumbCtx.needHide) {
          if (props.index > 1 && props.index <= breadcrumbCtx.total - breadcrumbCtx.maxCount) {
            return false;
          }
        }
        return true;
      });
      const displayMore = vue.computed(() => {
        if (breadcrumbCtx && breadcrumbCtx.needHide) {
          return props.index === 1;
        }
        return false;
      });
      const showSeparator = vue.computed(() => breadcrumbCtx ? props.index < breadcrumbCtx.total - 1 : true);
      const handleVisibleChange = (visible) => {
        dropdownVisible.value = visible;
      };
      const separatorRender = () => {
        var _a, _b, _c, _d, _e, _f, _g;
        if (!showSeparator.value)
          return null;
        const separatorElement = (_g = (_f = (_e = (_b = (_a = slots.separator) == null ? void 0 : _a.call(slots)) != null ? _b : props.separator) != null ? _e : (_d = breadcrumbCtx == null ? void 0 : (_c = breadcrumbCtx.slots).separator) == null ? void 0 : _d.call(_c)) != null ? _f : breadcrumbCtx == null ? void 0 : breadcrumbCtx.separator) != null ? _g : vue.createVNode(IconObliqueLine, null, null);
        return vue.createVNode("div", {
          "aria-hidden": "true",
          "class": `${prefixCls}-separator`
        }, [separatorElement]);
      };
      const renderItem = () => {
        var _a, _b, _c, _d;
        return vue.createVNode("div", vue.mergeProps({
          "role": "listitem",
          "class": [prefixCls, {
            [`${prefixCls}-with-dropdown`]: props.droplist || slots.droplist
          }]
        }, displayMore.value ? {
          "aria-label": "ellipses of breadcrumb items"
        } : void 0, attrs), [displayMore.value ? (_c = (_b = breadcrumbCtx == null ? void 0 : (_a = breadcrumbCtx.slots)["more-icon"]) == null ? void 0 : _b.call(_a)) != null ? _c : vue.createVNode(IconMore, null, null) : (_d = slots.default) == null ? void 0 : _d.call(slots), (props.droplist || slots.droplist) && vue.createVNode("span", {
          "aria-hidden": true,
          "class": [`${prefixCls}-dropdown-icon`, {
            [`${prefixCls}-dropdown-icon-active`]: dropdownVisible.value
          }]
        }, [vue.createVNode(IconDown, null, null)])]);
      };
      const renderDropdownContent = () => {
        var _a, _b, _c;
        return (_c = (_a = slots.droplist) == null ? void 0 : _a.call(slots)) != null ? _c : (_b = props.droplist) == null ? void 0 : _b.map((item) => vue.createVNode(Doption, {
          "value": item.path
        }, {
          default: () => [item.label]
        }));
      };
      const renderDropdown = () => {
        return vue.createVNode(Dropdown, vue.mergeProps({
          "popupVisible": dropdownVisible.value,
          "onPopupVisibleChange": handleVisibleChange
        }, props.dropdownProps), {
          default: () => [renderItem()],
          content: renderDropdownContent
        });
      };
      return () => {
        if (show.value) {
          return vue.createVNode(vue.Fragment, null, [slots.droplist || props.droplist ? renderDropdown() : renderItem(), separatorRender()]);
        }
        return null;
      };
    }
  });
  var _Breadcrumb = vue.defineComponent({
    name: "Breadcrumb",
    props: {
      maxCount: {
        type: Number,
        default: 0
      },
      routes: {
        type: Array
      },
      separator: {
        type: [String, Number]
      },
      customUrl: {
        type: Function
      }
    },
    setup(props, {
      slots
    }) {
      const {
        maxCount,
        separator,
        routes
      } = vue.toRefs(props);
      const prefixCls = getPrefixCls("breadcrumb");
      const total = vue.ref(0);
      const needHide = vue.computed(() => maxCount.value > 0 && total.value > maxCount.value + 1);
      vue.provide(breadcrumbInjectKey, vue.reactive({
        total,
        maxCount,
        separator,
        needHide,
        slots
      }));
      const defaultItemRender = (route, routes2, paths) => {
        var _a, _b;
        if (routes2.indexOf(route) === routes2.length - 1) {
          return vue.createVNode("span", null, [route.label]);
        }
        const href = (_b = (_a = props.customUrl) == null ? void 0 : _a.call(props, paths)) != null ? _b : `#/${paths.join("/").replace(/^\//, "")}`;
        return vue.createVNode("a", {
          "href": href
        }, [route.label]);
      };
      const renderByRoutes = () => {
        var _a;
        if (!((_a = routes.value) == null ? void 0 : _a.length))
          return null;
        if (total.value !== routes.value.length) {
          total.value = routes.value.length;
        }
        const paths = [];
        return routes.value.map((route, idx, origin) => {
          paths.push((route.path || "").replace(/^\//, ""));
          const currentPaths = [...paths];
          return vue.createVNode(BreadcrumbItem, {
            "key": route.path || route.label,
            "index": idx,
            "droplist": route.children
          }, {
            default: () => {
              var _a2, _b;
              return [(_b = (_a2 = slots["item-render"]) == null ? void 0 : _a2.call(slots, {
                route,
                routes: origin,
                paths: currentPaths
              })) != null ? _b : defaultItemRender(route, origin, currentPaths)];
            }
          });
        });
      };
      const renderByChildren = () => {
        var _a, _b;
        const children = getAllElements((_b = (_a = slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : []);
        if (total.value !== children.length) {
          total.value = children.length;
        }
        return children.map((child, index2) => {
          var _a2;
          child.props = vue.mergeProps((_a2 = child.props) != null ? _a2 : {}, {
            index: index2
          });
          return child;
        });
      };
      return () => {
        return vue.createVNode("div", {
          "role": "list",
          "class": prefixCls
        }, [slots.default ? renderByChildren() : renderByRoutes()]);
      };
    }
  });
  const Breadcrumb = Object.assign(_Breadcrumb, {
    Item: BreadcrumbItem,
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Breadcrumb.name, _Breadcrumb);
      app.component(componentPrefix + BreadcrumbItem.name, BreadcrumbItem);
    }
  });
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  var dayjs_min = { exports: {} };
  (function(module2, exports2) {
    !function(t2, e2) {
      module2.exports = e2();
    }(commonjsGlobal, function() {
      var t2 = 1e3, e2 = 6e4, n2 = 36e5, r2 = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", f = "month", h = "quarter", c = "year", d = "date", $ = "Invalid Date", l = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_") }, m = function(t3, e3, n3) {
        var r3 = String(t3);
        return !r3 || r3.length >= e3 ? t3 : "" + Array(e3 + 1 - r3.length).join(n3) + t3;
      }, g = { s: m, z: function(t3) {
        var e3 = -t3.utcOffset(), n3 = Math.abs(e3), r3 = Math.floor(n3 / 60), i2 = n3 % 60;
        return (e3 <= 0 ? "+" : "-") + m(r3, 2, "0") + ":" + m(i2, 2, "0");
      }, m: function t3(e3, n3) {
        if (e3.date() < n3.date())
          return -t3(n3, e3);
        var r3 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i2 = e3.clone().add(r3, f), s2 = n3 - i2 < 0, u2 = e3.clone().add(r3 + (s2 ? -1 : 1), f);
        return +(-(r3 + (n3 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
      }, a: function(t3) {
        return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
      }, p: function(t3) {
        return { M: f, y: c, w: o, d: a, D: d, h: u, m: s, s: i, ms: r2, Q: h }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t3) {
        return t3 === void 0;
      } }, D = "en", v = {};
      v[D] = M;
      var p = function(t3) {
        return t3 instanceof _;
      }, S = function(t3, e3, n3) {
        var r3;
        if (!t3)
          return D;
        if (typeof t3 == "string")
          v[t3] && (r3 = t3), e3 && (v[t3] = e3, r3 = t3);
        else {
          var i2 = t3.name;
          v[i2] = t3, r3 = i2;
        }
        return !n3 && r3 && (D = r3), r3 || !n3 && D;
      }, w = function(t3, e3) {
        if (p(t3))
          return t3.clone();
        var n3 = typeof e3 == "object" ? e3 : {};
        return n3.date = t3, n3.args = arguments, new _(n3);
      }, O = g;
      O.l = S, O.i = p, O.w = function(t3, e3) {
        return w(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
      };
      var _ = function() {
        function M2(t3) {
          this.$L = S(t3.locale, null, true), this.parse(t3);
        }
        var m2 = M2.prototype;
        return m2.parse = function(t3) {
          this.$d = function(t4) {
            var e3 = t4.date, n3 = t4.utc;
            if (e3 === null)
              return new Date(NaN);
            if (O.u(e3))
              return new Date();
            if (e3 instanceof Date)
              return new Date(e3);
            if (typeof e3 == "string" && !/Z$/i.test(e3)) {
              var r3 = e3.match(l);
              if (r3) {
                var i2 = r3[2] - 1 || 0, s2 = (r3[7] || "0").substring(0, 3);
                return n3 ? new Date(Date.UTC(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2)) : new Date(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2);
              }
            }
            return new Date(e3);
          }(t3), this.$x = t3.x || {}, this.init();
        }, m2.init = function() {
          var t3 = this.$d;
          this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
        }, m2.$utils = function() {
          return O;
        }, m2.isValid = function() {
          return !(this.$d.toString() === $);
        }, m2.isSame = function(t3, e3) {
          var n3 = w(t3);
          return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
        }, m2.isAfter = function(t3, e3) {
          return w(t3) < this.startOf(e3);
        }, m2.isBefore = function(t3, e3) {
          return this.endOf(e3) < w(t3);
        }, m2.$g = function(t3, e3, n3) {
          return O.u(t3) ? this[e3] : this.set(n3, t3);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t3, e3) {
          var n3 = this, r3 = !!O.u(e3) || e3, h2 = O.p(t3), $2 = function(t4, e4) {
            var i2 = O.w(n3.$u ? Date.UTC(n3.$y, e4, t4) : new Date(n3.$y, e4, t4), n3);
            return r3 ? i2 : i2.endOf(a);
          }, l2 = function(t4, e4) {
            return O.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
          }, y2 = this.$W, M3 = this.$M, m3 = this.$D, g2 = "set" + (this.$u ? "UTC" : "");
          switch (h2) {
            case c:
              return r3 ? $2(1, 0) : $2(31, 11);
            case f:
              return r3 ? $2(1, M3) : $2(0, M3 + 1);
            case o:
              var D2 = this.$locale().weekStart || 0, v2 = (y2 < D2 ? y2 + 7 : y2) - D2;
              return $2(r3 ? m3 - v2 : m3 + (6 - v2), M3);
            case a:
            case d:
              return l2(g2 + "Hours", 0);
            case u:
              return l2(g2 + "Minutes", 1);
            case s:
              return l2(g2 + "Seconds", 2);
            case i:
              return l2(g2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t3) {
          return this.startOf(t3, false);
        }, m2.$set = function(t3, e3) {
          var n3, o2 = O.p(t3), h2 = "set" + (this.$u ? "UTC" : ""), $2 = (n3 = {}, n3[a] = h2 + "Date", n3[d] = h2 + "Date", n3[f] = h2 + "Month", n3[c] = h2 + "FullYear", n3[u] = h2 + "Hours", n3[s] = h2 + "Minutes", n3[i] = h2 + "Seconds", n3[r2] = h2 + "Milliseconds", n3)[o2], l2 = o2 === a ? this.$D + (e3 - this.$W) : e3;
          if (o2 === f || o2 === c) {
            var y2 = this.clone().set(d, 1);
            y2.$d[$2](l2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
          } else
            $2 && this.$d[$2](l2);
          return this.init(), this;
        }, m2.set = function(t3, e3) {
          return this.clone().$set(t3, e3);
        }, m2.get = function(t3) {
          return this[O.p(t3)]();
        }, m2.add = function(r3, h2) {
          var d2, $2 = this;
          r3 = Number(r3);
          var l2 = O.p(h2), y2 = function(t3) {
            var e3 = w($2);
            return O.w(e3.date(e3.date() + Math.round(t3 * r3)), $2);
          };
          if (l2 === f)
            return this.set(f, this.$M + r3);
          if (l2 === c)
            return this.set(c, this.$y + r3);
          if (l2 === a)
            return y2(1);
          if (l2 === o)
            return y2(7);
          var M3 = (d2 = {}, d2[s] = e2, d2[u] = n2, d2[i] = t2, d2)[l2] || 1, m3 = this.$d.getTime() + r3 * M3;
          return O.w(m3, this);
        }, m2.subtract = function(t3, e3) {
          return this.add(-1 * t3, e3);
        }, m2.format = function(t3) {
          var e3 = this, n3 = this.$locale();
          if (!this.isValid())
            return n3.invalidDate || $;
          var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i2 = O.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n3.weekdays, f2 = n3.months, h2 = function(t4, n4, i3, s3) {
            return t4 && (t4[n4] || t4(e3, r3)) || i3[n4].substr(0, s3);
          }, c2 = function(t4) {
            return O.s(s2 % 12 || 12, t4, "0");
          }, d2 = n3.meridiem || function(t4, e4, n4) {
            var r4 = t4 < 12 ? "AM" : "PM";
            return n4 ? r4.toLowerCase() : r4;
          }, l2 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a2 + 1, MM: O.s(a2 + 1, 2, "0"), MMM: h2(n3.monthsShort, a2, f2, 3), MMMM: h2(f2, a2), D: this.$D, DD: O.s(this.$D, 2, "0"), d: String(this.$W), dd: h2(n3.weekdaysMin, this.$W, o2, 2), ddd: h2(n3.weekdaysShort, this.$W, o2, 3), dddd: o2[this.$W], H: String(s2), HH: O.s(s2, 2, "0"), h: c2(1), hh: c2(2), a: d2(s2, u2, true), A: d2(s2, u2, false), m: String(u2), mm: O.s(u2, 2, "0"), s: String(this.$s), ss: O.s(this.$s, 2, "0"), SSS: O.s(this.$ms, 3, "0"), Z: i2 };
          return r3.replace(y, function(t4, e4) {
            return e4 || l2[t4] || i2.replace(":", "");
          });
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r3, d2, $2) {
          var l2, y2 = O.p(d2), M3 = w(r3), m3 = (M3.utcOffset() - this.utcOffset()) * e2, g2 = this - M3, D2 = O.m(this, M3);
          return D2 = (l2 = {}, l2[c] = D2 / 12, l2[f] = D2, l2[h] = D2 / 3, l2[o] = (g2 - m3) / 6048e5, l2[a] = (g2 - m3) / 864e5, l2[u] = g2 / n2, l2[s] = g2 / e2, l2[i] = g2 / t2, l2)[y2] || g2, $2 ? D2 : O.a(D2);
        }, m2.daysInMonth = function() {
          return this.endOf(f).$D;
        }, m2.$locale = function() {
          return v[this.$L];
        }, m2.locale = function(t3, e3) {
          if (!t3)
            return this.$L;
          var n3 = this.clone(), r3 = S(t3, e3, true);
          return r3 && (n3.$L = r3), n3;
        }, m2.clone = function() {
          return O.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      }(), b = _.prototype;
      return w.prototype = b, [["$ms", r2], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", f], ["$y", c], ["$D", d]].forEach(function(t3) {
        b[t3[1]] = function(e3) {
          return this.$g(e3, t3[0], t3[1]);
        };
      }), w.extend = function(t3, e3) {
        return t3.$i || (t3(e3, _, w), t3.$i = true), w;
      }, w.locale = S, w.isDayjs = p, w.unix = function(t3) {
        return w(1e3 * t3);
      }, w.en = v[D], w.Ls = v, w.p = {}, w;
    });
  })(dayjs_min);
  var dayjs$1 = dayjs_min.exports;
  var customParseFormat$1 = { exports: {} };
  (function(module2, exports2) {
    !function(t2, e2) {
      module2.exports = e2();
    }(commonjsGlobal, function() {
      var t2 = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, e2 = /(\[[^[]*\])|([-:/.()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n2 = /\d\d/, r2 = /\d\d?/, i = /\d*[^\s\d-_:/()]+/, o = {}, s = function(t3) {
        return (t3 = +t3) + (t3 > 68 ? 1900 : 2e3);
      };
      var a = function(t3) {
        return function(e3) {
          this[t3] = +e3;
        };
      }, f = [/[+-]\d\d:?(\d\d)?|Z/, function(t3) {
        (this.zone || (this.zone = {})).offset = function(t4) {
          if (!t4)
            return 0;
          if (t4 === "Z")
            return 0;
          var e3 = t4.match(/([+-]|\d\d)/g), n3 = 60 * e3[1] + (+e3[2] || 0);
          return n3 === 0 ? 0 : e3[0] === "+" ? -n3 : n3;
        }(t3);
      }], u = function(t3) {
        var e3 = o[t3];
        return e3 && (e3.indexOf ? e3 : e3.s.concat(e3.f));
      }, h = function(t3, e3) {
        var n3, r3 = o.meridiem;
        if (r3) {
          for (var i2 = 1; i2 <= 24; i2 += 1)
            if (t3.indexOf(r3(i2, 0, e3)) > -1) {
              n3 = i2 > 12;
              break;
            }
        } else
          n3 = t3 === (e3 ? "pm" : "PM");
        return n3;
      }, d = { A: [i, function(t3) {
        this.afternoon = h(t3, false);
      }], a: [i, function(t3) {
        this.afternoon = h(t3, true);
      }], S: [/\d/, function(t3) {
        this.milliseconds = 100 * +t3;
      }], SS: [n2, function(t3) {
        this.milliseconds = 10 * +t3;
      }], SSS: [/\d{3}/, function(t3) {
        this.milliseconds = +t3;
      }], s: [r2, a("seconds")], ss: [r2, a("seconds")], m: [r2, a("minutes")], mm: [r2, a("minutes")], H: [r2, a("hours")], h: [r2, a("hours")], HH: [r2, a("hours")], hh: [r2, a("hours")], D: [r2, a("day")], DD: [n2, a("day")], Do: [i, function(t3) {
        var e3 = o.ordinal, n3 = t3.match(/\d+/);
        if (this.day = n3[0], e3)
          for (var r3 = 1; r3 <= 31; r3 += 1)
            e3(r3).replace(/\[|\]/g, "") === t3 && (this.day = r3);
      }], M: [r2, a("month")], MM: [n2, a("month")], MMM: [i, function(t3) {
        var e3 = u("months"), n3 = (u("monthsShort") || e3.map(function(t4) {
          return t4.substr(0, 3);
        })).indexOf(t3) + 1;
        if (n3 < 1)
          throw new Error();
        this.month = n3 % 12 || n3;
      }], MMMM: [i, function(t3) {
        var e3 = u("months").indexOf(t3) + 1;
        if (e3 < 1)
          throw new Error();
        this.month = e3 % 12 || e3;
      }], Y: [/[+-]?\d+/, a("year")], YY: [n2, function(t3) {
        this.year = s(t3);
      }], YYYY: [/\d{4}/, a("year")], Z: f, ZZ: f };
      function c(n3) {
        var r3, i2;
        r3 = n3, i2 = o && o.formats;
        for (var s2 = (n3 = r3.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(e3, n4, r4) {
          var o2 = r4 && r4.toUpperCase();
          return n4 || i2[r4] || t2[r4] || i2[o2].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(t3, e4, n5) {
            return e4 || n5.slice(1);
          });
        })).match(e2), a2 = s2.length, f2 = 0; f2 < a2; f2 += 1) {
          var u2 = s2[f2], h2 = d[u2], c2 = h2 && h2[0], l = h2 && h2[1];
          s2[f2] = l ? { regex: c2, parser: l } : u2.replace(/^\[|\]$/g, "");
        }
        return function(t3) {
          for (var e3 = {}, n4 = 0, r4 = 0; n4 < a2; n4 += 1) {
            var i3 = s2[n4];
            if (typeof i3 == "string")
              r4 += i3.length;
            else {
              var o2 = i3.regex, f3 = i3.parser, u3 = t3.substr(r4), h3 = o2.exec(u3)[0];
              f3.call(e3, h3), t3 = t3.replace(h3, "");
            }
          }
          return function(t4) {
            var e4 = t4.afternoon;
            if (e4 !== void 0) {
              var n5 = t4.hours;
              e4 ? n5 < 12 && (t4.hours += 12) : n5 === 12 && (t4.hours = 0), delete t4.afternoon;
            }
          }(e3), e3;
        };
      }
      return function(t3, e3, n3) {
        n3.p.customParseFormat = true, t3 && t3.parseTwoDigitYear && (s = t3.parseTwoDigitYear);
        var r3 = e3.prototype, i2 = r3.parse;
        r3.parse = function(t4) {
          var e4 = t4.date, r4 = t4.utc, s2 = t4.args;
          this.$u = r4;
          var a2 = s2[1];
          if (typeof a2 == "string") {
            var f2 = s2[2] === true, u2 = s2[3] === true, h2 = f2 || u2, d2 = s2[2];
            u2 && (d2 = s2[2]), o = this.$locale(), !f2 && d2 && (o = n3.Ls[d2]), this.$d = function(t5, e5, n4) {
              try {
                if (["x", "X"].indexOf(e5) > -1)
                  return new Date((e5 === "X" ? 1e3 : 1) * t5);
                var r5 = c(e5)(t5), i3 = r5.year, o2 = r5.month, s3 = r5.day, a3 = r5.hours, f3 = r5.minutes, u3 = r5.seconds, h3 = r5.milliseconds, d3 = r5.zone, l2 = new Date(), m2 = s3 || (i3 || o2 ? 1 : l2.getDate()), M2 = i3 || l2.getFullYear(), Y = 0;
                i3 && !o2 || (Y = o2 > 0 ? o2 - 1 : l2.getMonth());
                var p = a3 || 0, v = f3 || 0, D = u3 || 0, g = h3 || 0;
                return d3 ? new Date(Date.UTC(M2, Y, m2, p, v, D, g + 60 * d3.offset * 1e3)) : n4 ? new Date(Date.UTC(M2, Y, m2, p, v, D, g)) : new Date(M2, Y, m2, p, v, D, g);
              } catch (t6) {
                return new Date("");
              }
            }(e4, a2, r4), this.init(), d2 && d2 !== true && (this.$L = this.locale(d2).$L), h2 && e4 != this.format(a2) && (this.$d = new Date("")), o = {};
          } else if (a2 instanceof Array)
            for (var l = a2.length, m = 1; m <= l; m += 1) {
              s2[1] = a2[m - 1];
              var M = n3.apply(this, s2);
              if (M.isValid()) {
                this.$d = M.$d, this.$L = M.$L, this.init();
                break;
              }
              m === l && (this.$d = new Date(""));
            }
          else
            i2.call(this, t4);
        };
      };
    });
  })(customParseFormat$1);
  var customParseFormat = customParseFormat$1.exports;
  var isBetween$1 = { exports: {} };
  (function(module2, exports2) {
    !function(e2, i) {
      module2.exports = i();
    }(commonjsGlobal, function() {
      return function(e2, i, t2) {
        i.prototype.isBetween = function(e3, i2, s, f) {
          var n2 = t2(e3), o = t2(i2), r2 = (f = f || "()")[0] === "(", u = f[1] === ")";
          return (r2 ? this.isAfter(n2, s) : !this.isBefore(n2, s)) && (u ? this.isBefore(o, s) : !this.isAfter(o, s)) || (r2 ? this.isBefore(n2, s) : !this.isAfter(n2, s)) && (u ? this.isAfter(o, s) : !this.isBefore(o, s));
        };
      };
    });
  })(isBetween$1);
  var isBetween = isBetween$1.exports;
  var weekOfYear$1 = { exports: {} };
  (function(module2, exports2) {
    !function(e2, t2) {
      module2.exports = t2();
    }(commonjsGlobal, function() {
      var e2 = "week", t2 = "year";
      return function(i, n2, r2) {
        var f = n2.prototype;
        f.week = function(i2) {
          if (i2 === void 0 && (i2 = null), i2 !== null)
            return this.add(7 * (i2 - this.week()), "day");
          var n3 = this.$locale().yearStart || 1;
          if (this.month() === 11 && this.date() > 25) {
            var f2 = r2(this).startOf(t2).add(1, t2).date(n3), s = r2(this).endOf(e2);
            if (f2.isBefore(s))
              return 1;
          }
          var a = r2(this).startOf(t2).date(n3).startOf(e2).subtract(1, "millisecond"), o = this.diff(a, e2, true);
          return o < 0 ? r2(this).startOf("week").week() : Math.ceil(o);
        }, f.weeks = function(e3) {
          return e3 === void 0 && (e3 = null), this.week(e3);
        };
      };
    });
  })(weekOfYear$1);
  var weekOfYear = weekOfYear$1.exports;
  var advancedFormat = { exports: {} };
  (function(module2, exports2) {
    !function(e2, t2) {
      module2.exports = t2();
    }(commonjsGlobal, function() {
      return function(e2, t2, r2) {
        var n2 = t2.prototype, s = n2.format;
        r2.en.ordinal = function(e3) {
          var t3 = ["th", "st", "nd", "rd"], r3 = e3 % 100;
          return "[" + e3 + (t3[(r3 - 20) % 10] || t3[r3] || t3[0]) + "]";
        }, n2.format = function(e3) {
          var t3 = this, r3 = this.$locale();
          if (!this.isValid())
            return s.bind(this)(e3);
          var n3 = this.$utils(), a = (e3 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(e4) {
            switch (e4) {
              case "Q":
                return Math.ceil((t3.$M + 1) / 3);
              case "Do":
                return r3.ordinal(t3.$D);
              case "gggg":
                return t3.weekYear();
              case "GGGG":
                return t3.isoWeekYear();
              case "wo":
                return r3.ordinal(t3.week(), "W");
              case "w":
              case "ww":
                return n3.s(t3.week(), e4 === "w" ? 1 : 2, "0");
              case "W":
              case "WW":
                return n3.s(t3.isoWeek(), e4 === "W" ? 1 : 2, "0");
              case "k":
              case "kk":
                return n3.s(String(t3.$H === 0 ? 24 : t3.$H), e4 === "k" ? 1 : 2, "0");
              case "X":
                return Math.floor(t3.$d.getTime() / 1e3);
              case "x":
                return t3.$d.getTime();
              case "z":
                return "[" + t3.offsetName() + "]";
              case "zzz":
                return "[" + t3.offsetName("long") + "]";
              default:
                return e4;
            }
          });
          return s.bind(this)(a);
        };
      };
    });
  })(advancedFormat);
  var AdvancedFormat = advancedFormat.exports;
  var weekYear$1 = { exports: {} };
  (function(module2, exports2) {
    !function(e2, t2) {
      module2.exports = t2();
    }(commonjsGlobal, function() {
      return function(e2, t2) {
        t2.prototype.weekYear = function() {
          var e3 = this.month(), t3 = this.week(), n2 = this.year();
          return t3 === 1 && e3 === 11 ? n2 + 1 : e3 === 0 && t3 >= 52 ? n2 - 1 : n2;
        };
      };
    });
  })(weekYear$1);
  var weekYear = weekYear$1.exports;
  var quarterOfYear = { exports: {} };
  (function(module2, exports2) {
    !function(t2, n2) {
      module2.exports = n2();
    }(commonjsGlobal, function() {
      var t2 = "month", n2 = "quarter";
      return function(e2, i) {
        var r2 = i.prototype;
        r2.quarter = function(t3) {
          return this.$utils().u(t3) ? Math.ceil((this.month() + 1) / 3) : this.month(this.month() % 3 + 3 * (t3 - 1));
        };
        var s = r2.add;
        r2.add = function(e3, i2) {
          return e3 = Number(e3), this.$utils().p(i2) === n2 ? this.add(3 * e3, t2) : s.bind(this)(e3, i2);
        };
        var u = r2.startOf;
        r2.startOf = function(e3, i2) {
          var r3 = this.$utils(), s2 = !!r3.u(i2) || i2;
          if (r3.p(e3) === n2) {
            var o = this.quarter() - 1;
            return s2 ? this.month(3 * o).startOf(t2).startOf("day") : this.month(3 * o + 2).endOf(t2).endOf("day");
          }
          return u.bind(this)(e3, i2);
        };
      };
    });
  })(quarterOfYear);
  var QuarterOfYear = quarterOfYear.exports;
  var zhCn = { exports: {} };
  (function(module2, exports2) {
    !function(e2, _) {
      module2.exports = _(dayjs_min.exports);
    }(commonjsGlobal, function(e2) {
      function _(e3) {
        return e3 && typeof e3 == "object" && "default" in e3 ? e3 : { default: e3 };
      }
      var t2 = _(e2), d = { name: "zh-cn", weekdays: "\u661F\u671F\u65E5_\u661F\u671F\u4E00_\u661F\u671F\u4E8C_\u661F\u671F\u4E09_\u661F\u671F\u56DB_\u661F\u671F\u4E94_\u661F\u671F\u516D".split("_"), weekdaysShort: "\u5468\u65E5_\u5468\u4E00_\u5468\u4E8C_\u5468\u4E09_\u5468\u56DB_\u5468\u4E94_\u5468\u516D".split("_"), weekdaysMin: "\u65E5_\u4E00_\u4E8C_\u4E09_\u56DB_\u4E94_\u516D".split("_"), months: "\u4E00\u6708_\u4E8C\u6708_\u4E09\u6708_\u56DB\u6708_\u4E94\u6708_\u516D\u6708_\u4E03\u6708_\u516B\u6708_\u4E5D\u6708_\u5341\u6708_\u5341\u4E00\u6708_\u5341\u4E8C\u6708".split("_"), monthsShort: "1\u6708_2\u6708_3\u6708_4\u6708_5\u6708_6\u6708_7\u6708_8\u6708_9\u6708_10\u6708_11\u6708_12\u6708".split("_"), ordinal: function(e3, _2) {
        switch (_2) {
          case "W":
            return e3 + "\u5468";
          default:
            return e3 + "\u65E5";
        }
      }, weekStart: 1, yearStart: 4, formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY/MM/DD", LL: "YYYY\u5E74M\u6708D\u65E5", LLL: "YYYY\u5E74M\u6708D\u65E5Ah\u70B9mm\u5206", LLLL: "YYYY\u5E74M\u6708D\u65E5ddddAh\u70B9mm\u5206", l: "YYYY/M/D", ll: "YYYY\u5E74M\u6708D\u65E5", lll: "YYYY\u5E74M\u6708D\u65E5 HH:mm", llll: "YYYY\u5E74M\u6708D\u65E5dddd HH:mm" }, relativeTime: { future: "%s\u5185", past: "%s\u524D", s: "\u51E0\u79D2", m: "1 \u5206\u949F", mm: "%d \u5206\u949F", h: "1 \u5C0F\u65F6", hh: "%d \u5C0F\u65F6", d: "1 \u5929", dd: "%d \u5929", M: "1 \u4E2A\u6708", MM: "%d \u4E2A\u6708", y: "1 \u5E74", yy: "%d \u5E74" }, meridiem: function(e3, _2) {
        var t3 = 100 * e3 + _2;
        return t3 < 600 ? "\u51CC\u6668" : t3 < 900 ? "\u65E9\u4E0A" : t3 < 1100 ? "\u4E0A\u5348" : t3 < 1300 ? "\u4E2D\u5348" : t3 < 1800 ? "\u4E0B\u5348" : "\u665A\u4E0A";
      } };
      return t2.default.locale(d, null, true), d;
    });
  })(zhCn);
  const overwriteIsDayjs = (_, Dayjs2, dayjs2) => {
    dayjs2 = function(date, c) {
      if (isDayjs(date)) {
        return date.clone();
      }
      const cfg = typeof c === "object" ? c : {};
      cfg.date = date;
      cfg.args = arguments;
      return new Dayjs2(cfg);
    };
    const proto = Dayjs2.prototype;
    const old$Utils = proto.$utils;
    proto.$utils = () => {
      const newUtils = old$Utils();
      newUtils.i = isDayjs;
      return newUtils;
    };
    dayjs2.isDayjs = isDayjs;
  };
  dayjs$1.extend(overwriteIsDayjs);
  dayjs$1.extend(customParseFormat);
  dayjs$1.extend(isBetween);
  dayjs$1.extend(weekOfYear);
  dayjs$1.extend(AdvancedFormat);
  dayjs$1.extend(weekYear);
  dayjs$1.extend(QuarterOfYear);
  const dayjs = dayjs$1;
  const methods = {
    add(time, value, unit) {
      return time.add(value, unit);
    },
    subtract(time, value, unit) {
      return time.subtract(value, unit);
    },
    startOf(time, unit) {
      return time.startOf(unit);
    },
    endOf(time, unit) {
      return time.endOf(unit);
    },
    set(time, unit, value) {
      return time.set(unit, value);
    },
    isSameWeek(date1, date2, weekStart, localeName) {
      return date1.locale(__spreadProps(__spreadValues({}, dayjs.Ls[localeName.toLocaleLowerCase()]), { weekStart })).isSame(date2, "week");
    }
  };
  function getNow() {
    return dayjs();
  }
  function getSortedDayjsArray(values) {
    return [...values].sort((a, b) => a.valueOf() - b.valueOf());
  }
  function isValueChange(prevValue, currentValue) {
    const isDifference = (value1, value2) => {
      if (value1 === void 0 && value2 === void 0) {
        return false;
      }
      if (value1 && !value2 || !value1 && value2) {
        return true;
      }
      return (value1 == null ? void 0 : value1.valueOf()) !== (value2 == null ? void 0 : value2.valueOf());
    };
    if (currentValue === void 0 && prevValue === void 0) {
      return false;
    }
    if (isArray$1(currentValue) && isArray$1(prevValue)) {
      return isDifference(currentValue[0], prevValue[0]) || isDifference(currentValue[1], prevValue[1]);
    }
    if (!isArray$1(currentValue) && !isArray$1(prevValue)) {
      return isDifference(currentValue, prevValue);
    }
    return true;
  }
  function getDayjsValue(time, format) {
    const parseQuarterToMonth = (value) => {
      const reg = /(Q1)|(Q2)|(Q3)|(Q4)/;
      const quarter = {
        Q1: "01",
        Q2: "04",
        Q3: "07",
        Q4: "10"
      };
      const [q] = reg.exec(value);
      return value.replace(reg, quarter[q]);
    };
    const formatValue = (value) => {
      if (!value)
        return void 0;
      if (typeof value === "string") {
        if (isQuarter(format)) {
          return dayjs(parseQuarterToMonth(value), format.replace(/\[Q]Q/, "MM"));
        }
        return dayjs(value, format);
      }
      return dayjs(value);
    };
    if (isArray$1(time)) {
      return time.map(formatValue);
    }
    return formatValue(time);
  }
  function getDateValue$1(value) {
    const formatValue = (t2) => t2 ? t2.toDate() : void 0;
    if (isArray$1(value)) {
      return value.map(formatValue);
    }
    return formatValue(value);
  }
  function initializeDateLocale(localeName, weekStart) {
    dayjs.locale(__spreadProps(__spreadValues({}, dayjs.Ls[localeName.toLocaleLowerCase()]), { weekStart }));
  }
  function pickDataAttributes(obj) {
    const clone = {};
    obj && Object.keys(obj).forEach((key) => {
      const k = String(key);
      if (k.indexOf("data-") === 0) {
        clone[k] = obj[k];
      }
      if (k.indexOf("aria-") === 0) {
        clone[k] = obj[k];
      }
    });
    return clone;
  }
  function padStart(string, length, char = " ") {
    const s = String(string);
    if (!length) {
      return s;
    }
    const newString = s.length < length ? `${char}${s}` : s;
    return newString.length < length ? padStart(newString, length, char) : newString;
  }
  var Week = vue.defineComponent({
    name: "Week",
    props: {
      mode: {
        type: String
      },
      dayStartOfWeek: {
        type: Number
      },
      isWeek: {
        type: Boolean
      },
      panel: {
        type: Boolean
      },
      value: {
        type: Object,
        required: true
      },
      selectHandler: {
        type: Function
      },
      pageShowData: {
        type: Object,
        required: true
      },
      pageData: {
        type: Array
      }
    },
    setup(props) {
      const {
        dayStartOfWeek,
        isWeek,
        panel,
        mode
      } = vue.toRefs(props);
      const prefixCls = getPrefixCls("calendar-week-list");
      const {
        t: t2
      } = useI18n();
      const weekList = ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
      if (dayStartOfWeek.value === 0) {
        weekList.unshift("sunday");
      } else {
        weekList.push("sunday");
      }
      if (isWeek.value) {
        weekList.unshift("self");
      }
      return () => vue.createVNode("div", {
        "class": prefixCls
      }, [weekList.map((w) => vue.createVNode("div", {
        "class": `${prefixCls}-item`,
        "key": w
      }, [t2(`calendar.week.${panel.value || mode.value === "year" ? "short" : "long"}.${w}`)]))]);
    }
  });
  function getDateValue(date, index2) {
    if (!date) {
      return void 0;
    }
    if (isArray$1(date)) {
      return date[index2];
    }
    return void 0;
  }
  function useClassName({
    prefixCls,
    mergedValue,
    rangeValues,
    hoverRangeValues,
    panel,
    isSameTime,
    innerMode
  }) {
    function isInRange(current, startDate, endDate) {
      if (!startDate || !endDate) {
        return false;
      }
      return isSameTime(current, startDate) || isSameTime(current, endDate) || current.isBetween(startDate, endDate, null, "[]");
    }
    return function getCellClassName(cellDateObj, disabled) {
      const rangeStart = getDateValue(rangeValues, 0);
      const rangeEnd = getDateValue(rangeValues, 1);
      const hoverRangeStart = getDateValue(hoverRangeValues, 0);
      const hoverRangeEnd = getDateValue(hoverRangeValues, 1);
      const isInView = !cellDateObj.isPrev && !cellDateObj.isNext;
      const rangeAvailable = isInView && panel;
      const isRangeStart = rangeAvailable && rangeStart && isSameTime(cellDateObj.time, rangeStart);
      const isRangeEnd = rangeAvailable && rangeEnd && isSameTime(cellDateObj.time, rangeEnd);
      const nearRangeStart = hoverRangeStart && rangeStart && hoverRangeStart.isBefore(rangeStart);
      const nearRangeEnd = rangeEnd && hoverRangeEnd && hoverRangeEnd.isAfter(rangeEnd);
      const isHoverNearRange = nearRangeStart && isRangeStart || nearRangeEnd && isRangeEnd;
      let isToday = isSameTime(cellDateObj.time, getNow());
      if (!panel && innerMode === "year") {
        isToday = getNow().isSame(cellDateObj.time, "date");
      }
      return [
        `${prefixCls}-cell`,
        {
          [`${prefixCls}-cell-in-view`]: isInView,
          [`${prefixCls}-cell-today`]: isToday,
          [`${prefixCls}-cell-selected`]: mergedValue && isSameTime(cellDateObj.time, mergedValue),
          [`${prefixCls}-cell-range-start`]: isRangeStart,
          [`${prefixCls}-cell-range-end`]: isRangeEnd,
          [`${prefixCls}-cell-in-range`]: rangeAvailable && isInRange(cellDateObj.time, rangeStart, rangeEnd),
          [`${prefixCls}-cell-in-range-near-hover`]: isHoverNearRange,
          [`${prefixCls}-cell-hover-range-start`]: rangeAvailable && hoverRangeStart && isSameTime(cellDateObj.time, hoverRangeStart),
          [`${prefixCls}-cell-hover-range-end`]: rangeAvailable && hoverRangeEnd && isSameTime(cellDateObj.time, hoverRangeEnd),
          [`${prefixCls}-cell-hover-in-range`]: rangeAvailable && isInRange(cellDateObj.time, hoverRangeStart, hoverRangeEnd),
          [`${prefixCls}-cell-disabled`]: disabled
        }
      ];
    };
  }
  const allDaysInOnePage = 6 * 7;
  const getReturn = (time) => {
    return {
      year: time.year(),
      month: time.month() + 1,
      date: time.date(),
      day: time.day(),
      time
    };
  };
  const getTimeObj = (time) => {
    return {
      start: getReturn(methods.startOf(time, "month")),
      end: getReturn(methods.endOf(time, "month")),
      days: time.daysInMonth()
    };
  };
  function getAllDaysByTime(time, {
    dayStartOfWeek = 0,
    isWeek
  }) {
    const current = getTimeObj(time);
    const flatRows = Array(allDaysInOnePage).fill(null).map(() => ({}));
    const startIndex = dayStartOfWeek === 0 ? current.start.day : (current.start.day || 7) - 1;
    flatRows[startIndex] = __spreadProps(__spreadValues({}, current.start), {
      isCurrent: true
    });
    for (let i = 0; i < startIndex; i++) {
      flatRows[startIndex - i - 1] = __spreadProps(__spreadValues({}, getReturn(methods.subtract(current.start.time, i + 1, "day"))), {
        isPrev: true
      });
    }
    for (let i = 0; i < allDaysInOnePage - startIndex - 1; i++) {
      flatRows[startIndex + i + 1] = __spreadProps(__spreadValues({}, getReturn(methods.add(current.start.time, i + 1, "day"))), {
        isCurrent: i < current.days,
        isNext: i >= current.days - 1
      });
    }
    const rows = Array(6).fill(null).map(() => []);
    for (let i = 0; i < 6; i++) {
      rows[i] = flatRows.slice(i * 7, 7 * (i + 1));
      if (isWeek) {
        const weekTime = rows[i][0].time;
        const weekRows = [...rows[i]];
        rows[i].unshift({
          weekRows,
          weekOfYear: weekTime.week()
        });
      }
    }
    return rows;
  }
  var Month = vue.defineComponent({
    name: "Month",
    props: {
      cell: {
        type: Boolean
      },
      pageData: {
        type: Array
      },
      current: {
        type: Number
      },
      value: {
        type: Object,
        required: true
      },
      selectHandler: {
        type: Function,
        required: true
      },
      mode: {
        type: String
      },
      pageShowDate: {
        type: Object,
        required: true
      },
      panel: {
        type: Boolean
      },
      dayStartOfWeek: {
        type: Number,
        required: true
      },
      isWeek: {
        type: Boolean,
        required: true
      }
    },
    setup(props) {
      const {
        pageData
      } = vue.toRefs(props);
      const prefixCls = getPrefixCls("calendar");
      const pageShowDateYear = props.pageShowDate.year();
      const getCellClassName = vue.computed(() => useClassName({
        prefixCls,
        mergedValue: props.value,
        panel: false,
        innerMode: props.mode,
        rangeValues: [],
        hoverRangeValues: [],
        isSameTime: (current, target2) => current.isSame(target2, "day")
      }));
      function renderDays(row) {
        return row.map((col, index2) => {
          if (col.time) {
            const onClickHandler = () => props.selectHandler(col.time, false);
            const tdProps = props.isWeek ? {
              onClick: onClickHandler
            } : {};
            const tdDivProps = !props.isWeek ? {
              onClick: onClickHandler
            } : {};
            return vue.createVNode("div", vue.mergeProps({
              "key": index2,
              "class": getCellClassName.value(col, false)
            }, tdProps), [vue.createVNode("div", vue.mergeProps({
              "class": `${prefixCls}-date`
            }, tdDivProps), [vue.createVNode("div", {
              "class": `${prefixCls}-date-value`
            }, [props.panel ? col.date : vue.createVNode("div", {
              "class": `${prefixCls}-date-circle`
            }, [col.date])])])]);
          }
          if ("weekOfYear" in col) {
            const rowYear = props.value.year();
            const rowMonth = props.value.month() + 1;
            const rowWeek = props.value.week();
            const selectedWeek = props.value && col.weekRows.find((r2) => r2.year === rowYear && r2.month === rowMonth) && rowWeek === col.weekOfYear;
            return vue.createVNode("div", {
              "key": index2,
              "class": [`${prefixCls}-cell`, `${prefixCls}-cell-week`, {
                [`${prefixCls}-cell-selected-week`]: selectedWeek,
                [`${prefixCls}-cell-in-range`]: selectedWeek
              }]
            }, [vue.createVNode("div", {
              "class": `${prefixCls}-date`
            }, [vue.createVNode("div", {
              "class": `${prefixCls}-date-value`
            }, [col.weekOfYear])])]);
          }
          return null;
        });
      }
      let pd = pageData.value;
      if (typeof props.current === "number") {
        pd = getAllDaysByTime(dayjs(`${pageShowDateYear}-${padStart(props.current + 1, 2, "0")}-01`), {
          dayStartOfWeek: props.dayStartOfWeek,
          isWeek: props.isWeek
        });
      }
      return () => vue.createVNode("div", {
        "class": props.cell ? `${prefixCls}-month-cell` : `${prefixCls}-month`
      }, [vue.createVNode(Week, {
        "value": props.value,
        "selectHandler": props.selectHandler,
        "dayStartOfWeek": props.dayStartOfWeek,
        "isWeek": props.isWeek,
        "panel": props.panel,
        "mode": props.mode,
        "pageShowData": props.pageShowDate,
        "pageData": props.pageData
      }, null), vue.createVNode("div", {
        "class": `${prefixCls}-month-cell-body`
      }, [pd == null ? void 0 : pd.map((row, index2) => vue.createVNode("div", {
        "key": index2,
        "class": [`${prefixCls}-month-row`, {
          [`${prefixCls}-row-week`]: props.isWeek
        }]
      }, [renderDays(row)]))])]);
    }
  });
  const MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"].map((month, index2) => {
    return {
      name: month,
      value: index2
    };
  });
  const monthGroup = Array(3);
  for (let i = 0; i < 3; i++) {
    monthGroup[i] = MONTHS.slice(i * 4, 4 * (i + 1));
  }
  const monthGroupPanel = Array(4);
  for (let i = 0; i < 4; i++) {
    monthGroupPanel[i] = MONTHS.slice(i * 3, 3 * (i + 1));
  }
  var Year = vue.defineComponent({
    name: "Year",
    props: {
      mode: {
        type: String,
        required: true
      },
      dayStartOfWeek: {
        type: Number,
        required: true
      },
      value: {
        type: Object,
        required: true
      },
      isWeek: {
        type: Boolean
      },
      panel: {
        type: Boolean,
        default: false
      },
      pageShowData: {
        type: Object,
        required: true
      },
      pageData: {
        type: Array
      },
      selectHandler: {
        type: Function,
        required: true
      }
    },
    setup(props) {
      const prefixCls = getPrefixCls("calendar");
      const getCellClassName = vue.computed(() => useClassName({
        prefixCls,
        mergedValue: props.value,
        panel: false,
        innerMode: props.mode,
        rangeValues: [],
        hoverRangeValues: [],
        isSameTime: (current, target2) => current.isSame(target2, "month")
      }));
      const {
        t: t2
      } = useI18n();
      const showYear = vue.computed(() => props.pageShowData.year());
      const mg = props.panel ? monthGroupPanel : monthGroup;
      return () => vue.createVNode("div", {
        "class": `${prefixCls}-year`
      }, [mg.map((row, rowIndex) => vue.createVNode("div", {
        "class": `${prefixCls}-year-row`,
        "key": rowIndex
      }, [row.map((col) => {
        const time = dayjs(`${showYear.value}-${padStart(col.value + 1, 2, "0")}-01`);
        const divProps = props.panel ? {
          onClick: () => props.selectHandler(time, false)
        } : {};
        return vue.createVNode("div", {
          "key": col.value,
          "class": getCellClassName.value(__spreadProps(__spreadValues({}, col), {
            time
          }), false)
        }, [props.panel ? vue.createVNode("div", vue.mergeProps({
          "class": `${prefixCls}-date`
        }, divProps), [vue.createVNode("div", {
          "class": `${prefixCls}-date-value`
        }, [t2(`calendar.month.short.${col.name}`)])]) : vue.createVNode("div", {
          "class": `${prefixCls}-month-with-days`
        }, [vue.createVNode("div", {
          "class": `${prefixCls}-month-title`
        }, [t2(`calendar.month.long.${col.name}`)]), vue.createVNode(Month, {
          "pageShowDate": props.pageShowData,
          "pageData": props.pageData,
          "dayStartOfWeek": props.dayStartOfWeek,
          "selectHandler": props.selectHandler,
          "isWeek": props.isWeek,
          "cell": true,
          "current": col.value,
          "value": props.value,
          "mode": props.mode
        }, null)])]);
      })]))]);
    }
  });
  const useInput = ({
    defaultValue,
    modelValue,
    emit,
    eventName = "input",
    updateEventName = "update:modelValue",
    eventHandlers
  }) => {
    var _a;
    const inputRef = vue.ref();
    const _value = vue.ref((_a = defaultValue == null ? void 0 : defaultValue.value) != null ? _a : "");
    const _focused = vue.ref(false);
    const isComposition = vue.ref(false);
    const compositionValue = vue.ref("");
    let initialValue;
    const computedValue = vue.computed(() => {
      var _a2;
      return (_a2 = modelValue == null ? void 0 : modelValue.value) != null ? _a2 : _value.value;
    });
    const updateValue = (value, ev) => {
      _value.value = value;
      emit(updateEventName, value);
      emit(eventName, value, ev);
    };
    const handleInput = (ev) => {
      const { value } = ev.target;
      if (!isComposition.value) {
        updateValue(value, ev);
        vue.nextTick(() => {
          if (inputRef.value && computedValue.value !== inputRef.value.value) {
            inputRef.value.value = computedValue.value;
          }
        });
      }
    };
    const handleChange = (ev) => {
      if (eventName === "input" && computedValue.value !== initialValue) {
        initialValue = computedValue.value;
        emit("change", computedValue.value, ev);
      }
    };
    const handleComposition = (ev) => {
      var _a2;
      const { value } = ev.target;
      if (ev.type === "compositionend") {
        isComposition.value = false;
        compositionValue.value = "";
        updateValue(value, ev);
        vue.nextTick(() => {
          if (inputRef.value && computedValue.value !== inputRef.value.value) {
            inputRef.value.value = computedValue.value;
          }
        });
      } else {
        isComposition.value = true;
        compositionValue.value = computedValue.value + ((_a2 = ev.data) != null ? _a2 : "");
      }
    };
    const handleFocus = (ev) => {
      var _a2, _b;
      _focused.value = true;
      initialValue = computedValue.value;
      emit("focus", ev);
      (_b = (_a2 = eventHandlers == null ? void 0 : eventHandlers.value) == null ? void 0 : _a2.onFocus) == null ? void 0 : _b.call(_a2, ev);
    };
    const handleBlur = (ev) => {
      var _a2, _b;
      _focused.value = false;
      emit("blur", ev);
      (_b = (_a2 = eventHandlers == null ? void 0 : eventHandlers.value) == null ? void 0 : _a2.onBlur) == null ? void 0 : _b.call(_a2, ev);
      handleChange(ev);
    };
    const handleKeyDown = (ev) => {
      const keyCode = ev.key || ev.code;
      if (!isComposition.value && keyCode === Enter.key) {
        emit("pressEnter", ev);
        handleChange(ev);
      }
    };
    const handleMousedown = (ev) => {
      if (inputRef.value && ev.target !== inputRef.value) {
        ev.preventDefault();
        inputRef.value.focus();
      }
    };
    vue.watch(computedValue, (value) => {
      if (inputRef.value && value !== inputRef.value.value) {
        inputRef.value.value = value;
      }
    });
    return {
      inputRef,
      _value,
      _focused,
      isComposition,
      compositionValue,
      computedValue,
      handleInput,
      handleComposition,
      handleFocus,
      handleBlur,
      handleKeyDown,
      handleMousedown
    };
  };
  var InputLabel = vue.defineComponent({
    name: "InputLabel",
    inheritAttrs: false,
    props: {
      modelValue: Object,
      inputValue: {
        type: String,
        default: ""
      },
      enabledInput: Boolean,
      formatLabel: Function,
      placeholder: String,
      retainInputValue: Boolean,
      disabled: Boolean,
      baseCls: String,
      size: String,
      error: Boolean,
      focused: Boolean,
      uninjectFormItemContext: Boolean
    },
    emits: ["update:inputValue", "inputValueChange", "focus", "blur"],
    setup(props, {
      attrs,
      emit,
      slots
    }) {
      var _a;
      const {
        size,
        disabled,
        error,
        inputValue,
        uninjectFormItemContext
      } = vue.toRefs(props);
      const prefixCls = (_a = props.baseCls) != null ? _a : getPrefixCls("input-label");
      const {
        mergedSize: _mergedSize,
        mergedDisabled,
        mergedError,
        eventHandlers
      } = useFormItem({
        size,
        disabled,
        error,
        uninject: uninjectFormItemContext == null ? void 0 : uninjectFormItemContext.value
      });
      const {
        mergedSize
      } = useSize$1(_mergedSize);
      const {
        inputRef,
        _focused,
        computedValue: computedInputValue,
        handleInput,
        handleComposition,
        handleFocus,
        handleBlur,
        handleMousedown
      } = useInput({
        modelValue: inputValue,
        emit,
        eventName: "inputValueChange",
        updateEventName: "update:inputValue",
        eventHandlers
      });
      const mergedFocused = vue.computed(() => {
        var _a2;
        return (_a2 = props.focused) != null ? _a2 : _focused.value;
      });
      const showInput = vue.computed(() => props.enabledInput && _focused.value || !props.modelValue);
      const formatLabel = () => {
        var _a2, _b;
        if (props.modelValue) {
          return (_b = (_a2 = props.formatLabel) == null ? void 0 : _a2.call(props, props.modelValue)) != null ? _b : props.modelValue.label;
        }
        return "";
      };
      const mergedPlaceholder = vue.computed(() => {
        if (props.enabledInput && props.modelValue) {
          return formatLabel();
        }
        return props.placeholder;
      });
      const renderLabel = () => {
        var _a2, _b;
        if (props.modelValue) {
          return (_b = (_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
            data: props.modelValue
          })) != null ? _b : formatLabel();
        }
        return null;
      };
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-size-${mergedSize.value}`, {
        [`${prefixCls}-search`]: props.enabledInput,
        [`${prefixCls}-focus`]: mergedFocused.value,
        [`${prefixCls}-disabled`]: mergedDisabled.value,
        [`${prefixCls}-error`]: mergedError.value
      }]);
      const wrapperAttrs = vue.computed(() => omit(attrs, INPUT_EVENTS));
      const inputAttrs = vue.computed(() => pick(attrs, INPUT_EVENTS));
      const render = () => vue.createVNode("span", vue.mergeProps(wrapperAttrs.value, {
        "class": cls.value,
        "title": formatLabel(),
        "onMousedown": handleMousedown
      }), [slots.prefix && vue.createVNode("span", {
        "class": `${prefixCls}-prefix`
      }, [slots.prefix()]), vue.createVNode("input", vue.mergeProps(inputAttrs.value, {
        "ref": inputRef,
        "class": [`${prefixCls}-input`, {
          [`${prefixCls}-input-hidden`]: !showInput.value
        }],
        "value": computedInputValue.value,
        "readonly": !props.enabledInput,
        "placeholder": mergedPlaceholder.value,
        "disabled": mergedDisabled.value,
        "onInput": handleInput,
        "onFocus": handleFocus,
        "onBlur": handleBlur,
        "onCompositionstart": handleComposition,
        "onCompositionupdate": handleComposition,
        "onCompositionend": handleComposition
      }), null), vue.createVNode("span", {
        "class": [`${prefixCls}-value`, {
          [`${prefixCls}-value-hidden`]: showInput.value
        }]
      }, [renderLabel()]), slots.suffix && vue.createVNode("span", {
        "class": `${prefixCls}-suffix`
      }, [slots.suffix()])]);
      return {
        inputRef,
        render
      };
    },
    methods: {
      focus() {
        var _a;
        (_a = this.inputRef) == null ? void 0 : _a.focus();
      },
      blur() {
        var _a;
        (_a = this.inputRef) == null ? void 0 : _a.blur();
      }
    },
    render() {
      return this.render();
    }
  });
  const getValueData = (value, fieldNames) => {
    const result = [];
    for (const item of value) {
      if (isObject$1(item)) {
        result.push({
          raw: item,
          value: item[fieldNames.value],
          label: item[fieldNames.label],
          closable: item[fieldNames.closable],
          tagProps: item[fieldNames.tagProps]
        });
      } else if (value || isNumber$1(value)) {
        const raw = {
          value: item,
          label: String(item),
          closable: true
        };
        result.push(__spreadValues({
          raw
        }, raw));
      }
    }
    return result;
  };
  const TAG_COLORS = [
    "red",
    "orangered",
    "orange",
    "gold",
    "lime",
    "green",
    "cyan",
    "blue",
    "arcoblue",
    "purple",
    "pinkpurple",
    "magenta",
    "gray"
  ];
  const _sfc_main$2p = vue.defineComponent({
    name: "Tag",
    components: {
      IconHover,
      IconClose,
      IconLoading
    },
    props: {
      color: {
        type: String
      },
      size: {
        type: String
      },
      bordered: {
        type: Boolean,
        default: false
      },
      visible: {
        type: Boolean,
        default: void 0
      },
      defaultVisible: {
        type: Boolean,
        default: true
      },
      loading: {
        type: Boolean,
        default: false
      },
      closable: {
        type: Boolean,
        default: false
      },
      checkable: {
        type: Boolean,
        default: false
      },
      checked: {
        type: Boolean,
        default: void 0
      },
      defaultChecked: {
        type: Boolean,
        default: true
      }
    },
    emits: {
      "update:visible": (visible) => true,
      "update:checked": (checked) => true,
      "close": (ev) => true,
      "check": (checked, ev) => true
    },
    setup(props, { emit }) {
      const { size } = vue.toRefs(props);
      const prefixCls = getPrefixCls("tag");
      const isBuiltInColor = vue.computed(() => props.color && TAG_COLORS.includes(props.color));
      const isCustomColor = vue.computed(() => props.color && !TAG_COLORS.includes(props.color));
      const _visible = vue.ref(props.defaultVisible);
      const _checked = vue.ref(props.defaultChecked);
      const computedVisible = vue.computed(() => {
        var _a;
        return (_a = props.visible) != null ? _a : _visible.value;
      });
      const computedChecked = vue.computed(() => {
        var _a;
        return props.checkable ? (_a = props.checked) != null ? _a : _checked.value : true;
      });
      const { mergedSize: _mergedSize } = useSize$1(size);
      const mergedSize = vue.computed(() => {
        if (_mergedSize.value === "mini") {
          return "small";
        }
        return _mergedSize.value;
      });
      const handleClose = (ev) => {
        _visible.value = false;
        emit("update:visible", false);
        emit("close", ev);
      };
      const handleClick = (ev) => {
        if (props.checkable) {
          const newChecked = !computedChecked.value;
          _checked.value = newChecked;
          emit("update:checked", newChecked);
          emit("check", newChecked, ev);
        }
      };
      const cls = vue.computed(() => [
        prefixCls,
        `${prefixCls}-size-${mergedSize.value}`,
        {
          [`${prefixCls}-loading`]: props.loading,
          [`${prefixCls}-hide`]: !computedVisible.value,
          [`${prefixCls}-${props.color}`]: isBuiltInColor.value,
          [`${prefixCls}-bordered`]: props.bordered,
          [`${prefixCls}-checkable`]: props.checkable,
          [`${prefixCls}-checked`]: computedChecked.value,
          [`${prefixCls}-custom-color`]: isCustomColor.value
        }
      ]);
      const style = vue.computed(() => {
        if (isCustomColor.value) {
          return {
            backgroundColor: props.color
          };
        }
        return void 0;
      });
      return {
        prefixCls,
        cls,
        style,
        computedVisible,
        computedChecked,
        handleClick,
        handleClose
      };
    }
  });
  function _sfc_render$2o(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_icon_close = vue.resolveComponent("icon-close");
    const _component_icon_hover = vue.resolveComponent("icon-hover");
    const _component_icon_loading = vue.resolveComponent("icon-loading");
    return _ctx.computedVisible ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 0,
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.style),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    }, [
      _ctx.$slots.icon ? (vue.openBlock(), vue.createElementBlock("span", {
        key: 0,
        class: vue.normalizeClass(`${_ctx.prefixCls}-icon`)
      }, [
        vue.renderSlot(_ctx.$slots, "icon")
      ], 2)) : vue.createCommentVNode("v-if", true),
      vue.renderSlot(_ctx.$slots, "default"),
      _ctx.closable ? (vue.openBlock(), vue.createBlock(_component_icon_hover, {
        key: 1,
        role: "button",
        "aria-label": "Close",
        prefix: _ctx.prefixCls,
        class: vue.normalizeClass(`${_ctx.prefixCls}-close-btn`),
        onClick: vue.withModifiers(_ctx.handleClose, ["stop"])
      }, {
        default: vue.withCtx(() => [
          vue.renderSlot(_ctx.$slots, "close-icon", {}, () => [
            vue.createVNode(_component_icon_close)
          ])
        ]),
        _: 3
      }, 8, ["prefix", "class", "onClick"])) : vue.createCommentVNode("v-if", true),
      _ctx.loading ? (vue.openBlock(), vue.createElementBlock("span", {
        key: 2,
        class: vue.normalizeClass(`${_ctx.prefixCls}-loading-icon`)
      }, [
        vue.createVNode(_component_icon_loading)
      ], 2)) : vue.createCommentVNode("v-if", true)
    ], 6)) : vue.createCommentVNode("v-if", true);
  }
  var _Tag = /* @__PURE__ */ _export_sfc(_sfc_main$2p, [["render", _sfc_render$2o]]);
  const Tag = Object.assign(_Tag, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Tag.name, _Tag);
    }
  });
  const DEFAULT_FIELD_NAMES$1 = {
    value: "value",
    label: "label",
    closable: "closable",
    tagProps: "tagProps"
  };
  var _InputTag = vue.defineComponent({
    name: "InputTag",
    inheritAttrs: false,
    props: {
      modelValue: {
        type: Array
      },
      defaultValue: {
        type: Array,
        default: () => []
      },
      inputValue: String,
      defaultInputValue: {
        type: String,
        default: ""
      },
      placeholder: String,
      disabled: {
        type: Boolean,
        default: false
      },
      error: {
        type: Boolean,
        default: false
      },
      readonly: {
        type: Boolean,
        default: false
      },
      allowClear: {
        type: Boolean,
        default: false
      },
      size: {
        type: String
      },
      maxTagCount: {
        type: Number,
        default: 0
      },
      retainInputValue: {
        type: [Boolean, Object],
        default: false
      },
      formatTag: {
        type: Function
      },
      uniqueValue: {
        type: Boolean,
        default: false
      },
      fieldNames: {
        type: Object
      },
      baseCls: String,
      focused: Boolean,
      disabledInput: Boolean,
      uninjectFormItemContext: Boolean
    },
    emits: {
      "update:modelValue": (value) => true,
      "update:inputValue": (inputValue) => true,
      "change": (value, ev) => true,
      "inputValueChange": (inputValue, ev) => true,
      "pressEnter": (inputValue, ev) => true,
      "remove": (removed, ev) => true,
      "clear": (ev) => true,
      "focus": (ev) => true,
      "blur": (ev) => true
    },
    setup(props, {
      emit,
      slots,
      attrs
    }) {
      const {
        size,
        disabled,
        error,
        uninjectFormItemContext,
        modelValue
      } = vue.toRefs(props);
      const prefixCls = props.baseCls || getPrefixCls("input-tag");
      const inputRef = vue.ref();
      const mirrorRef = vue.ref();
      const {
        mergedSize: _mergedSize,
        mergedDisabled,
        mergedError,
        feedback,
        eventHandlers
      } = useFormItem({
        size,
        disabled,
        error,
        uninject: uninjectFormItemContext == null ? void 0 : uninjectFormItemContext.value
      });
      const {
        mergedSize
      } = useSize$1(_mergedSize);
      const mergedFieldNames = vue.computed(() => __spreadValues(__spreadValues({}, DEFAULT_FIELD_NAMES$1), props.fieldNames));
      const _focused = vue.ref(false);
      const _value = vue.ref(props.defaultValue);
      const _inputValue = vue.ref(props.defaultInputValue);
      const isComposition = vue.ref(false);
      const compositionValue = vue.ref("");
      const retainInputValue = vue.computed(() => {
        if (isObject$1(props.retainInputValue)) {
          return __spreadValues({
            create: false,
            blur: false
          }, props.retainInputValue);
        }
        return {
          create: props.retainInputValue,
          blur: props.retainInputValue
        };
      });
      const inputStyle = vue.reactive({
        width: "12px"
      });
      const mergedFocused = vue.computed(() => props.focused || _focused.value);
      const updateInputValue = (value, ev) => {
        _inputValue.value = value;
        emit("update:inputValue", value);
        emit("inputValueChange", value, ev);
      };
      const handleComposition = (ev) => {
        var _a;
        const {
          value
        } = ev.target;
        if (ev.type === "compositionend") {
          isComposition.value = false;
          compositionValue.value = "";
          updateInputValue(value, ev);
          vue.nextTick(() => {
            if (inputRef.value && computedInputValue.value !== inputRef.value.value) {
              inputRef.value.value = computedInputValue.value;
            }
          });
        } else {
          isComposition.value = true;
          compositionValue.value = computedInputValue.value + ((_a = ev.data) != null ? _a : "");
        }
      };
      const computedValue = vue.computed(() => {
        var _a;
        return (_a = props.modelValue) != null ? _a : _value.value;
      });
      const computedInputValue = vue.computed(() => {
        var _a;
        return (_a = props.inputValue) != null ? _a : _inputValue.value;
      });
      vue.watch(modelValue, (value) => {
        if (isUndefined(value) || isNull(value)) {
          _value.value = [];
        }
      });
      const handleMousedown = (e2) => {
        if (inputRef.value && e2.target !== inputRef.value) {
          e2.preventDefault();
          inputRef.value.focus();
        }
      };
      const handleInput = (ev) => {
        const {
          value
        } = ev.target;
        if (!isComposition.value) {
          updateInputValue(value, ev);
          vue.nextTick(() => {
            if (inputRef.value && computedInputValue.value !== inputRef.value.value) {
              inputRef.value.value = computedInputValue.value;
            }
          });
        }
      };
      const valueData = vue.computed(() => getValueData(computedValue.value, mergedFieldNames.value));
      const tags = vue.computed(() => {
        if (props.maxTagCount > 0) {
          const invisibleTags = valueData.value.length - props.maxTagCount;
          if (invisibleTags > 0) {
            const result = valueData.value.slice(0, props.maxTagCount);
            const raw = {
              value: "__arco__more",
              label: `+${invisibleTags}...`,
              closable: false
            };
            result.push(__spreadValues({
              raw
            }, raw));
            return result;
          }
        }
        return valueData.value;
      });
      const updateValue = (value, ev) => {
        var _a, _b;
        _value.value = value;
        emit("update:modelValue", value);
        emit("change", value, ev);
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a, ev);
      };
      const handleRemove = (value, index2, e2) => {
        var _a;
        const newValue = (_a = computedValue.value) == null ? void 0 : _a.filter((_, i) => i !== index2);
        updateValue(newValue, e2);
        emit("remove", value, e2);
      };
      const handleClear = (e2) => {
        const newValue = [];
        updateValue(newValue, e2);
        emit("clear", e2);
      };
      const showClearBtn = vue.computed(() => !mergedDisabled.value && !props.readonly && props.allowClear && Boolean(computedValue.value.length));
      const handlePressEnter = (e2) => {
        var _a;
        if (computedInputValue.value) {
          e2.preventDefault();
          if (props.uniqueValue && ((_a = computedValue.value) == null ? void 0 : _a.includes(computedInputValue.value))) {
            emit("pressEnter", computedInputValue.value, e2);
            return;
          }
          const newValue = computedValue.value.concat(computedInputValue.value);
          updateValue(newValue, e2);
          emit("pressEnter", computedInputValue.value, e2);
          if (!retainInputValue.value.create) {
            updateInputValue("", e2);
          }
        }
      };
      const handleFocus = (ev) => {
        var _a, _b;
        _focused.value = true;
        emit("focus", ev);
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onFocus) == null ? void 0 : _b.call(_a, ev);
      };
      const handleBlur = (ev) => {
        var _a, _b;
        _focused.value = false;
        if (!retainInputValue.value.blur && computedInputValue.value) {
          updateInputValue("", ev);
        }
        emit("blur", ev);
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onBlur) == null ? void 0 : _b.call(_a, ev);
      };
      const getLastClosableIndex = () => {
        for (let i = valueData.value.length - 1; i >= 0; i--) {
          if (valueData.value[i].closable) {
            return i;
          }
        }
        return -1;
      };
      const handleKeyDown = (e2) => {
        const keyCode = e2.key || e2.code;
        if (!isComposition.value && computedInputValue.value && keyCode === Enter.key) {
          handlePressEnter(e2);
        }
        if (!isComposition.value && tags.value.length > 0 && !computedInputValue.value && keyCode === Backspace.key) {
          const lastIndex = getLastClosableIndex();
          if (lastIndex >= 0) {
            handleRemove(valueData.value[lastIndex].value, lastIndex, e2);
          }
        }
      };
      const setInputWidth = (width) => {
        if (width > 12) {
          inputStyle.width = `${width}px`;
        } else {
          inputStyle.width = "12px";
        }
      };
      vue.onMounted(() => {
        if (mirrorRef.value) {
          setInputWidth(mirrorRef.value.offsetWidth);
        }
      });
      const handleResize = () => {
        if (mirrorRef.value) {
          setInputWidth(mirrorRef.value.offsetWidth);
        }
      };
      vue.watch(computedInputValue, (value) => {
        if (inputRef.value && !isComposition.value && value !== inputRef.value.value) {
          inputRef.value.value = value;
        }
      });
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-size-${mergedSize.value}`, {
        [`${prefixCls}-disabled`]: mergedDisabled.value,
        [`${prefixCls}-disabled-input`]: props.disabledInput,
        [`${prefixCls}-error`]: mergedError.value,
        [`${prefixCls}-focus`]: mergedFocused.value,
        [`${prefixCls}-readonly`]: props.readonly,
        [`${prefixCls}-has-tag`]: tags.value.length > 0,
        [`${prefixCls}-has-prefix`]: Boolean(slots.prefix),
        [`${prefixCls}-has-suffix`]: Boolean(slots.suffix) || showClearBtn.value || feedback.value,
        [`${prefixCls}-has-placeholder`]: !computedValue.value.length
      }]);
      const wrapperAttrs = vue.computed(() => omit(attrs, INPUT_EVENTS));
      const inputAttrs = vue.computed(() => pick(attrs, INPUT_EVENTS));
      const render = () => {
        var _a;
        return vue.createVNode("span", vue.mergeProps({
          "class": cls.value,
          "onMousedown": handleMousedown
        }, wrapperAttrs.value), [vue.createVNode(ResizeObserver$1, {
          "onResize": handleResize
        }, {
          default: () => [vue.createVNode("span", {
            "ref": mirrorRef,
            "class": `${prefixCls}-mirror`
          }, [tags.value.length > 0 ? compositionValue.value || computedInputValue.value : compositionValue.value || computedInputValue.value || props.placeholder])]
        }), slots.prefix && vue.createVNode("span", {
          "class": `${prefixCls}-prefix`
        }, [slots.prefix()]), vue.createVNode(vue.TransitionGroup, {
          "tag": "span",
          "name": "input-tag-zoom",
          "class": `${prefixCls}-inner`
        }, {
          default: () => [tags.value.map((item, index2) => vue.createVNode(Tag, vue.mergeProps({
            "key": `tag-${item.value}`,
            "class": `${prefixCls}-tag`,
            "closable": !mergedDisabled.value && !props.readonly && item.closable,
            "visible": true
          }, item.tagProps, {
            "onClose": (ev) => handleRemove(item.value, index2, ev)
          }), {
            default: () => {
              var _a2, _b, _c, _d;
              return [(_d = (_c = (_a2 = slots.tag) == null ? void 0 : _a2.call(slots, {
                data: item.raw
              })) != null ? _c : (_b = props.formatTag) == null ? void 0 : _b.call(props, item.raw)) != null ? _d : item.label];
            }
          })), vue.createVNode("input", vue.mergeProps(inputAttrs.value, {
            "ref": inputRef,
            "key": "input-tag-input",
            "class": `${prefixCls}-input`,
            "style": inputStyle,
            "placeholder": tags.value.length === 0 ? props.placeholder : void 0,
            "disabled": mergedDisabled.value,
            "readonly": props.readonly || props.disabledInput,
            "onInput": handleInput,
            "onKeydown": handleKeyDown,
            "onFocus": handleFocus,
            "onBlur": handleBlur,
            "onCompositionstart": handleComposition,
            "onCompositionupdate": handleComposition,
            "onCompositionend": handleComposition
          }), null)]
        }), showClearBtn.value && vue.createVNode(IconHover, {
          "class": `${prefixCls}-clear-btn`,
          "onClick": handleClear,
          "onMousedown": (e2) => e2.stopPropagation()
        }, {
          default: () => [vue.createVNode(IconClose, null, null)]
        }), (slots.suffix || Boolean(feedback.value)) && vue.createVNode("span", {
          "class": `${prefixCls}-suffix`
        }, [(_a = slots.suffix) == null ? void 0 : _a.call(slots), Boolean(feedback.value) && vue.createVNode(FeedbackIcon, {
          "type": feedback.value
        }, null)])]);
      };
      return {
        inputRef,
        render
      };
    },
    methods: {
      focus() {
        var _a;
        (_a = this.inputRef) == null ? void 0 : _a.focus();
      },
      blur() {
        var _a;
        (_a = this.inputRef) == null ? void 0 : _a.blur();
      }
    },
    render() {
      return this.render();
    }
  });
  const InputTag = Object.assign(_InputTag, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _InputTag.name, _InputTag);
    }
  });
  var SelectView = vue.defineComponent({
    name: "SelectView",
    props: {
      modelValue: {
        type: Array,
        required: true
      },
      inputValue: String,
      placeholder: String,
      disabled: {
        type: Boolean,
        default: false
      },
      error: {
        type: Boolean,
        default: false
      },
      loading: {
        type: Boolean,
        default: false
      },
      opened: {
        type: Boolean,
        default: false
      },
      size: {
        type: String
      },
      bordered: {
        type: Boolean,
        default: true
      },
      multiple: {
        type: Boolean,
        default: false
      },
      allowClear: {
        type: Boolean,
        default: false
      },
      allowCreate: {
        type: Boolean,
        default: false
      },
      allowSearch: {
        type: Boolean,
        default: (props) => isArray$1(props.modelValue)
      },
      maxTagCount: {
        type: Number,
        default: 0
      },
      retainInputValue: {
        type: Boolean,
        default: false
      }
    },
    emits: ["remove", "clear", "focus", "blur"],
    setup(props, {
      emit,
      slots
    }) {
      const {
        size,
        disabled,
        error
      } = vue.toRefs(props);
      const prefixCls = getPrefixCls("select-view");
      const {
        feedback,
        eventHandlers,
        mergedDisabled,
        mergedSize: _mergedSize,
        mergedError
      } = useFormItem({
        size,
        disabled,
        error
      });
      const {
        mergedSize
      } = useSize$1(_mergedSize);
      const {
        opened
      } = vue.toRefs(props);
      const componentRef = vue.ref();
      const inputRef = vue.computed(() => {
        var _a;
        return (_a = componentRef.value) == null ? void 0 : _a.inputRef;
      });
      const isEmptyValue2 = vue.computed(() => props.modelValue.length === 0);
      const enabledInput = vue.computed(() => props.allowSearch || props.allowCreate);
      const showClearBtn = vue.computed(() => props.allowClear && !props.disabled && !isEmptyValue2.value);
      const handleFocus = (ev) => {
        var _a, _b;
        emit("focus", ev);
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onFocus) == null ? void 0 : _b.call(_a, ev);
      };
      const handleBlur = (ev) => {
        var _a, _b;
        emit("blur", ev);
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onBlur) == null ? void 0 : _b.call(_a, ev);
      };
      const handleRemove = (tag) => {
        emit("remove", tag);
      };
      const handleClear = (ev) => {
        emit("clear", ev);
      };
      const renderIcon = () => {
        var _a, _b, _c, _d;
        if (props.loading) {
          return (_b = (_a = slots["loading-icon"]) == null ? void 0 : _a.call(slots)) != null ? _b : vue.createVNode(IconLoading, null, null);
        }
        if (props.allowSearch && props.opened) {
          return (_d = (_c = slots["search-icon"]) == null ? void 0 : _c.call(slots)) != null ? _d : vue.createVNode(IconSearch, null, null);
        }
        if (slots["arrow-icon"]) {
          return slots["arrow-icon"]();
        }
        return vue.createVNode(IconDown, {
          "class": `${prefixCls}-arrow-icon`
        }, null);
      };
      const renderSuffix = () => vue.createVNode(vue.Fragment, null, [showClearBtn.value && vue.createVNode(IconHover, {
        "class": `${prefixCls}-clear-btn`,
        "onClick": handleClear,
        "onMousedown": (ev) => ev.stopPropagation()
      }, {
        default: () => [vue.createVNode(IconClose, null, null)]
      }), vue.createVNode("span", {
        "class": `${prefixCls}-icon`
      }, [renderIcon()]), Boolean(feedback.value) && vue.createVNode(FeedbackIcon, {
        "type": feedback.value
      }, null)]);
      vue.watch(opened, (opened2) => {
        if (!opened2 && inputRef.value && inputRef.value.isSameNode(document.activeElement)) {
          inputRef.value.blur();
        }
      });
      const cls = vue.computed(() => [`${prefixCls}-${props.multiple ? "multiple" : "single"}`, {
        [`${prefixCls}-opened`]: props.opened,
        [`${prefixCls}-borderless`]: !props.bordered
      }]);
      const render = () => {
        if (props.multiple) {
          return vue.createVNode(InputTag, {
            "ref": componentRef,
            "baseCls": prefixCls,
            "class": cls.value,
            "modelValue": props.modelValue,
            "inputValue": props.inputValue,
            "focused": props.opened,
            "placeholder": props.placeholder,
            "disabled": mergedDisabled.value,
            "size": mergedSize.value,
            "error": mergedError.value,
            "maxTagCount": props.maxTagCount,
            "disabledInput": !props.allowSearch && !props.allowCreate,
            "retainInputValue": true,
            "uninjectFormItemContext": true,
            "onRemove": handleRemove,
            "onFocus": handleFocus,
            "onBlur": handleBlur
          }, {
            prefix: slots.prefix,
            suffix: renderSuffix,
            tag: slots.label
          });
        }
        return vue.createVNode(InputLabel, {
          "ref": componentRef,
          "baseCls": prefixCls,
          "class": cls.value,
          "modelValue": props.modelValue[0],
          "inputValue": props.inputValue,
          "focused": props.opened,
          "placeholder": props.placeholder,
          "disabled": mergedDisabled.value,
          "size": mergedSize.value,
          "error": mergedError.value,
          "enabledInput": enabledInput.value,
          "uninjectFormItemContext": true,
          "onFocus": handleFocus,
          "onBlur": handleBlur
        }, {
          default: slots.label,
          prefix: slots.prefix,
          suffix: renderSuffix
        });
      };
      return {
        inputRef,
        handleFocus,
        handleBlur,
        render
      };
    },
    methods: {
      focus() {
        if (this.inputRef) {
          this.inputRef.focus();
        }
      },
      blur() {
        if (this.inputRef) {
          this.inputRef.blur();
        }
      }
    },
    render() {
      return this.render();
    }
  });
  const _sfc_main$2o = vue.defineComponent({
    name: "Optgroup",
    props: {
      label: {
        type: String
      }
    },
    setup() {
      const prefixCls = getPrefixCls("select-group");
      return {
        prefixCls
      };
    }
  });
  function _sfc_render$2n(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock(vue.Fragment, null, [
      vue.createElementVNode("li", {
        class: vue.normalizeClass(`${_ctx.prefixCls}-title`)
      }, [
        vue.renderSlot(_ctx.$slots, "label", {}, () => [
          vue.createTextVNode(vue.toDisplayString(_ctx.label), 1)
        ])
      ], 2),
      vue.renderSlot(_ctx.$slots, "default")
    ], 64);
  }
  var Optgroup = /* @__PURE__ */ _export_sfc(_sfc_main$2o, [["render", _sfc_render$2n]]);
  const useSize = ({
    dataKeys,
    contentRef,
    fixedSize,
    estimatedSize,
    buffer
  }) => {
    const firstRangeAverageSize = vue.ref(0);
    const sizeMap = new Map();
    const total = vue.computed(() => dataKeys.value.length);
    const start = vue.ref(0);
    const end = vue.computed(() => {
      const _end = start.value + buffer.value * 3;
      if (_end > total.value)
        return total.value;
      return _end;
    });
    const maxStart = vue.computed(() => {
      const max = total.value - buffer.value * 3;
      if (max < 0)
        return 0;
      return max;
    });
    const setStart = (index2) => {
      if (index2 < 0) {
        start.value = 0;
      } else if (index2 > maxStart.value) {
        start.value = maxStart.value;
      } else {
        start.value = index2;
      }
    };
    const isFixed = vue.ref(fixedSize.value);
    const _estimatedSize = vue.computed(() => {
      if (estimatedSize.value !== 30) {
        return estimatedSize.value;
      }
      return firstRangeAverageSize.value || estimatedSize.value;
    });
    const setItemSize = (key, size) => {
      sizeMap.set(key, size);
    };
    const getItemSize = (index2) => {
      var _a;
      if (isFixed.value) {
        return _estimatedSize.value;
      }
      const _key = dataKeys.value[index2];
      return (_a = sizeMap.get(_key)) != null ? _a : _estimatedSize.value;
    };
    const hasItemSize = (key) => {
      return sizeMap.has(key);
    };
    vue.onMounted(() => {
      const firstRangeTotalSize = Array.from(sizeMap.values()).reduce((pre, value) => pre + value, 0);
      if (firstRangeTotalSize > 0) {
        firstRangeAverageSize.value = firstRangeTotalSize / sizeMap.size;
      }
    });
    const getScrollOffset = (index2) => {
      if (isFixed.value) {
        return _estimatedSize.value * index2;
      }
      return getOffset(0, index2);
    };
    const getOffset = (start2, end2) => {
      let offset = 0;
      for (let i = start2; i < end2; i++) {
        offset += getItemSize(i);
      }
      return offset;
    };
    const frontPadding = vue.computed(() => {
      if (isFixed.value) {
        return _estimatedSize.value * start.value;
      }
      return getOffset(0, start.value);
    });
    const getOffsetIndex = (scrollOffset) => {
      const isForward = scrollOffset >= frontPadding.value;
      let offset = Math.abs(scrollOffset - frontPadding.value);
      const _start = isForward ? start.value : start.value - 1;
      let offsetIndex = 0;
      while (offset > 0) {
        offset -= getItemSize(_start + offsetIndex);
        isForward ? offsetIndex++ : offsetIndex--;
      }
      return offsetIndex;
    };
    const getStartByScroll = (scrollOffset) => {
      const offsetIndex = getOffsetIndex(scrollOffset);
      const _start = start.value + offsetIndex - buffer.value;
      if (_start < 0)
        return 0;
      if (_start > maxStart.value)
        return maxStart.value;
      return _start;
    };
    const behindPadding = vue.computed(() => {
      if (isFixed.value) {
        return _estimatedSize.value * (total.value - end.value);
      }
      return getOffset(end.value, total.value);
    });
    return {
      frontPadding,
      behindPadding,
      start,
      end,
      getStartByScroll,
      setItemSize,
      hasItemSize,
      setStart,
      getScrollOffset
    };
  };
  var VirtualListItem = vue.defineComponent({
    name: "VirtualListItem",
    props: {
      hasItemSize: {
        type: Function,
        required: true
      },
      setItemSize: {
        type: Function,
        required: true
      }
    },
    setup(props, {
      slots
    }) {
      var _a;
      const key = (_a = vue.getCurrentInstance()) == null ? void 0 : _a.vnode.key;
      const itemRef = vue.ref();
      const setItemSize = () => {
        var _a2, _b, _c, _d;
        const ele = (_b = (_a2 = itemRef.value) == null ? void 0 : _a2.$el) != null ? _b : itemRef.value;
        const height = (_d = (_c = ele == null ? void 0 : ele.getBoundingClientRect) == null ? void 0 : _c.call(ele).height) != null ? _d : ele == null ? void 0 : ele.offsetHeight;
        if (height) {
          props.setItemSize(key, height);
        }
      };
      vue.onMounted(() => setItemSize());
      vue.onBeforeUnmount(() => setItemSize());
      return () => {
        var _a2;
        const child = getFirstComponent((_a2 = slots.default) == null ? void 0 : _a2.call(slots));
        if (child) {
          return vue.cloneVNode(child, {
            ref: itemRef
          }, true);
        }
        return null;
      };
    }
  });
  const _sfc_main$2n = vue.defineComponent({
    name: "VirtualList",
    components: { VirtualListItem },
    props: {
      height: {
        type: [Number, String],
        default: 200
      },
      data: {
        type: Array,
        default: () => []
      },
      threshold: {
        type: Number,
        default: 0
      },
      itemKey: {
        type: String,
        default: "key"
      },
      fixedSize: {
        type: Boolean,
        default: false
      },
      estimatedSize: {
        type: Number,
        default: 30
      },
      buffer: {
        type: Number,
        default: 10
      },
      component: {
        type: [String, Object],
        default: "div"
      },
      listAttrs: {
        type: Object
      },
      contentAttrs: {
        type: Object
      },
      paddingPosition: {
        type: String,
        default: "content"
      }
    },
    emits: {
      scroll: (ev) => true,
      reachBottom: (ev) => true
    },
    setup(props, { emit }) {
      const { data, itemKey, fixedSize, estimatedSize, buffer, height } = vue.toRefs(props);
      const prefixCls = getPrefixCls("virtual-list");
      const mergedComponent = vue.computed(() => {
        if (isObject$1(props.component)) {
          return __spreadValues({
            container: "div",
            list: "div",
            content: "div"
          }, props.component);
        }
        return {
          container: props.component,
          list: "div",
          content: "div"
        };
      });
      const containerRef = vue.ref();
      const contentRef = vue.ref();
      const style = vue.computed(() => {
        return {
          height: isNumber$1(height.value) ? `${height.value}px` : height.value,
          overflow: "auto"
        };
      });
      const dataKeys = vue.computed(() => data.value.map((item, index2) => {
        var _a;
        return (_a = item[itemKey.value]) != null ? _a : index2;
      }));
      const {
        frontPadding,
        behindPadding,
        start,
        end,
        getStartByScroll,
        setItemSize,
        hasItemSize,
        setStart,
        getScrollOffset
      } = useSize({
        dataKeys,
        contentRef,
        fixedSize,
        estimatedSize,
        buffer
      });
      const shouldScroll = vue.ref(true);
      const scrollData = vue.reactive({
        scrollTop: 0,
        scrollHeight: 0
      });
      vue.watch(dataKeys, () => {
        shouldScroll.value = false;
      });
      const currentList = vue.computed(() => {
        if (props.threshold && data.value.length <= props.threshold) {
          return data.value;
        }
        return data.value.slice(start.value, end.value);
      });
      const onScroll = (ev) => {
        const { scrollTop, scrollHeight, offsetHeight } = ev.target;
        if (shouldScroll.value) {
          scrollData.scrollTop = scrollTop;
          scrollData.scrollHeight = scrollHeight;
          const _start = getStartByScroll(scrollTop);
          if (_start !== start.value) {
            setStart(_start);
          }
          emit("scroll", ev);
          const bottom = Math.floor(scrollHeight - (scrollTop + offsetHeight));
          if (bottom <= 0) {
            emit("reachBottom", ev);
          }
        } else {
          if (scrollHeight !== scrollData.scrollHeight) {
            shouldScroll.value = true;
            setTimeout(() => {
              scrollTo2(scrollData.scrollTop);
            }, 10);
          }
          scrollTo2(scrollData.scrollTop);
        }
      };
      const scrollTo2 = (options) => {
        var _a, _b;
        if (containerRef.value) {
          if (isNumber$1(options)) {
            containerRef.value.scrollTop = options;
          } else {
            const _index = (_b = options.index) != null ? _b : dataKeys.value.indexOf((_a = options.key) != null ? _a : "");
            setStart(_index - buffer.value);
            containerRef.value.scrollTop = getScrollOffset(_index);
            vue.nextTick(() => {
              if (containerRef.value) {
                const _scrollTop = getScrollOffset(_index);
                if (_scrollTop !== containerRef.value.scrollTop) {
                  containerRef.value.scrollTop = _scrollTop;
                }
              }
            });
          }
        }
      };
      return {
        prefixCls,
        containerRef,
        contentRef,
        frontPadding,
        currentList,
        behindPadding,
        onScroll,
        setItemSize,
        hasItemSize,
        start,
        scrollTo: scrollTo2,
        style,
        mergedComponent
      };
    }
  });
  function _sfc_render$2m(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_VirtualListItem = vue.resolveComponent("VirtualListItem");
    return vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.mergedComponent.container), {
      ref: "containerRef",
      class: vue.normalizeClass(_ctx.prefixCls),
      style: vue.normalizeStyle(_ctx.style),
      onScroll: _ctx.onScroll
    }, {
      default: vue.withCtx(() => [
        (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.mergedComponent.list), vue.mergeProps(_ctx.listAttrs, {
          style: _ctx.paddingPosition === "list" ? {
            paddingTop: `${_ctx.frontPadding}px`,
            paddingBottom: `${_ctx.behindPadding}px`
          } : {}
        }), {
          default: vue.withCtx(() => [
            (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.mergedComponent.content), vue.mergeProps({ ref: "contentRef" }, _ctx.contentAttrs, {
              style: _ctx.paddingPosition === "content" ? {
                paddingTop: `${_ctx.frontPadding}px`,
                paddingBottom: `${_ctx.behindPadding}px`
              } : {}
            }), {
              default: vue.withCtx(() => [
                (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.currentList, (item, index2) => {
                  var _a;
                  return vue.openBlock(), vue.createBlock(_component_VirtualListItem, {
                    key: (_a = item[_ctx.itemKey]) != null ? _a : _ctx.start + index2,
                    "has-item-size": _ctx.hasItemSize,
                    "set-item-size": _ctx.setItemSize
                  }, {
                    default: vue.withCtx(() => [
                      vue.renderSlot(_ctx.$slots, "item", {
                        item,
                        index: _ctx.start + index2
                      })
                    ]),
                    _: 2
                  }, 1032, ["has-item-size", "set-item-size"]);
                }), 128))
              ]),
              _: 3
            }, 16, ["style"]))
          ]),
          _: 3
        }, 16, ["style"]))
      ]),
      _: 3
    }, 8, ["class", "style", "onScroll"]);
  }
  var VirtualList = /* @__PURE__ */ _export_sfc(_sfc_main$2n, [["render", _sfc_render$2m]]);
  const target = typeof window === "undefined" ? global : window;
  function debounce(callback, delay) {
    let timer = 0;
    return (...args) => {
      if (timer) {
        target.clearTimeout(timer);
      }
      timer = target.setTimeout(() => {
        timer = 0;
        callback(...args);
      }, delay);
    };
  }
  function _isSlot$g(s) {
    return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !vue.isVNode(s);
  }
  const DEFAULT_FIELD_NAMES = {
    value: "value",
    label: "label",
    disabled: "disabled",
    tagProps: "tagProps",
    render: "render"
  };
  var _Select = vue.defineComponent({
    name: "Select",
    components: {
      Trigger,
      SelectView
    },
    inheritAttrs: false,
    props: {
      multiple: {
        type: Boolean,
        default: false
      },
      modelValue: {
        type: [String, Number, Object, Array]
      },
      defaultValue: {
        type: [String, Number, Object, Array],
        default: (props) => isUndefined(props.multiple) ? "" : []
      },
      inputValue: {
        type: String
      },
      defaultInputValue: {
        type: String,
        default: ""
      },
      size: {
        type: String
      },
      placeholder: String,
      loading: {
        type: Boolean,
        default: false
      },
      disabled: {
        type: Boolean,
        default: false
      },
      error: {
        type: Boolean,
        default: false
      },
      allowClear: {
        type: Boolean,
        default: false
      },
      allowSearch: {
        type: [Boolean, Object],
        default: (props) => Boolean(props.multiple)
      },
      allowCreate: {
        type: Boolean,
        default: false
      },
      maxTagCount: {
        type: Number,
        default: 0
      },
      popupContainer: {
        type: [String, Object]
      },
      bordered: {
        type: Boolean,
        default: true
      },
      defaultActiveFirstOption: {
        type: Boolean,
        default: true
      },
      popupVisible: {
        type: Boolean,
        default: void 0
      },
      defaultPopupVisible: {
        type: Boolean,
        default: false
      },
      unmountOnClose: {
        type: Boolean,
        default: false
      },
      filterOption: {
        type: [Boolean, Function],
        default: true
      },
      options: {
        type: Array,
        default: () => []
      },
      virtualListProps: {
        type: Object
      },
      triggerProps: {
        type: Object
      },
      formatLabel: {
        type: Function
      },
      fallbackOption: {
        type: [Boolean, Function],
        default: true
      },
      showExtraOptions: {
        type: Boolean,
        default: true
      },
      valueKey: {
        type: String,
        default: "value"
      },
      searchDelay: {
        type: Number,
        default: 500
      },
      limit: {
        type: Number,
        default: 0
      },
      fieldNames: {
        type: Object
      },
      scrollbar: {
        type: [Boolean, Object],
        default: true
      },
      showHeaderOnEmpty: {
        type: Boolean,
        default: false
      },
      showFooterOnEmpty: {
        type: Boolean,
        default: false
      }
    },
    emits: {
      "update:modelValue": (value) => true,
      "update:inputValue": (inputValue) => true,
      "update:popupVisible": (visible) => true,
      "change": (value) => true,
      "inputValueChange": (inputValue) => true,
      "popupVisibleChange": (visible) => true,
      "clear": (ev) => true,
      "remove": (removed) => true,
      "search": (inputValue) => true,
      "dropdownScroll": (ev) => true,
      "dropdownReachBottom": (ev) => true,
      "exceedLimit": (value, ev) => true
    },
    setup(props, {
      slots,
      emit,
      attrs
    }) {
      const {
        size,
        disabled,
        error,
        options,
        filterOption,
        valueKey,
        multiple,
        popupVisible,
        showExtraOptions,
        modelValue,
        fieldNames,
        loading,
        defaultActiveFirstOption
      } = vue.toRefs(props);
      const prefixCls = getPrefixCls("select");
      const {
        mergedSize,
        mergedDisabled,
        mergedError,
        eventHandlers
      } = useFormItem({
        size,
        disabled,
        error
      });
      const component = vue.computed(() => props.virtualListProps ? "div" : "li");
      const retainInputValue = vue.computed(() => isObject$1(props.allowSearch) && Boolean(props.allowSearch.retainInputValue));
      vue.computed(() => {
        if (isFunction$1(props.formatLabel)) {
          return (data) => {
            const optionInfo = optionInfoMap.get(data.value);
            return props.formatLabel(optionInfo);
          };
        }
        return void 0;
      });
      const dropdownRef = vue.ref();
      const optionRefs = vue.ref({});
      const virtualListRef = vue.ref();
      const {
        computedPopupVisible,
        handlePopupVisibleChange
      } = useTrigger({
        popupVisible,
        emit
      });
      const _value = vue.ref(props.defaultValue);
      const computedValueObjects = vue.computed(() => {
        var _a;
        const mergedValue = (_a = props.modelValue) != null ? _a : _value.value;
        const valueArray = isArray$1(mergedValue) ? mergedValue : mergedValue || isNumber$1(mergedValue) || isString$1(mergedValue) ? [mergedValue] : [];
        return valueArray.map((value) => ({
          value,
          key: getKeyFromValue(value, props.valueKey)
        }));
      });
      vue.watch(modelValue, (value) => {
        if (isUndefined(value) || isNull(value)) {
          _value.value = multiple.value ? [] : value;
        }
      });
      const computedValueKeys = vue.computed(() => computedValueObjects.value.map((obj) => obj.key));
      const mergedFieldNames = vue.computed(() => __spreadValues(__spreadValues({}, DEFAULT_FIELD_NAMES), fieldNames == null ? void 0 : fieldNames.value));
      const _selectedOption = vue.ref();
      const getRawOptionFromValueKeys = (valueKeys) => {
        const optionMap = {};
        valueKeys.forEach((key) => {
          optionMap[key] = optionInfoMap.get(key);
        });
        return optionMap;
      };
      const updateSelectedOption = (valueKeys) => {
        _selectedOption.value = getRawOptionFromValueKeys(valueKeys);
      };
      const getFallBackOption = (value) => {
        if (isFunction$1(props.fallbackOption)) {
          return props.fallbackOption(value);
        }
        return {
          [mergedFieldNames.value.value]: value,
          [mergedFieldNames.value.label]: String(isObject$1(value) ? value[valueKey == null ? void 0 : valueKey.value] : value)
        };
      };
      const getExtraValueData = () => {
        const valueArray = [];
        const keyArray = [];
        if (props.allowCreate || props.fallbackOption) {
          for (const item of computedValueObjects.value) {
            if (!keyArray.includes(item.key) && item.value !== "") {
              const optionInfo = optionInfoMap.get(item.key);
              if (!optionInfo || optionInfo.origin === "extraOptions") {
                valueArray.push(item);
                keyArray.push(item.key);
              }
            }
          }
        }
        if (props.allowCreate && computedInputValue.value) {
          const key = getKeyFromValue(computedInputValue.value);
          if (!keyArray.includes(key)) {
            const optionInfo = optionInfoMap.get(key);
            if (!optionInfo || optionInfo.origin === "extraOptions") {
              valueArray.push({
                value: computedInputValue.value,
                key
              });
            }
          }
        }
        return valueArray;
      };
      const extraValueObjects = vue.ref([]);
      const extraOptions = vue.computed(() => extraValueObjects.value.map((obj) => {
        var _a;
        let optionInfo = getFallBackOption(obj.value);
        const extraOptionRawInfo = (_a = _selectedOption.value) == null ? void 0 : _a[obj.key];
        if (!isUndefined(extraOptionRawInfo) && !isEmptyObject$1(extraOptionRawInfo)) {
          optionInfo = __spreadValues(__spreadValues({}, optionInfo), extraOptionRawInfo);
        }
        return optionInfo;
      }));
      vue.nextTick(() => {
        vue.watchEffect(() => {
          var _a;
          const valueData = getExtraValueData();
          if (valueData.length !== extraValueObjects.value.length) {
            extraValueObjects.value = valueData;
          } else if (valueData.length > 0) {
            for (let i = 0; i < valueData.length; i++) {
              if (valueData[i].key !== ((_a = extraValueObjects.value[i]) == null ? void 0 : _a.key)) {
                extraValueObjects.value = valueData;
                break;
              }
            }
          }
        });
      });
      const _inputValue = vue.ref("");
      const computedInputValue = vue.computed(() => {
        var _a;
        return (_a = props.inputValue) != null ? _a : _inputValue.value;
      });
      vue.watch(computedPopupVisible, (visible) => {
        if (!visible && !retainInputValue.value && computedInputValue.value) {
          updateInputValue("");
        }
      });
      const getValueFromValueKeys = (valueKeys) => {
        var _a, _b;
        if (!props.multiple) {
          return (_b = (_a = optionInfoMap.get(valueKeys[0])) == null ? void 0 : _a.value) != null ? _b : hasEmptyStringKey(optionInfoMap) ? void 0 : "";
        }
        return valueKeys.map((key) => {
          var _a2, _b2;
          return (_b2 = (_a2 = optionInfoMap.get(key)) == null ? void 0 : _a2.value) != null ? _b2 : "";
        });
      };
      const updateValue = (valueKeys) => {
        var _a, _b;
        const value = getValueFromValueKeys(valueKeys);
        _value.value = value;
        emit("update:modelValue", value);
        emit("change", value);
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a);
        updateSelectedOption(valueKeys);
      };
      const updateInputValue = (inputValue) => {
        _inputValue.value = inputValue;
        emit("update:inputValue", inputValue);
        emit("inputValueChange", inputValue);
      };
      const handleSelect = (key, ev) => {
        if (props.multiple) {
          if (!computedValueKeys.value.includes(key)) {
            if (enabledOptionKeys.value.includes(key)) {
              if (props.limit > 0 && computedValueKeys.value.length >= props.limit) {
                const info = optionInfoMap.get(key);
                emit("exceedLimit", info == null ? void 0 : info.value, ev);
              } else {
                const valueKeys = computedValueKeys.value.concat(key);
                updateValue(valueKeys);
              }
            }
          } else {
            const valueKeys = computedValueKeys.value.filter((_key) => _key !== key);
            updateValue(valueKeys);
          }
          if (!retainInputValue.value) {
            updateInputValue("");
          }
        } else {
          if (key !== computedValueKeys.value[0]) {
            updateValue([key]);
          }
          if (retainInputValue.value) {
            const optionInfo = optionInfoMap.get(key);
            if (optionInfo) {
              updateInputValue(optionInfo.label);
            }
          }
          handlePopupVisibleChange(false);
        }
      };
      const handleSearch = debounce((value) => {
        emit("search", value);
      }, props.searchDelay);
      const handleInputValueChange = (inputValue) => {
        if (inputValue !== computedInputValue.value) {
          if (!computedPopupVisible.value) {
            handlePopupVisibleChange(true);
          }
          updateInputValue(inputValue);
          if (props.allowSearch) {
            handleSearch(inputValue);
          }
        }
      };
      const handleRemove = (key) => {
        const optionInfo = optionInfoMap.get(key);
        const newKeys = computedValueKeys.value.filter((_key) => _key !== key);
        updateValue(newKeys);
        emit("remove", optionInfo == null ? void 0 : optionInfo.value);
      };
      const handleClear = (e2) => {
        e2 == null ? void 0 : e2.stopPropagation();
        const newKeys = computedValueKeys.value.filter((key) => {
          var _a;
          return (_a = optionInfoMap.get(key)) == null ? void 0 : _a.disabled;
        });
        updateValue(newKeys);
        updateInputValue("");
        emit("clear", e2);
      };
      const handleDropdownScroll = (e2) => {
        emit("dropdownScroll", e2);
      };
      const handleDropdownReachBottom = (e2) => {
        emit("dropdownReachBottom", e2);
      };
      const {
        validOptions,
        optionInfoMap,
        validOptionInfos,
        enabledOptionKeys,
        handleKeyDown
      } = useSelect({
        multiple,
        options,
        extraOptions,
        inputValue: computedInputValue,
        filterOption,
        showExtraOptions,
        component,
        valueKey,
        fieldNames,
        loading,
        popupVisible: computedPopupVisible,
        valueKeys: computedValueKeys,
        dropdownRef,
        optionRefs,
        virtualListRef,
        defaultActiveFirstOption,
        onSelect: handleSelect,
        onPopupVisibleChange: handlePopupVisibleChange
      });
      const selectViewValue = vue.computed(() => {
        var _a;
        const result = [];
        for (const item of computedValueObjects.value) {
          const optionInfo = optionInfoMap.get(item.key);
          if (optionInfo) {
            result.push(__spreadProps(__spreadValues({}, optionInfo), {
              value: item.key,
              label: (_a = optionInfo == null ? void 0 : optionInfo.label) != null ? _a : String(isObject$1(item.value) ? item.value[valueKey == null ? void 0 : valueKey.value] : item.value),
              closable: !(optionInfo == null ? void 0 : optionInfo.disabled),
              tagProps: optionInfo == null ? void 0 : optionInfo.tagProps
            }));
          }
        }
        return result;
      });
      const getOptionContentFunc = (optionInfo) => {
        if (isFunction$1(slots.option)) {
          const optionSlot = slots.option;
          return () => optionSlot({
            data: optionInfo.raw
          });
        }
        if (isFunction$1(optionInfo.render)) {
          return optionInfo.render;
        }
        return () => optionInfo.label;
      };
      const renderOption = (optionInfo) => {
        if (isGroupOptionInfo(optionInfo)) {
          let _slot;
          return vue.createVNode(Optgroup, {
            "key": optionInfo.key,
            "label": optionInfo.label
          }, _isSlot$g(_slot = optionInfo.options.map((child) => renderOption(child))) ? _slot : {
            default: () => [_slot]
          });
        }
        if (!isValidOption(optionInfo, {
          inputValue: computedInputValue.value,
          filterOption: filterOption == null ? void 0 : filterOption.value
        })) {
          return null;
        }
        return vue.createVNode(Option, {
          "ref": (ref) => {
            if (ref == null ? void 0 : ref.$el) {
              optionRefs.value[optionInfo.key] = ref.$el;
            }
          },
          "key": optionInfo.key,
          "value": optionInfo.value,
          "label": optionInfo.label,
          "disabled": optionInfo.disabled,
          "internal": true
        }, {
          default: getOptionContentFunc(optionInfo)
        });
      };
      const renderDropDown = () => {
        return vue.createVNode(SelectDropdown, {
          "ref": dropdownRef,
          "loading": props.loading,
          "empty": validOptionInfos.value.length === 0,
          "virtualList": Boolean(props.virtualListProps),
          "scrollbar": props.scrollbar,
          "showHeaderOnEmpty": props.showHeaderOnEmpty,
          "showFooterOnEmpty": props.showFooterOnEmpty,
          "onScroll": handleDropdownScroll,
          "onReachBottom": handleDropdownReachBottom
        }, {
          "default": () => {
            var _a, _b;
            return [...(_b = (_a = slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : [], ...validOptions.value.map(renderOption)];
          },
          "virtual-list": () => vue.createVNode(VirtualList, vue.mergeProps(props.virtualListProps, {
            "ref": virtualListRef,
            "data": validOptions.value
          }), {
            item: ({
              item
            }) => renderOption(item)
          }),
          "empty": slots.empty,
          "header": slots.header,
          "footer": slots.footer
        });
      };
      const renderLabel = ({
        data
      }) => {
        var _a, _b, _c, _d;
        if ((slots.label || isFunction$1(props.formatLabel)) && data) {
          const optionInfo = optionInfoMap.get(data.value);
          if (optionInfo == null ? void 0 : optionInfo.raw) {
            return (_c = (_a = slots.label) == null ? void 0 : _a.call(slots, {
              data: optionInfo.raw
            })) != null ? _c : (_b = props.formatLabel) == null ? void 0 : _b.call(props, optionInfo.raw);
          }
        }
        return (_d = data == null ? void 0 : data.label) != null ? _d : "";
      };
      return () => vue.createVNode(Trigger, vue.mergeProps({
        "trigger": "click",
        "position": "bl",
        "popupOffset": 4,
        "animationName": "slide-dynamic-origin",
        "hideEmpty": true,
        "preventFocus": true,
        "autoFitPopupWidth": true,
        "autoFitTransformOrigin": true,
        "disabled": mergedDisabled.value,
        "popupVisible": computedPopupVisible.value,
        "unmountOnClose": props.unmountOnClose,
        "clickToClose": !(props.allowSearch || props.allowCreate),
        "popupContainer": props.popupContainer,
        "onPopupVisibleChange": handlePopupVisibleChange
      }, props.triggerProps), {
        default: () => {
          var _a, _b;
          return [(_b = (_a = slots.trigger) == null ? void 0 : _a.call(slots)) != null ? _b : vue.createVNode(SelectView, vue.mergeProps({
            "class": prefixCls,
            "modelValue": selectViewValue.value,
            "inputValue": computedInputValue.value,
            "multiple": props.multiple,
            "disabled": mergedDisabled.value,
            "error": mergedError.value,
            "loading": props.loading,
            "allowClear": props.allowClear,
            "allowCreate": props.allowCreate,
            "allowSearch": Boolean(props.allowSearch),
            "opened": computedPopupVisible.value,
            "maxTagCount": props.maxTagCount,
            "placeholder": props.placeholder,
            "bordered": props.bordered,
            "size": mergedSize.value,
            "onInputValueChange": handleInputValueChange,
            "onRemove": handleRemove,
            "onClear": handleClear,
            "onKeydown": handleKeyDown
          }, attrs), {
            "label": renderLabel,
            "prefix": slots.prefix,
            "arrow-icon": slots["arrow-icon"],
            "loading-icon": slots["loading-icon"],
            "search-icon": slots["search-icon"]
          })];
        },
        content: renderDropDown
      });
    }
  });
  const Select = Object.assign(_Select, {
    Option,
    OptGroup: Optgroup,
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Select.name, _Select);
      app.component(componentPrefix + Option.name, Option);
      app.component(componentPrefix + Optgroup.name, Optgroup);
    }
  });
  const radioGroupKey = Symbol("RadioGroup");
  var _Radio = vue.defineComponent({
    name: "Radio",
    components: {
      IconHover
    },
    props: {
      modelValue: {
        type: [String, Number, Boolean],
        default: void 0
      },
      defaultChecked: {
        type: Boolean,
        default: false
      },
      value: {
        type: [String, Number, Boolean],
        default: true
      },
      type: {
        type: String,
        default: "radio"
      },
      disabled: {
        type: Boolean,
        default: false
      },
      uninjectGroupContext: {
        type: Boolean,
        default: false
      }
    },
    emits: {
      "update:modelValue": (value) => true,
      "change": (value, ev) => true
    },
    setup(props, {
      emit,
      slots
    }) {
      const prefixCls = getPrefixCls("radio");
      const {
        modelValue
      } = vue.toRefs(props);
      const radioGroupCtx = !props.uninjectGroupContext ? vue.inject(radioGroupKey, void 0) : void 0;
      const {
        mergedDisabled: _mergedDisabled,
        eventHandlers
      } = useFormItem({
        disabled: vue.toRef(props, "disabled")
      });
      const inputRef = vue.ref(null);
      const _checked = vue.ref(props.defaultChecked);
      const isGroup = vue.computed(() => (radioGroupCtx == null ? void 0 : radioGroupCtx.name) === "ArcoRadioGroup");
      const mergedType = vue.computed(() => {
        var _a;
        return (_a = radioGroupCtx == null ? void 0 : radioGroupCtx.type) != null ? _a : props.type;
      });
      const mergedDisabled = vue.computed(() => (radioGroupCtx == null ? void 0 : radioGroupCtx.disabled) || _mergedDisabled.value);
      const computedChecked = vue.computed(() => {
        var _a, _b;
        if (isGroup.value) {
          return (radioGroupCtx == null ? void 0 : radioGroupCtx.value) === ((_a = props.value) != null ? _a : true);
        }
        if (!isUndefined(props.modelValue)) {
          return props.modelValue === ((_b = props.value) != null ? _b : true);
        }
        return _checked.value;
      });
      vue.watch(modelValue, (value) => {
        if (isUndefined(value) || isNull(value)) {
          _checked.value = false;
        }
      });
      vue.watch(computedChecked, (curValue, preValue) => {
        if (curValue !== preValue) {
          _checked.value = curValue;
          if (inputRef.value) {
            inputRef.value.checked = curValue;
          }
        }
      });
      const handleFocus = (ev) => {
        var _a, _b;
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onFocus) == null ? void 0 : _b.call(_a, ev);
      };
      const handleBlur = (ev) => {
        var _a, _b;
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onBlur) == null ? void 0 : _b.call(_a, ev);
      };
      const handleClick = (ev) => {
        ev.stopPropagation();
      };
      const handleChange = (e2) => {
        var _a, _b, _c, _d, _e;
        _checked.value = true;
        if (isGroup.value) {
          radioGroupCtx == null ? void 0 : radioGroupCtx.handleChange((_a = props.value) != null ? _a : true, e2);
        } else {
          emit("update:modelValue", (_b = props.value) != null ? _b : true);
          emit("change", (_c = props.value) != null ? _c : true, e2);
          (_e = (_d = eventHandlers.value) == null ? void 0 : _d.onChange) == null ? void 0 : _e.call(_d, e2);
        }
        vue.nextTick(() => {
          if (inputRef.value && inputRef.value.checked !== computedChecked.value) {
            inputRef.value.checked = computedChecked.value;
          }
        });
      };
      const cls = vue.computed(() => [`${mergedType.value === "button" ? `${prefixCls}-button` : prefixCls}`, {
        [`${prefixCls}-checked`]: computedChecked.value,
        [`${prefixCls}-disabled`]: mergedDisabled.value
      }]);
      const defaultRadio = () => vue.createVNode(vue.Fragment, null, [vue.createVNode(vue.resolveComponent("icon-hover"), {
        "class": `${prefixCls}-icon-hover`,
        "disabled": mergedDisabled.value || computedChecked.value
      }, {
        default: () => [vue.createVNode("span", {
          "class": `${prefixCls}-icon`
        }, null)]
      }), slots.default && vue.createVNode("span", {
        "class": `${prefixCls}-label`
      }, [slots.default()])]);
      return () => {
        var _a, _b, _c, _d;
        return vue.createVNode("label", {
          "class": cls.value
        }, [vue.createVNode("input", {
          "ref": inputRef,
          "type": "radio",
          "checked": computedChecked.value,
          "value": props.value,
          "class": `${prefixCls}-target`,
          "disabled": mergedDisabled.value,
          "onClick": handleClick,
          "onChange": handleChange,
          "onFocus": handleFocus,
          "onBlur": handleBlur
        }, null), mergedType.value === "radio" ? (_d = (_c = (_b = slots.radio) != null ? _b : (_a = radioGroupCtx == null ? void 0 : radioGroupCtx.slots) == null ? void 0 : _a.radio) == null ? void 0 : _c({
          checked: computedChecked.value,
          disabled: mergedDisabled.value
        })) != null ? _d : defaultRadio() : vue.createVNode("span", {
          "class": `${prefixCls}-button-content`
        }, [slots.default && slots.default()])]);
      };
    }
  });
  var RadioGroup = vue.defineComponent({
    name: "RadioGroup",
    props: {
      modelValue: {
        type: [String, Number, Boolean],
        default: void 0
      },
      defaultValue: {
        type: [String, Number, Boolean],
        default: ""
      },
      type: {
        type: String,
        default: "radio"
      },
      size: {
        type: String
      },
      options: {
        type: Array
      },
      direction: {
        type: String,
        default: "horizontal"
      },
      disabled: {
        type: Boolean,
        default: false
      }
    },
    emits: {
      "update:modelValue": (value) => true,
      "change": (value, ev) => true
    },
    setup(props, {
      emit,
      slots
    }) {
      const prefixCls = getPrefixCls("radio-group");
      const {
        size,
        type,
        disabled,
        modelValue
      } = vue.toRefs(props);
      const {
        mergedDisabled,
        mergedSize,
        eventHandlers
      } = useFormItem({
        size,
        disabled
      });
      const _value = vue.ref(props.defaultValue);
      const computedValue = vue.computed(() => {
        var _a;
        return (_a = props.modelValue) != null ? _a : _value.value;
      });
      const options = vue.computed(() => {
        var _a;
        return ((_a = props.options) != null ? _a : []).map((option) => {
          if (isString$1(option) || isNumber$1(option)) {
            return {
              label: option,
              value: option
            };
          }
          return option;
        });
      });
      const handleChange = (value, e2) => {
        var _a, _b;
        _value.value = value;
        emit("update:modelValue", value);
        emit("change", value, e2);
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a, e2);
      };
      vue.provide(radioGroupKey, vue.reactive({
        name: "ArcoRadioGroup",
        value: computedValue,
        size: mergedSize,
        type,
        disabled: mergedDisabled,
        slots,
        handleChange
      }));
      vue.watch(computedValue, (cur) => {
        if (_value.value !== cur) {
          _value.value = cur;
        }
      });
      vue.watch(modelValue, (val) => {
        if (isUndefined(val) || isNull(val)) {
          _value.value = "";
        }
      });
      const cls = vue.computed(() => [`${prefixCls}${props.type === "button" ? "-button" : ""}`, `${prefixCls}-size-${mergedSize.value}`, `${prefixCls}-direction-${props.direction}`, {
        [`${prefixCls}-disabled`]: mergedDisabled.value
      }]);
      const renderOptions = () => {
        return options.value.map((option) => vue.createVNode(_Radio, {
          "key": option.value,
          "value": option.value,
          "disabled": option.disabled,
          "modelValue": computedValue.value === option.value
        }, {
          default: () => [slots.label ? slots.label({
            data: option
          }) : isFunction$1(option.label) ? option.label() : option.label]
        }));
      };
      return () => {
        var _a;
        return vue.createVNode("span", {
          "class": cls.value
        }, [options.value.length > 0 ? renderOptions() : (_a = slots.default) == null ? void 0 : _a.call(slots)]);
      };
    }
  });
  const Radio = Object.assign(_Radio, {
    Group: RadioGroup,
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Radio.name, _Radio);
      app.component(componentPrefix + RadioGroup.name, RadioGroup);
    }
  });
  const _sfc_main$2m = vue.defineComponent({
    name: "IconLeft",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-left`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$10 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$N = /* @__PURE__ */ vue.createElementVNode("path", { d: "M32 8.4 16.444 23.956 32 39.513" }, null, -1);
  const _hoisted_3$K = [
    _hoisted_2$N
  ];
  function _sfc_render$2l(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$K, 14, _hoisted_1$10);
  }
  var _IconLeft = /* @__PURE__ */ _export_sfc(_sfc_main$2m, [["render", _sfc_render$2l]]);
  const IconLeft = Object.assign(_IconLeft, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconLeft.name, _IconLeft);
    }
  });
  function _isSlot$f(s) {
    return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !vue.isVNode(s);
  }
  function getPopupContainer(node) {
    return node.parentElement;
  }
  var Header = vue.defineComponent({
    name: "Header",
    props: {
      mode: {
        type: String
      },
      dayStartOfWeek: {
        type: Number
      },
      isWeek: {
        type: Boolean
      },
      panel: {
        type: Boolean
      },
      modes: {
        type: Array
      },
      headerType: {
        type: String
      },
      pageShowData: {
        type: Object,
        required: true
      },
      move: {
        type: Function,
        required: true
      },
      onYearChange: {
        type: Function,
        required: true
      },
      onMonthChange: {
        type: Function,
        required: true
      },
      changePageShowDate: {
        type: Function,
        required: true
      },
      onModeChange: {
        type: Function,
        required: true
      },
      headerValueFormat: {
        type: String,
        required: true
      }
    },
    emits: ["yearChange", "monthChange"],
    setup(props) {
      const prefixCls = getPrefixCls("calendar");
      const {
        t: t2
      } = useI18n();
      const modesOptions = isArray$1(props.modes) ? props.modes.map((m) => ({
        label: t2(`datePicker.view.${m}`),
        value: m
      })) : [];
      const isSelectHeaderType = props.headerType === "select";
      const pageShowDateYear = props.pageShowData.year();
      const pageShowDateMonth = props.pageShowData.month() + 1;
      const optionsYear = vue.computed(() => {
        const options = [pageShowDateYear];
        for (let i = 1; i <= 10; i++) {
          options.unshift(pageShowDateYear - i);
        }
        for (let i = 1; i < 10; i++) {
          options.push(pageShowDateYear + i);
        }
        return options;
      });
      const optionsMonth = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
      return () => {
        let _slot;
        return vue.createVNode("div", {
          "class": `${prefixCls}-header`
        }, [vue.createVNode("div", {
          "class": `${prefixCls}-header-left`
        }, [isSelectHeaderType ? vue.createVNode(vue.Fragment, null, [vue.createVNode(Select, {
          "size": "small",
          "class": `${prefixCls}-header-value-year`,
          "value": pageShowDateYear,
          "options": optionsYear.value,
          "onChange": props.onYearChange,
          "getPopupContainer": getPopupContainer
        }, null), props.mode === "month" && vue.createVNode(Select, {
          "size": "small",
          "class": `${prefixCls}-header-value-month`,
          "value": pageShowDateMonth,
          "options": optionsMonth,
          "onChange": props.onMonthChange,
          "getPopupContainer": getPopupContainer
        }, null)]) : vue.createVNode(vue.Fragment, null, [vue.createVNode("div", {
          "class": `${prefixCls}-header-icon`,
          "role": "button",
          "tabIndex": 0,
          "onClick": () => props.changePageShowDate("prev", props.mode)
        }, [vue.createVNode(IconLeft, null, null)]), vue.createVNode("div", {
          "class": `${prefixCls}-header-value`
        }, [props.pageShowData.format(props.headerValueFormat)]), vue.createVNode("div", {
          "role": "button",
          "tabIndex": 0,
          "class": `${prefixCls}-header-icon`,
          "onClick": () => props.changePageShowDate("next", props.mode)
        }, [vue.createVNode(IconRight, null, null)])]), vue.createVNode(Button, {
          "size": "small",
          "onClick": () => props.move(getNow())
        }, _isSlot$f(_slot = t2(`datePicker.today`)) ? _slot : {
          default: () => [_slot]
        })]), vue.createVNode("div", {
          "class": `${prefixCls}-header-right`
        }, [vue.createVNode(Radio.Group, {
          "size": "small",
          "type": "button",
          "options": modesOptions,
          "onChange": props.onModeChange,
          "modelValue": props.mode
        }, null)])]);
      };
    }
  });
  function getFormat(mode, panel) {
    return mode === "month" || mode === "year" && !panel ? "YYYY-MM-DD" : "YYYY-MM";
  }
  var _Calendar = vue.defineComponent({
    name: "Calendar",
    props: {
      modelValue: {
        type: Date,
        default: void 0
      },
      defaultValue: {
        type: Date
      },
      mode: {
        type: String
      },
      defaultMode: {
        type: String,
        default: "month"
      },
      modes: {
        type: Array,
        default: () => ["month", "year"]
      },
      allowSelect: {
        type: Boolean,
        default: true
      },
      panel: {
        type: Boolean,
        default: false
      },
      panelWidth: {
        type: Number
      },
      panelTodayBtn: {
        type: Boolean,
        default: false
      },
      dayStartOfWeek: {
        type: Number,
        default: 0
      },
      isWeek: {
        type: Boolean,
        default: false
      }
    },
    emits: {
      "update:modelValue": (date) => true,
      "change": (date) => true,
      "panelChange": (date) => true
    },
    setup(props, {
      emit
    }) {
      const {
        dayStartOfWeek,
        isWeek
      } = vue.toRefs(props);
      const prefixCls = getPrefixCls("calendar");
      const _mode = vue.ref(props.defaultMode);
      const {
        t: t2
      } = useI18n();
      const computedMode = vue.computed(() => {
        if (props.mode) {
          return props.mode;
        }
        return _mode.value;
      });
      const format = getFormat(computedMode.value, props.panel);
      const _value = vue.ref(getDayjsValue(props.defaultValue || Date.now(), format));
      const computedValue = vue.computed(() => {
        if (props.modelValue) {
          return getDayjsValue(props.modelValue, format);
        }
        return _value.value;
      });
      const pageShowDate = vue.ref(computedValue.value || getNow());
      const pageData = vue.computed(() => {
        return getAllDaysByTime(pageShowDate.value, {
          dayStartOfWeek: dayStartOfWeek.value,
          isWeek: isWeek.value
        });
      });
      function onChangePageDate(time) {
        pageShowDate.value = time;
        emit("panelChange", time.toDate());
      }
      function move(time) {
        _value.value = time;
        emit("change", time.toDate());
        emit("update:modelValue", time.toDate());
        onChangePageDate(time);
      }
      function selectHandler(time, disabled = false) {
        if (!disabled) {
          move(time);
        }
      }
      let headerValueFormat = "";
      if (computedMode.value === "month") {
        headerValueFormat = t2("calendar.formatMonth");
      } else if (computedMode.value === "year") {
        headerValueFormat = t2("calendar.formatYear");
      }
      function changePageShowDate(type, unit) {
        if (type === "prev") {
          pageShowDate.value = methods.subtract(pageShowDate.value, 1, unit);
        }
        if (type === "next") {
          pageShowDate.value = methods.add(pageShowDate.value, 1, unit);
        }
        emit("panelChange", pageShowDate.value.toDate());
      }
      function onChangeYear(year) {
        const newValue = methods.set(pageShowDate.value, "year", year);
        pageShowDate.value = newValue;
        emit("panelChange", newValue.toDate());
      }
      function onChangeMonth(month) {
        const newValue = methods.set(pageShowDate.value, "month", month - 1);
        pageShowDate.value = newValue;
        emit("panelChange", newValue.toDate());
      }
      function changeMode(mode) {
        _mode.value = mode;
      }
      const cls = vue.computed(() => [prefixCls, computedMode.value === "month" ? `${prefixCls}-mode-month` : `${prefixCls}-mode-year`, {
        [`${prefixCls}-panel`]: props.panel && (computedMode.value === "month" || computedMode.value === "year")
      }]);
      const baseStyle = props.panel ? {
        width: props.panelWidth
      } : {};
      return () => vue.createVNode("div", vue.mergeProps({
        "class": cls.value,
        "style": baseStyle
      }, pickDataAttributes(props)), [vue.createVNode(Header, {
        "move": move,
        "headerValueFormat": headerValueFormat,
        "modes": ["month", "year"],
        "mode": computedMode.value,
        "pageShowData": pageShowDate.value,
        "dayStartOfWeek": props.dayStartOfWeek,
        "isWeek": props.isWeek,
        "onModeChange": changeMode,
        "onYearChange": onChangeYear,
        "onMonthChange": onChangeMonth,
        "changePageShowDate": changePageShowDate
      }, null), computedMode.value === "month" && vue.createVNode("div", {
        "class": `${prefixCls}-body`
      }, [vue.createVNode(Month, {
        "key": pageShowDate.value.month(),
        "pageData": pageData.value,
        "value": computedValue.value,
        "mode": computedMode.value,
        "selectHandler": selectHandler,
        "isWeek": props.isWeek,
        "dayStartOfWeek": props.dayStartOfWeek,
        "pageShowDate": pageShowDate.value
      }, null)]), computedMode.value === "year" && vue.createVNode("div", {
        "class": `${prefixCls}-body`
      }, [vue.createVNode(Year, {
        "key": pageShowDate.value.year(),
        "pageData": pageData.value,
        "pageShowData": pageShowDate.value,
        "mode": computedMode.value,
        "isWeek": props.isWeek,
        "value": computedValue.value,
        "dayStartOfWeek": props.dayStartOfWeek,
        "selectHandler": selectHandler
      }, null)]), props.panel && props.panelTodayBtn && vue.createVNode("div", {
        "class": `${prefixCls}-footer-btn-wrapper`
      }, [t2("today")])]);
    }
  });
  const Calendar = Object.assign(_Calendar, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Calendar.name, _Calendar);
    }
  });
  const cardInjectionKey = Symbol("ArcoCard");
  var _Card = vue.defineComponent({
    name: "Card",
    components: {
      Spin
    },
    props: {
      bordered: {
        type: Boolean,
        default: true
      },
      loading: {
        type: Boolean,
        default: false
      },
      hoverable: {
        type: Boolean,
        default: false
      },
      size: {
        type: String
      },
      headerStyle: {
        type: Object,
        default: () => ({})
      },
      bodyStyle: {
        type: Object,
        default: () => ({})
      },
      title: {
        type: String
      },
      extra: {
        type: String
      }
    },
    setup(props, {
      slots
    }) {
      const prefixCls = getPrefixCls("card");
      const {
        size
      } = vue.toRefs(props);
      const {
        mergedSize: _mergedSize
      } = useSize$1(size);
      const mergedSize = vue.computed(() => {
        if (_mergedSize.value === "small" || _mergedSize.value === "mini") {
          return "small";
        }
        return "medium";
      });
      const renderActions = (vns) => {
        const actions = getAllElements(vns);
        return vue.createVNode("div", {
          "class": `${prefixCls}-actions`
        }, [vue.createVNode("div", {
          "class": `${prefixCls}-actions-right`
        }, [actions.map((action, index2) => vue.createVNode("span", {
          "key": `action-${index2}`,
          "class": `${prefixCls}-actions-item`
        }, [action]))])]);
      };
      const cardContext = vue.reactive({
        hasMeta: false,
        hasGrid: false,
        slots,
        renderActions
      });
      vue.provide(cardInjectionKey, cardContext);
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-size-${mergedSize.value}`, {
        [`${prefixCls}-loading`]: props.loading,
        [`${prefixCls}-bordered`]: props.bordered,
        [`${prefixCls}-hoverable`]: props.hoverable,
        [`${prefixCls}-contain-grid`]: cardContext.hasGrid
      }]);
      return () => {
        var _a, _b, _c, _d, _e, _f, _g;
        const hasTitle = Boolean((_a = slots.title) != null ? _a : props.title);
        const hasExtra = Boolean((_b = slots.extra) != null ? _b : props.extra);
        return vue.createVNode("div", {
          "class": cls.value
        }, [(hasTitle || hasExtra) && vue.createVNode("div", {
          "class": [`${prefixCls}-header`, {
            [`${prefixCls}-header-no-title`]: !hasTitle
          }],
          "style": props.headerStyle
        }, [hasTitle && vue.createVNode("div", {
          "class": `${prefixCls}-header-title`
        }, [(_d = (_c = slots.title) == null ? void 0 : _c.call(slots)) != null ? _d : props.title]), hasExtra && vue.createVNode("div", {
          "class": `${prefixCls}-header-extra`
        }, [(_f = (_e = slots.extra) == null ? void 0 : _e.call(slots)) != null ? _f : props.extra])]), slots.cover && vue.createVNode("div", {
          "class": `${prefixCls}-cover`
        }, [slots.cover()]), vue.createVNode("div", {
          "class": `${prefixCls}-body`,
          "style": props.bodyStyle
        }, [props.loading ? vue.createVNode(Spin, null, null) : (_g = slots.default) == null ? void 0 : _g.call(slots), slots.actions && !cardContext.hasMeta && renderActions(slots.actions())])]);
      };
    }
  });
  var CardMeta = vue.defineComponent({
    name: "CardMeta",
    props: {
      title: {
        type: String
      },
      description: {
        type: String
      }
    },
    setup(props, {
      slots
    }) {
      const prefixCls = getPrefixCls("card-meta");
      const context = vue.inject(cardInjectionKey);
      vue.onMounted(() => {
        if (context) {
          context.hasMeta = true;
        }
      });
      return () => {
        var _a, _b, _c, _d, _e, _f;
        const hasTitle = Boolean((_a = slots.title) != null ? _a : props.title);
        const hasDesc = Boolean((_b = slots.description) != null ? _b : props.description);
        return vue.createVNode("div", {
          "class": prefixCls
        }, [(hasTitle || hasDesc) && vue.createVNode("div", {
          "class": `${prefixCls}-content`
        }, [hasTitle && vue.createVNode("div", {
          "class": `${prefixCls}-title`
        }, [(_d = (_c = slots.title) == null ? void 0 : _c.call(slots)) != null ? _d : props.title]), hasDesc && vue.createVNode("div", {
          "class": `${prefixCls}-description`
        }, [(_f = (_e = slots.description) == null ? void 0 : _e.call(slots)) != null ? _f : props.description])]), (slots.avatar || (context == null ? void 0 : context.slots.actions)) && vue.createVNode("div", {
          "class": [`${prefixCls}-footer `, {
            [`${prefixCls}-footer-only-actions`]: !slots.avatar
          }]
        }, [slots.avatar && vue.createVNode("div", {
          "class": `${prefixCls}-avatar`
        }, [slots.avatar()]), context && context.slots.actions && context.renderActions(context.slots.actions())])]);
      };
    }
  });
  const _sfc_main$2l = vue.defineComponent({
    name: "CardGrid",
    props: {
      hoverable: {
        type: Boolean,
        default: false
      }
    },
    setup(props) {
      const prefixCls = getPrefixCls("card-grid");
      const context = vue.inject(cardInjectionKey);
      vue.onMounted(() => {
        if (context) {
          context.hasGrid = true;
        }
      });
      const cls = vue.computed(() => {
        return [
          prefixCls,
          {
            [`${prefixCls}-hoverable`]: props.hoverable
          }
        ];
      });
      return {
        cls
      };
    }
  });
  function _sfc_render$2k(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.cls)
    }, [
      vue.renderSlot(_ctx.$slots, "default")
    ], 2);
  }
  var CardGrid = /* @__PURE__ */ _export_sfc(_sfc_main$2l, [["render", _sfc_render$2k]]);
  const Card = Object.assign(_Card, {
    Meta: CardMeta,
    Grid: CardGrid,
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Card.name, _Card);
      app.component(componentPrefix + CardMeta.name, CardMeta);
      app.component(componentPrefix + CardGrid.name, CardGrid);
    }
  });
  const _sfc_main$2k = vue.defineComponent({
    name: "Indicator",
    props: {
      count: {
        type: Number,
        default: 2
      },
      activeIndex: {
        type: Number,
        default: 0
      },
      type: {
        type: String,
        default: "line"
      },
      position: {
        type: String,
        default: "bottom"
      },
      trigger: {
        type: String,
        default: "click"
      }
    },
    emits: ["select"],
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("carousel-indicator");
      const onClick = (event) => {
        var _a;
        event.preventDefault();
        if (props.type === "slider") {
          const x = event.offsetX;
          const width = event.currentTarget.clientWidth;
          if (event.target === event.currentTarget) {
            const index2 = Math.floor(x / width * props.count);
            index2 !== props.activeIndex && emit("select", index2);
          }
        } else {
          const index2 = Number.parseInt((_a = event.target.getAttribute("data-index")) != null ? _a : "", 10);
          if (!Number.isNaN(index2) && index2 !== props.activeIndex) {
            emit("select", index2);
          }
        }
      };
      const eventHandlers = vue.computed(() => {
        return props.trigger === "click" ? { onClick } : { onMouseover: onClick };
      });
      const cls = vue.computed(() => [
        `${prefixCls}`,
        `${prefixCls}-${props.type}`,
        `${prefixCls}-${props.position}`
      ]);
      const sliderStyle = vue.computed(() => {
        const step = 100 / props.count;
        return { width: `${step}%`, left: `${props.activeIndex * step}%` };
      });
      return {
        prefixCls,
        eventHandlers,
        cls,
        sliderStyle
      };
    }
  });
  const _hoisted_1$$ = ["data-index"];
  function _sfc_render$2j(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", vue.mergeProps({ class: _ctx.cls }, _ctx.eventHandlers), [
      _ctx.type === "slider" ? (vue.openBlock(), vue.createElementBlock("span", {
        key: 0,
        style: vue.normalizeStyle(_ctx.sliderStyle),
        class: vue.normalizeClass([`${_ctx.prefixCls}-item`, `${_ctx.prefixCls}-item-active`])
      }, null, 6)) : (vue.openBlock(true), vue.createElementBlock(vue.Fragment, { key: 1 }, vue.renderList(Array(_ctx.count), (_, index2) => {
        return vue.openBlock(), vue.createElementBlock("span", {
          key: index2,
          "data-index": index2,
          class: vue.normalizeClass([
            `${_ctx.prefixCls}-item`,
            { [`${_ctx.prefixCls}-item-active`]: index2 === _ctx.activeIndex }
          ])
        }, null, 10, _hoisted_1$$);
      }), 128))
    ], 16);
  }
  var CarouselIndicator = /* @__PURE__ */ _export_sfc(_sfc_main$2k, [["render", _sfc_render$2j]]);
  const _sfc_main$2j = vue.defineComponent({
    name: "IconUp",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-up`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$_ = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$M = /* @__PURE__ */ vue.createElementVNode("path", { d: "M39.6 30.557 24.043 15 8.487 30.557" }, null, -1);
  const _hoisted_3$J = [
    _hoisted_2$M
  ];
  function _sfc_render$2i(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$J, 14, _hoisted_1$_);
  }
  var _IconUp = /* @__PURE__ */ _export_sfc(_sfc_main$2j, [["render", _sfc_render$2i]]);
  const IconUp = Object.assign(_IconUp, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconUp.name, _IconUp);
    }
  });
  const _sfc_main$2i = vue.defineComponent({
    name: "Arrow",
    components: {
      IconUp,
      IconDown,
      IconLeft,
      IconRight
    },
    props: {
      direction: {
        type: String,
        default: "horizontal"
      },
      showArrow: {
        type: String,
        default: "always"
      }
    },
    emits: ["previousClick", "nextClick"],
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("carousel");
      const onPreviousClick = (ev) => {
        emit("previousClick", ev);
      };
      const onNextClick = (ev) => {
        emit("nextClick", ev);
      };
      const cls = vue.computed(() => [
        `${prefixCls}-arrow`,
        {
          [`${prefixCls}-arrow-hover`]: props.showArrow === "hover"
        }
      ]);
      return {
        prefixCls,
        cls,
        onPreviousClick,
        onNextClick
      };
    }
  });
  function _sfc_render$2h(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_IconLeft = vue.resolveComponent("IconLeft");
    const _component_IconUp = vue.resolveComponent("IconUp");
    const _component_IconRight = vue.resolveComponent("IconRight");
    const _component_IconDown = vue.resolveComponent("IconDown");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.cls)
    }, [
      vue.createElementVNode("div", {
        class: vue.normalizeClass(`${_ctx.prefixCls}-arrow-${_ctx.direction === "vertical" ? "top" : "left"}`),
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onPreviousClick && _ctx.onPreviousClick(...args))
      }, [
        _ctx.direction === "horizontal" ? (vue.openBlock(), vue.createBlock(_component_IconLeft, { key: 0 })) : (vue.openBlock(), vue.createBlock(_component_IconUp, { key: 1 }))
      ], 2),
      vue.createElementVNode("div", {
        class: vue.normalizeClass(`${_ctx.prefixCls}-arrow-${_ctx.direction === "vertical" ? "bottom" : "right"}`),
        onClick: _cache[1] || (_cache[1] = (...args) => _ctx.onNextClick && _ctx.onNextClick(...args))
      }, [
        _ctx.direction === "horizontal" ? (vue.openBlock(), vue.createBlock(_component_IconRight, { key: 0 })) : (vue.openBlock(), vue.createBlock(_component_IconDown, { key: 1 }))
      ], 2)
    ], 2);
  }
  var CarouselArrow = /* @__PURE__ */ _export_sfc(_sfc_main$2i, [["render", _sfc_render$2h]]);
  const carouselInjectionKey = Symbol("ArcoCarousel");
  const useChildrenComponents = (name) => {
    const children = {};
    const components2 = vue.ref([]);
    const getComponents = () => {
      if (children.value) {
        const _components = getComponentsFromChildren(children.value, name);
        if (_components.length !== components2.value.length || _components.toString() !== components2.value.toString()) {
          components2.value = _components;
        }
      }
    };
    vue.onMounted(() => getComponents());
    vue.onUpdated(() => getComponents());
    return {
      children,
      components: components2
    };
  };
  const DEFAULT_AUTO_PLAY = {
    interval: 3e3,
    hoverToPause: true
  };
  function getValidIndex(i, length) {
    const indexNumber = +i;
    return typeof indexNumber === "number" && !Number.isNaN(indexNumber) ? (indexNumber + length) % length : i;
  }
  var _Carousel = vue.defineComponent({
    name: "Carousel",
    props: {
      current: {
        type: Number
      },
      defaultCurrent: {
        type: Number,
        default: 1
      },
      autoPlay: {
        type: [Boolean, Object],
        default: false
      },
      moveSpeed: {
        type: Number,
        default: 500
      },
      animationName: {
        type: String,
        default: "slide"
      },
      trigger: {
        type: String,
        default: "click"
      },
      direction: {
        type: String,
        default: "horizontal"
      },
      showArrow: {
        type: String,
        default: "always"
      },
      arrowClass: {
        type: String,
        default: ""
      },
      indicatorType: {
        type: String,
        default: "dot"
      },
      indicatorPosition: {
        type: String,
        default: "bottom"
      },
      indicatorClass: {
        type: String,
        default: ""
      },
      transitionTimingFunction: {
        type: String,
        default: "cubic-bezier(0.34, 0.69, 0.1, 1)"
      }
    },
    emits: {
      "update:current": (index2) => true,
      "change": (index2, prevIndex, isManual) => true
    },
    setup(props, {
      emit,
      slots
    }) {
      const {
        current,
        animationName,
        moveSpeed,
        transitionTimingFunction
      } = vue.toRefs(props);
      const prefixCls = getPrefixCls("carousel");
      const isPause = vue.ref(false);
      const previousIndex = vue.ref();
      const slideDirection = vue.ref();
      const computedAutoPlay = vue.computed(() => {
        if (isObject$1(props.autoPlay)) {
          return __spreadValues(__spreadValues({}, DEFAULT_AUTO_PLAY), props.autoPlay);
        }
        return props.autoPlay ? DEFAULT_AUTO_PLAY : {};
      });
      let intervalTimer = 0;
      let animationTimer = 0;
      const {
        children,
        components: components2
      } = useChildrenComponents("CarouselItem");
      const _index = vue.ref(props.defaultCurrent - 1);
      const mergedIndexes = vue.computed(() => {
        const childrenLength = components2.value.length;
        const mergedIndex = isNumber$1(current.value) ? getValidIndex(current.value - 1, childrenLength) : _index.value;
        const prevIndex = getValidIndex(mergedIndex - 1, childrenLength);
        const nextIndex = getValidIndex(mergedIndex + 1, childrenLength);
        return {
          mergedIndex,
          mergedPrevIndex: prevIndex,
          mergedNextIndex: nextIndex
        };
      });
      const carouselContext = vue.reactive({
        items: components2,
        slideTo,
        mergedIndexes,
        previousIndex,
        animationName,
        slideDirection,
        transitionTimingFunction,
        moveSpeed
      });
      vue.provide(carouselInjectionKey, carouselContext);
      const clearTimer = () => {
        if (intervalTimer) {
          window.clearInterval(intervalTimer);
        }
      };
      vue.watchEffect(() => {
        var _a;
        const {
          interval
        } = computedAutoPlay.value || {};
        const {
          mergedNextIndex
        } = mergedIndexes.value;
        const shouldInterval = ((_a = components2.value) == null ? void 0 : _a.length) > 1 && !isPause.value && Boolean(interval);
        clearTimer();
        if (shouldInterval) {
          intervalTimer = window.setInterval(() => {
            slideTo({
              targetIndex: mergedNextIndex
            });
          }, interval);
        }
      });
      vue.onBeforeUnmount(() => {
        clearTimer();
      });
      function slideTo({
        targetIndex,
        isNegative = false,
        isManual = false
      }) {
        if (!animationTimer && targetIndex !== mergedIndexes.value.mergedIndex) {
          previousIndex.value = _index.value;
          _index.value = targetIndex;
          slideDirection.value = isNegative ? "negative" : "positive";
          animationTimer = window.setTimeout(() => {
            animationTimer = 0;
          }, moveSpeed.value);
          emit("update:current", _index.value + 1);
          emit("change", _index.value + 1, previousIndex.value + 1, isManual);
        }
      }
      const onPreviousClick = () => slideTo({
        targetIndex: mergedIndexes.value.mergedPrevIndex,
        isNegative: true,
        isManual: true
      });
      const onNextClick = () => slideTo({
        targetIndex: mergedIndexes.value.mergedNextIndex,
        isManual: true
      });
      const onSelect = (index2) => slideTo({
        targetIndex: index2,
        isNegative: index2 < mergedIndexes.value.mergedIndex,
        isManual: true
      });
      const eventHandlers = vue.computed(() => {
        return computedAutoPlay.value.hoverToPause ? {
          onMouseenter: () => {
            isPause.value = true;
          },
          onMouseleave: () => {
            isPause.value = false;
          }
        } : {};
      });
      const hasIndicator = vue.computed(() => {
        return props.indicatorType !== "never" && components2.value.length > 1;
      });
      const hasArrow = vue.computed(() => {
        return props.showArrow !== "never" && components2.value.length > 1;
      });
      const cls = vue.computed(() => {
        return [prefixCls, `${prefixCls}-indicator-position-${props.indicatorPosition}`];
      });
      const contentCls = vue.computed(() => {
        return [`${prefixCls}-${props.animationName}`, `${prefixCls}-${props.direction}`, {
          [`${prefixCls}-negative`]: slideDirection.value === "negative"
        }];
      });
      const indicatorCls = vue.computed(() => {
        return [`${prefixCls}-indicator-wrapper`, `${prefixCls}-indicator-wrapper-${props.indicatorPosition}`];
      });
      return () => {
        var _a;
        children.value = (_a = slots.default) == null ? void 0 : _a.call(slots);
        return vue.createVNode("div", vue.mergeProps({
          "class": cls.value
        }, eventHandlers.value), [vue.createVNode("div", {
          "class": contentCls.value
        }, [children.value]), hasIndicator.value && vue.createVNode("div", {
          "class": indicatorCls.value
        }, [vue.createVNode(CarouselIndicator, {
          "class": props.indicatorClass,
          "type": props.indicatorType,
          "count": components2.value.length,
          "activeIndex": mergedIndexes.value.mergedIndex,
          "position": props.indicatorPosition,
          "trigger": props.trigger,
          "onSelect": onSelect
        }, null)]), hasArrow.value && vue.createVNode(CarouselArrow, {
          "class": props.arrowClass,
          "direction": props.direction,
          "showArrow": props.showArrow,
          "onPreviousClick": onPreviousClick,
          "onNextClick": onNextClick
        }, null)]);
      };
    }
  });
  const _sfc_main$2h = vue.defineComponent({
    name: "CarouselItem",
    setup() {
      const prefixCls = getPrefixCls("carousel-item");
      const instance = vue.getCurrentInstance();
      const context = vue.inject(carouselInjectionKey, {});
      const index2 = vue.computed(() => {
        var _a, _b, _c;
        return (_c = (_b = context.items) == null ? void 0 : _b.indexOf((_a = instance == null ? void 0 : instance.uid) != null ? _a : -1)) != null ? _c : -1;
      });
      const isCurrent = vue.computed(() => {
        var _a;
        return ((_a = context.mergedIndexes) == null ? void 0 : _a.mergedIndex) === index2.value;
      });
      const cls = vue.computed(() => {
        const { previousIndex, animationName, slideDirection, mergedIndexes } = context;
        return {
          [`${prefixCls}-prev`]: index2.value === (mergedIndexes == null ? void 0 : mergedIndexes.mergedPrevIndex),
          [`${prefixCls}-next`]: index2.value === (mergedIndexes == null ? void 0 : mergedIndexes.mergedNextIndex),
          [`${prefixCls}-current`]: isCurrent.value,
          [`${prefixCls}-slide-in`]: animationName === "slide" && slideDirection && isCurrent.value,
          [`${prefixCls}-slide-out`]: animationName === "slide" && slideDirection && index2.value === previousIndex
        };
      });
      const animationStyle = vue.computed(() => {
        const { transitionTimingFunction, moveSpeed } = context;
        return {
          transitionTimingFunction,
          transitionDuration: `${moveSpeed}ms`,
          animationTimingFunction: transitionTimingFunction,
          animationDuration: `${moveSpeed}ms`
        };
      });
      return {
        cls,
        animationStyle,
        isCurrent
      };
    }
  });
  const _hoisted_1$Z = ["aria-hidden"];
  function _sfc_render$2g(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      "aria-hidden": !_ctx.isCurrent,
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.animationStyle)
    }, [
      vue.renderSlot(_ctx.$slots, "default")
    ], 14, _hoisted_1$Z);
  }
  var CarouselItem = /* @__PURE__ */ _export_sfc(_sfc_main$2h, [["render", _sfc_render$2g]]);
  const Carousel = Object.assign(_Carousel, {
    Item: CarouselItem,
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Carousel.name, _Carousel);
      app.component(componentPrefix + CarouselItem.name, CarouselItem);
    }
  });
  const getOptionInfos = (options, {
    optionMap,
    leafOptionMap,
    leafOptionSet,
    leafOptionValueMap,
    totalLevel: innerLevel,
    checkStrictly,
    enabledLazyLoad,
    lazyLoadOptions,
    valueKey,
    fieldNames
  }) => {
    let totalLevel = 0;
    const travelOptions = (options2, parent, level) => {
      var _a;
      const parentPath = (_a = parent == null ? void 0 : parent.path) != null ? _a : [];
      totalLevel = Math.max(totalLevel, level != null ? level : 1);
      return options2.map((item, index2) => {
        var _a2;
        const value = item[fieldNames.value];
        const data = {
          raw: item,
          value,
          label: (_a2 = item[fieldNames.label]) != null ? _a2 : String(value),
          disabled: Boolean(item[fieldNames.disabled]),
          selectionDisabled: false,
          render: item[fieldNames.render],
          tagProps: item[fieldNames.tagProps],
          isLeaf: item[fieldNames.isLeaf],
          level: parentPath.length,
          index: index2,
          key: "",
          valueKey: String(isObject$1(value) ? value[valueKey.value] : value),
          parent,
          path: [],
          pathValue: []
        };
        const path = parentPath.concat(data);
        const pathValue = [];
        const key = path.map((item2) => {
          pathValue.push(item2.value);
          return item2.valueKey;
        }).join("-");
        data.path = path;
        data.pathValue = pathValue;
        data.key = key;
        if (item[fieldNames.children]) {
          data.isLeaf = false;
          data.children = travelOptions(item[fieldNames.children], data, (level != null ? level : 1) + 1);
        } else if (enabledLazyLoad && !data.isLeaf) {
          data.isLeaf = false;
          if (lazyLoadOptions[key]) {
            data.children = travelOptions(lazyLoadOptions[key], data, (level != null ? level : 1) + 1);
          }
        } else {
          data.isLeaf = true;
        }
        if (data.children && !data.disabled) {
          data.totalLeafOptions = data.children.reduce((pre, item2) => {
            if (isNumber$1(item2.totalLeafOptions)) {
              return pre + item2.totalLeafOptions;
            }
            if (item2.disabled || item2.selectionDisabled) {
              return pre;
            }
            return pre + (item2.isLeaf ? 1 : 0);
          }, 0);
          if (data.totalLeafOptions === 0 && !checkStrictly.value) {
            data.selectionDisabled = true;
          }
        }
        optionMap.set(data.key, data);
        if (data.isLeaf || checkStrictly.value) {
          leafOptionSet.add(data);
          leafOptionMap.set(data.key, data);
          if (!leafOptionValueMap.has(data.valueKey)) {
            leafOptionValueMap.set(data.valueKey, data.key);
          }
        }
        return data;
      });
    };
    const result = travelOptions(options);
    innerLevel.value = totalLevel;
    return result;
  };
  const getCheckedStatus = (option, valueMap) => {
    var _a, _b;
    let checked = false;
    let indeterminate = false;
    if (option.isLeaf) {
      if (valueMap == null ? void 0 : valueMap.has(option.key)) {
        checked = true;
      }
    } else {
      const reg = new RegExp(`^${option.key}(-|$)`);
      const checkedLeafOptionNumber = Array.from((_a = valueMap == null ? void 0 : valueMap.keys()) != null ? _a : []).reduce((pre, key) => {
        if (reg.test(key)) {
          return pre + 1;
        }
        return pre;
      }, 0);
      if (checkedLeafOptionNumber > 0 && checkedLeafOptionNumber >= ((_b = option.totalLeafOptions) != null ? _b : 1)) {
        checked = true;
      } else if (checkedLeafOptionNumber > 0) {
        indeterminate = true;
      }
    }
    return {
      checked,
      indeterminate
    };
  };
  const getLeafOptionKeys = (option) => {
    const keys = [];
    if (option.isLeaf) {
      keys.push(option.key);
    } else if (option.children) {
      for (const item of option.children) {
        keys.push(...getLeafOptionKeys(item));
      }
    }
    return keys;
  };
  const getLeafOptionInfos = (option) => {
    const infos = [];
    if (option.disabled || option.selectionDisabled) {
      return infos;
    }
    if (option.isLeaf) {
      infos.push(option);
    } else if (option.children) {
      for (const item of option.children) {
        infos.push(...getLeafOptionInfos(item));
      }
    }
    return infos;
  };
  const getValueKey = (value, {
    valueKey,
    leafOptionValueMap
  }) => {
    var _a;
    if (isArray$1(value)) {
      return value.map((item) => {
        if (isObject$1(item))
          return item[valueKey];
        return item;
      }).join("-");
    }
    const _value = isObject$1(value) ? value[valueKey] : value;
    return (_a = leafOptionValueMap.get(String(_value))) != null ? _a : String(_value);
  };
  const getValidValues = (value, { multiple, pathMode }) => {
    if (!isArray$1(value)) {
      return isUndefined(value) || isNull(value) || value === "" ? [] : [value];
    }
    if (pathMode && !multiple && value.length > 0 && !isArray$1(value[0])) {
      return [value];
    }
    return value;
  };
  const getOptionLabel = (option) => {
    return option.path.map((item) => item.label).join(" / ");
  };
  const cascaderInjectionKey = Symbol("ArcoCascader");
  var CascaderOption = vue.defineComponent({
    name: "CascaderOption",
    props: {
      option: {
        type: Object,
        required: true
      },
      active: Boolean,
      multiple: Boolean,
      checkStrictly: Boolean,
      searchOption: Boolean,
      pathLabel: Boolean
    },
    setup(props) {
      const prefixCls = getPrefixCls("cascader-option");
      const cascaderCtx = vue.inject(cascaderInjectionKey, {});
      const isLoading = vue.ref(false);
      const events = {};
      const handlePathChange = (ev) => {
        var _a;
        if (isFunction$1(cascaderCtx.loadMore) && !props.option.isLeaf) {
          const {
            isLeaf,
            children,
            key
          } = props.option;
          if (!isLeaf && !children) {
            isLoading.value = true;
            new Promise((resolve) => {
              var _a2;
              (_a2 = cascaderCtx.loadMore) == null ? void 0 : _a2.call(cascaderCtx, props.option.raw, resolve);
            }).then((children2) => {
              var _a2;
              isLoading.value = false;
              if (children2) {
                (_a2 = cascaderCtx.addLazyLoadOptions) == null ? void 0 : _a2.call(cascaderCtx, children2, key);
              }
            });
          }
        }
        (_a = cascaderCtx.setSelectedPath) == null ? void 0 : _a.call(cascaderCtx, props.option.key);
      };
      if (!props.option.disabled) {
        events.onMouseenter = [() => {
          var _a;
          return (_a = cascaderCtx.setActiveKey) == null ? void 0 : _a.call(cascaderCtx, props.option.key);
        }];
        events.onMouseleave = () => {
          var _a;
          return (_a = cascaderCtx.setActiveKey) == null ? void 0 : _a.call(cascaderCtx);
        };
        events.onClick = [];
        if (cascaderCtx.expandTrigger === "hover") {
          events.onMouseenter.push((ev) => handlePathChange());
        } else {
          events.onClick.push((ev) => handlePathChange());
        }
        if (props.option.isLeaf && !props.multiple) {
          events.onClick.push((ev) => {
            var _a;
            handlePathChange();
            (_a = cascaderCtx.onClickOption) == null ? void 0 : _a.call(cascaderCtx, props.option);
          });
        }
      }
      const cls = vue.computed(() => [prefixCls, {
        [`${prefixCls}-active`]: props.active,
        [`${prefixCls}-disabled`]: props.option.disabled
      }]);
      const checkedStatus = vue.computed(() => {
        var _a;
        if (props.checkStrictly) {
          return {
            checked: (_a = cascaderCtx.valueMap) == null ? void 0 : _a.has(props.option.key),
            indeterminate: false
          };
        }
        return getCheckedStatus(props.option, cascaderCtx.valueMap);
      });
      const renderLabelContent = () => {
        var _a, _b, _c;
        if (props.pathLabel) {
          return (_b = (_a = cascaderCtx == null ? void 0 : cascaderCtx.formatLabel) == null ? void 0 : _a.call(cascaderCtx, props.option.path.map((item) => item.raw))) != null ? _b : getOptionLabel(props.option);
        }
        if ((_c = cascaderCtx.slots) == null ? void 0 : _c.option) {
          return cascaderCtx.slots.option({
            data: props.option
          });
        }
        if (isFunction$1(props.option.render)) {
          return props.option.render();
        }
        return props.option.label;
      };
      const renderIcon = () => {
        if (isLoading.value) {
          return vue.createVNode(IconLoading, null, null);
        }
        if (!props.searchOption && !props.option.isLeaf) {
          return vue.createVNode(IconRight, null, null);
        }
        return null;
      };
      return () => {
        var _a;
        return vue.createVNode("li", vue.mergeProps({
          "tabindex": "0",
          "role": "menuitem",
          "aria-disabled": props.option.disabled,
          "aria-haspopup": !props.option.isLeaf,
          "aria-expanded": !props.option.isLeaf && props.active,
          "title": props.option.label,
          "class": cls.value
        }, events), [props.multiple && vue.createVNode(Checkbox, {
          "modelValue": checkedStatus.value.checked,
          "indeterminate": checkedStatus.value.indeterminate,
          "disabled": props.option.disabled || props.option.selectionDisabled,
          "uninjectGroupContext": true,
          "onChange": (value, ev) => {
            var _a2;
            ev.stopPropagation();
            handlePathChange();
            (_a2 = cascaderCtx.onClickOption) == null ? void 0 : _a2.call(cascaderCtx, props.option, !checkedStatus.value.checked);
          },
          "onClick": (ev) => ev.stopPropagation()
        }, null), props.checkStrictly && !props.multiple && vue.createVNode(Radio, {
          "modelValue": (_a = cascaderCtx.valueMap) == null ? void 0 : _a.has(props.option.key),
          "disabled": props.option.disabled,
          "uninjectGroupContext": true,
          "onChange": (value, ev) => {
            var _a2;
            ev.stopPropagation();
            handlePathChange();
            (_a2 = cascaderCtx.onClickOption) == null ? void 0 : _a2.call(cascaderCtx, props.option, true);
          },
          "onClick": (ev) => ev.stopPropagation()
        }, null), vue.createVNode("div", {
          "class": `${prefixCls}-label`
        }, [renderLabelContent(), renderIcon()])]);
      };
    }
  });
  var CascaderColumn = vue.defineComponent({
    name: "CascaderColumn",
    props: {
      column: {
        type: Array,
        required: true
      },
      level: {
        type: Number,
        default: 0
      },
      selectedPath: {
        type: Array,
        required: true
      },
      activeKey: String,
      totalLevel: {
        type: Number,
        required: true
      },
      multiple: Boolean,
      checkStrictly: Boolean,
      virtualListProps: {
        type: Object
      }
    },
    setup(props, {
      slots
    }) {
      const prefixCls = getPrefixCls("cascader");
      const configCtx = vue.inject(configProviderInjectionKey, void 0);
      const virtualListRef = vue.ref();
      const isVirtual = vue.ref(Boolean(props.virtualListProps));
      const renderEmpty = () => {
        var _a, _b, _c, _d, _e;
        return (_e = (_d = (_a = slots.empty) == null ? void 0 : _a.call(slots)) != null ? _d : (_c = configCtx == null ? void 0 : (_b = configCtx.slots).empty) == null ? void 0 : _c.call(_b, {
          component: "cascader"
        })) != null ? _e : vue.createVNode(Empty, null, null);
      };
      return () => {
        var _a;
        return vue.createVNode("div", {
          "class": `${prefixCls}-panel-column`,
          "style": {
            zIndex: props.totalLevel - props.level
          }
        }, [isVirtual.value ? vue.createVNode(VirtualList, vue.mergeProps({
          "key": (_a = props.column) == null ? void 0 : _a.length
        }, props.virtualListProps, {
          "ref": virtualListRef,
          "data": props.column
        }), {
          item: ({
            item
          }) => {
            return vue.createVNode(CascaderOption, {
              "key": item.key,
              "option": item,
              "active": props.selectedPath.includes(item.key) || item.key === props.activeKey,
              "multiple": props.multiple,
              "checkStrictly": props.checkStrictly
            }, null);
          }
        }) : vue.createVNode(Scrollbar, {
          "class": `${prefixCls}-column-content`
        }, {
          default: () => [props.column.length === 0 ? vue.createVNode("div", {
            "class": `${prefixCls}-list-empty`
          }, [renderEmpty()]) : vue.createVNode("ul", {
            "role": "menu",
            "class": [`${prefixCls}-list`, {
              [`${prefixCls}-list-multiple`]: Boolean(props == null ? void 0 : props.multiple),
              [`${prefixCls}-list-strictly`]: Boolean(props == null ? void 0 : props.checkStrictly)
            }]
          }, [props.column.map((item) => {
            return vue.createVNode(CascaderOption, {
              "key": item.key,
              "option": item,
              "active": props.selectedPath.includes(item.key) || item.key === props.activeKey,
              "multiple": props.multiple,
              "checkStrictly": props.checkStrictly
            }, null);
          })])]
        })]);
      };
    }
  });
  function _isSlot$e(s) {
    return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !vue.isVNode(s);
  }
  var BaseCascaderPanel = vue.defineComponent({
    name: "BaseCascaderPanel",
    props: {
      displayColumns: {
        type: Array,
        required: true
      },
      selectedPath: {
        type: Array,
        required: true
      },
      activeKey: String,
      totalLevel: {
        type: Number,
        required: true
      },
      multiple: Boolean,
      checkStrictly: Boolean,
      loading: Boolean,
      dropdown: Boolean,
      virtualListProps: {
        type: Object
      }
    },
    setup(props, {
      slots
    }) {
      const prefixCls = getPrefixCls("cascader");
      const configCtx = vue.inject(configProviderInjectionKey, void 0);
      const renderEmpty = () => {
        var _a, _b, _c, _d, _e;
        return (_e = (_d = (_a = slots.empty) == null ? void 0 : _a.call(slots)) != null ? _d : (_c = configCtx == null ? void 0 : (_b = configCtx.slots).empty) == null ? void 0 : _c.call(_b, {
          component: "cascader"
        })) != null ? _e : vue.createVNode(Empty, null, null);
      };
      const renderContent = () => {
        if (props.loading) {
          return vue.createVNode("div", {
            "key": "panel-column-loading",
            "class": [`${prefixCls}-panel-column`, `${prefixCls}-panel-column-loading`]
          }, [vue.createVNode(Spin, null, null)]);
        }
        if (props.displayColumns.length === 0) {
          return vue.createVNode("div", {
            "key": "panel-column-empty",
            "class": `${prefixCls}-panel-column`
          }, [vue.createVNode("div", {
            "class": `${prefixCls}-list-empty`
          }, [renderEmpty()])]);
        }
        return props.displayColumns.map((column, index2) => vue.createVNode(CascaderColumn, {
          "key": `column-${index2}`,
          "column": column,
          "level": index2,
          "selectedPath": props.selectedPath,
          "activeKey": props.activeKey,
          "totalLevel": props.totalLevel,
          "multiple": props.multiple,
          "checkStrictly": props.checkStrictly,
          "virtualListProps": props.virtualListProps
        }, null));
      };
      return () => {
        let _slot;
        return vue.createVNode(vue.TransitionGroup, {
          "tag": "div",
          "name": "cascader-slide",
          "class": [`${prefixCls}-panel`, {
            [`${prefixCls}-dropdown-panel`]: props.dropdown
          }]
        }, _isSlot$e(_slot = renderContent()) ? _slot : {
          default: () => [_slot]
        });
      };
    }
  });
  function _isSlot$d(s) {
    return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !vue.isVNode(s);
  }
  var CascaderSearchPanel = vue.defineComponent({
    name: "CascaderSearchPanel",
    props: {
      options: {
        type: Array,
        required: true
      },
      loading: Boolean,
      activeKey: String,
      multiple: Boolean,
      checkStrictly: Boolean,
      pathLabel: Boolean
    },
    setup(props, {
      slots
    }) {
      const prefixCls = getPrefixCls("cascader");
      const configCtx = vue.inject(configProviderInjectionKey, void 0);
      const renderContent = () => {
        var _a, _b, _c, _d, _e;
        if (props.loading) {
          return vue.createVNode(Spin, null, null);
        }
        if (props.options.length === 0) {
          return vue.createVNode("div", {
            "class": `${prefixCls}-list-empty`
          }, [(_e = (_d = (_a = slots.empty) == null ? void 0 : _a.call(slots)) != null ? _d : (_c = configCtx == null ? void 0 : (_b = configCtx.slots).empty) == null ? void 0 : _c.call(_b, {
            component: "cascader"
          })) != null ? _e : vue.createVNode(Empty, null, null)]);
        }
        return vue.createVNode("ul", {
          "role": "menu",
          "class": [`${prefixCls}-list`, `${prefixCls}-search-list`, {
            [`${prefixCls}-list-multiple`]: props.multiple
          }]
        }, [props.options.map((item) => vue.createVNode(CascaderOption, {
          "key": item.key,
          "class": `${prefixCls}-search-option`,
          "option": item,
          "active": item.key === props.activeKey,
          "multiple": props.multiple,
          "checkStrictly": props.checkStrictly,
          "pathLabel": props.pathLabel,
          "searchOption": true
        }, null))]);
      };
      return () => {
        let _slot;
        return vue.createVNode(Scrollbar, {
          "class": [`${prefixCls}-panel`, `${prefixCls}-search-panel`]
        }, _isSlot$d(_slot = renderContent()) ? _slot : {
          default: () => [_slot]
        });
      };
    }
  });
  const useSelectedPath = (options, {
    optionMap,
    filteredLeafOptions,
    showSearchPanel,
    expandChild
  }) => {
    const activeKey = vue.ref();
    const activeOption = vue.computed(() => {
      if (activeKey.value)
        return optionMap.get(activeKey.value);
      return void 0;
    });
    const selectedPath = vue.ref([]);
    const displayColumns = vue.computed(() => {
      const columns = [options.value];
      for (const key of selectedPath.value) {
        const option = optionMap.get(key);
        if (option == null ? void 0 : option.children) {
          columns.push(option.children);
        }
      }
      return columns;
    });
    const setSelectedPath = (key) => {
      var _a;
      const option = getTargetOption(key);
      selectedPath.value = (_a = option == null ? void 0 : option.path.map((item) => item.key)) != null ? _a : [];
    };
    const setActiveKey = (key) => {
      activeKey.value = key;
    };
    const enabledOptions = vue.computed(() => {
      var _a;
      if (showSearchPanel == null ? void 0 : showSearchPanel.value) {
        return filteredLeafOptions.value.filter((item) => !item.disabled);
      }
      if (activeOption.value && activeOption.value.parent) {
        return (_a = activeOption.value.parent.children) == null ? void 0 : _a.filter((item) => !item.disabled);
      }
      return options.value.filter((item) => !item.disabled);
    });
    const getTargetOption = (key) => {
      let target2 = key ? optionMap.get(key) : void 0;
      if (expandChild.value) {
        while (target2 && target2.children && target2.children.length > 0) {
          target2 = target2.children[0];
        }
      }
      return target2;
    };
    const getNextActiveNode = (direction) => {
      var _a, _b, _c, _d, _e, _f, _g;
      const _length = (_b = (_a = enabledOptions.value) == null ? void 0 : _a.length) != null ? _b : 0;
      if (activeKey.value) {
        const enabledIndex = (_d = (_c = enabledOptions.value) == null ? void 0 : _c.findIndex((item) => item.key === activeKey.value)) != null ? _d : 0;
        if (direction === "next") {
          return (_e = enabledOptions.value) == null ? void 0 : _e[(_length + enabledIndex + 1) % _length];
        }
        return (_f = enabledOptions.value) == null ? void 0 : _f[(_length + enabledIndex - 1) % _length];
      }
      return (_g = enabledOptions.value) == null ? void 0 : _g[0];
    };
    return {
      activeKey,
      activeOption,
      selectedPath,
      displayColumns,
      setActiveKey,
      setSelectedPath,
      getNextActiveNode
    };
  };
  const _sfc_main$2g = vue.defineComponent({
    name: "Cascader",
    components: {
      Trigger,
      SelectView,
      BaseCascaderPanel,
      CascaderSearchPanel
    },
    inheritAttrs: false,
    props: {
      pathMode: {
        type: Boolean,
        default: false
      },
      multiple: {
        type: Boolean,
        default: false
      },
      modelValue: {
        type: [String, Number, Object, Array]
      },
      defaultValue: {
        type: [String, Number, Object, Array],
        default: (props) => props.multiple ? [] : props.pathMode ? void 0 : ""
      },
      options: {
        type: Array,
        default: () => []
      },
      disabled: {
        type: Boolean,
        default: false
      },
      error: {
        type: Boolean,
        default: false
      },
      size: {
        type: String
      },
      allowSearch: {
        type: Boolean,
        default: (props) => Boolean(props.multiple)
      },
      allowClear: {
        type: Boolean,
        default: false
      },
      inputValue: {
        type: String,
        default: void 0
      },
      defaultInputValue: {
        type: String,
        default: ""
      },
      popupVisible: {
        type: Boolean,
        default: void 0
      },
      expandTrigger: {
        type: String,
        default: "click"
      },
      defaultPopupVisible: {
        type: Boolean,
        default: false
      },
      placeholder: String,
      filterOption: {
        type: Function
      },
      popupContainer: {
        type: [String, Object]
      },
      maxTagCount: {
        type: Number,
        default: 0
      },
      formatLabel: {
        type: Function
      },
      triggerProps: {
        type: Object
      },
      checkStrictly: {
        type: Boolean,
        default: false
      },
      loadMore: {
        type: Function
      },
      loading: {
        type: Boolean,
        default: false
      },
      searchOptionOnlyLabel: {
        type: Boolean,
        default: false
      },
      searchDelay: {
        type: Number,
        default: 500
      },
      fieldNames: {
        type: Object
      },
      valueKey: {
        type: String,
        default: "value"
      },
      fallback: {
        type: [Boolean, Function],
        default: true
      },
      expandChild: {
        type: Boolean,
        default: false
      },
      virtualListProps: {
        type: Object
      }
    },
    emits: {
      "update:modelValue": (value) => true,
      "update:popupVisible": (visible) => true,
      "change": (value) => true,
      "inputValueChange": (value) => true,
      "clear": () => true,
      "search": (value) => true,
      "popupVisibleChange": (visible) => true,
      "focus": (ev) => true,
      "blur": (ev) => true
    },
    setup(props, { emit, slots }) {
      const {
        options,
        checkStrictly,
        loadMore,
        formatLabel,
        modelValue,
        disabled,
        valueKey,
        expandTrigger,
        expandChild
      } = vue.toRefs(props);
      const _value = vue.ref(props.defaultValue);
      const _inputValue = vue.ref(props.defaultInputValue);
      const _popupVisible = vue.ref(props.defaultPopupVisible);
      const { mergedDisabled, eventHandlers } = useFormItem({ disabled });
      vue.watch(modelValue, (value) => {
        if (isUndefined(value) || isNull(value)) {
          _value.value = props.multiple ? [] : void 0;
        }
      });
      const optionInfos = vue.ref([]);
      const totalLevel = vue.ref(1);
      const optionMap = vue.reactive(new Map());
      const leafOptionMap = vue.reactive(new Map());
      const leafOptionValueMap = vue.reactive(new Map());
      const leafOptionSet = vue.reactive(new Set());
      const lazyLoadOptions = vue.reactive({});
      const addLazyLoadOptions = (children, key) => {
        lazyLoadOptions[key] = children;
      };
      const DEFAULT_FIELD_NAMES2 = {
        value: "value",
        label: "label",
        disabled: "disabled",
        children: "children",
        tagProps: "tagProps",
        render: "render",
        isLeaf: "isLeaf"
      };
      const mergedFieldNames = vue.computed(() => __spreadValues(__spreadValues({}, DEFAULT_FIELD_NAMES2), props.fieldNames));
      vue.watch([options, lazyLoadOptions, mergedFieldNames], ([_options, _lazyLoadOptions, _fieldNames]) => {
        optionMap.clear();
        leafOptionMap.clear();
        leafOptionValueMap.clear();
        leafOptionSet.clear();
        optionInfos.value = getOptionInfos(_options != null ? _options : [], {
          enabledLazyLoad: Boolean(props.loadMore),
          lazyLoadOptions,
          optionMap,
          leafOptionSet,
          leafOptionMap,
          leafOptionValueMap,
          totalLevel,
          checkStrictly,
          valueKey,
          fieldNames: _fieldNames
        });
      }, {
        immediate: true,
        deep: true
      });
      const computedValueMap = vue.computed(() => {
        var _a;
        const values = getValidValues((_a = props.modelValue) != null ? _a : _value.value, {
          multiple: props.multiple,
          pathMode: props.pathMode
        });
        return new Map(values.map((value) => [
          getValueKey(value, {
            valueKey: props.valueKey,
            leafOptionValueMap
          }),
          value
        ]));
      });
      const computedInputValue = vue.computed(() => {
        var _a;
        return (_a = props.inputValue) != null ? _a : _inputValue.value;
      });
      const computedPopupVisible = vue.computed(() => {
        var _a;
        return (_a = props.popupVisible) != null ? _a : _popupVisible.value;
      });
      const getFilteredStatus = (label) => {
        var _a;
        return label == null ? void 0 : label.toLocaleLowerCase().includes((_a = computedInputValue.value) == null ? void 0 : _a.toLocaleLowerCase());
      };
      const filteredLeafOptions = vue.computed(() => {
        const options2 = props.checkStrictly ? Array.from(optionMap.values()) : Array.from(leafOptionSet);
        return options2.filter((item) => {
          var _a;
          if (isFunction$1(props.filterOption)) {
            return props.filterOption(computedInputValue.value, item.raw);
          }
          if (props.checkStrictly) {
            return getFilteredStatus(item.label);
          }
          return (_a = item.path) == null ? void 0 : _a.find((leaf) => getFilteredStatus(leaf.label));
        });
      });
      const updateValue = (values) => {
        var _a, _b, _c;
        const value = props.multiple ? values : (_a = values[0]) != null ? _a : "";
        if (values.length === 0) {
          setSelectedPath();
          setActiveKey();
        }
        _value.value = value;
        emit("update:modelValue", value);
        emit("change", value);
        (_c = (_b = eventHandlers.value) == null ? void 0 : _b.onChange) == null ? void 0 : _c.call(_b);
      };
      const handlePopupVisibleChange = (visible) => {
        if (computedPopupVisible.value !== visible) {
          _popupVisible.value = visible;
          emit("popupVisibleChange", visible);
        }
      };
      const handleRemove = (key) => {
        if (props.multiple) {
          const option = leafOptionMap.get(key);
          if (option) {
            selectMultiple(option, false);
          } else {
            const values = [];
            computedValueMap.value.forEach((value, _key) => {
              if (_key !== key) {
                values.push(value);
              }
            });
            updateValue(values);
          }
        }
      };
      const selectSingle = (option) => {
        updateValue([props.pathMode ? option.pathValue : option.value]);
        handlePopupVisibleChange(false);
      };
      const selectMultiple = (option, checked) => {
        if (checked) {
          const leafOptionInfos = props.checkStrictly ? [option] : getLeafOptionInfos(option);
          updateValue([
            ...computedValueMap.value.values(),
            ...leafOptionInfos.filter((item) => !computedValueMap.value.has(item.key)).map((item) => {
              return props.pathMode ? item.pathValue : item.value;
            })
          ]);
        } else {
          const leafOptionKeys = props.checkStrictly ? [option.key] : getLeafOptionKeys(option);
          const values = [];
          computedValueMap.value.forEach((value, key) => {
            if (!leafOptionKeys.includes(key)) {
              values.push(value);
            }
          });
          updateValue(values);
        }
        handleInputValueChange("", "optionChecked");
      };
      const handleClickOption = (option, checked) => {
        if (props.multiple) {
          selectMultiple(option, checked != null ? checked : true);
        } else {
          selectSingle(option);
        }
      };
      const handleSearch = debounce((value) => {
        emit("search", value);
      }, props.searchDelay);
      const handleInputValueChange = (value, reason) => {
        if (value !== computedInputValue.value) {
          if (reason === "manual" && !computedPopupVisible.value) {
            _popupVisible.value = true;
            emit("popupVisibleChange", true);
          }
          _inputValue.value = value;
          emit("inputValueChange", value);
          if (props.allowSearch) {
            handleSearch(value);
          }
        }
      };
      vue.watch(computedPopupVisible, (value) => {
        if (value) {
          if (computedValueMap.value.size > 0) {
            const keys = Array.from(computedValueMap.value.keys());
            const lastKey = keys[keys.length - 1];
            const option = leafOptionMap.get(lastKey);
            if (option && option.key !== activeKey.value) {
              setSelectedPath(option.key);
              setActiveKey(option.key);
            }
          }
        } else {
          if (computedValueMap.value.size === 0) {
            setSelectedPath();
            setActiveKey();
          }
          handleInputValueChange("", "optionListHide");
        }
      });
      const handleClear = (e2) => {
        e2.stopPropagation();
        if (props.multiple) {
          const newValues = [];
          computedValueMap.value.forEach((value, key) => {
            const option = leafOptionMap.get(key);
            if (option == null ? void 0 : option.disabled) {
              newValues.push(props.pathMode ? option.pathValue : option.value);
            }
          });
          updateValue(newValues);
        } else {
          updateValue([]);
        }
        handleInputValueChange("", "manual");
        emit("clear");
      };
      const showSearchPanel = vue.computed(() => props.allowSearch && computedInputValue.value.length > 0);
      const handleFocus = (e2) => {
        emit("focus", e2);
      };
      const handleBlur = (e2) => {
        emit("blur", e2);
      };
      const {
        activeKey,
        activeOption,
        selectedPath,
        displayColumns,
        setActiveKey,
        setSelectedPath,
        getNextActiveNode
      } = useSelectedPath(optionInfos, {
        optionMap,
        filteredLeafOptions,
        showSearchPanel,
        expandChild
      });
      vue.provide(cascaderInjectionKey, vue.reactive({
        onClickOption: handleClickOption,
        setActiveKey,
        setSelectedPath,
        loadMore,
        expandTrigger,
        addLazyLoadOptions,
        formatLabel,
        slots,
        valueMap: computedValueMap
      }));
      const handleKeyDown = getKeyDownHandler(new Map([
        [
          KEYBOARD_KEY.ENTER,
          (ev) => {
            if (computedPopupVisible.value) {
              if (activeOption.value) {
                let checked;
                if (props.checkStrictly || activeOption.value.isLeaf) {
                  checked = !computedValueMap.value.has(activeOption.value.key);
                } else {
                  checked = !getCheckedStatus(activeOption.value, computedValueMap.value).checked;
                }
                setSelectedPath(activeOption.value.key);
                handleClickOption(activeOption.value, checked);
              }
            } else {
              handlePopupVisibleChange(true);
            }
          }
        ],
        [
          KEYBOARD_KEY.ESC,
          (ev) => {
            handlePopupVisibleChange(false);
          }
        ],
        [
          KEYBOARD_KEY.ARROW_DOWN,
          (ev) => {
            ev.preventDefault();
            const activeNode = getNextActiveNode("next");
            setActiveKey(activeNode == null ? void 0 : activeNode.key);
          }
        ],
        [
          KEYBOARD_KEY.ARROW_UP,
          (ev) => {
            ev.preventDefault();
            const activeNode = getNextActiveNode("preview");
            setActiveKey(activeNode == null ? void 0 : activeNode.key);
          }
        ],
        [
          KEYBOARD_KEY.ARROW_RIGHT,
          (ev) => {
            var _a, _b;
            if (!showSearchPanel.value) {
              ev.preventDefault();
              if ((_a = activeOption.value) == null ? void 0 : _a.children) {
                setSelectedPath(activeOption.value.key);
                setActiveKey((_b = activeOption.value.children[0]) == null ? void 0 : _b.key);
              }
            }
          }
        ],
        [
          KEYBOARD_KEY.ARROW_LEFT,
          (ev) => {
            var _a;
            if (!showSearchPanel.value) {
              ev.preventDefault();
              if ((_a = activeOption.value) == null ? void 0 : _a.parent) {
                setSelectedPath(activeOption.value.parent.key);
                setActiveKey(activeOption.value.parent.key);
              }
            }
          }
        ]
      ]));
      const selectViewValue = vue.computed(() => {
        const result = [];
        computedValueMap.value.forEach((value, key) => {
          var _a, _b;
          const option = leafOptionMap.get(key);
          if (option) {
            result.push({
              value: key,
              label: (_b = (_a = props.formatLabel) == null ? void 0 : _a.call(props, option.path.map((item) => item.raw))) != null ? _b : getOptionLabel(option),
              closable: !option.disabled,
              tagProps: option.tagProps
            });
          } else if (props.fallback) {
            const label = isFunction$1(props.fallback) ? props.fallback(value) : isArray$1(value) ? value.join(" / ") : String(value);
            result.push({
              value: key,
              label,
              closable: true
            });
          }
        });
        return result;
      });
      return {
        optionInfos,
        filteredLeafOptions,
        selectedPath,
        activeKey,
        displayColumns,
        computedInputValue,
        computedPopupVisible,
        handleClear,
        selectViewValue,
        handleInputValueChange,
        showSearchPanel,
        handlePopupVisibleChange,
        handleFocus,
        handleBlur,
        handleRemove,
        mergedDisabled,
        handleKeyDown,
        totalLevel
      };
    }
  });
  function _sfc_render$2f(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_select_view = vue.resolveComponent("select-view");
    const _component_cascader_search_panel = vue.resolveComponent("cascader-search-panel");
    const _component_base_cascader_panel = vue.resolveComponent("base-cascader-panel");
    const _component_trigger = vue.resolveComponent("trigger");
    return vue.openBlock(), vue.createBlock(_component_trigger, vue.mergeProps(_ctx.triggerProps, {
      trigger: "click",
      "animation-name": "slide-dynamic-origin",
      "auto-fit-transform-origin": "",
      "popup-visible": _ctx.computedPopupVisible,
      position: "bl",
      disabled: _ctx.mergedDisabled,
      "popup-offset": 4,
      "auto-fit-popup-width": _ctx.showSearchPanel,
      "popup-container": _ctx.popupContainer,
      "prevent-focus": true,
      "click-to-close": !_ctx.allowSearch,
      onPopupVisibleChange: _ctx.handlePopupVisibleChange
    }), {
      content: vue.withCtx(() => [
        _ctx.showSearchPanel ? (vue.openBlock(), vue.createBlock(_component_cascader_search_panel, {
          key: 0,
          options: _ctx.filteredLeafOptions,
          "active-key": _ctx.activeKey,
          multiple: _ctx.multiple,
          "check-strictly": _ctx.checkStrictly,
          loading: _ctx.loading,
          "path-label": !_ctx.searchOptionOnlyLabel
        }, vue.createSlots({ _: 2 }, [
          _ctx.$slots.empty ? {
            name: "empty",
            fn: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "empty")
            ])
          } : void 0
        ]), 1032, ["options", "active-key", "multiple", "check-strictly", "loading", "path-label"])) : (vue.openBlock(), vue.createBlock(_component_base_cascader_panel, {
          key: 1,
          "display-columns": _ctx.displayColumns,
          "selected-path": _ctx.selectedPath,
          "active-key": _ctx.activeKey,
          multiple: _ctx.multiple,
          "total-level": _ctx.totalLevel,
          "check-strictly": _ctx.checkStrictly,
          loading: _ctx.loading,
          "virtual-list-props": _ctx.virtualListProps,
          dropdown: ""
        }, vue.createSlots({ _: 2 }, [
          _ctx.$slots.empty ? {
            name: "empty",
            fn: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "empty")
            ])
          } : void 0
        ]), 1032, ["display-columns", "selected-path", "active-key", "multiple", "total-level", "check-strictly", "loading", "virtual-list-props"]))
      ]),
      default: vue.withCtx(() => [
        vue.createVNode(_component_select_view, vue.mergeProps({
          "model-value": _ctx.selectViewValue,
          "input-value": _ctx.computedInputValue,
          disabled: _ctx.mergedDisabled,
          error: _ctx.error,
          multiple: _ctx.multiple,
          "allow-clear": _ctx.allowClear,
          "allow-search": _ctx.allowSearch,
          size: _ctx.size,
          opened: _ctx.computedPopupVisible,
          placeholder: _ctx.placeholder,
          loading: _ctx.loading,
          "max-tag-count": _ctx.maxTagCount
        }, _ctx.$attrs, {
          onInputValueChange: _ctx.handleInputValueChange,
          onClear: _ctx.handleClear,
          onFocus: _ctx.handleFocus,
          onBlur: _ctx.handleBlur,
          onRemove: _ctx.handleRemove,
          onKeydown: _ctx.handleKeyDown
        }), vue.createSlots({ _: 2 }, [
          _ctx.$slots.label ? {
            name: "label",
            fn: vue.withCtx((data) => [
              vue.renderSlot(_ctx.$slots, "label", vue.normalizeProps(vue.guardReactiveProps(data)))
            ])
          } : void 0,
          _ctx.$slots.prefix ? {
            name: "prefix",
            fn: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "prefix")
            ])
          } : void 0,
          _ctx.$slots["arrow-icon"] ? {
            name: "arrow-icon",
            fn: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "arrow-icon")
            ])
          } : void 0,
          _ctx.$slots["loading-icon"] ? {
            name: "loading-icon",
            fn: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "loading-icon")
            ])
          } : void 0,
          _ctx.$slots["search-icon"] ? {
            name: "search-icon",
            fn: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "search-icon")
            ])
          } : void 0
        ]), 1040, ["model-value", "input-value", "disabled", "error", "multiple", "allow-clear", "allow-search", "size", "opened", "placeholder", "loading", "max-tag-count", "onInputValueChange", "onClear", "onFocus", "onBlur", "onRemove", "onKeydown"])
      ]),
      _: 3
    }, 16, ["popup-visible", "disabled", "auto-fit-popup-width", "popup-container", "click-to-close", "onPopupVisibleChange"]);
  }
  var _Cascader = /* @__PURE__ */ _export_sfc(_sfc_main$2g, [["render", _sfc_render$2f]]);
  const _sfc_main$2f = vue.defineComponent({
    name: "CascaderPanel",
    components: {
      BaseCascaderPanel
    },
    props: {
      pathMode: {
        type: Boolean,
        default: false
      },
      multiple: {
        type: Boolean,
        default: false
      },
      modelValue: {
        type: [String, Number, Array]
      },
      defaultValue: {
        type: [String, Number, Array],
        default: (props) => props.multiple ? [] : props.pathMode ? void 0 : ""
      },
      options: {
        type: Array,
        default: () => []
      },
      expandTrigger: {
        type: String,
        default: "click"
      },
      checkStrictly: {
        type: Boolean,
        default: false
      },
      loadMore: {
        type: Function
      },
      fieldNames: {
        type: Object
      },
      valueKey: {
        type: String,
        default: "value"
      },
      expandChild: {
        type: Boolean,
        default: false
      }
    },
    emits: {
      "update:modelValue": (value) => true,
      "change": (value) => true
    },
    setup(props, { emit, slots }) {
      const {
        options,
        checkStrictly,
        loadMore,
        modelValue,
        valueKey,
        expandChild,
        expandTrigger
      } = vue.toRefs(props);
      const _value = vue.ref(props.defaultValue);
      vue.watch(modelValue, (value) => {
        if (isUndefined(value) || isNull(value)) {
          _value.value = props.multiple ? [] : void 0;
        }
      });
      const optionInfos = vue.ref([]);
      const totalLevel = vue.ref(1);
      const optionMap = vue.reactive(new Map());
      const leafOptionMap = vue.reactive(new Map());
      const leafOptionValueMap = vue.reactive(new Map());
      const leafOptionSet = vue.reactive(new Set());
      const lazyLoadOptions = vue.reactive({});
      const addLazyLoadOptions = (children, key) => {
        lazyLoadOptions[key] = children;
      };
      const DEFAULT_FIELD_NAMES2 = {
        value: "value",
        label: "label",
        disabled: "disabled",
        children: "children",
        tagProps: "tagProps",
        render: "render",
        isLeaf: "isLeaf"
      };
      const mergedFieldNames = vue.computed(() => __spreadValues(__spreadValues({}, DEFAULT_FIELD_NAMES2), props.fieldNames));
      vue.watch([options, lazyLoadOptions, mergedFieldNames], ([_options, _lazyLoadOptions, _fieldNames]) => {
        optionMap.clear();
        leafOptionMap.clear();
        leafOptionValueMap.clear();
        leafOptionSet.clear();
        optionInfos.value = getOptionInfos(_options != null ? _options : [], {
          enabledLazyLoad: Boolean(props.loadMore),
          lazyLoadOptions: _lazyLoadOptions,
          optionMap,
          leafOptionSet,
          leafOptionMap,
          leafOptionValueMap,
          totalLevel,
          checkStrictly,
          fieldNames: _fieldNames,
          valueKey
        });
      }, {
        immediate: true
      });
      const computedValueMap = vue.computed(() => {
        var _a;
        const values = getValidValues((_a = props.modelValue) != null ? _a : _value.value, {
          multiple: props.multiple,
          pathMode: props.pathMode
        });
        return new Map(values.map((value) => [
          getValueKey(value, {
            valueKey: props.valueKey,
            leafOptionValueMap
          }),
          value
        ]));
      });
      const filteredLeafOptions = vue.computed(() => props.checkStrictly ? Array.from(optionMap.values()) : Array.from(leafOptionSet));
      const updateValue = (values) => {
        var _a;
        const value = props.multiple ? values : (_a = values[0]) != null ? _a : "";
        if (values.length === 0) {
          setSelectedPath();
          setActiveKey();
        }
        _value.value = value;
        emit("update:modelValue", value);
        emit("change", value);
      };
      const selectSingle = (option) => {
        updateValue([props.pathMode ? option.pathValue : option.value]);
      };
      const selectMultiple = (option, checked) => {
        if (checked) {
          const leafOptionInfos = props.checkStrictly ? [option] : getLeafOptionInfos(option);
          updateValue([
            ...computedValueMap.value.values(),
            ...leafOptionInfos.filter((item) => !computedValueMap.value.has(item.key)).map((item) => {
              return props.pathMode ? item.pathValue : item.value;
            })
          ]);
        } else {
          const leafOptionKeys = props.checkStrictly ? [option.key] : getLeafOptionKeys(option);
          const values = [];
          computedValueMap.value.forEach((value, key) => {
            if (!leafOptionKeys.includes(key)) {
              values.push(value);
            }
          });
          updateValue(values);
        }
      };
      const handleClickOption = (option, checked) => {
        if (props.multiple) {
          selectMultiple(option, checked != null ? checked : true);
        } else {
          selectSingle(option);
        }
      };
      const {
        activeKey,
        activeOption,
        selectedPath,
        displayColumns,
        setActiveKey,
        setSelectedPath,
        getNextActiveNode
      } = useSelectedPath(optionInfos, {
        optionMap,
        filteredLeafOptions,
        expandChild
      });
      vue.provide(cascaderInjectionKey, vue.reactive({
        onClickOption: handleClickOption,
        setActiveKey,
        setSelectedPath,
        loadMore,
        addLazyLoadOptions,
        slots,
        valueMap: computedValueMap,
        expandTrigger
      }));
      const handleKeyDown = getKeyDownHandler(new Map([
        [
          KEYBOARD_KEY.ENTER,
          (ev) => {
            if (activeOption.value) {
              let checked;
              if (props.checkStrictly || activeOption.value.isLeaf) {
                checked = !computedValueMap.value.has(activeOption.value.key);
              } else {
                checked = !getCheckedStatus(activeOption.value, computedValueMap.value).checked;
              }
              setSelectedPath(activeOption.value.key);
              handleClickOption(activeOption.value, checked);
            }
          }
        ],
        [
          KEYBOARD_KEY.ARROW_DOWN,
          (ev) => {
            ev.preventDefault();
            const activeNode = getNextActiveNode("next");
            setActiveKey(activeNode == null ? void 0 : activeNode.key);
          }
        ],
        [
          KEYBOARD_KEY.ARROW_UP,
          (ev) => {
            ev.preventDefault();
            const activeNode = getNextActiveNode("preview");
            setActiveKey(activeNode == null ? void 0 : activeNode.key);
          }
        ],
        [
          KEYBOARD_KEY.ARROW_RIGHT,
          (ev) => {
            var _a, _b;
            ev.preventDefault();
            if ((_a = activeOption.value) == null ? void 0 : _a.children) {
              setSelectedPath(activeOption.value.key);
              setActiveKey((_b = activeOption.value.children[0]) == null ? void 0 : _b.key);
            }
          }
        ],
        [
          KEYBOARD_KEY.ARROW_LEFT,
          (ev) => {
            var _a;
            ev.preventDefault();
            if ((_a = activeOption.value) == null ? void 0 : _a.parent) {
              setSelectedPath(activeOption.value.parent.key);
              setActiveKey(activeOption.value.parent.key);
            }
          }
        ]
      ]));
      return {
        optionInfos,
        filteredLeafOptions,
        selectedPath,
        activeKey,
        displayColumns,
        handleKeyDown,
        totalLevel
      };
    }
  });
  function _sfc_render$2e(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_base_cascader_panel = vue.resolveComponent("base-cascader-panel");
    return vue.openBlock(), vue.createBlock(_component_base_cascader_panel, {
      "display-columns": _ctx.displayColumns,
      "selected-path": _ctx.selectedPath,
      "active-key": _ctx.activeKey,
      multiple: _ctx.multiple,
      "total-level": _ctx.totalLevel,
      "check-strictly": _ctx.checkStrictly,
      onKeydown: _ctx.handleKeyDown
    }, vue.createSlots({ _: 2 }, [
      _ctx.$slots.empty ? {
        name: "empty",
        fn: vue.withCtx(() => [
          vue.renderSlot(_ctx.$slots, "empty")
        ])
      } : void 0
    ]), 1032, ["display-columns", "selected-path", "active-key", "multiple", "total-level", "check-strictly", "onKeydown"]);
  }
  var CascaderPanel = /* @__PURE__ */ _export_sfc(_sfc_main$2f, [["render", _sfc_render$2e]]);
  const Cascader = Object.assign(_Cascader, {
    CascaderPanel,
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Cascader.name, _Cascader);
      app.component(componentPrefix + CascaderPanel.name, CascaderPanel);
    }
  });
  const collapseKey = Symbol("collapseCtx");
  const _sfc_main$2e = vue.defineComponent({
    name: "Collapse",
    props: {
      activeKey: {
        type: Array,
        default: void 0
      },
      defaultActiveKey: {
        type: Array,
        default: () => []
      },
      accordion: {
        type: Boolean,
        default: false
      },
      showExpandIcon: {
        type: Boolean,
        default: void 0
      },
      expandIconPosition: {
        type: String,
        default: "left"
      },
      bordered: {
        type: Boolean,
        default: true
      },
      destroyOnHide: {
        type: Boolean,
        default: false
      }
    },
    emits: {
      "update:activeKey": (activeKey) => true,
      "change": (activeKey, ev) => true
    },
    setup(props, { emit, slots }) {
      const { expandIconPosition, destroyOnHide, showExpandIcon } = vue.toRefs(props);
      const prefixCls = getPrefixCls("collapse");
      const _activeKey = vue.ref(props.defaultActiveKey);
      const computedActiveKeys = vue.computed(() => {
        var _a;
        const activeKey = (_a = props.activeKey) != null ? _a : _activeKey.value;
        if (!isArray$1(activeKey)) {
          return [activeKey];
        }
        return activeKey;
      });
      const handleClick = (key, e2) => {
        let newActiveKeys = [];
        if (props.accordion) {
          if (!computedActiveKeys.value.includes(key)) {
            newActiveKeys = [key];
          }
          _activeKey.value = newActiveKeys;
        } else {
          newActiveKeys = [...computedActiveKeys.value];
          const _index = newActiveKeys.indexOf(key);
          if (_index > -1) {
            newActiveKeys.splice(_index, 1);
          } else if (props.accordion) {
            newActiveKeys = [key];
          } else {
            newActiveKeys.push(key);
          }
          _activeKey.value = newActiveKeys;
        }
        emit("update:activeKey", newActiveKeys);
        emit("change", newActiveKeys, e2);
      };
      vue.provide(collapseKey, vue.reactive({
        activeKeys: computedActiveKeys,
        slots,
        showExpandIcon,
        expandIconPosition,
        destroyOnHide,
        handleClick
      }));
      const cls = vue.computed(() => [
        prefixCls,
        {
          [`${prefixCls}-borderless`]: !props.bordered
        }
      ]);
      return {
        prefixCls,
        cls
      };
    }
  });
  function _sfc_render$2d(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.cls)
    }, [
      vue.renderSlot(_ctx.$slots, "default")
    ], 2);
  }
  var _Collapse = /* @__PURE__ */ _export_sfc(_sfc_main$2e, [["render", _sfc_render$2d]]);
  const _sfc_main$2d = vue.defineComponent({
    name: "IconCaretRight",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-caret-right`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$Y = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$L = /* @__PURE__ */ vue.createElementVNode("path", {
    d: "M34.829 23.063c.6.48.6 1.394 0 1.874L17.949 38.44c-.785.629-1.949.07-1.949-.937V10.497c0-1.007 1.164-1.566 1.95-.937l16.879 13.503Z",
    fill: "currentColor",
    stroke: "none"
  }, null, -1);
  const _hoisted_3$I = [
    _hoisted_2$L
  ];
  function _sfc_render$2c(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$I, 14, _hoisted_1$Y);
  }
  var _IconCaretRight = /* @__PURE__ */ _export_sfc(_sfc_main$2d, [["render", _sfc_render$2c]]);
  const IconCaretRight = Object.assign(_IconCaretRight, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconCaretRight.name, _IconCaretRight);
    }
  });
  const _sfc_main$2c = vue.defineComponent({
    name: "IconCaretLeft",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-caret-left`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$X = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$K = /* @__PURE__ */ vue.createElementVNode("path", {
    d: "M13.171 24.937a1.2 1.2 0 0 1 0-1.874L30.051 9.56c.785-.629 1.949-.07 1.949.937v27.006c0 1.006-1.164 1.566-1.95.937L13.171 24.937Z",
    fill: "currentColor",
    stroke: "none"
  }, null, -1);
  const _hoisted_3$H = [
    _hoisted_2$K
  ];
  function _sfc_render$2b(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$H, 14, _hoisted_1$X);
  }
  var _IconCaretLeft = /* @__PURE__ */ _export_sfc(_sfc_main$2c, [["render", _sfc_render$2b]]);
  const IconCaretLeft = Object.assign(_IconCaretLeft, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconCaretLeft.name, _IconCaretLeft);
    }
  });
  var CollapseItem = vue.defineComponent({
    name: "CollapseItem",
    components: {
      IconHover,
      IconCaretRight,
      IconCaretLeft
    },
    props: {
      key: [String, Number],
      header: String,
      disabled: {
        type: Boolean,
        default: false
      },
      showExpandIcon: {
        type: Boolean,
        default: true
      },
      destroyOnHide: {
        type: Boolean,
        default: false
      }
    },
    setup(props, {
      slots
    }) {
      var _a;
      const instance = vue.getCurrentInstance();
      const prefixCls = getPrefixCls("collapse-item");
      const collapseCtx = vue.inject(collapseKey, {});
      const key = instance && isNumber$1(instance == null ? void 0 : instance.vnode.key) ? instance.vnode.key : String((_a = instance == null ? void 0 : instance.vnode.key) != null ? _a : "");
      const isActive = vue.computed(() => {
        var _a2;
        return (_a2 = collapseCtx.activeKeys) == null ? void 0 : _a2.includes(key);
      });
      const mergedDestroyOnHide = vue.computed(() => collapseCtx.destroyOnHide || props.destroyOnHide);
      const mergedShowExpandIcon = vue.computed(() => {
        var _a2;
        return (_a2 = collapseCtx == null ? void 0 : collapseCtx.showExpandIcon) != null ? _a2 : props.showExpandIcon;
      });
      const mounted = vue.ref(mergedDestroyOnHide.value ? isActive.value : true);
      const expandIconPosition = vue.computed(() => {
        var _a2;
        return (_a2 = collapseCtx == null ? void 0 : collapseCtx.expandIconPosition) != null ? _a2 : "left";
      });
      const handleClick = (e2) => {
        var _a2;
        if (!props.disabled) {
          (_a2 = collapseCtx.handleClick) == null ? void 0 : _a2.call(collapseCtx, key, e2);
        }
      };
      vue.watch(isActive, (isActive2) => {
        if (isActive2 && !mounted.value) {
          mounted.value = true;
        }
      });
      const transitionEvents = {
        onEnter: (el) => {
          el.style.height = `${el.scrollHeight}px`;
        },
        onAfterEnter: (el) => {
          el.style.height = "auto";
        },
        onBeforeLeave: (el) => {
          el.style.height = `${el.scrollHeight}px`;
        },
        onLeave: (el) => {
          el.style.height = "0";
        },
        onAfterLeave: () => {
          if (mergedDestroyOnHide.value) {
            mounted.value = false;
          }
        }
      };
      const cls = vue.computed(() => [prefixCls, {
        [`${prefixCls}-active`]: isActive.value
      }]);
      const headerCls = vue.computed(() => [`${prefixCls}-header`, `${prefixCls}-header-${collapseCtx == null ? void 0 : collapseCtx.expandIconPosition}`, {
        [`${prefixCls}-header-disabled`]: props.disabled
      }]);
      const iconCls = vue.computed(() => [{
        [`${prefixCls}-icon-right`]: (collapseCtx == null ? void 0 : collapseCtx.expandIconPosition) === "right"
      }]);
      const contentCls = vue.computed(() => [`${prefixCls}-content`, {
        [`${prefixCls}-content-expend`]: isActive.value
      }]);
      const defaultExpandIcon = () => expandIconPosition.value === "right" ? vue.createVNode(vue.resolveComponent("icon-caret-left"), {
        "class": `${prefixCls}-expand-icon`
      }, null) : vue.createVNode(vue.resolveComponent("icon-caret-right"), {
        "class": `${prefixCls}-expand-icon`
      }, null);
      const expandIconRender = () => mergedShowExpandIcon.value && vue.createVNode(vue.resolveComponent("icon-hover"), {
        "prefix": prefixCls,
        "class": iconCls.value,
        "disabled": props.disabled
      }, {
        default: () => {
          var _a2, _b, _c, _d;
          return [(_d = (_c = (_b = slots["expand-icon"]) != null ? _b : (_a2 = collapseCtx == null ? void 0 : collapseCtx.slots) == null ? void 0 : _a2["expand-icon"]) == null ? void 0 : _c({
            active: isActive.value,
            disabled: props.disabled,
            position: expandIconPosition.value
          })) != null ? _d : defaultExpandIcon()];
        }
      });
      return () => {
        var _a2, _b, _c;
        return vue.createVNode("div", {
          "class": cls.value
        }, [vue.createVNode("div", {
          "role": "button",
          "aria-disabled": props.disabled,
          "aria-expanded": isActive.value,
          "tabindex": "0",
          "class": headerCls.value,
          "onClick": handleClick
        }, [expandIconRender(), vue.createVNode("div", {
          "class": `${prefixCls}-header-title`
        }, [(_b = (_a2 = slots.header) == null ? void 0 : _a2.call(slots)) != null ? _b : props.header]), slots.extra && vue.createVNode("div", {
          "class": `${prefixCls}-header-extra`
        }, [(_c = slots.extra) == null ? void 0 : _c.call(slots)])]), vue.createVNode(vue.Transition, vue.mergeProps({
          "name": "collapse-slider"
        }, transitionEvents), {
          default: () => {
            var _a3;
            return [vue.withDirectives(vue.createVNode("div", {
              "role": "region",
              "class": contentCls.value
            }, [mounted.value && vue.createVNode("div", {
              "ref": "contentBoxRef",
              "class": `${prefixCls}-content-box`
            }, [(_a3 = slots.default) == null ? void 0 : _a3.call(slots)])]), [[vue.vShow, isActive.value]])];
          }
        })]);
      };
    }
  });
  const Collapse = Object.assign(_Collapse, {
    Item: CollapseItem,
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Collapse.name, _Collapse);
      app.component(componentPrefix + CollapseItem.name, CollapseItem);
    }
  });
  function hasPropOrSlot(props, slots, propName) {
    return vue.computed(() => Boolean(props[propName] || slots[propName]));
  }
  const _sfc_main$2b = vue.defineComponent({
    name: "Comment",
    props: {
      author: {
        type: String
      },
      avatar: {
        type: String
      },
      content: {
        type: String
      },
      datetime: {
        type: String
      },
      align: {
        type: [String, Object],
        default: "left"
      }
    },
    setup(props, { slots }) {
      const prefixCls = getPrefixCls("comment");
      const [hasAuthor, hasAvatar, hasContent, hasDatetime] = [
        "author",
        "avatar",
        "content",
        "datetime"
      ].map((propName) => hasPropOrSlot(props, slots, propName));
      const computedAlign = vue.computed(() => {
        const { align } = props;
        return __spreadValues({}, isString$1(align) ? {
          datetime: align,
          actions: align
        } : align);
      });
      return {
        prefixCls,
        hasAuthor,
        hasAvatar,
        hasContent,
        hasDatetime,
        computedAlign
      };
    }
  });
  const _hoisted_1$W = ["src"];
  const _hoisted_2$J = { key: 0 };
  const _hoisted_3$G = { key: 0 };
  const _hoisted_4$c = { key: 0 };
  function _sfc_render$2a(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.prefixCls)
    }, [
      _ctx.hasAvatar ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: vue.normalizeClass(`${_ctx.prefixCls}-avatar`)
      }, [
        _ctx.avatar ? (vue.openBlock(), vue.createElementBlock("img", {
          key: 0,
          src: _ctx.avatar,
          alt: "comment-avatar"
        }, null, 8, _hoisted_1$W)) : vue.renderSlot(_ctx.$slots, "avatar", { key: 1 })
      ], 2)) : vue.createCommentVNode("v-if", true),
      vue.createElementVNode("div", {
        class: vue.normalizeClass(`${_ctx.prefixCls}-inner`)
      }, [
        vue.createElementVNode("div", {
          class: vue.normalizeClass(`${_ctx.prefixCls}-inner-content`)
        }, [
          _ctx.hasAuthor || _ctx.hasDatetime ? (vue.openBlock(), vue.createElementBlock("div", {
            key: 0,
            class: vue.normalizeClass(`${_ctx.prefixCls}-title ${_ctx.prefixCls}-title-align-${_ctx.computedAlign.datetime}`)
          }, [
            _ctx.hasAuthor ? (vue.openBlock(), vue.createElementBlock("span", {
              key: 0,
              class: vue.normalizeClass(`${_ctx.prefixCls}-author`)
            }, [
              _ctx.author ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_2$J, vue.toDisplayString(_ctx.author), 1)) : vue.renderSlot(_ctx.$slots, "author", { key: 1 })
            ], 2)) : vue.createCommentVNode("v-if", true),
            _ctx.hasDatetime ? (vue.openBlock(), vue.createElementBlock("span", {
              key: 1,
              class: vue.normalizeClass(`${_ctx.prefixCls}-datetime`)
            }, [
              _ctx.datetime ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_3$G, vue.toDisplayString(_ctx.datetime), 1)) : vue.renderSlot(_ctx.$slots, "datetime", { key: 1 })
            ], 2)) : vue.createCommentVNode("v-if", true)
          ], 2)) : vue.createCommentVNode("v-if", true),
          _ctx.hasContent ? (vue.openBlock(), vue.createElementBlock("div", {
            key: 1,
            class: vue.normalizeClass(`${_ctx.prefixCls}-content`)
          }, [
            _ctx.content ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_4$c, vue.toDisplayString(_ctx.content), 1)) : vue.renderSlot(_ctx.$slots, "content", { key: 1 })
          ], 2)) : vue.createCommentVNode("v-if", true),
          _ctx.$slots.actions ? (vue.openBlock(), vue.createElementBlock("div", {
            key: 2,
            class: vue.normalizeClass(`${_ctx.prefixCls}-actions ${_ctx.prefixCls}-actions-align-${_ctx.computedAlign.actions}`)
          }, [
            vue.renderSlot(_ctx.$slots, "actions")
          ], 2)) : vue.createCommentVNode("v-if", true)
        ], 2),
        _ctx.$slots.default ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 0,
          class: vue.normalizeClass(`${_ctx.prefixCls}-inner-comment`)
        }, [
          vue.renderSlot(_ctx.$slots, "default")
        ], 2)) : vue.createCommentVNode("v-if", true)
      ], 2)
    ], 2);
  }
  var _Comment = /* @__PURE__ */ _export_sfc(_sfc_main$2b, [["render", _sfc_render$2a]]);
  const Comment = Object.assign(_Comment, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Comment.name, _Comment);
    }
  });
  const _sfc_main$2a = vue.defineComponent({
    name: "ConfigProvider",
    props: {
      prefixCls: {
        type: String,
        default: "arco"
      },
      locale: {
        type: Object
      },
      size: {
        type: String
      },
      global: {
        type: Boolean,
        default: false
      },
      updateAtScroll: {
        type: Boolean,
        default: false
      },
      scrollToClose: {
        type: Boolean,
        default: false
      },
      exchangeTime: {
        type: Boolean,
        default: true
      }
    },
    setup(props, { slots }) {
      const {
        prefixCls,
        locale,
        size,
        updateAtScroll,
        scrollToClose,
        exchangeTime
      } = vue.toRefs(props);
      const config = vue.reactive({
        slots,
        prefixCls,
        locale,
        size,
        updateAtScroll,
        scrollToClose,
        exchangeTime
      });
      if (props.global) {
        const instance = vue.getCurrentInstance();
        if (instance) {
          instance.appContext.app.provide(configProviderInjectionKey, config);
        }
      } else {
        vue.provide(configProviderInjectionKey, config);
      }
    }
  });
  function _sfc_render$29(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.renderSlot(_ctx.$slots, "default");
  }
  var _ConfigProvider = /* @__PURE__ */ _export_sfc(_sfc_main$2a, [["render", _sfc_render$29]]);
  const ConfigProvider = Object.assign(_ConfigProvider, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _ConfigProvider.name, _ConfigProvider);
    }
  });
  function useState(defaultValue) {
    const value = vue.ref(defaultValue);
    const setValue = (newValue) => {
      value.value = newValue;
    };
    return [value, setValue];
  }
  function usePickerState(props) {
    const { modelValue, defaultValue, format } = vue.toRefs(props);
    const computedModelValue = vue.computed(() => {
      return getDayjsValue(modelValue.value, format.value);
    });
    const computedDefaultValue = vue.computed(() => {
      return getDayjsValue(defaultValue.value, format.value);
    });
    const [localValue, setLocalValue] = useState(!isUndefined(computedModelValue.value) ? computedModelValue.value : !isUndefined(computedDefaultValue.value) ? computedDefaultValue.value : void 0);
    vue.watch(computedModelValue, () => {
      if (isUndefined(computedModelValue.value)) {
        setLocalValue(void 0);
      }
    });
    const mergeValue = vue.computed(() => computedModelValue.value || localValue.value);
    return {
      value: mergeValue,
      setValue: setLocalValue
    };
  }
  const _sfc_main$29 = vue.defineComponent({
    name: "DateInput",
    components: {
      IconHover,
      IconClose,
      FeedbackIcon
    },
    props: {
      size: {
        type: String
      },
      focused: {
        type: Boolean
      },
      disabled: {
        type: Boolean
      },
      readonly: {
        type: Boolean
      },
      error: {
        type: Boolean
      },
      allowClear: {
        type: Boolean
      },
      placeholder: {
        type: String
      },
      inputValue: {
        type: String
      },
      value: {
        type: Object
      },
      format: {
        type: [String, Function],
        required: true
      }
    },
    emits: ["clear", "press-enter", "change", "blur"],
    setup(props, { emit, slots }) {
      const { error, focused, disabled, size, value, format, inputValue } = vue.toRefs(props);
      const {
        mergedSize: _mergedSize,
        mergedDisabled,
        mergedError,
        feedback
      } = useFormItem({ size, disabled, error });
      const { mergedSize } = useSize$1(_mergedSize);
      const prefixCls = getPrefixCls("picker");
      const classNames = vue.computed(() => [
        prefixCls,
        `${prefixCls}-size-${mergedSize.value}`,
        {
          [`${prefixCls}-focused`]: focused.value,
          [`${prefixCls}-disabled`]: mergedDisabled.value,
          [`${prefixCls}-error`]: mergedError.value,
          [`${prefixCls}-has-prefix`]: slots.prefix
        }
      ]);
      const displayValue = vue.computed(() => {
        if (inputValue == null ? void 0 : inputValue.value)
          return inputValue == null ? void 0 : inputValue.value;
        if ((value == null ? void 0 : value.value) && isDayjs(value.value)) {
          return isFunction$1(format.value) ? format.value(value.value) : value.value.format(format.value);
        }
        return void 0;
      });
      const refInput = vue.ref();
      return {
        feedback,
        prefixCls,
        classNames,
        displayValue,
        mergedDisabled,
        refInput,
        onPressEnter() {
          emit("press-enter");
        },
        onChange(e2) {
          emit("change", e2);
        },
        onClear(e2) {
          emit("clear", e2);
        },
        onBlur(e2) {
          emit("blur", e2);
        }
      };
    },
    methods: {
      focus() {
        this.refInput && this.refInput.focus && this.refInput.focus();
      },
      blur() {
        this.refInput && this.refInput.blur && this.refInput.blur();
      }
    }
  });
  const _hoisted_1$V = ["disabled", "placeholder", "value"];
  function _sfc_render$28(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_IconClose = vue.resolveComponent("IconClose");
    const _component_IconHover = vue.resolveComponent("IconHover");
    const _component_FeedbackIcon = vue.resolveComponent("FeedbackIcon");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.classNames)
    }, [
      _ctx.$slots.prefix ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: vue.normalizeClass(`${_ctx.prefixCls}-prefix`)
      }, [
        vue.renderSlot(_ctx.$slots, "prefix")
      ], 2)) : vue.createCommentVNode("v-if", true),
      vue.createElementVNode("div", {
        class: vue.normalizeClass(`${_ctx.prefixCls}-input`)
      }, [
        vue.createElementVNode("input", vue.mergeProps({
          ref: "refInput",
          disabled: _ctx.mergedDisabled,
          placeholder: _ctx.placeholder,
          class: `${_ctx.prefixCls}-start-time`,
          value: _ctx.displayValue
        }, _ctx.readonly ? { readonly: true } : {}, {
          onKeydown: _cache[0] || (_cache[0] = vue.withKeys((...args) => _ctx.onPressEnter && _ctx.onPressEnter(...args), ["enter"])),
          onInput: _cache[1] || (_cache[1] = (...args) => _ctx.onChange && _ctx.onChange(...args)),
          onBlur: _cache[2] || (_cache[2] = (...args) => _ctx.onBlur && _ctx.onBlur(...args))
        }), null, 16, _hoisted_1$V)
      ], 2),
      vue.createElementVNode("div", {
        class: vue.normalizeClass(`${_ctx.prefixCls}-suffix`)
      }, [
        _ctx.allowClear && !_ctx.mergedDisabled && _ctx.displayValue ? (vue.openBlock(), vue.createBlock(_component_IconHover, {
          key: 0,
          prefix: _ctx.prefixCls,
          class: vue.normalizeClass(`${_ctx.prefixCls}-clear-icon`),
          onClick: _ctx.onClear
        }, {
          default: vue.withCtx(() => [
            vue.createVNode(_component_IconClose)
          ]),
          _: 1
        }, 8, ["prefix", "class", "onClick"])) : vue.createCommentVNode("v-if", true),
        vue.createElementVNode("span", {
          class: vue.normalizeClass(`${_ctx.prefixCls}-suffix-icon`)
        }, [
          vue.renderSlot(_ctx.$slots, "suffix-icon")
        ], 2),
        _ctx.feedback ? (vue.openBlock(), vue.createBlock(_component_FeedbackIcon, {
          key: 1,
          type: _ctx.feedback
        }, null, 8, ["type"])) : vue.createCommentVNode("v-if", true)
      ], 2)
    ], 2);
  }
  var DateInput = /* @__PURE__ */ _export_sfc(_sfc_main$29, [["render", _sfc_render$28]]);
  function getColumnsFromFormat(format) {
    const units2 = ["H", "h", "m", "s", "a", "A"];
    const list = [];
    let use12Hours = false;
    units2.forEach((unit) => {
      if (format.indexOf(unit) !== -1) {
        list.push(unit);
        if (unit === "a" || unit === "A") {
          use12Hours = true;
        }
      }
    });
    return {
      list,
      use12Hours
    };
  }
  const scrollIds = new Map();
  function scrollTo(element, to, duration) {
    const scrollId = scrollIds.get(element);
    if (!isUndefined(scrollId)) {
      cancelAnimationFrame(scrollId);
    }
    if (duration <= 0) {
      element.scrollTop = to;
    }
    scrollIds.set(element, requestAnimationFrame(() => {
      const tween = new Tween({
        from: { scrollTop: element.scrollTop },
        to: { scrollTop: to },
        duration,
        onUpdate: (keys) => {
          element.scrollTop = keys.scrollTop;
        }
      });
      tween.start();
    }));
  }
  function getFormattedValue(time, format) {
    const formatValue = (time2) => {
      if (isArray$1(time2)) {
        return time2.map((t2) => formatValue(t2));
      }
      if (isUndefined(time2))
        return void 0;
      return time2.format(format);
    };
    return formatValue(time);
  }
  function isValidRangeValue$1(value) {
    if (isUndefined(value))
      return true;
    if (!isArray$1(value))
      return false;
    return value.length === 0 || value.length === 2 && isDayjs(value[0]) && isDayjs(value[1]);
  }
  function isValidInputValue(time, format) {
    if (!time)
      return false;
    return typeof time === "string" && dayjs(time, format).format(format) === time;
  }
  function isDisabledTime(value, {
    disabledHours,
    disabledMinutes,
    disabledSeconds
  }) {
    if (!value)
      return false;
    const hour = value.hour();
    const minute = value.minute();
    const second = value.second();
    const disabledHourList = (disabledHours == null ? void 0 : disabledHours()) || [];
    const disabledMinuteList = (disabledMinutes == null ? void 0 : disabledMinutes(hour)) || [];
    const disabledSecondList = (disabledSeconds == null ? void 0 : disabledSeconds(hour, minute)) || [];
    const isDisabledItem = (num, disabledList) => {
      return !isUndefined(num) && disabledList.includes(num);
    };
    return isDisabledItem(hour, disabledHourList) || isDisabledItem(minute, disabledMinuteList) || isDisabledItem(second, disabledSecondList);
  }
  var RenderFunction = vue.defineComponent({
    name: "RenderFunction",
    props: {
      renderFunc: {
        type: Function,
        required: true
      }
    },
    render() {
      return this.renderFunc(this.$attrs);
    }
  });
  const PickerInjectionKey = Symbol("PickerInjectionKey");
  function useDatePickerTransform$1() {
    const { datePickerT } = vue.inject(PickerInjectionKey) || {};
    return datePickerT || ((key, ...args) => key);
  }
  const _sfc_main$28 = vue.defineComponent({
    name: "PanelShortcuts",
    components: {
      Button,
      RenderFunction
    },
    props: {
      prefixCls: {
        type: String,
        required: true
      },
      shortcuts: {
        type: Array,
        default: () => []
      },
      showNowBtn: {
        type: Boolean
      }
    },
    emits: ["item-click", "item-mouse-enter", "item-mouse-leave", "now-click"],
    setup(props, { emit }) {
      const datePickerT = useDatePickerTransform$1();
      return {
        datePickerT,
        onItemClick: (item) => {
          emit("item-click", item);
        },
        onItemMouseEnter: (item) => {
          emit("item-mouse-enter", item);
        },
        onItemMouseLeave: (item) => {
          emit("item-mouse-leave", item);
        },
        onNowClick: () => {
          emit("now-click");
        },
        isFunction: isFunction$1
      };
    }
  });
  function _sfc_render$27(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Button = vue.resolveComponent("Button");
    const _component_RenderFunction = vue.resolveComponent("RenderFunction");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(`${_ctx.prefixCls}-shortcuts`)
    }, [
      _ctx.showNowBtn ? (vue.openBlock(), vue.createBlock(_component_Button, {
        key: 0,
        size: "mini",
        onClick: _cache[0] || (_cache[0] = () => _ctx.onNowClick())
      }, {
        default: vue.withCtx(() => [
          vue.createTextVNode(vue.toDisplayString(_ctx.datePickerT("datePicker.now")), 1)
        ]),
        _: 1
      })) : vue.createCommentVNode("v-if", true),
      (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.shortcuts, (item, index2) => {
        return vue.openBlock(), vue.createBlock(_component_Button, {
          key: index2,
          size: "mini",
          onClick: () => _ctx.onItemClick(item),
          onMouseenter: () => _ctx.onItemMouseEnter(item),
          onMouseleave: () => _ctx.onItemMouseLeave(item)
        }, {
          default: vue.withCtx(() => [
            _ctx.isFunction(item.label) ? (vue.openBlock(), vue.createBlock(_component_RenderFunction, {
              key: 0,
              "render-func": item.label
            }, null, 8, ["render-func"])) : (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 1 }, [
              vue.createTextVNode(vue.toDisplayString(item.label), 1)
            ], 2112))
          ]),
          _: 2
        }, 1032, ["onClick", "onMouseenter", "onMouseleave"]);
      }), 128))
    ], 2);
  }
  var PanelShortcuts = /* @__PURE__ */ _export_sfc(_sfc_main$28, [["render", _sfc_render$27]]);
  function newArray(length) {
    return [...Array(length)];
  }
  function normalizeRangeValue(value) {
    if (isUndefined(value)) {
      return void 0;
    }
    return isArray$1(value) ? value : [value, void 0];
  }
  function isCompleteRangeValue(value) {
    return !!value && isDayjs(value[0]) && isDayjs(value[1]);
  }
  function isValidRangeValue(value) {
    return isUndefined(value) || value.length === 0 || isCompleteRangeValue(value);
  }
  function mergeValueWithTime(defaultValue, dateValue, timeValue) {
    const dateVal = dateValue || defaultValue;
    const timeVal = timeValue || defaultValue;
    return timeVal.set("year", dateVal.year()).set("month", dateVal.month()).set("date", dateVal.date());
  }
  const _sfc_main$27 = vue.defineComponent({
    name: "IconDoubleLeft",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-double-left`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$U = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$I = /* @__PURE__ */ vue.createElementVNode("path", { d: "M36.857 9.9 22.715 24.042l14.142 14.142M25.544 9.9 11.402 24.042l14.142 14.142" }, null, -1);
  const _hoisted_3$F = [
    _hoisted_2$I
  ];
  function _sfc_render$26(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$F, 14, _hoisted_1$U);
  }
  var _IconDoubleLeft = /* @__PURE__ */ _export_sfc(_sfc_main$27, [["render", _sfc_render$26]]);
  const IconDoubleLeft = Object.assign(_IconDoubleLeft, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconDoubleLeft.name, _IconDoubleLeft);
    }
  });
  const _sfc_main$26 = vue.defineComponent({
    name: "IconDoubleRight",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-double-right`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$T = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$H = /* @__PURE__ */ vue.createElementVNode("path", { d: "m11.143 38.1 14.142-14.142L11.143 9.816M22.456 38.1l14.142-14.142L22.456 9.816" }, null, -1);
  const _hoisted_3$E = [
    _hoisted_2$H
  ];
  function _sfc_render$25(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$E, 14, _hoisted_1$T);
  }
  var _IconDoubleRight = /* @__PURE__ */ _export_sfc(_sfc_main$26, [["render", _sfc_render$25]]);
  const IconDoubleRight = Object.assign(_IconDoubleRight, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconDoubleRight.name, _IconDoubleRight);
    }
  });
  const _sfc_main$25 = vue.defineComponent({
    name: "PanelHeader",
    components: {
      IconLeft,
      IconRight,
      IconDoubleLeft,
      IconDoubleRight,
      RenderFunction
    },
    props: {
      prefixCls: {
        type: String,
        required: true
      },
      title: {
        type: String,
        required: true
      },
      mode: {
        type: String,
        default: "date"
      },
      value: {
        type: Object
      },
      icons: {
        type: Object
      },
      onPrev: {
        type: Function
      },
      onSuperPrev: {
        type: Function
      },
      onNext: {
        type: Function
      },
      onSuperNext: {
        type: Function
      },
      onLabelClick: {
        type: Function
      }
    },
    emits: ["label-click"],
    setup(props) {
      return {
        showPrev: vue.computed(() => isFunction$1(props.onPrev)),
        showSuperPrev: vue.computed(() => isFunction$1(props.onSuperPrev)),
        showNext: vue.computed(() => isFunction$1(props.onNext)),
        showSuperNext: vue.computed(() => isFunction$1(props.onSuperNext)),
        year: vue.computed(() => ["date", "quarter", "month", "week"].includes(props.mode) && props.value ? props.value.format("YYYY") : ""),
        month: vue.computed(() => ["date", "week"].includes(props.mode) && props.value ? props.value.format("MM") : ""),
        getIconClassName: (show) => [
          `${props.prefixCls}-header-icon`,
          {
            [`${props.prefixCls}-header-icon-hidden`]: !show
          }
        ]
      };
    }
  });
  const _hoisted_1$S = { key: 1 };
  function _sfc_render$24(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_RenderFunction = vue.resolveComponent("RenderFunction");
    const _component_IconDoubleLeft = vue.resolveComponent("IconDoubleLeft");
    const _component_IconLeft = vue.resolveComponent("IconLeft");
    const _component_IconRight = vue.resolveComponent("IconRight");
    const _component_IconDoubleRight = vue.resolveComponent("IconDoubleRight");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(`${_ctx.prefixCls}-header`)
    }, [
      vue.createElementVNode("div", {
        class: vue.normalizeClass(_ctx.getIconClassName(_ctx.showSuperPrev)),
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onSuperPrev && _ctx.onSuperPrev(...args))
      }, [
        _ctx.showSuperPrev ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
          _ctx.icons && _ctx.icons.prevDouble ? (vue.openBlock(), vue.createBlock(_component_RenderFunction, {
            key: 0,
            "render-func": _ctx.icons && _ctx.icons.prevDouble
          }, null, 8, ["render-func"])) : (vue.openBlock(), vue.createBlock(_component_IconDoubleLeft, { key: 1 }))
        ], 2112)) : vue.createCommentVNode("v-if", true)
      ], 2),
      vue.createElementVNode("div", {
        class: vue.normalizeClass(_ctx.getIconClassName(_ctx.showPrev)),
        onClick: _cache[1] || (_cache[1] = (...args) => _ctx.onPrev && _ctx.onPrev(...args))
      }, [
        _ctx.showPrev ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
          _ctx.icons && _ctx.icons.prev ? (vue.openBlock(), vue.createBlock(_component_RenderFunction, {
            key: 0,
            "render-func": _ctx.icons && _ctx.icons.prev
          }, null, 8, ["render-func"])) : (vue.openBlock(), vue.createBlock(_component_IconLeft, { key: 1 }))
        ], 2112)) : vue.createCommentVNode("v-if", true)
      ], 2),
      vue.createElementVNode("div", {
        class: vue.normalizeClass(`${_ctx.prefixCls}-header-title`)
      }, [
        _ctx.onLabelClick && (_ctx.year || _ctx.month) ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
          _ctx.year ? (vue.openBlock(), vue.createElementBlock("span", {
            key: 0,
            class: vue.normalizeClass(`${_ctx.prefixCls}-header-label`),
            onClick: _cache[2] || (_cache[2] = () => _ctx.onLabelClick && _ctx.onLabelClick("year"))
          }, vue.toDisplayString(_ctx.year), 3)) : vue.createCommentVNode("v-if", true),
          _ctx.year && _ctx.month ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_1$S, "-")) : vue.createCommentVNode("v-if", true),
          _ctx.month ? (vue.openBlock(), vue.createElementBlock("span", {
            key: 2,
            class: vue.normalizeClass(`${_ctx.prefixCls}-header-label`),
            onClick: _cache[3] || (_cache[3] = () => _ctx.onLabelClick && _ctx.onLabelClick("month"))
          }, vue.toDisplayString(_ctx.month), 3)) : vue.createCommentVNode("v-if", true)
        ], 64)) : (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 1 }, [
          vue.createTextVNode(vue.toDisplayString(_ctx.title), 1)
        ], 2112))
      ], 2),
      vue.createElementVNode("div", {
        class: vue.normalizeClass(_ctx.getIconClassName(_ctx.showNext)),
        onClick: _cache[4] || (_cache[4] = (...args) => _ctx.onNext && _ctx.onNext(...args))
      }, [
        _ctx.showNext ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
          _ctx.icons && _ctx.icons.next ? (vue.openBlock(), vue.createBlock(_component_RenderFunction, {
            key: 0,
            "render-func": _ctx.icons && _ctx.icons.next
          }, null, 8, ["render-func"])) : (vue.openBlock(), vue.createBlock(_component_IconRight, { key: 1 }))
        ], 2112)) : vue.createCommentVNode("v-if", true)
      ], 2),
      vue.createElementVNode("div", {
        class: vue.normalizeClass(_ctx.getIconClassName(_ctx.showSuperNext)),
        onClick: _cache[5] || (_cache[5] = (...args) => _ctx.onSuperNext && _ctx.onSuperNext(...args))
      }, [
        _ctx.showSuperNext ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
          _ctx.icons && _ctx.icons.nextDouble ? (vue.openBlock(), vue.createBlock(_component_RenderFunction, {
            key: 0,
            "render-func": _ctx.icons && _ctx.icons.nextDouble
          }, null, 8, ["render-func"])) : (vue.openBlock(), vue.createBlock(_component_IconDoubleRight, { key: 1 }))
        ], 2112)) : vue.createCommentVNode("v-if", true)
      ], 2)
    ], 2);
  }
  var PanelHeader = /* @__PURE__ */ _export_sfc(_sfc_main$25, [["render", _sfc_render$24]]);
  function useCellClassName(props) {
    const { rangeValues } = vue.toRefs(props);
    const sortedRangeValues = vue.computed(() => (rangeValues == null ? void 0 : rangeValues.value) && rangeValues.value.every(isDayjs) ? getSortedDayjsArray(rangeValues.value) : rangeValues == null ? void 0 : rangeValues.value);
    const rangeStart = vue.computed(() => {
      var _a;
      return (_a = sortedRangeValues.value) == null ? void 0 : _a[0];
    });
    const rangeEnd = vue.computed(() => {
      var _a;
      return (_a = sortedRangeValues.value) == null ? void 0 : _a[1];
    });
    return {
      getCellClassName: (cellData, disabled) => {
        const { value, isSameTime, mode, prefixCls } = props;
        const isInView = !cellData.isPrev && !cellData.isNext;
        const isSelected = value && isSameTime(cellData.value, value);
        let isToday = isSameTime(cellData.value, getNow());
        if (mode === "week") {
          isToday = getNow().isSame(cellData.value, "date");
        }
        const isRangeStart = isInView && rangeStart.value && isSameTime(cellData.value, rangeStart.value);
        const isRangeEnd = isInView && rangeEnd.value && isSameTime(cellData.value, rangeEnd.value);
        const isInRange = isInView && rangeStart.value && rangeEnd.value && (isRangeStart || isRangeEnd || cellData.value.isBetween(rangeStart.value, rangeEnd.value, null, "[]"));
        return [
          `${prefixCls}-cell`,
          {
            [`${prefixCls}-cell-in-view`]: isInView,
            [`${prefixCls}-cell-today`]: isToday,
            [`${prefixCls}-cell-selected`]: isSelected,
            [`${prefixCls}-cell-range-start`]: isRangeStart,
            [`${prefixCls}-cell-range-end`]: isRangeEnd,
            [`${prefixCls}-cell-in-range`]: isInRange,
            [`${prefixCls}-cell-disabled`]: disabled
          },
          cellData.classNames
        ];
      }
    };
  }
  const _sfc_main$24 = vue.defineComponent({
    name: "PanelBody",
    components: {
      RenderFunction
    },
    props: {
      prefixCls: {
        type: String,
        required: true
      },
      rows: {
        type: Array,
        default: () => []
      },
      value: {
        type: Object
      },
      disabledDate: {
        type: Function
      },
      isSameTime: {
        type: Function,
        required: true
      },
      mode: {
        type: String
      },
      rangeValues: {
        type: Array
      },
      dateRender: {
        type: Function
      }
    },
    emits: ["cell-click", "cell-mouse-enter"],
    setup(props, { emit }) {
      const { prefixCls, value, disabledDate, isSameTime, mode, rangeValues } = vue.toRefs(props);
      const { getCellClassName } = useCellClassName(vue.reactive({
        prefixCls,
        value,
        isSameTime,
        mode,
        rangeValues
      }));
      const isCellDisabled = (cellData) => !!(isFunction$1(disabledDate == null ? void 0 : disabledDate.value) && (disabledDate == null ? void 0 : disabledDate.value(getDateValue$1(cellData.value))));
      return {
        isWeek: vue.computed(() => (mode == null ? void 0 : mode.value) === "week"),
        getCellClassName: (cellData) => {
          const disabled = isCellDisabled(cellData);
          return getCellClassName(cellData, disabled);
        },
        onCellClick: (cellData) => {
          const disabled = isCellDisabled(cellData);
          if (disabled)
            return;
          emit("cell-click", cellData);
        },
        onCellMouseEnter: (cellData) => {
          const disabled = isCellDisabled(cellData);
          if (disabled)
            return;
          emit("cell-mouse-enter", cellData);
        },
        onCellMouseLeave: (cellData) => {
          const disabled = isCellDisabled(cellData);
          if (disabled)
            return;
          emit("cell-mouse-enter", cellData);
        },
        getDateValue: getDateValue$1
      };
    }
  });
  const _hoisted_1$R = ["onMouseenter", "onMouseleave", "onClick"];
  function _sfc_render$23(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_RenderFunction = vue.resolveComponent("RenderFunction");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(`${_ctx.prefixCls}-body`)
    }, [
      (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.rows, (row, rowIndex) => {
        return vue.openBlock(), vue.createElementBlock("div", {
          key: rowIndex,
          class: vue.normalizeClass([
            `${_ctx.prefixCls}-row`,
            {
              [`${_ctx.prefixCls}-row-week`]: _ctx.isWeek
            }
          ])
        }, [
          (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(row, (cell, colIndex) => {
            return vue.openBlock(), vue.createElementBlock(vue.Fragment, null, [
              vue.createCommentVNode(" \u4E00\u5E74\u4E2D\u7684\u7B2C\u51E0\u5468\uFF0C\u53EA\u5728 week \u6A21\u5F0F\u4E0B\u663E\u793A "),
              _ctx.isWeek && colIndex === 0 ? (vue.openBlock(), vue.createElementBlock("div", {
                key: colIndex,
                class: vue.normalizeClass([`${_ctx.prefixCls}-cell`, `${_ctx.prefixCls}-cell-week`])
              }, [
                vue.createElementVNode("div", {
                  class: vue.normalizeClass(`${_ctx.prefixCls}-date`)
                }, [
                  vue.createElementVNode("div", {
                    class: vue.normalizeClass(`${_ctx.prefixCls}-date-value`)
                  }, vue.toDisplayString(cell.label), 3)
                ], 2)
              ], 2)) : (vue.openBlock(), vue.createElementBlock("div", {
                key: colIndex,
                class: vue.normalizeClass(_ctx.getCellClassName(cell)),
                onMouseenter: () => {
                  _ctx.onCellMouseEnter(cell);
                },
                onMouseleave: () => {
                  _ctx.onCellMouseLeave(cell);
                },
                onClick: () => {
                  _ctx.onCellClick(cell);
                }
              }, [
                _ctx.dateRender ? (vue.openBlock(), vue.createBlock(_component_RenderFunction, {
                  key: 0,
                  "render-func": _ctx.dateRender,
                  date: _ctx.getDateValue(cell.value)
                }, null, 8, ["render-func", "date"])) : (vue.openBlock(), vue.createElementBlock("div", {
                  key: 1,
                  class: vue.normalizeClass(`${_ctx.prefixCls}-date`)
                }, [
                  vue.createElementVNode("div", {
                    class: vue.normalizeClass(`${_ctx.prefixCls}-date-value`)
                  }, vue.toDisplayString(cell.label), 3)
                ], 2))
              ], 42, _hoisted_1$R))
            ], 64);
          }), 256))
        ], 2);
      }), 128))
    ], 2);
  }
  var PanelBody = /* @__PURE__ */ _export_sfc(_sfc_main$24, [["render", _sfc_render$23]]);
  const _sfc_main$23 = vue.defineComponent({
    name: "PanelWeekList",
    props: {
      prefixCls: {
        type: String,
        required: true
      },
      weekList: {
        type: Array,
        required: true
      }
    },
    setup() {
      const datePickerT = useDatePickerTransform$1();
      const labelList = vue.computed(() => {
        return [
          "sunday",
          "monday",
          "tuesday",
          "wednesday",
          "thursday",
          "friday",
          "saturday"
        ].map((i) => datePickerT(`datePicker.week.short.${i}`));
      });
      return {
        labelList
      };
    }
  });
  function _sfc_render$22(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(`${_ctx.prefixCls}-week-list`)
    }, [
      (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.weekList, (key) => {
        return vue.openBlock(), vue.createElementBlock("div", {
          key,
          class: vue.normalizeClass(`${_ctx.prefixCls}-week-list-item`)
        }, vue.toDisplayString(_ctx.labelList[key] || ""), 3);
      }), 128))
    ], 2);
  }
  var PanelWeekList = /* @__PURE__ */ _export_sfc(_sfc_main$23, [["render", _sfc_render$22]]);
  const _sfc_main$22 = vue.defineComponent({
    name: "TimePickerColumn",
    props: {
      prefixCls: {
        type: String,
        required: true
      },
      list: {
        type: Array,
        required: true
      },
      value: {
        type: [Number, String]
      },
      visible: {
        type: Boolean
      }
    },
    emits: ["select"],
    setup(props, { emit }) {
      const { visible, value } = vue.toRefs(props);
      const refMap = vue.ref(new Map());
      const refWrapper = vue.ref();
      function scrollToTop(easing2 = false) {
        if (!refWrapper.value || isUndefined(value == null ? void 0 : value.value) || !(visible == null ? void 0 : visible.value)) {
          return;
        }
        const refSelected = refMap.value.get(value.value);
        if (refSelected) {
          scrollTo(refWrapper.value, refSelected.offsetTop, easing2 ? 100 : 0);
        }
      }
      vue.watch([value, visible], (_, [, preVisible]) => {
        if (visible.value !== preVisible) {
          vue.nextTick(() => {
            scrollToTop();
          });
        } else {
          scrollToTop(true);
        }
      });
      vue.onMounted(() => {
        scrollToTop();
      });
      return {
        refWrapper,
        refMap,
        onItemRef(el, item) {
          refMap.value.set(item.value, el);
        },
        onItemClick(item) {
          if (!item.disabled) {
            emit("select", item.value);
          }
        }
      };
    }
  });
  const _hoisted_1$Q = ["onClick"];
  function _sfc_render$21(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      ref: "refWrapper",
      class: vue.normalizeClass(`${_ctx.prefixCls}-column`)
    }, [
      vue.createElementVNode("ul", null, [
        (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.list, (item) => {
          return vue.openBlock(), vue.createElementBlock("li", {
            key: item.value,
            ref: (el) => {
              _ctx.onItemRef(el, item);
            },
            class: vue.normalizeClass([
              `${_ctx.prefixCls}-cell`,
              {
                [`${_ctx.prefixCls}-cell-disabled`]: item.disabled,
                [`${_ctx.prefixCls}-cell-selected`]: item.selected
              }
            ]),
            onClick: () => {
              _ctx.onItemClick(item);
            }
          }, [
            vue.createElementVNode("div", {
              class: vue.normalizeClass(`${_ctx.prefixCls}-cell-inner`)
            }, vue.toDisplayString(item.label), 3)
          ], 10, _hoisted_1$Q);
        }), 128))
      ])
    ], 2);
  }
  var TimeColumn = /* @__PURE__ */ _export_sfc(_sfc_main$22, [["render", _sfc_render$21]]);
  function useTimeList(props) {
    const {
      format,
      step,
      use12Hours,
      hideDisabledOptions,
      disabledHours,
      disabledMinutes,
      disabledSeconds,
      selectedHour,
      selectedMinute,
      selectedSecond,
      selectedAmpm,
      disabled
    } = vue.toRefs(props);
    const hours = vue.computed(() => {
      var _a;
      const { hour: hourStep = 1 } = (step == null ? void 0 : step.value) || {};
      const disabledList = ((_a = disabledHours == null ? void 0 : disabledHours.value) == null ? void 0 : _a.call(disabledHours)) || [];
      let list = [];
      for (let i = 0; i < (use12Hours.value ? 12 : 24); i += hourStep) {
        list.push(i);
      }
      if (use12Hours.value) {
        list[0] = 12;
      }
      if (hideDisabledOptions.value && disabledList.length) {
        list = list.filter((h) => disabledList.indexOf(h) < 0);
      }
      return list.map((h) => ({
        label: padStart(h, 2, "0"),
        value: h,
        selected: selectedHour.value === h,
        disabled: (disabled == null ? void 0 : disabled.value) || disabledList.includes(h)
      }));
    });
    const minutes = vue.computed(() => {
      var _a;
      const { minute: minuteStep = 1 } = (step == null ? void 0 : step.value) || {};
      const disabledList = ((_a = disabledMinutes == null ? void 0 : disabledMinutes.value) == null ? void 0 : _a.call(disabledMinutes, selectedHour.value)) || [];
      let list = [];
      for (let i = 0; i < 60; i += minuteStep) {
        list.push(i);
      }
      if (hideDisabledOptions.value && disabledList.length) {
        list = list.filter((m) => disabledList.indexOf(m) < 0);
      }
      return list.map((m) => ({
        label: padStart(m, 2, "0"),
        value: m,
        selected: selectedMinute.value === m,
        disabled: (disabled == null ? void 0 : disabled.value) || disabledList.includes(m)
      }));
    });
    const seconds = vue.computed(() => {
      var _a;
      const { second: secondStep = 1 } = (step == null ? void 0 : step.value) || {};
      const disabledList = ((_a = disabledSeconds == null ? void 0 : disabledSeconds.value) == null ? void 0 : _a.call(disabledSeconds, selectedHour.value, selectedMinute.value)) || [];
      let list = [];
      for (let i = 0; i < 60; i += secondStep) {
        list.push(i);
      }
      if (hideDisabledOptions.value && disabledList.length) {
        list = list.filter((s) => disabledList.indexOf(s) < 0);
      }
      return list.map((s) => ({
        label: padStart(s, 2, "0"),
        value: s,
        selected: selectedSecond.value === s,
        disabled: (disabled == null ? void 0 : disabled.value) || disabledList.includes(s)
      }));
    });
    const AMPM = ["am", "pm"];
    const ampmList = vue.computed(() => {
      const isUpperCase = getColumnsFromFormat(format.value).list.includes("A");
      return AMPM.map((a) => ({
        label: isUpperCase ? a.toUpperCase() : a,
        value: a,
        selected: selectedAmpm.value === a,
        disabled: disabled == null ? void 0 : disabled.value
      }));
    });
    return {
      hours,
      minutes,
      seconds,
      ampmList
    };
  }
  function useTimeFormat(props) {
    const {
      format: propFormat,
      use12Hours: propUse12Hours,
      defaultFormat
    } = vue.toRefs(props);
    const format = vue.computed(() => {
      let res = (propFormat == null ? void 0 : propFormat.value) || (defaultFormat == null ? void 0 : defaultFormat.value);
      if (!res || !getColumnsFromFormat(res).list.length) {
        res = (propUse12Hours == null ? void 0 : propUse12Hours.value) ? "hh:mm:ss a" : "HH:mm:ss";
      }
      return res;
    });
    const configFromFormat = vue.computed(() => getColumnsFromFormat(format.value));
    const list = vue.computed(() => configFromFormat.value.list);
    const formatUse12Hours = vue.computed(() => configFromFormat.value.use12Hours);
    const computedUse12Hours = vue.computed(() => !!((propUse12Hours == null ? void 0 : propUse12Hours.value) || formatUse12Hours.value));
    return {
      columns: list,
      use12Hours: computedUse12Hours,
      format
    };
  }
  function useIsDisabledTime(props) {
    const isDisabled = (value) => {
      return isDisabledTime(value, {
        disabledHours: props.disabledHours,
        disabledMinutes: props.disabledMinutes,
        disabledSeconds: props.disabledSeconds
      });
    };
    return (value) => {
      return isArray$1(value) ? value.some((i) => isDisabled(i)) : isDisabled(value);
    };
  }
  const _sfc_main$21 = vue.defineComponent({
    name: "TimePickerPanel",
    components: {
      TimeColumn,
      Button
    },
    props: {
      value: {
        type: Object
      },
      visible: {
        type: Boolean
      },
      format: {
        type: String,
        default: "HH:mm:ss"
      },
      use12Hours: {
        type: Boolean
      },
      step: {
        type: Object
      },
      disabledHours: {
        type: Function
      },
      disabledMinutes: {
        type: Function
      },
      disabledSeconds: {
        type: Function
      },
      hideDisabledOptions: {
        type: Boolean
      },
      hideFooter: {
        type: Boolean
      },
      isRange: {
        type: Boolean
      },
      disabled: {
        type: Boolean
      }
    },
    emits: {
      select: (value) => isDayjs(value),
      confirm: (value) => isDayjs(value)
    },
    setup(props, { emit }) {
      const {
        value,
        visible,
        format,
        step,
        use12Hours,
        hideDisabledOptions,
        disabledHours,
        disabledMinutes,
        disabledSeconds,
        disabled
      } = vue.toRefs(props);
      const prefixCls = getPrefixCls("timepicker");
      const { t: t2 } = useI18n();
      const {
        columns,
        use12Hours: computedUse12Hours,
        format: computedFormat
      } = useTimeFormat(vue.reactive({
        format,
        use12Hours
      }));
      const selectedValue = vue.ref(value == null ? void 0 : value.value);
      const setSelectedValue = (value2) => {
        selectedValue.value = value2;
      };
      vue.watch([visible, value], () => {
        if (!visible.value)
          return;
        setSelectedValue(value == null ? void 0 : value.value);
      });
      const selectedHour = vue.computed(() => {
        var _a;
        const _hour = (_a = selectedValue.value) == null ? void 0 : _a.hour();
        if (isUndefined(_hour) || !computedUse12Hours.value)
          return _hour;
        if (_hour > 12)
          return _hour - 12;
        if (_hour === 0)
          return 12;
        return _hour;
      });
      const selectedMinute = vue.computed(() => {
        var _a;
        return (_a = selectedValue.value) == null ? void 0 : _a.minute();
      });
      const selectedSecond = vue.computed(() => {
        var _a;
        return (_a = selectedValue.value) == null ? void 0 : _a.second();
      });
      const selectedAmpm = vue.computed(() => {
        var _a;
        const _hour = (_a = selectedValue.value) == null ? void 0 : _a.hour();
        return !isUndefined(_hour) && _hour >= 12 ? "pm" : "am";
      });
      const { hours, minutes, seconds, ampmList } = useTimeList(vue.reactive({
        format: computedFormat,
        step,
        use12Hours: computedUse12Hours,
        hideDisabledOptions,
        disabledHours,
        disabledMinutes,
        disabledSeconds,
        selectedHour,
        selectedMinute,
        selectedSecond,
        selectedAmpm,
        disabled
      }));
      const isDisabledTime2 = useIsDisabledTime(vue.reactive({
        disabledHours,
        disabledMinutes,
        disabledSeconds
      }));
      const confirmBtnDisabled = vue.computed(() => isDisabledTime2(selectedValue.value));
      function emitConfirm(value2) {
        if (isUndefined(value2))
          return;
        emit("confirm", value2);
      }
      function emitSelect(value2) {
        setSelectedValue(value2);
        emit("select", value2);
      }
      function onSelect(value2, type = "hour") {
        let newValue;
        const hour = selectedHour.value || "00";
        const minute = selectedMinute.value || "00";
        const second = selectedSecond.value || "00";
        const ampm = selectedAmpm.value || "am";
        switch (type) {
          case "hour":
            newValue = `${value2}:${minute}:${second}`;
            break;
          case "minute":
            newValue = `${hour}:${value2}:${second}`;
            break;
          case "second":
            newValue = `${hour}:${minute}:${value2}`;
            break;
          case "ampm":
            newValue = `${hour}:${minute}:${second} ${value2}`;
            break;
          default:
            newValue = "00:00:00";
        }
        let valueFormat = "HH:mm:ss";
        if (computedUse12Hours.value) {
          valueFormat = "HH:mm:ss a";
          if (type !== "ampm") {
            newValue = `${newValue} ${ampm}`;
          }
        }
        newValue = dayjs(newValue, valueFormat);
        emitSelect(newValue);
      }
      return {
        prefixCls,
        t: t2,
        hours,
        minutes,
        seconds,
        ampmList,
        selectedValue,
        selectedHour,
        selectedMinute,
        selectedSecond,
        selectedAmpm,
        computedUse12Hours,
        confirmBtnDisabled,
        columns,
        onSelect,
        onSelectNow() {
          const newValue = dayjs(new Date());
          emitSelect(newValue);
        },
        onConfirm() {
          emitConfirm(selectedValue.value);
        }
      };
    }
  });
  function _sfc_render$20(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_TimeColumn = vue.resolveComponent("TimeColumn");
    const _component_Button = vue.resolveComponent("Button");
    return vue.openBlock(), vue.createElementBlock(vue.Fragment, null, [
      vue.createElementVNode("div", {
        class: vue.normalizeClass(_ctx.prefixCls)
      }, [
        _ctx.columns.includes("H") || _ctx.columns.includes("h") ? (vue.openBlock(), vue.createBlock(_component_TimeColumn, {
          key: 0,
          value: _ctx.selectedHour,
          list: _ctx.hours,
          "prefix-cls": _ctx.prefixCls,
          visible: _ctx.visible,
          onSelect: _cache[0] || (_cache[0] = (value) => {
            _ctx.onSelect(value, "hour");
          })
        }, null, 8, ["value", "list", "prefix-cls", "visible"])) : vue.createCommentVNode("v-if", true),
        _ctx.columns.includes("m") ? (vue.openBlock(), vue.createBlock(_component_TimeColumn, {
          key: 1,
          value: _ctx.selectedMinute,
          list: _ctx.minutes,
          "prefix-cls": _ctx.prefixCls,
          visible: _ctx.visible,
          onSelect: _cache[1] || (_cache[1] = (value) => {
            _ctx.onSelect(value, "minute");
          })
        }, null, 8, ["value", "list", "prefix-cls", "visible"])) : vue.createCommentVNode("v-if", true),
        _ctx.columns.includes("s") ? (vue.openBlock(), vue.createBlock(_component_TimeColumn, {
          key: 2,
          value: _ctx.selectedSecond,
          list: _ctx.seconds,
          "prefix-cls": _ctx.prefixCls,
          visible: _ctx.visible,
          onSelect: _cache[2] || (_cache[2] = (value) => {
            _ctx.onSelect(value, "second");
          })
        }, null, 8, ["value", "list", "prefix-cls", "visible"])) : vue.createCommentVNode("v-if", true),
        _ctx.computedUse12Hours ? (vue.openBlock(), vue.createBlock(_component_TimeColumn, {
          key: 3,
          value: _ctx.selectedAmpm,
          list: _ctx.ampmList,
          "prefix-cls": _ctx.prefixCls,
          visible: _ctx.visible,
          onSelect: _cache[3] || (_cache[3] = (value) => {
            _ctx.onSelect(value, "ampm");
          })
        }, null, 8, ["value", "list", "prefix-cls", "visible"])) : vue.createCommentVNode("v-if", true)
      ], 2),
      _ctx.$slots["extra-footer"] ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: vue.normalizeClass(`${_ctx.prefixCls}-footer-extra-wrapper`)
      }, [
        vue.renderSlot(_ctx.$slots, "extra-footer")
      ], 2)) : vue.createCommentVNode("v-if", true),
      !_ctx.hideFooter ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 1,
        class: vue.normalizeClass(`${_ctx.prefixCls}-footer-btn-wrapper`)
      }, [
        !_ctx.isRange ? (vue.openBlock(), vue.createBlock(_component_Button, {
          key: 0,
          size: "mini",
          onClick: _ctx.onSelectNow
        }, {
          default: vue.withCtx(() => [
            vue.createTextVNode(vue.toDisplayString(_ctx.t("datePicker.now")), 1)
          ]),
          _: 1
        }, 8, ["onClick"])) : vue.createCommentVNode("v-if", true),
        vue.createVNode(_component_Button, {
          type: "primary",
          size: "mini",
          disabled: _ctx.confirmBtnDisabled || !_ctx.selectedValue,
          onClick: _ctx.onConfirm
        }, {
          default: vue.withCtx(() => [
            vue.createTextVNode(vue.toDisplayString(_ctx.t("datePicker.ok")), 1)
          ]),
          _: 1
        }, 8, ["disabled", "onClick"])
      ], 2)) : vue.createCommentVNode("v-if", true)
    ], 64);
  }
  var Panel$1 = /* @__PURE__ */ _export_sfc(_sfc_main$21, [["render", _sfc_render$20]]);
  const _sfc_main$20 = vue.defineComponent({
    name: "IconCalendar",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-calendar`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$P = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$G = /* @__PURE__ */ vue.createElementVNode("path", { d: "M7 22h34M14 5v8m20-8v8M8 41h32a1 1 0 0 0 1-1V10a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1Z" }, null, -1);
  const _hoisted_3$D = [
    _hoisted_2$G
  ];
  function _sfc_render$1$(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$D, 14, _hoisted_1$P);
  }
  var _IconCalendar = /* @__PURE__ */ _export_sfc(_sfc_main$20, [["render", _sfc_render$1$]]);
  const IconCalendar = Object.assign(_IconCalendar, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconCalendar.name, _IconCalendar);
    }
  });
  const _sfc_main$1$ = vue.defineComponent({
    name: "IconClockCircle",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-clock-circle`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$O = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$F = /* @__PURE__ */ vue.createElementVNode("path", { d: "M24 14v10h9.5m8.5 0c0 9.941-8.059 18-18 18S6 33.941 6 24 14.059 6 24 6s18 8.059 18 18Z" }, null, -1);
  const _hoisted_3$C = [
    _hoisted_2$F
  ];
  function _sfc_render$1_(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$C, 14, _hoisted_1$O);
  }
  var _IconClockCircle = /* @__PURE__ */ _export_sfc(_sfc_main$1$, [["render", _sfc_render$1_]]);
  const IconClockCircle = Object.assign(_IconClockCircle, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconClockCircle.name, _IconClockCircle);
    }
  });
  function useMergeState(defaultValue, props) {
    const { value } = vue.toRefs(props);
    const [localValue, setLocalValue] = useState(!isUndefined(value.value) ? value.value : defaultValue);
    vue.watch(value, (newVal) => {
      isUndefined(newVal) && setLocalValue(void 0);
    });
    const mergeValue = vue.computed(() => !isUndefined(value.value) ? value.value : localValue.value);
    return [mergeValue, setLocalValue, localValue];
  }
  const ROW_COUNT$2 = 6;
  const COL_COUNT$2 = 7;
  const CELL_COUNT$2 = ROW_COUNT$2 * COL_COUNT$2;
  function getCellData(time) {
    return {
      label: time.date(),
      value: time
    };
  }
  const _sfc_main$1_ = vue.defineComponent({
    name: "DatePanel",
    components: {
      PanelHeader,
      PanelBody,
      PanelWeekList,
      TimePanel: Panel$1,
      IconCalendar,
      IconClockCircle
    },
    props: {
      isRange: {
        type: Boolean
      },
      value: {
        type: Object
      },
      rangeValues: {
        type: Array
      },
      headerValue: {
        type: Object,
        required: true
      },
      footerValue: {
        type: Object
      },
      timePickerValue: {
        type: Object
      },
      headerOperations: {
        type: Object,
        default: () => ({})
      },
      headerIcons: {
        type: Object,
        default: () => ({})
      },
      dayStartOfWeek: {
        type: Number,
        default: 0
      },
      disabledDate: {
        type: Function
      },
      disabledTime: {
        type: Function
      },
      isSameTime: {
        type: Function
      },
      mode: {
        type: String,
        default: "date"
      },
      showTime: {
        type: Boolean
      },
      timePickerProps: {
        type: Object
      },
      currentView: {
        type: String
      },
      dateRender: {
        type: Function
      },
      disabled: {
        type: Boolean
      },
      onHeaderLabelClick: {
        type: Function
      }
    },
    emits: [
      "select",
      "time-picker-select",
      "cell-mouse-enter",
      "current-view-change",
      "update:currentView"
    ],
    setup(props, { emit }) {
      const {
        isRange,
        headerValue,
        footerValue,
        dayStartOfWeek,
        isSameTime,
        mode,
        showTime,
        currentView,
        disabledTime
      } = vue.toRefs(props);
      const datePickerT = useDatePickerTransform$1();
      const isWeek = vue.computed(() => (mode == null ? void 0 : mode.value) === "week");
      const prefixCls = vue.computed(() => getPrefixCls(isWeek.value ? "panel-week" : "panel-date"));
      const pickerPrefixCls = getPrefixCls("picker");
      const [localCurrentView, setLocalCurrentView] = useMergeState("date", vue.reactive({ value: currentView }));
      const showViewTabs = vue.computed(() => showTime.value && isRange.value);
      const showDateView = vue.computed(() => !showTime.value || !showViewTabs.value || localCurrentView.value === "date");
      const showTimeView = vue.computed(() => showTime.value && (!showViewTabs.value || localCurrentView.value === "time"));
      const classNames = vue.computed(() => [
        prefixCls.value,
        {
          [`${prefixCls.value}-with-view-tabs`]: showViewTabs.value
        }
      ]);
      const headerTitle = vue.computed(() => headerValue.value.format("YYYY-MM"));
      const disabledTimeProps = vue.computed(() => {
        var _a;
        return showTime.value && ((_a = disabledTime == null ? void 0 : disabledTime.value) == null ? void 0 : _a.call(disabledTime, getDateValue$1((footerValue == null ? void 0 : footerValue.value) || getNow()))) || {};
      });
      const weekList = vue.computed(() => {
        const list = [0, 1, 2, 3, 4, 5, 6];
        const index2 = Math.max(dayStartOfWeek.value % 7, 0);
        return [...list.slice(index2), ...list.slice(0, index2)];
      });
      const rows = vue.computed(() => {
        const startDate = methods.startOf(headerValue.value, "month");
        const startDay = startDate.day();
        const days = startDate.daysInMonth();
        const startIndex = weekList.value.indexOf(startDay);
        const flatData = newArray(CELL_COUNT$2);
        for (let i = 0; i < flatData.length; i++) {
          flatData[i] = __spreadProps(__spreadValues({}, getCellData(methods.add(startDate, i - startIndex, "day"))), {
            isPrev: i < startIndex,
            isNext: i > startIndex + days - 1
          });
        }
        const rows2 = newArray(ROW_COUNT$2).map((_, index2) => {
          const row = flatData.slice(index2 * COL_COUNT$2, (index2 + 1) * COL_COUNT$2);
          if (isWeek.value) {
            const valueOfWeek = row[0].value;
            row.unshift({
              label: valueOfWeek.week(),
              value: valueOfWeek
            });
          }
          return row;
        });
        return rows2;
      });
      const mergedIsSameTime = vue.computed(() => (isSameTime == null ? void 0 : isSameTime.value) || ((current, target2) => {
        return current.isSame(target2, "day");
      }));
      function onCellClick(cellData) {
        emit("select", cellData.value);
      }
      function onTimePanelSelect(time) {
        emit("time-picker-select", time);
      }
      function onCellMouseEnter(cellData) {
        emit("cell-mouse-enter", cellData.value);
      }
      return {
        prefixCls,
        classNames,
        pickerPrefixCls,
        headerTitle,
        rows,
        weekList: vue.computed(() => isWeek.value ? [-1, ...weekList.value] : weekList.value),
        mergedIsSameTime,
        disabledTimeProps,
        onCellClick,
        onCellMouseEnter,
        onTimePanelSelect,
        showViewTabs,
        showDateView,
        showTimeView,
        changeViewTo: (newView) => {
          emit("current-view-change", newView);
          emit("update:currentView", newView);
          setLocalCurrentView(newView);
        },
        datePickerT
      };
    }
  });
  function _sfc_render$1Z(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_PanelHeader = vue.resolveComponent("PanelHeader");
    const _component_PanelWeekList = vue.resolveComponent("PanelWeekList");
    const _component_PanelBody = vue.resolveComponent("PanelBody");
    const _component_TimePanel = vue.resolveComponent("TimePanel");
    const _component_IconCalendar = vue.resolveComponent("IconCalendar");
    const _component_IconClockCircle = vue.resolveComponent("IconClockCircle");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.classNames)
    }, [
      _ctx.showDateView ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: vue.normalizeClass(`${_ctx.prefixCls}-inner`)
      }, [
        vue.createVNode(_component_PanelHeader, vue.mergeProps(__spreadProps(__spreadValues({}, _ctx.headerOperations), {
          icons: _ctx.headerIcons
        }), {
          "prefix-cls": _ctx.pickerPrefixCls,
          title: _ctx.headerTitle,
          mode: _ctx.mode,
          value: _ctx.headerValue,
          "on-label-click": _ctx.onHeaderLabelClick
        }), null, 16, ["prefix-cls", "title", "mode", "value", "on-label-click"]),
        vue.createVNode(_component_PanelWeekList, {
          "prefix-cls": _ctx.pickerPrefixCls,
          "week-list": _ctx.weekList
        }, null, 8, ["prefix-cls", "week-list"]),
        vue.createVNode(_component_PanelBody, {
          mode: _ctx.mode,
          "prefix-cls": _ctx.pickerPrefixCls,
          rows: _ctx.rows,
          value: _ctx.isRange ? void 0 : _ctx.value,
          "range-values": _ctx.rangeValues,
          "disabled-date": _ctx.disabledDate,
          "is-same-time": _ctx.mergedIsSameTime,
          "date-render": _ctx.dateRender,
          onCellClick: _ctx.onCellClick,
          onCellMouseEnter: _ctx.onCellMouseEnter
        }, null, 8, ["mode", "prefix-cls", "rows", "value", "range-values", "disabled-date", "is-same-time", "date-render", "onCellClick", "onCellMouseEnter"])
      ], 2)) : vue.createCommentVNode("v-if", true),
      _ctx.showTimeView ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 1,
        class: vue.normalizeClass(`${_ctx.prefixCls}-timepicker`)
      }, [
        vue.createElementVNode("header", {
          class: vue.normalizeClass(`${_ctx.prefixCls}-timepicker-title`)
        }, vue.toDisplayString(_ctx.datePickerT("datePicker.selectTime")), 3),
        vue.createVNode(_component_TimePanel, vue.mergeProps(__spreadValues(__spreadValues({}, _ctx.timePickerProps), _ctx.disabledTimeProps), {
          "hide-footer": "",
          value: _ctx.value || _ctx.isRange ? _ctx.timePickerValue : void 0,
          disabled: _ctx.disabled,
          onSelect: _ctx.onTimePanelSelect
        }), null, 16, ["value", "disabled", "onSelect"])
      ], 2)) : vue.createCommentVNode("v-if", true),
      _ctx.showViewTabs ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 2,
        class: vue.normalizeClass(`${_ctx.prefixCls}-footer`)
      }, [
        vue.createElementVNode("div", {
          class: vue.normalizeClass(`${_ctx.prefixCls}-view-tabs`)
        }, [
          vue.createElementVNode("div", {
            class: vue.normalizeClass([
              `${_ctx.prefixCls}-view-tab-pane`,
              { [`${_ctx.prefixCls}-view-tab-pane-active`]: _ctx.showDateView }
            ]),
            onClick: _cache[0] || (_cache[0] = () => _ctx.changeViewTo("date"))
          }, [
            vue.createVNode(_component_IconCalendar),
            vue.createElementVNode("span", {
              class: vue.normalizeClass(`${_ctx.prefixCls}-view-tab-pane-text`)
            }, vue.toDisplayString(_ctx.footerValue && _ctx.footerValue.format("YYYY-MM-DD")), 3)
          ], 2),
          vue.createElementVNode("div", {
            class: vue.normalizeClass([
              `${_ctx.prefixCls}-view-tab-pane`,
              { [`${_ctx.prefixCls}-view-tab-pane-active`]: _ctx.showTimeView }
            ]),
            onClick: _cache[1] || (_cache[1] = () => _ctx.changeViewTo("time"))
          }, [
            vue.createVNode(_component_IconClockCircle),
            vue.createElementVNode("span", {
              class: vue.normalizeClass(`${_ctx.prefixCls}-view-tab-pane-text`)
            }, vue.toDisplayString(_ctx.timePickerValue && _ctx.timePickerValue.format("HH:mm:ss")), 3)
          ], 2)
        ], 2)
      ], 2)) : vue.createCommentVNode("v-if", true)
    ], 2);
  }
  var DatePanel = /* @__PURE__ */ _export_sfc(_sfc_main$1_, [["render", _sfc_render$1Z]]);
  const _sfc_main$1Z = vue.defineComponent({
    name: "WeekPanel",
    components: {
      DatePanel
    },
    props: {
      dayStartOfWeek: {
        type: Number,
        default: 0
      }
    },
    emits: ["select", "cell-mouse-enter"],
    setup(props, { emit }) {
      const { locale } = useI18n();
      const isSameTime = (current, target2) => {
        return methods.isSameWeek(current, target2, props.dayStartOfWeek, locale.value);
      };
      return {
        isSameTime,
        onSelect: (value) => {
          const startDateOfWeek = methods.startOf(value, "week");
          emit("select", startDateOfWeek);
        },
        onCellMouseEnter: (value) => {
          const startDateOfWeek = methods.startOf(value, "week");
          emit("cell-mouse-enter", startDateOfWeek);
        }
      };
    }
  });
  function _sfc_render$1Y(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_DatePanel = vue.resolveComponent("DatePanel");
    return vue.openBlock(), vue.createBlock(_component_DatePanel, vue.mergeProps(_ctx.$attrs, {
      mode: "week",
      "is-week": "",
      "day-start-of-week": _ctx.dayStartOfWeek,
      "is-same-time": _ctx.isSameTime,
      onSelect: _ctx.onSelect,
      onCellMouseEnter: _ctx.onCellMouseEnter
    }), null, 16, ["day-start-of-week", "is-same-time", "onSelect", "onCellMouseEnter"]);
  }
  var WeekPanel = /* @__PURE__ */ _export_sfc(_sfc_main$1Z, [["render", _sfc_render$1Y]]);
  const MONTH_LIST = [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ];
  const CELL_COUNT$1 = 12;
  const ROW_COUNT$1 = 4;
  const COL_COUNT$1 = 3;
  const _sfc_main$1Y = vue.defineComponent({
    name: "MonthPanel",
    components: {
      PanelHeader,
      PanelBody
    },
    props: {
      headerValue: {
        type: Object,
        required: true
      },
      headerOperations: {
        type: Object,
        default: () => ({})
      },
      headerIcons: {
        type: Object,
        default: () => ({})
      },
      value: {
        type: Object
      },
      disabledDate: {
        type: Function
      },
      rangeValues: {
        type: Array
      },
      dateRender: {
        type: Function
      },
      onHeaderLabelClick: {
        type: Function
      },
      abbreviation: {
        type: Boolean,
        default: true
      }
    },
    emits: ["select", "cell-mouse-enter"],
    setup(props, { emit }) {
      const datePickerT = useDatePickerTransform$1();
      const { headerValue } = vue.toRefs(props);
      const prefixCls = vue.computed(() => getPrefixCls("panel-month"));
      const pickerPrefixCls = getPrefixCls("picker");
      const headerTitle = vue.computed(() => headerValue.value.format("YYYY"));
      const rows = vue.computed(() => {
        const year = headerValue.value.year();
        const isAbbr = props.abbreviation ? "short" : "long";
        const flatData = newArray(CELL_COUNT$1).map((_, index2) => ({
          label: datePickerT(`datePicker.month.${isAbbr}.${MONTH_LIST[index2]}`),
          value: dayjs(`${year}-${index2 + 1}`, "YYYY-M")
        }));
        const rows2 = newArray(ROW_COUNT$1).map((_, index2) => flatData.slice(index2 * COL_COUNT$1, (index2 + 1) * COL_COUNT$1));
        return rows2;
      });
      const isSameTime = (current, target2) => current.isSame(target2, "month");
      function onCellClick(cellData) {
        emit("select", cellData.value);
      }
      function onCellMouseEnter(cellData) {
        emit("cell-mouse-enter", cellData.value);
      }
      return {
        prefixCls,
        pickerPrefixCls,
        headerTitle,
        rows,
        isSameTime,
        onCellClick,
        onCellMouseEnter
      };
    }
  });
  function _sfc_render$1X(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_PanelHeader = vue.resolveComponent("PanelHeader");
    const _component_PanelBody = vue.resolveComponent("PanelBody");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.prefixCls)
    }, [
      vue.createElementVNode("div", {
        class: vue.normalizeClass(`${_ctx.prefixCls}-inner`)
      }, [
        vue.createVNode(_component_PanelHeader, vue.mergeProps(__spreadProps(__spreadValues({}, _ctx.headerOperations), {
          icons: _ctx.headerIcons
        }), {
          "prefix-cls": _ctx.pickerPrefixCls,
          title: _ctx.headerTitle,
          mode: "month",
          value: _ctx.headerValue,
          "on-label-click": _ctx.onHeaderLabelClick
        }), null, 16, ["prefix-cls", "title", "value", "on-label-click"]),
        vue.createVNode(_component_PanelBody, {
          mode: "month",
          "prefix-cls": _ctx.pickerPrefixCls,
          rows: _ctx.rows,
          value: _ctx.value,
          "range-values": _ctx.rangeValues,
          "disabled-date": _ctx.disabledDate,
          "is-same-time": _ctx.isSameTime,
          "date-render": _ctx.dateRender,
          onCellClick: _ctx.onCellClick,
          onCellMouseEnter: _ctx.onCellMouseEnter
        }, null, 8, ["prefix-cls", "rows", "value", "range-values", "disabled-date", "is-same-time", "date-render", "onCellClick", "onCellMouseEnter"])
      ], 2)
    ], 2);
  }
  var MonthPanel = /* @__PURE__ */ _export_sfc(_sfc_main$1Y, [["render", _sfc_render$1X]]);
  const ROW_COUNT = 4;
  const COL_COUNT = 3;
  const CELL_COUNT = ROW_COUNT * COL_COUNT;
  const SPAN = 10;
  const _sfc_main$1X = vue.defineComponent({
    name: "YearPanel",
    components: {
      PanelHeader,
      PanelBody
    },
    props: {
      headerValue: {
        type: Object,
        required: true
      },
      headerOperations: {
        type: Object,
        default: () => ({})
      },
      headerIcons: {
        type: Object,
        default: () => ({})
      },
      value: {
        type: Object
      },
      disabledDate: {
        type: Function
      },
      rangeValues: {
        type: Array
      },
      dateRender: {
        type: Function
      }
    },
    emits: ["select", "cell-mouse-enter"],
    setup(props, { emit }) {
      const { headerValue } = vue.toRefs(props);
      const prefixCls = vue.computed(() => getPrefixCls("panel-year"));
      const pickerPrefixCls = getPrefixCls("picker");
      const rows = vue.computed(() => {
        const startYear = Math.floor(headerValue.value.year() / SPAN) * SPAN - 1;
        const flatData = newArray(CELL_COUNT).map((_, index2) => ({
          label: startYear + index2,
          value: dayjs(`${startYear + index2}`, "YYYY"),
          isPrev: index2 < 1,
          isNext: index2 > SPAN
        }));
        const rows2 = newArray(ROW_COUNT).map((_, index2) => flatData.slice(index2 * COL_COUNT, (index2 + 1) * COL_COUNT));
        return rows2;
      });
      const headerTitle = vue.computed(() => `${rows.value[0][1].label}-${rows.value[ROW_COUNT - 1][COL_COUNT - 1].label}`);
      const isSameTime = (current, target2) => current.isSame(target2, "year");
      function onCellClick(cellData) {
        emit("select", cellData.value);
      }
      function onCellMouseEnter(cellData) {
        emit("cell-mouse-enter", cellData.value);
      }
      return {
        prefixCls,
        pickerPrefixCls,
        headerTitle,
        rows,
        isSameTime,
        onCellClick,
        onCellMouseEnter
      };
    }
  });
  function _sfc_render$1W(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_PanelHeader = vue.resolveComponent("PanelHeader");
    const _component_PanelBody = vue.resolveComponent("PanelBody");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.prefixCls)
    }, [
      vue.createElementVNode("div", {
        class: vue.normalizeClass(`${_ctx.prefixCls}-inner`)
      }, [
        vue.createVNode(_component_PanelHeader, vue.mergeProps(__spreadProps(__spreadValues({}, _ctx.headerOperations), {
          icons: _ctx.headerIcons
        }), {
          "prefix-cls": _ctx.pickerPrefixCls,
          title: _ctx.headerTitle
        }), null, 16, ["prefix-cls", "title"]),
        vue.createVNode(_component_PanelBody, {
          mode: "year",
          "prefix-cls": _ctx.pickerPrefixCls,
          rows: _ctx.rows,
          value: _ctx.value,
          "range-values": _ctx.rangeValues,
          "disabled-date": _ctx.disabledDate,
          "is-same-time": _ctx.isSameTime,
          "date-render": _ctx.dateRender,
          onCellClick: _ctx.onCellClick,
          onCellMouseEnter: _ctx.onCellMouseEnter
        }, null, 8, ["prefix-cls", "rows", "value", "range-values", "disabled-date", "is-same-time", "date-render", "onCellClick", "onCellMouseEnter"])
      ], 2)
    ], 2);
  }
  var YearPanel = /* @__PURE__ */ _export_sfc(_sfc_main$1X, [["render", _sfc_render$1W]]);
  const _sfc_main$1W = vue.defineComponent({
    name: "QuarterPanel",
    components: {
      PanelHeader,
      PanelBody
    },
    props: {
      headerValue: {
        type: Object,
        required: true
      },
      headerOperations: {
        type: Object,
        default: () => ({})
      },
      headerIcons: {
        type: Object,
        default: () => ({})
      },
      value: {
        type: Object
      },
      disabledDate: {
        type: Function
      },
      rangeValues: {
        type: Array
      },
      dateRender: {
        type: Function
      },
      onHeaderLabelClick: {
        type: Function
      }
    },
    emits: ["select", "cell-mouse-enter"],
    setup(props, { emit }) {
      const { headerValue } = vue.toRefs(props);
      const prefixCls = vue.computed(() => getPrefixCls("panel-quarter"));
      const pickerPrefixCls = getPrefixCls("picker");
      const headerTitle = vue.computed(() => headerValue.value.format("YYYY"));
      const rows = vue.computed(() => {
        const year = headerValue.value.year();
        return [
          [1, 2, 3, 4].map((q) => ({
            label: `Q${q}`,
            value: dayjs(`${year}-${padStart((q - 1) * 3 + 1, 2, "0")}-01`)
          }))
        ];
      });
      const isSameTime = (current, target2) => current.isSame(target2, "month") || current.isSame(target2, "year") && Math.floor(current.month() / 3) === Math.floor(target2.month() / 3);
      function onCellClick(cellData) {
        emit("select", cellData.value);
      }
      function onCellMouseEnter(cellData) {
        emit("cell-mouse-enter", cellData.value);
      }
      return {
        prefixCls,
        pickerPrefixCls,
        headerTitle,
        rows,
        isSameTime,
        onCellClick,
        onCellMouseEnter
      };
    }
  });
  function _sfc_render$1V(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_PanelHeader = vue.resolveComponent("PanelHeader");
    const _component_PanelBody = vue.resolveComponent("PanelBody");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.prefixCls)
    }, [
      vue.createElementVNode("div", {
        class: vue.normalizeClass(`${_ctx.prefixCls}-inner`)
      }, [
        vue.createVNode(_component_PanelHeader, vue.mergeProps(__spreadProps(__spreadValues({}, _ctx.headerOperations), {
          icons: _ctx.headerIcons
        }), {
          "prefix-cls": _ctx.pickerPrefixCls,
          title: _ctx.headerTitle,
          mode: "quarter",
          value: _ctx.headerValue,
          "on-label-click": _ctx.onHeaderLabelClick
        }), null, 16, ["prefix-cls", "title", "value", "on-label-click"]),
        vue.createVNode(_component_PanelBody, {
          mode: "quarter",
          "prefix-cls": _ctx.pickerPrefixCls,
          rows: _ctx.rows,
          value: _ctx.value,
          "range-values": _ctx.rangeValues,
          "disabled-date": _ctx.disabledDate,
          "is-same-time": _ctx.isSameTime,
          "date-render": _ctx.dateRender,
          onCellClick: _ctx.onCellClick,
          onCellMouseEnter: _ctx.onCellMouseEnter
        }, null, 8, ["prefix-cls", "rows", "value", "range-values", "disabled-date", "is-same-time", "date-render", "onCellClick", "onCellMouseEnter"])
      ], 2)
    ], 2);
  }
  var QuarterPanel = /* @__PURE__ */ _export_sfc(_sfc_main$1W, [["render", _sfc_render$1V]]);
  const _sfc_main$1V = vue.defineComponent({
    name: "IconLink",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-link`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$N = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$E = /* @__PURE__ */ vue.createElementVNode("path", { d: "m14.1 25.414-4.95 4.95a6 6 0 0 0 8.486 8.485l8.485-8.485a6 6 0 0 0 0-8.485m7.779.707 4.95-4.95a6 6 0 1 0-8.486-8.485l-8.485 8.485a6 6 0 0 0 0 8.485" }, null, -1);
  const _hoisted_3$B = [
    _hoisted_2$E
  ];
  function _sfc_render$1U(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$B, 14, _hoisted_1$N);
  }
  var _IconLink = /* @__PURE__ */ _export_sfc(_sfc_main$1V, [["render", _sfc_render$1U]]);
  const IconLink = Object.assign(_IconLink, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconLink.name, _IconLink);
    }
  });
  const _sfc_main$1U = vue.defineComponent({
    name: "Link",
    components: { IconLink, IconLoading },
    props: {
      href: String,
      status: {
        type: String,
        default: "normal"
      },
      hoverable: {
        type: Boolean,
        default: true
      },
      icon: Boolean,
      loading: Boolean,
      disabled: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { slots, emit }) {
      const prefixCls = getPrefixCls("link");
      const showIcon = hasPropOrSlot(props, slots, "icon");
      const handleClick = (ev) => {
        if (props.disabled || props.loading) {
          ev.preventDefault();
          return;
        }
        emit("click", ev);
      };
      const cls = vue.computed(() => [
        prefixCls,
        `${prefixCls}-status-${props.status}`,
        {
          [`${prefixCls}-disabled`]: props.disabled,
          [`${prefixCls}-loading`]: props.loading,
          [`${prefixCls}-hoverless`]: !props.hoverable,
          [`${prefixCls}-with-icon`]: props.loading || showIcon.value
        }
      ]);
      return {
        cls,
        prefixCls,
        showIcon,
        handleClick
      };
    }
  });
  const _hoisted_1$M = ["href"];
  function _sfc_render$1T(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_icon_loading = vue.resolveComponent("icon-loading");
    const _component_icon_link = vue.resolveComponent("icon-link");
    return vue.openBlock(), vue.createElementBlock("a", {
      href: _ctx.disabled ? void 0 : _ctx.href,
      class: vue.normalizeClass(_ctx.cls),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    }, [
      _ctx.loading || _ctx.showIcon ? (vue.openBlock(), vue.createElementBlock("span", {
        key: 0,
        class: vue.normalizeClass(`${_ctx.prefixCls}-icon`)
      }, [
        _ctx.loading ? (vue.openBlock(), vue.createBlock(_component_icon_loading, { key: 0 })) : vue.renderSlot(_ctx.$slots, "icon", { key: 1 }, () => [
          vue.createVNode(_component_icon_link)
        ])
      ], 2)) : vue.createCommentVNode("v-if", true),
      vue.renderSlot(_ctx.$slots, "default")
    ], 10, _hoisted_1$M);
  }
  var _Link = /* @__PURE__ */ _export_sfc(_sfc_main$1U, [["render", _sfc_render$1T]]);
  const Link = Object.assign(_Link, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Link.name, _Link);
    }
  });
  const _sfc_main$1T = vue.defineComponent({
    name: "PanelFooter",
    components: {
      Link,
      Button
    },
    props: {
      prefixCls: {
        type: String,
        required: true
      },
      showTodayBtn: {
        type: Boolean
      },
      showConfirmBtn: {
        type: Boolean
      },
      confirmBtnDisabled: {
        type: Boolean
      }
    },
    emits: ["today-btn-click", "confirm-btn-click"],
    setup(_, { emit }) {
      const datePickerT = useDatePickerTransform$1();
      return {
        datePickerT,
        onTodayClick: () => {
          emit("today-btn-click");
        },
        onConfirmBtnClick: () => {
          emit("confirm-btn-click");
        }
      };
    }
  });
  function _sfc_render$1S(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Link = vue.resolveComponent("Link");
    const _component_Button = vue.resolveComponent("Button");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(`${_ctx.prefixCls}-footer`)
    }, [
      _ctx.$slots.extra ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: vue.normalizeClass(`${_ctx.prefixCls}-footer-extra-wrapper`)
      }, [
        vue.renderSlot(_ctx.$slots, "extra")
      ], 2)) : vue.createCommentVNode("v-if", true),
      _ctx.showTodayBtn ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 1,
        class: vue.normalizeClass(`${_ctx.prefixCls}-footer-now-wrapper`)
      }, [
        vue.createVNode(_component_Link, { onClick: _ctx.onTodayClick }, {
          default: vue.withCtx(() => [
            vue.createTextVNode(vue.toDisplayString(_ctx.datePickerT("datePicker.today")), 1)
          ]),
          _: 1
        }, 8, ["onClick"])
      ], 2)) : vue.createCommentVNode("v-if", true),
      _ctx.$slots.btn || _ctx.showConfirmBtn ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 2,
        class: vue.normalizeClass(`${_ctx.prefixCls}-footer-btn-wrapper`)
      }, [
        vue.renderSlot(_ctx.$slots, "btn"),
        _ctx.showConfirmBtn ? (vue.openBlock(), vue.createBlock(_component_Button, {
          key: 0,
          class: vue.normalizeClass(`${_ctx.prefixCls}-btn-confirm`),
          type: "primary",
          size: "mini",
          disabled: _ctx.confirmBtnDisabled,
          onClick: _ctx.onConfirmBtnClick
        }, {
          default: vue.withCtx(() => [
            vue.createTextVNode(vue.toDisplayString(_ctx.datePickerT("datePicker.ok")), 1)
          ]),
          _: 1
        }, 8, ["class", "disabled", "onClick"])) : vue.createCommentVNode("v-if", true)
      ], 2)) : vue.createCommentVNode("v-if", true)
    ], 2);
  }
  var PanelFooter = /* @__PURE__ */ _export_sfc(_sfc_main$1T, [["render", _sfc_render$1S]]);
  function usePanelSpan(props) {
    const { mode } = vue.toRefs(props);
    const span = vue.computed(() => ({ date: 1, week: 1, year: 10 * 12, quarter: 12, month: 12 })[mode.value]);
    const superSpan = vue.computed(() => ["year"].includes(mode.value) ? 10 * 12 : 12);
    return {
      span,
      superSpan
    };
  }
  function useHeaderValue(props) {
    const { mode, value, defaultValue, selectedValue, format, onChange } = vue.toRefs(props);
    const computedMode = vue.computed(() => (mode == null ? void 0 : mode.value) || "date");
    const { span, superSpan } = usePanelSpan(vue.reactive({
      mode: computedMode
    }));
    const isSame = (current, target2) => {
      const unit = computedMode.value === "date" || computedMode.value === "week" ? "M" : "y";
      return current.isSame(target2, unit);
    };
    const computedValue = vue.computed(() => getDayjsValue(value == null ? void 0 : value.value, format.value));
    const computedDefaultValue = vue.computed(() => getDayjsValue(defaultValue == null ? void 0 : defaultValue.value, format.value));
    const localValue = vue.ref(computedDefaultValue.value || getNow());
    const headerValue = vue.computed(() => computedValue.value || localValue.value);
    const setLocalValue = (newVal) => {
      if (!newVal)
        return;
      localValue.value = newVal;
    };
    const setHeaderValue = (newVal, emitChange = true) => {
      var _a;
      if (!newVal)
        return;
      if (emitChange && !isSame(headerValue.value, newVal)) {
        (_a = onChange == null ? void 0 : onChange.value) == null ? void 0 : _a.call(onChange, newVal);
      }
      setLocalValue(newVal);
    };
    if (selectedValue == null ? void 0 : selectedValue.value) {
      setLocalValue(selectedValue.value);
    }
    vue.watch(() => selectedValue == null ? void 0 : selectedValue.value, (newVal) => {
      setHeaderValue(newVal);
    });
    function getDefaultLocalValue() {
      return (selectedValue == null ? void 0 : selectedValue.value) || computedDefaultValue.value || getNow();
    }
    function resetHeaderValue(emitChange = true) {
      const defaultLocalValue = getDefaultLocalValue();
      if (emitChange) {
        setHeaderValue(defaultLocalValue);
      } else {
        setLocalValue(defaultLocalValue);
      }
    }
    const showSingleBtn = vue.computed(() => span.value !== superSpan.value);
    const headerOperations = vue.computed(() => ({
      onSuperPrev: () => {
        setHeaderValue(methods.subtract(headerValue.value, superSpan.value, "M"));
      },
      onPrev: showSingleBtn.value ? () => {
        setHeaderValue(methods.subtract(headerValue.value, span.value, "M"));
      } : void 0,
      onNext: showSingleBtn.value ? () => {
        setHeaderValue(methods.add(headerValue.value, span.value, "M"));
      } : void 0,
      onSuperNext: () => {
        setHeaderValue(methods.add(headerValue.value, superSpan.value, "M"));
      }
    }));
    return {
      headerValue,
      setHeaderValue,
      headerOperations,
      resetHeaderValue,
      getDefaultLocalValue
    };
  }
  const _sfc_main$1S = vue.defineComponent({
    name: "DatePikerPanel",
    components: {
      DatePanel,
      PanelShortcuts,
      PanelFooter,
      WeekPanel,
      MonthPanel,
      YearPanel,
      QuarterPanel,
      RenderFunction
    },
    props: {
      mode: {
        type: String
      },
      headerMode: {
        type: String
      },
      prefixCls: {
        type: String,
        required: true
      },
      value: {
        type: Object
      },
      headerValue: {
        type: Object,
        required: true
      },
      timePickerValue: {
        type: Object
      },
      showTime: {
        type: Boolean
      },
      showConfirmBtn: {
        type: Boolean
      },
      shortcuts: {
        type: Array,
        default: () => []
      },
      shortcutsPosition: {
        type: String,
        default: "bottom"
      },
      format: {
        type: String,
        required: true
      },
      dayStartOfWeek: {
        type: Number,
        default: 0
      },
      disabledDate: {
        type: Function
      },
      disabledTime: {
        type: Function
      },
      timePickerProps: {
        type: Object
      },
      extra: {
        type: Function
      },
      dateRender: {
        type: Function
      },
      hideTrigger: {
        type: Boolean
      },
      confirmBtnDisabled: {
        type: Boolean
      },
      showNowBtn: {
        type: Boolean
      },
      headerIcons: {
        type: Object,
        default: () => ({})
      },
      headerOperations: {
        type: Object
      },
      abbreviation: {
        type: Boolean
      }
    },
    emits: [
      "cell-click",
      "time-picker-select",
      "shortcut-click",
      "shortcut-mouse-enter",
      "shortcut-mouse-leave",
      "confirm",
      "today-btn-click",
      "header-label-click",
      "header-select",
      "month-header-click"
    ],
    setup(props, { emit }) {
      const {
        prefixCls,
        shortcuts,
        shortcutsPosition,
        format,
        value,
        disabledDate,
        hideTrigger,
        showNowBtn,
        dateRender,
        showConfirmBtn,
        headerValue,
        headerIcons,
        headerOperations,
        headerMode
      } = vue.toRefs(props);
      const hasShortcuts = vue.computed(() => Boolean(shortcuts.value && shortcuts.value.length));
      const showShortcutsNowBtn = vue.computed(() => showNowBtn.value && showConfirmBtn.value && !hasShortcuts.value);
      const showShortcuts = vue.computed(() => showShortcutsNowBtn.value || hasShortcuts.value);
      const showShortcutsInLeft = vue.computed(() => showShortcuts.value && shortcutsPosition.value === "left");
      const showShortcutsInRight = vue.computed(() => showShortcuts.value && shortcutsPosition.value === "right");
      const showShortcutsInBottom = vue.computed(() => showShortcuts.value && shortcutsPosition.value === "bottom");
      const classNames = vue.computed(() => [
        `${prefixCls.value}-container`,
        {
          [`${prefixCls.value}-container-panel-only`]: hideTrigger.value,
          [`${prefixCls.value}-container-shortcuts-placement-left`]: showShortcutsInLeft.value,
          [`${prefixCls.value}-container-shortcuts-placement-right`]: showShortcutsInRight.value
        }
      ]);
      const footerValue = vue.computed(() => (value == null ? void 0 : value.value) || getNow());
      const {
        headerValue: headerPanelHeaderValue,
        setHeaderValue: setHeaderPanelHeaderValue,
        headerOperations: headerPanelHeaderOperations
      } = useHeaderValue(vue.reactive({
        mode: headerMode,
        format
      }));
      vue.watch(headerValue, (val) => {
        setHeaderPanelHeaderValue(val);
      });
      function getShortcutValue(shortcut) {
        const { value: value2 } = shortcut;
        return getDayjsValue(isFunction$1(value2) ? value2() : value2, shortcut.format || format.value);
      }
      function onShortcutClick(shortcut) {
        emit("shortcut-click", getShortcutValue(shortcut), shortcut);
      }
      function onShortcutMouseEnter(shortcut) {
        emit("shortcut-mouse-enter", getShortcutValue(shortcut));
      }
      function onShortcutMouseLeave(shortcut) {
        emit("shortcut-mouse-leave", getShortcutValue(shortcut));
      }
      function onPanelSelect(date) {
        emit("cell-click", date);
      }
      function onTimePickerSelect(time) {
        emit("time-picker-select", time);
      }
      function onTodayBtnClick() {
        emit("today-btn-click", getNow());
      }
      function onConfirmBtnClick() {
        emit("confirm");
      }
      function onPanelHeaderLabelClick(type) {
        emit("header-label-click", type);
      }
      function onHeaderPanelSelect(date) {
        emit("header-select", date);
      }
      function onMonthHeaderLabelClick() {
        emit("month-header-click");
      }
      const shortcutsProps = vue.reactive({
        prefixCls,
        shortcuts,
        showNowBtn: showShortcutsNowBtn,
        onItemClick: onShortcutClick,
        onItemMouseEnter: onShortcutMouseEnter,
        onItemMouseLeave: onShortcutMouseLeave,
        onNowClick: onTodayBtnClick
      });
      const commonPanelProps = vue.reactive({
        value,
        headerValue,
        headerIcons,
        headerOperations,
        disabledDate,
        dateRender,
        onSelect: onPanelSelect,
        onHeaderLabelClick: onPanelHeaderLabelClick
      });
      return {
        classNames,
        showShortcutsInLeft,
        showShortcutsInRight,
        showShortcutsInBottom,
        shortcutsProps,
        commonPanelProps,
        footerValue,
        onTodayBtnClick,
        onConfirmBtnClick,
        onTimePickerSelect,
        onHeaderPanelSelect,
        headerPanelHeaderValue,
        headerPanelHeaderOperations,
        onMonthHeaderLabelClick
      };
    }
  });
  function _sfc_render$1R(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_PanelShortcuts = vue.resolveComponent("PanelShortcuts");
    const _component_YearPanel = vue.resolveComponent("YearPanel");
    const _component_MonthPanel = vue.resolveComponent("MonthPanel");
    const _component_WeekPanel = vue.resolveComponent("WeekPanel");
    const _component_QuarterPanel = vue.resolveComponent("QuarterPanel");
    const _component_DatePanel = vue.resolveComponent("DatePanel");
    const _component_RenderFunction = vue.resolveComponent("RenderFunction");
    const _component_PanelFooter = vue.resolveComponent("PanelFooter");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.classNames)
    }, [
      _ctx.showShortcutsInLeft ? (vue.openBlock(), vue.createBlock(_component_PanelShortcuts, vue.normalizeProps(vue.mergeProps({ key: 0 }, _ctx.shortcutsProps)), null, 16)) : vue.createCommentVNode("v-if", true),
      vue.createElementVNode("div", {
        class: vue.normalizeClass(`${_ctx.prefixCls}-panel-wrapper`)
      }, [
        _ctx.headerMode ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
          _ctx.headerMode === "year" ? (vue.openBlock(), vue.createBlock(_component_YearPanel, {
            key: 0,
            "header-value": _ctx.headerPanelHeaderValue,
            "header-icons": _ctx.headerIcons,
            "header-operations": _ctx.headerPanelHeaderOperations,
            onSelect: _ctx.onHeaderPanelSelect
          }, null, 8, ["header-value", "header-icons", "header-operations", "onSelect"])) : _ctx.headerMode === "month" ? (vue.openBlock(), vue.createBlock(_component_MonthPanel, {
            key: 1,
            "header-value": _ctx.headerPanelHeaderValue,
            "header-icons": _ctx.headerIcons,
            "header-operations": _ctx.headerPanelHeaderOperations,
            abbreviation: _ctx.abbreviation,
            onSelect: _ctx.onHeaderPanelSelect,
            onHeaderLabelClick: _ctx.onMonthHeaderLabelClick
          }, null, 8, ["header-value", "header-icons", "header-operations", "abbreviation", "onSelect", "onHeaderLabelClick"])) : vue.createCommentVNode("v-if", true)
        ], 2112)) : (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 1 }, [
          _ctx.mode === "week" ? (vue.openBlock(), vue.createBlock(_component_WeekPanel, vue.mergeProps({ key: 0 }, _ctx.commonPanelProps, { "day-start-of-week": _ctx.dayStartOfWeek }), null, 16, ["day-start-of-week"])) : _ctx.mode === "month" ? (vue.openBlock(), vue.createBlock(_component_MonthPanel, vue.mergeProps({
            key: 1,
            abbreviation: _ctx.abbreviation
          }, _ctx.commonPanelProps), null, 16, ["abbreviation"])) : _ctx.mode === "year" ? (vue.openBlock(), vue.createBlock(_component_YearPanel, vue.normalizeProps(vue.mergeProps({ key: 2 }, _ctx.commonPanelProps)), null, 16)) : _ctx.mode === "quarter" ? (vue.openBlock(), vue.createBlock(_component_QuarterPanel, vue.normalizeProps(vue.mergeProps({ key: 3 }, _ctx.commonPanelProps)), null, 16)) : (vue.openBlock(), vue.createBlock(_component_DatePanel, vue.mergeProps({ key: 4 }, _ctx.commonPanelProps, {
            mode: "date",
            "show-time": _ctx.showTime,
            "time-picker-props": _ctx.timePickerProps,
            "day-start-of-week": _ctx.dayStartOfWeek,
            "footer-value": _ctx.footerValue,
            "time-picker-value": _ctx.timePickerValue,
            "disabled-time": _ctx.disabledTime,
            onTimePickerSelect: _ctx.onTimePickerSelect
          }), null, 16, ["show-time", "time-picker-props", "day-start-of-week", "footer-value", "time-picker-value", "disabled-time", "onTimePickerSelect"])),
          vue.createVNode(_component_PanelFooter, {
            "prefix-cls": _ctx.prefixCls,
            "show-today-btn": _ctx.showNowBtn && !(_ctx.showConfirmBtn || _ctx.showShortcutsInBottom),
            "show-confirm-btn": _ctx.showConfirmBtn,
            "confirm-btn-disabled": _ctx.confirmBtnDisabled,
            onTodayBtnClick: _ctx.onTodayBtnClick,
            onConfirmBtnClick: _ctx.onConfirmBtnClick
          }, vue.createSlots({ _: 2 }, [
            _ctx.extra ? {
              name: "extra",
              fn: vue.withCtx(() => [
                _ctx.extra ? (vue.openBlock(), vue.createBlock(_component_RenderFunction, {
                  key: 0,
                  "render-func": _ctx.extra
                }, null, 8, ["render-func"])) : vue.createCommentVNode("v-if", true)
              ])
            } : void 0,
            _ctx.showShortcutsInBottom ? {
              name: "btn",
              fn: vue.withCtx(() => [
                vue.createVNode(_component_PanelShortcuts, vue.normalizeProps(vue.guardReactiveProps(_ctx.shortcutsProps)), null, 16)
              ])
            } : void 0
          ]), 1032, ["prefix-cls", "show-today-btn", "show-confirm-btn", "confirm-btn-disabled", "onTodayBtnClick", "onConfirmBtnClick"])
        ], 64))
      ], 2),
      _ctx.showShortcutsInRight ? (vue.openBlock(), vue.createBlock(_component_PanelShortcuts, vue.normalizeProps(vue.mergeProps({ key: 1 }, _ctx.shortcutsProps)), null, 16)) : vue.createCommentVNode("v-if", true)
    ], 2);
  }
  var PickerPanel = /* @__PURE__ */ _export_sfc(_sfc_main$1S, [["render", _sfc_render$1R]]);
  function getDefaultFormat(mode = "date", showTime = false) {
    switch (mode) {
      case "date":
        return showTime ? "YYYY-MM-DD HH:mm:ss" : "YYYY-MM-DD";
      case "month":
        return "YYYY-MM";
      case "year":
        return "YYYY";
      case "week":
        return "gggg-wo";
      case "quarter":
        return "YYYY-[Q]Q";
      default:
        return "YYYY-MM-DD";
    }
  }
  function getDefaultValueFormat(mode = "date", showTime = false) {
    switch (mode) {
      case "date":
        return showTime ? "YYYY-MM-DD HH:mm:ss" : "YYYY-MM-DD";
      case "month":
        return "YYYY-MM";
      case "year":
        return "YYYY";
      case "week":
        return "YYYY-MM-DD";
      case "quarter":
        return "YYYY-MM";
      default:
        return "YYYY-MM-DD";
    }
  }
  function useFormat(props) {
    const {
      format: propFormat,
      mode,
      showTime,
      valueFormat: propValueFormat
    } = vue.toRefs(props);
    const format = vue.computed(() => !isFunction$1(propFormat == null ? void 0 : propFormat.value) && (propFormat == null ? void 0 : propFormat.value) || getDefaultFormat(mode == null ? void 0 : mode.value, showTime == null ? void 0 : showTime.value));
    const valueFormat = vue.computed(() => (propValueFormat == null ? void 0 : propValueFormat.value) || getDefaultValueFormat(mode == null ? void 0 : mode.value, showTime == null ? void 0 : showTime.value));
    const parseValueFormat = vue.computed(() => ["timestamp", "Date"].includes(valueFormat.value) ? format.value : valueFormat.value);
    return {
      format,
      valueFormat,
      parseValueFormat
    };
  }
  function useIsDisabledDate(props) {
    const { mode, showTime, disabledDate, disabledTime, isRange } = vue.toRefs(props);
    const needCheckTime = vue.computed(() => (mode == null ? void 0 : mode.value) === "date" && (showTime == null ? void 0 : showTime.value));
    const isDisabledDate = vue.computed(() => {
      return (current, type) => {
        if (!(disabledDate == null ? void 0 : disabledDate.value))
          return false;
        const dateValue = getDateValue$1(current);
        if (isRange == null ? void 0 : isRange.value)
          return disabledDate.value(dateValue, type);
        return disabledDate.value(dateValue);
      };
    });
    const isDisabledItem = (num, getDisabledList) => {
      const list = (getDisabledList == null ? void 0 : getDisabledList()) || [];
      return list.includes(num);
    };
    const isDisabledTime2 = vue.computed(() => {
      return (current, type) => {
        if (!needCheckTime.value)
          return false;
        if (!(disabledTime == null ? void 0 : disabledTime.value))
          return false;
        const dateValue = getDateValue$1(current);
        const disabledTimeProps = (isRange == null ? void 0 : isRange.value) ? disabledTime.value(dateValue, type) : disabledTime.value(dateValue);
        return isDisabledItem(current.hour(), disabledTimeProps.disabledHours) || isDisabledItem(current.minute(), disabledTimeProps.disabledMinutes) || isDisabledItem(current.second(), disabledTimeProps.disabledSeconds);
      };
    });
    return function isDisabled(value, type) {
      return value && (isDisabledDate.value(value, type || "start") || isDisabledTime2.value(value, type || "start"));
    };
  }
  const getValueByPath = (obj, path) => {
    if (!obj || !path) {
      return void 0;
    }
    path = path.replace(/\[(\w+)\]/g, ".$1");
    const keys = path.split(".");
    if (keys.length === 0) {
      return void 0;
    }
    let temp = obj;
    for (let i = 0; i < keys.length; i++) {
      if (!isObject$1(temp) && !isArray$1(temp) || !keys[i]) {
        return void 0;
      }
      if (i !== keys.length - 1) {
        temp = temp[keys[i]];
      } else {
        return temp[keys[i]];
      }
    }
    return void 0;
  };
  const setValueByPath = (obj, path, value, { addPath } = {}) => {
    if (!obj || !path) {
      return;
    }
    path = path.replace(/\[(\w+)\]/g, ".$1");
    const keys = path.split(".");
    if (keys.length === 0) {
      return;
    }
    let temp = obj;
    for (let i = 0; i < keys.length; i++) {
      if (!isObject$1(temp) && !isArray$1(temp) || !keys[i]) {
        return;
      }
      if (i !== keys.length - 1) {
        if (addPath && isUndefined(temp[keys[i]])) {
          temp[keys[i]] = {};
        }
        temp = temp[keys[i]];
      } else {
        temp[keys[i]] = value;
      }
    }
  };
  function useDatePickerTransform(props) {
    const { locale } = vue.toRefs(props);
    const { locale: i18nLocale, t: t2 } = useI18n();
    dayjs.locale(i18nLocale.value.toLowerCase());
    const datePickerT = (key, ...args) => {
      const keyForLocale = key.startsWith("datePicker.") ? key.split(".").slice(1).join(".") : key;
      return getValueByPath((locale == null ? void 0 : locale.value) || {}, keyForLocale) || t2(key, ...args);
    };
    vue.provide(PickerInjectionKey, {
      datePickerT
    });
    return datePickerT;
  }
  function useTimePickerValue(props) {
    const { timePickerProps, selectedValue } = vue.toRefs(props);
    const timePickerPropsFormat = vue.computed(() => {
      var _a;
      return (_a = timePickerProps == null ? void 0 : timePickerProps.value) == null ? void 0 : _a.format;
    });
    const timePickerPropsUse12Hours = vue.computed(() => {
      var _a;
      return !!((_a = timePickerProps == null ? void 0 : timePickerProps.value) == null ? void 0 : _a.use12Hours);
    });
    const { format } = useTimeFormat(vue.reactive({
      format: timePickerPropsFormat,
      use12Hours: timePickerPropsUse12Hours
    }));
    const defaultTimePickerValue = vue.computed(() => {
      var _a;
      return getDayjsValue((_a = timePickerProps == null ? void 0 : timePickerProps.value) == null ? void 0 : _a.defaultValue, format.value);
    });
    const getDefaultValue = () => (selectedValue == null ? void 0 : selectedValue.value) || defaultTimePickerValue.value || getNow();
    const timePickerValue = vue.ref(getDefaultValue());
    function setTimePickerValue(val) {
      if (val) {
        timePickerValue.value = val;
      }
    }
    function resetTimePickerValue() {
      timePickerValue.value = getDefaultValue();
    }
    vue.watch(selectedValue, (newVal) => {
      setTimePickerValue(newVal);
    });
    return [timePickerValue, setTimePickerValue, resetTimePickerValue];
  }
  function getReturnValue(date, format) {
    if (format === "timestamp") {
      return date.toDate().getTime();
    }
    if (format === "Date") {
      return date.toDate();
    }
    return date.format(format);
  }
  function useReturnValue(props) {
    const { format } = vue.toRefs(props);
    return (date) => getReturnValue(date, format.value);
  }
  function getReturnRangeValue(dates, format) {
    return dates.map((date) => date ? getReturnValue(date, format) : void 0);
  }
  const _sfc_main$1R = vue.defineComponent({
    name: "Picker",
    components: {
      DateInput,
      Trigger,
      PickerPanel,
      IconCalendar
    },
    inheritAttrs: false,
    props: {
      locale: {
        type: Object
      },
      hideTrigger: {
        type: Boolean
      },
      allowClear: {
        type: Boolean,
        default: true
      },
      readonly: {
        type: Boolean
      },
      error: {
        type: Boolean
      },
      size: {
        type: String
      },
      shortcuts: {
        type: Array,
        default: () => []
      },
      shortcutsPosition: {
        type: String,
        default: "bottom"
      },
      position: {
        type: String,
        default: "bl"
      },
      popupVisible: {
        type: Boolean,
        default: void 0
      },
      defaultPopupVisible: {
        type: Boolean,
        default: false
      },
      triggerProps: {
        type: Object
      },
      unmountOnClose: {
        type: Boolean
      },
      placeholder: {
        type: String
      },
      disabled: {
        type: Boolean
      },
      disabledDate: {
        type: Function
      },
      disabledTime: {
        type: Function
      },
      pickerValue: {
        type: [Object, String, Number]
      },
      defaultPickerValue: {
        type: [Object, String, Number]
      },
      popupContainer: {
        type: [String, Object]
      },
      mode: {
        type: String,
        default: "date"
      },
      format: {
        type: [String, Function]
      },
      valueFormat: {
        type: String
      },
      previewShortcut: {
        type: Boolean,
        default: true
      },
      showConfirmBtn: {
        type: Boolean
      },
      showTime: {
        type: Boolean
      },
      timePickerProps: {
        type: Object
      },
      showNowBtn: {
        type: Boolean,
        default: true
      },
      dayStartOfWeek: {
        type: Number,
        default: 0
      },
      modelValue: {
        type: [Object, String, Number]
      },
      defaultValue: {
        type: [Object, String, Number]
      },
      disabledInput: {
        type: Boolean,
        default: false
      },
      abbreviation: {
        type: Boolean,
        default: true
      }
    },
    emits: {
      "change": (value, date, dateString) => true,
      "update:modelValue": (value) => true,
      "select": (value, date, dateString) => true,
      "popup-visible-change": (visible) => true,
      "update:popupVisible": (visible) => true,
      "ok": (value, date, dateString) => true,
      "clear": () => true,
      "select-shortcut": (shortcut) => true,
      "picker-value-change": (value, date, dateString) => true,
      "update:pickerValue": (value) => true
    },
    setup(props, { emit, slots }) {
      const {
        mode,
        modelValue,
        defaultValue,
        format,
        valueFormat,
        placeholder,
        popupVisible,
        defaultPopupVisible,
        disabled,
        showTime,
        timePickerProps,
        disabledDate,
        disabledTime,
        readonly,
        locale,
        pickerValue,
        defaultPickerValue,
        dayStartOfWeek,
        previewShortcut,
        showConfirmBtn
      } = vue.toRefs(props);
      const { locale: globalLocal } = useI18n();
      vue.watchEffect(() => {
        initializeDateLocale(globalLocal.value, dayStartOfWeek.value);
      });
      const { mergedDisabled, eventHandlers } = useFormItem({ disabled });
      const datePickerT = useDatePickerTransform(vue.reactive({
        locale
      }));
      const prefixCls = getPrefixCls("picker");
      const refInput = vue.ref();
      const computedPlaceholder = vue.computed(() => (placeholder == null ? void 0 : placeholder.value) || {
        date: datePickerT("datePicker.placeholder.date"),
        month: datePickerT("datePicker.placeholder.month"),
        year: datePickerT("datePicker.placeholder.year"),
        week: datePickerT("datePicker.placeholder.week"),
        quarter: datePickerT("datePicker.placeholder.quarter")
      }[mode.value] || datePickerT("datePicker.placeholder.date"));
      const {
        format: computedFormat,
        valueFormat: returnValueFormat,
        parseValueFormat
      } = useFormat(vue.reactive({ format, mode, showTime, valueFormat }));
      const inputFormat = vue.computed(() => format && isFunction$1(format.value) ? (value) => {
        var _a;
        return (_a = format.value) == null ? void 0 : _a.call(format, getDateValue$1(value));
      } : computedFormat.value);
      const getReturnValue2 = useReturnValue(vue.reactive({
        format: returnValueFormat
      }));
      const isDisabledDate = useIsDisabledDate(vue.reactive({
        mode,
        disabledDate,
        disabledTime,
        showTime
      }));
      const needConfirm = vue.computed(() => showTime.value || showConfirmBtn.value);
      const confirmBtnDisabled = vue.computed(() => needConfirm.value && (!forSelectedValue.value || isDisabledDate(forSelectedValue.value)));
      const isDateTime = vue.computed(() => mode.value === "date" && showTime.value);
      const { value: selectedValue, setValue: setSelectedValue } = usePickerState(vue.reactive({
        modelValue,
        defaultValue,
        format: parseValueFormat
      }));
      const [processValue, setProcessValue] = useState();
      const [previewValue, setPreviewValue] = useState();
      const forSelectedValue = vue.computed(() => {
        var _a;
        return (_a = processValue.value) != null ? _a : selectedValue.value;
      });
      const panelValue = vue.computed(() => {
        var _a, _b;
        return (_b = (_a = previewValue.value) != null ? _a : processValue.value) != null ? _b : selectedValue.value;
      });
      const [inputValue, setInputValue] = useState();
      const [panelVisible, setLocalPanelVisible] = useMergeState(defaultPopupVisible.value, vue.reactive({ value: popupVisible }));
      const setPanelVisible = (newVisible) => {
        if (panelVisible.value !== newVisible) {
          setLocalPanelVisible(newVisible);
          emit("popup-visible-change", newVisible);
          emit("update:popupVisible", newVisible);
        }
      };
      const { headerValue, setHeaderValue, headerOperations, resetHeaderValue } = useHeaderValue(vue.reactive({
        mode,
        value: pickerValue,
        defaultValue: defaultPickerValue,
        selectedValue: panelValue,
        format: parseValueFormat,
        onChange: (newVal) => {
          const returnValue = getReturnValue2(newVal);
          const formattedValue = getFormattedValue(newVal, parseValueFormat.value);
          const dateValue = getDateValue$1(newVal);
          emit("picker-value-change", returnValue, dateValue, formattedValue);
          emit("update:pickerValue", returnValue);
        }
      }));
      const [timePickerValue, , resetTimePickerValue] = useTimePickerValue(vue.reactive({
        timePickerProps,
        selectedValue: panelValue
      }));
      const inputEditable = vue.computed(() => !readonly.value && !isFunction$1(inputFormat.value));
      const headerMode = vue.ref();
      vue.watch(panelVisible, (newVisible) => {
        setProcessValue(void 0);
        setPreviewValue(void 0);
        headerMode.value = void 0;
        if (newVisible) {
          resetHeaderValue();
          resetTimePickerValue();
        }
        if (!newVisible) {
          setInputValue(void 0);
        }
      });
      function emitChange(value, emitOk) {
        var _a, _b;
        const returnValue = value ? getReturnValue2(value) : void 0;
        const formattedValue = getFormattedValue(value, parseValueFormat.value);
        const dateValue = getDateValue$1(value);
        if (isValueChange(value, selectedValue.value)) {
          emit("update:modelValue", returnValue);
          emit("change", returnValue, dateValue, formattedValue);
          (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a);
        }
        if (emitOk) {
          emit("ok", returnValue, dateValue, formattedValue);
        }
      }
      function confirm(value, showPanel, emitOk) {
        if (isDisabledDate(value)) {
          return;
        }
        emitChange(value, emitOk);
        setSelectedValue(value);
        setProcessValue(void 0);
        setPreviewValue(void 0);
        setInputValue(void 0);
        headerMode.value = void 0;
        if (isBoolean$1(showPanel)) {
          setPanelVisible(showPanel);
        }
      }
      function select(value, emitSelect) {
        setProcessValue(value);
        setPreviewValue(void 0);
        setInputValue(void 0);
        headerMode.value = void 0;
        if (emitSelect) {
          const returnValue = value ? getReturnValue2(value) : void 0;
          const formattedValue = getFormattedValue(value, parseValueFormat.value);
          const dateValue = getDateValue$1(value);
          emit("select", returnValue, dateValue, formattedValue);
        }
      }
      function focusInput(index2) {
        refInput.value && refInput.value.focus && refInput.value.focus(index2);
      }
      function getMergedOpValue(date, time) {
        if (!isDateTime.value && !timePickerProps.value)
          return date;
        return mergeValueWithTime(getNow(), date, time);
      }
      function onPanelVisibleChange(visible) {
        if (mergedDisabled.value)
          return;
        setPanelVisible(visible);
      }
      function onInputClear(e2) {
        e2.stopPropagation();
        confirm(void 0);
        emit("clear");
      }
      function onInputBlur() {
        var _a, _b;
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onBlur) == null ? void 0 : _b.call(_a);
      }
      function onInputChange(e2) {
        setPanelVisible(true);
        const targetValue = e2.target.value;
        setInputValue(targetValue);
        if (!isValidInputValue(targetValue, computedFormat.value))
          return;
        const newValue = dayjs(targetValue, computedFormat.value);
        if (isDisabledDate(newValue))
          return;
        if (needConfirm.value) {
          select(newValue);
        } else {
          confirm(newValue, true);
        }
      }
      function onInputPressEnter() {
        confirm(panelValue.value, false);
      }
      function onPanelSelect(value) {
        if (needConfirm.value) {
          select(value, true);
        } else {
          confirm(value, false);
        }
      }
      function onPanelCellClick(value) {
        const newValue = getMergedOpValue(value, timePickerValue.value);
        onPanelSelect(newValue);
      }
      function onTimePickerSelect(time) {
        const newValue = getMergedOpValue(panelValue.value || getNow(), time);
        onPanelSelect(newValue);
      }
      function onPanelConfirm() {
        confirm(panelValue.value, false, true);
      }
      function onPanelClick() {
        if (props.disabledInput) {
          focusInput();
        }
      }
      let clearPreviewTimer;
      vue.onUnmounted(() => {
        clearTimeout(clearPreviewTimer);
      });
      function onPanelShortcutMouseEnter(value) {
        clearTimeout(clearPreviewTimer);
        setPreviewValue(value);
        setInputValue(void 0);
      }
      function onPanelShortcutMouseLeave() {
        clearTimeout(clearPreviewTimer);
        clearPreviewTimer = setTimeout(() => {
          setPreviewValue(void 0);
        }, 100);
      }
      function onPanelShortcutClick(value, shortcut) {
        emit("select-shortcut", shortcut);
        confirm(value, false);
      }
      function onPanelHeaderLabelClick(type) {
        headerMode.value = type;
      }
      function onMonthHeaderClick() {
        headerMode.value = "year";
      }
      function onPanelHeaderSelect(date) {
        let newValue = headerValue.value;
        newValue = newValue.set("year", date.year());
        if (headerMode.value === "month") {
          newValue = newValue.set("month", date.month());
        }
        setHeaderValue(newValue);
        if (mode.value === "quarter" || mode.value === "month") {
          headerMode.value = void 0;
          return;
        }
        headerMode.value = headerMode.value === "year" ? "month" : void 0;
      }
      const computedTimePickerProps = vue.computed(() => __spreadProps(__spreadValues({
        format: computedFormat.value
      }, omit((timePickerProps == null ? void 0 : timePickerProps.value) || {}, ["defaultValue"])), {
        visible: panelVisible.value
      }));
      const panelProps = vue.computed(() => __spreadProps(__spreadValues({}, pick(props, [
        "mode",
        "shortcuts",
        "shortcutsPosition",
        "dayStartOfWeek",
        "disabledDate",
        "disabledTime",
        "showTime",
        "hideTrigger",
        "abbreviation"
      ])), {
        showNowBtn: props.showNowBtn && mode.value === "date",
        prefixCls,
        format: parseValueFormat.value,
        value: panelValue.value,
        visible: panelVisible.value,
        showConfirmBtn: needConfirm.value,
        confirmBtnDisabled: confirmBtnDisabled.value,
        timePickerProps: computedTimePickerProps.value,
        extra: slots.extra,
        dateRender: slots.cell,
        headerValue: headerValue.value,
        headerIcons: {
          prev: slots["icon-prev"],
          prevDouble: slots["icon-prev-double"],
          next: slots["icon-next"],
          nextDouble: slots["icon-next-double"]
        },
        headerOperations: headerOperations.value,
        timePickerValue: timePickerValue.value,
        headerMode: headerMode.value,
        onCellClick: onPanelCellClick,
        onTimePickerSelect,
        onConfirm: onPanelConfirm,
        onShortcutClick: onPanelShortcutClick,
        onShortcutMouseEnter: previewShortcut.value ? onPanelShortcutMouseEnter : void 0,
        onShortcutMouseLeave: previewShortcut.value ? onPanelShortcutMouseLeave : void 0,
        onTodayBtnClick: onPanelSelect,
        onHeaderLabelClick: onPanelHeaderLabelClick,
        onHeaderSelect: onPanelHeaderSelect,
        onMonthHeaderClick
      }));
      return {
        prefixCls,
        refInput,
        panelProps,
        panelValue,
        inputValue,
        selectedValue,
        inputFormat,
        computedPlaceholder,
        panelVisible,
        inputEditable,
        needConfirm,
        mergedDisabled,
        onPanelVisibleChange,
        onInputClear,
        onInputChange,
        onInputPressEnter,
        onInputBlur,
        onPanelClick
      };
    }
  });
  function _sfc_render$1Q(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_IconCalendar = vue.resolveComponent("IconCalendar");
    const _component_DateInput = vue.resolveComponent("DateInput");
    const _component_PickerPanel = vue.resolveComponent("PickerPanel");
    const _component_Trigger = vue.resolveComponent("Trigger");
    return !_ctx.hideTrigger ? (vue.openBlock(), vue.createBlock(_component_Trigger, vue.mergeProps({
      key: 0,
      trigger: "click",
      "animation-name": "slide-dynamic-origin",
      "auto-fit-transform-origin": "",
      "click-to-close": false,
      "popup-offset": 4
    }, _ctx.triggerProps, {
      position: _ctx.position,
      disabled: _ctx.mergedDisabled || _ctx.readonly,
      "prevent-focus": true,
      "popup-visible": _ctx.panelVisible,
      "unmount-on-close": _ctx.unmountOnClose,
      "popup-container": _ctx.popupContainer,
      onPopupVisibleChange: _ctx.onPanelVisibleChange
    }), {
      content: vue.withCtx(() => [
        vue.createVNode(_component_PickerPanel, vue.mergeProps(_ctx.panelProps, { onClick: _ctx.onPanelClick }), null, 16, ["onClick"])
      ]),
      default: vue.withCtx(() => [
        vue.renderSlot(_ctx.$slots, "default", {}, () => [
          vue.createVNode(_component_DateInput, vue.mergeProps(_ctx.$attrs, {
            ref: "refInput",
            size: _ctx.size,
            focused: _ctx.panelVisible,
            visible: _ctx.panelVisible,
            error: _ctx.error,
            disabled: _ctx.mergedDisabled,
            readonly: !_ctx.inputEditable || _ctx.disabledInput,
            "allow-clear": _ctx.allowClear && !_ctx.readonly,
            placeholder: _ctx.computedPlaceholder,
            "input-value": _ctx.inputValue,
            value: _ctx.needConfirm ? _ctx.panelValue : _ctx.selectedValue,
            format: _ctx.inputFormat,
            onClear: _ctx.onInputClear,
            onChange: _ctx.onInputChange,
            onPressEnter: _ctx.onInputPressEnter,
            onBlur: _ctx.onInputBlur
          }), vue.createSlots({
            "suffix-icon": vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "suffix-icon", {}, () => [
                vue.createVNode(_component_IconCalendar)
              ])
            ]),
            _: 2
          }, [
            _ctx.$slots.prefix ? {
              name: "prefix",
              fn: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "prefix")
              ])
            } : void 0
          ]), 1040, ["size", "focused", "visible", "error", "disabled", "readonly", "allow-clear", "placeholder", "input-value", "value", "format", "onClear", "onChange", "onPressEnter", "onBlur"])
        ])
      ]),
      _: 3
    }, 16, ["position", "disabled", "popup-visible", "unmount-on-close", "popup-container", "onPopupVisibleChange"])) : (vue.openBlock(), vue.createBlock(_component_PickerPanel, vue.normalizeProps(vue.mergeProps({ key: 1 }, __spreadValues(__spreadValues({}, _ctx.$attrs), _ctx.panelProps))), null, 16));
  }
  var Picker = /* @__PURE__ */ _export_sfc(_sfc_main$1R, [["render", _sfc_render$1Q]]);
  var _DatePicker = vue.defineComponent({
    name: "DatePicker",
    props: {
      modelValue: {
        type: [Object, String, Number]
      },
      defaultValue: {
        type: [Object, String, Number]
      },
      format: {
        type: [String, Function]
      },
      dayStartOfWeek: {
        type: Number,
        default: 0
      },
      showTime: {
        type: Boolean
      },
      timePickerProps: {
        type: Object
      },
      disabled: {
        type: Boolean
      },
      disabledDate: {
        type: Function
      },
      disabledTime: {
        type: Function
      },
      showNowBtn: {
        type: Boolean,
        default: true
      }
    },
    setup(props, {
      attrs,
      slots
    }) {
      return () => vue.createVNode(Picker, vue.mergeProps(props, attrs, {
        "mode": "date"
      }), slots);
    }
  });
  var WeekPicker = vue.defineComponent({
    name: "WeekPicker",
    props: {
      modelValue: {
        type: [Object, String, Number]
      },
      defaultValue: {
        type: [Object, String, Number]
      },
      format: {
        type: String,
        default: "gggg-wo"
      },
      valueFormat: {
        type: String,
        default: "YYYY-MM-DD"
      },
      dayStartOfWeek: {
        type: Number,
        default: 0
      }
    },
    setup(props, {
      attrs,
      slots
    }) {
      return () => vue.createVNode(Picker, vue.mergeProps(props, attrs, {
        "mode": "week"
      }), slots);
    }
  });
  var MonthPicker = vue.defineComponent({
    name: "MonthPicker",
    props: {
      modelValue: {
        type: [Object, String, Number]
      },
      defaultValue: {
        type: [Object, String, Number]
      },
      format: {
        type: String,
        default: "YYYY-MM"
      }
    },
    setup(props, {
      attrs,
      slots
    }) {
      return () => vue.createVNode(Picker, vue.mergeProps(props, attrs, {
        "mode": "month"
      }), slots);
    }
  });
  var YearPicker = vue.defineComponent({
    name: "YearPicker",
    props: {
      modelValue: {
        type: [Object, String, Number]
      },
      defaultValue: {
        type: [Object, String, Number]
      },
      format: {
        type: String,
        default: "YYYY"
      }
    },
    setup(props, {
      attrs,
      slots
    }) {
      return () => vue.createVNode(Picker, vue.mergeProps(props, attrs, {
        "mode": "year"
      }), slots);
    }
  });
  var QuarterPicker = vue.defineComponent({
    name: "QuarterPicker",
    props: {
      modelValue: {
        type: [Object, String, Number]
      },
      defaultValue: {
        type: [Object, String, Number]
      },
      format: {
        type: String,
        default: "YYYY-[Q]Q"
      },
      valueFormat: {
        type: String,
        default: "YYYY-MM"
      }
    },
    setup(props, {
      attrs,
      slots
    }) {
      return () => vue.createVNode(Picker, vue.mergeProps(props, attrs, {
        "mode": "quarter"
      }), slots);
    }
  });
  function useRangePickerState(props) {
    const { modelValue, defaultValue, format } = vue.toRefs(props);
    const computedModelValue = vue.computed(() => {
      return getDayjsValue(normalizeRangeValue(modelValue.value), format.value);
    });
    const computedDefaultValue = vue.computed(() => {
      return getDayjsValue(normalizeRangeValue(defaultValue.value), format.value);
    });
    const [localValue, setLocalValue] = useState(!isUndefined(computedModelValue.value) ? computedModelValue.value : !isUndefined(computedDefaultValue.value) ? computedDefaultValue.value : []);
    vue.watch(computedModelValue, () => {
      if (isUndefined(computedModelValue.value)) {
        setLocalValue([]);
      }
    });
    const mergeValue = vue.computed(() => computedModelValue.value || localValue.value);
    return {
      value: mergeValue,
      setValue: setLocalValue
    };
  }
  function useRangeHeaderValue(props) {
    const {
      startHeaderMode,
      endHeaderMode,
      mode,
      value,
      defaultValue,
      selectedValue,
      format,
      onChange
    } = vue.toRefs(props);
    const isDateOrWeek = vue.computed(() => ["date", "week"].includes(mode.value));
    const unit = vue.computed(() => isDateOrWeek.value ? "M" : "y");
    const isSame = (current, target2) => current.isSame(target2, unit.value);
    const { span, superSpan } = usePanelSpan(vue.reactive({
      mode
    }));
    const startValue = vue.computed(() => {
      var _a;
      return (_a = value.value) == null ? void 0 : _a[0];
    });
    const endValue = vue.computed(() => {
      var _a;
      return (_a = value.value) == null ? void 0 : _a[1];
    });
    const startDefaultValue = vue.computed(() => {
      var _a;
      return (_a = defaultValue.value) == null ? void 0 : _a[0];
    });
    const endDefaultValue = vue.computed(() => {
      var _a;
      return (_a = defaultValue.value) == null ? void 0 : _a[1];
    });
    const emitChange = (newVal) => {
      (onChange == null ? void 0 : onChange.value) && onChange.value(newVal);
    };
    const {
      headerValue: startHeaderValue,
      setHeaderValue: setStartHeaderValue,
      headerOperations: startHeaderOperations,
      getDefaultLocalValue: getDefaultStartHeaderValue
    } = useHeaderValue(vue.reactive({
      mode: (startHeaderMode == null ? void 0 : startHeaderMode.value) || mode,
      value: startValue,
      defaultValue: startDefaultValue,
      selectedValue: void 0,
      format,
      onChange: (newVal) => {
        emitChange([newVal, endHeaderValue.value]);
      }
    }));
    const {
      headerValue: endHeaderValue,
      setHeaderValue: setEndHeaderValue,
      headerOperations: endHeaderOperations,
      getDefaultLocalValue: getDefaultEndHeaderValue
    } = useHeaderValue(vue.reactive({
      mode: (endHeaderMode == null ? void 0 : endHeaderMode.value) || mode,
      value: endValue,
      defaultValue: endDefaultValue,
      selectedValue: void 0,
      format,
      onChange: (newVal) => {
        emitChange([startHeaderValue.value, newVal]);
      }
    }));
    const setHeaderValue = (newVal) => {
      const isSameStartValue = isSame(startHeaderValue.value, newVal[0]);
      const isSameEndValue = isSame(endHeaderValue.value, newVal[1]);
      setStartHeaderValue(newVal[0], false);
      setEndHeaderValue(newVal[1], false);
      if (!isSameStartValue || !isSameEndValue) {
        (onChange == null ? void 0 : onChange.value) && (onChange == null ? void 0 : onChange.value(newVal));
      }
    };
    function getFixedValue(values) {
      let [header02, header12] = getSortedDayjsArray(values);
      const nextHeader = methods.add(header02, span.value, "M");
      if (header12.isBefore(nextHeader, unit.value)) {
        header12 = nextHeader;
      }
      return [header02, header12];
    }
    function getFormSelectedValue() {
      var _a, _b;
      let selected02 = (_a = selectedValue.value) == null ? void 0 : _a[0];
      let selected12 = (_b = selectedValue.value) == null ? void 0 : _b[1];
      if (selected02 && selected12) {
        [selected02, selected12] = getSortedDayjsArray([selected02, selected12]);
      }
      return [selected02, selected12];
    }
    const [selected0, selected1] = getFormSelectedValue();
    const [header0, header1] = getFixedValue([
      selected0 || startHeaderValue.value,
      selected1 || endHeaderValue.value
    ]);
    setStartHeaderValue(header0, false);
    setEndHeaderValue(header1, false);
    const resetHeaderValue = () => {
      const defaultStartHeaderValue = getDefaultStartHeaderValue();
      const defaultEndHeaderValue = getDefaultEndHeaderValue();
      vue.nextTick(() => {
        const [selected02, selected12] = getFormSelectedValue();
        const [header02, header12] = getFixedValue([
          selected02 || defaultStartHeaderValue,
          selected12 || defaultEndHeaderValue
        ]);
        setHeaderValue([header02, header12]);
      });
    };
    const canShortenMonth = vue.computed(() => methods.add(startHeaderValue.value, span.value, "M").isBefore(endHeaderValue.value, unit.value));
    const canShortenYear = vue.computed(() => methods.add(startHeaderValue.value, superSpan.value, "M").isBefore(endHeaderValue.value, unit.value));
    const computedStartHeaderOperations = vue.computed(() => {
      const operations = ["onSuperPrev"];
      if (isDateOrWeek.value)
        operations.push("onPrev");
      if (canShortenMonth.value && isDateOrWeek)
        operations.push("onNext");
      if (canShortenYear.value)
        operations.push("onSuperNext");
      return pick(startHeaderOperations.value, operations);
    });
    const computedEndHeaderOperations = vue.computed(() => {
      const operations = ["onSuperNext"];
      if (isDateOrWeek.value)
        operations.push("onNext");
      if (canShortenMonth.value && isDateOrWeek.value)
        operations.push("onPrev");
      if (canShortenYear.value)
        operations.push("onSuperPrev");
      return pick(endHeaderOperations.value, operations);
    });
    return {
      startHeaderValue,
      endHeaderValue,
      startHeaderOperations: computedStartHeaderOperations,
      endHeaderOperations: computedEndHeaderOperations,
      setHeaderValue,
      resetHeaderValue
    };
  }
  const _sfc_main$1Q = vue.defineComponent({
    name: "DateInputRange",
    components: {
      IconHover,
      IconClose,
      FeedbackIcon
    },
    props: {
      size: {
        type: String
      },
      focused: {
        type: Boolean
      },
      focusedIndex: {
        type: Number
      },
      error: {
        type: Boolean
      },
      disabled: {
        type: [Boolean, Array],
        default: false
      },
      readonly: {
        type: Boolean
      },
      allowClear: {
        type: Boolean
      },
      placeholder: {
        type: Array,
        default: () => []
      },
      inputValue: {
        type: Array
      },
      value: {
        type: Array,
        default: () => []
      },
      format: {
        type: [String, Function],
        required: true
      }
    },
    emits: [
      "focused-index-change",
      "update:focusedIndex",
      "change",
      "clear",
      "press-enter"
    ],
    setup(props, { emit, slots }) {
      const {
        error,
        focused,
        disabled,
        size,
        value,
        format,
        focusedIndex,
        inputValue
      } = vue.toRefs(props);
      const {
        mergedSize: _mergedSize,
        mergedDisabled,
        mergedError,
        feedback
      } = useFormItem({ size, error });
      const { mergedSize } = useSize$1(_mergedSize);
      const refInput0 = vue.ref();
      const refInput1 = vue.ref();
      const getDisabled = (index2) => {
        if (mergedDisabled.value) {
          return mergedDisabled.value;
        }
        return isArray$1(disabled.value) ? disabled.value[index2] : disabled.value;
      };
      const disabled0 = vue.computed(() => getDisabled(0));
      const disabled1 = vue.computed(() => getDisabled(1));
      const prefixCls = getPrefixCls("picker");
      const classNames = vue.computed(() => [
        prefixCls,
        `${prefixCls}-range`,
        `${prefixCls}-size-${mergedSize.value}`,
        {
          [`${prefixCls}-focused`]: focused.value,
          [`${prefixCls}-disabled`]: disabled0.value && disabled1.value,
          [`${prefixCls}-error`]: mergedError.value,
          [`${prefixCls}-has-prefix`]: slots.prefix
        }
      ]);
      function getInputWrapClassName(index2) {
        return [
          `${prefixCls}-input`,
          {
            [`${prefixCls}-input-active`]: index2 === (focusedIndex == null ? void 0 : focusedIndex.value)
          }
        ];
      }
      function getDisplayValue(index2) {
        var _a, _b;
        if (inputValue == null ? void 0 : inputValue.value) {
          return (_a = inputValue == null ? void 0 : inputValue.value) == null ? void 0 : _a[index2];
        }
        const targetValue = (_b = value == null ? void 0 : value.value) == null ? void 0 : _b[index2];
        if (targetValue && isDayjs(targetValue)) {
          return isFunction$1(format.value) ? format.value(targetValue) : targetValue.format(format.value);
        }
        return void 0;
      }
      const displayValue0 = vue.computed(() => getDisplayValue(0));
      const displayValue1 = vue.computed(() => getDisplayValue(1));
      function changeFocusedInput(index2) {
        emit("focused-index-change", index2);
        emit("update:focusedIndex", index2);
      }
      function onChange(e2) {
        e2.stopPropagation();
        emit("change", e2);
      }
      function onPressEnter() {
        emit("press-enter");
      }
      function onPressTab(e2) {
        e2.preventDefault();
      }
      function onClear(e2) {
        emit("clear", e2);
      }
      return {
        prefixCls,
        classNames,
        refInput0,
        refInput1,
        disabled0,
        disabled1,
        mergedDisabled,
        getDisabled,
        getInputWrapClassName,
        displayValue0,
        displayValue1,
        changeFocusedInput,
        onChange,
        onPressEnter,
        onPressTab,
        onClear,
        feedback
      };
    },
    methods: {
      focus(index2) {
        const targetIndex = isNumber$1(index2) ? index2 : this.focusedIndex;
        const targetElement = targetIndex === 0 ? this.refInput0 : this.refInput1;
        !isUndefined(targetIndex) && !this.getDisabled(targetIndex) && targetElement && targetElement.focus && targetElement.focus();
      },
      blur() {
        const targetElement = this.focusedIndex === 0 ? this.refInput0 : this.refInput1;
        targetElement && targetElement.blur && targetElement.blur();
      }
    }
  });
  const _hoisted_1$L = ["disabled", "placeholder", "value"];
  const _hoisted_2$D = /* @__PURE__ */ vue.createTextVNode(" - ");
  const _hoisted_3$A = ["disabled", "placeholder", "value"];
  function _sfc_render$1P(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_IconClose = vue.resolveComponent("IconClose");
    const _component_IconHover = vue.resolveComponent("IconHover");
    const _component_FeedbackIcon = vue.resolveComponent("FeedbackIcon");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.classNames)
    }, [
      _ctx.$slots.prefix ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: vue.normalizeClass(`${_ctx.prefixCls}-prefix`)
      }, [
        vue.renderSlot(_ctx.$slots, "prefix")
      ], 2)) : vue.createCommentVNode("v-if", true),
      vue.createElementVNode("div", {
        class: vue.normalizeClass(_ctx.getInputWrapClassName(0))
      }, [
        vue.createElementVNode("input", vue.mergeProps({
          ref: "refInput0",
          disabled: _ctx.disabled0,
          placeholder: _ctx.placeholder[0],
          value: _ctx.displayValue0
        }, _ctx.readonly ? { readonly: true } : {}, {
          onInput: _cache[0] || (_cache[0] = (...args) => _ctx.onChange && _ctx.onChange(...args)),
          onKeydown: [
            _cache[1] || (_cache[1] = vue.withKeys((...args) => _ctx.onPressEnter && _ctx.onPressEnter(...args), ["enter"])),
            _cache[2] || (_cache[2] = vue.withKeys((...args) => _ctx.onPressTab && _ctx.onPressTab(...args), ["tab"]))
          ],
          onClick: _cache[3] || (_cache[3] = () => _ctx.changeFocusedInput(0))
        }), null, 16, _hoisted_1$L)
      ], 2),
      vue.createElementVNode("span", {
        class: vue.normalizeClass(`${_ctx.prefixCls}-separator`)
      }, [
        vue.renderSlot(_ctx.$slots, "separator", {}, () => [
          _hoisted_2$D
        ])
      ], 2),
      vue.createElementVNode("div", {
        class: vue.normalizeClass(_ctx.getInputWrapClassName(1))
      }, [
        vue.createElementVNode("input", vue.mergeProps({
          ref: "refInput1",
          disabled: _ctx.disabled1,
          placeholder: _ctx.placeholder[1],
          value: _ctx.displayValue1
        }, _ctx.readonly ? { readonly: true } : {}, {
          onInput: _cache[4] || (_cache[4] = (...args) => _ctx.onChange && _ctx.onChange(...args)),
          onKeydown: [
            _cache[5] || (_cache[5] = vue.withKeys((...args) => _ctx.onPressEnter && _ctx.onPressEnter(...args), ["enter"])),
            _cache[6] || (_cache[6] = vue.withKeys((...args) => _ctx.onPressTab && _ctx.onPressTab(...args), ["tab"]))
          ],
          onClick: _cache[7] || (_cache[7] = () => _ctx.changeFocusedInput(1))
        }), null, 16, _hoisted_3$A)
      ], 2),
      vue.createElementVNode("div", {
        class: vue.normalizeClass(`${_ctx.prefixCls}-suffix`)
      }, [
        _ctx.allowClear && !_ctx.mergedDisabled && _ctx.value.length === 2 ? (vue.openBlock(), vue.createBlock(_component_IconHover, {
          key: 0,
          prefix: _ctx.prefixCls,
          class: vue.normalizeClass(`${_ctx.prefixCls}-clear-icon`),
          onClick: _ctx.onClear
        }, {
          default: vue.withCtx(() => [
            vue.createVNode(_component_IconClose)
          ]),
          _: 1
        }, 8, ["prefix", "class", "onClick"])) : vue.createCommentVNode("v-if", true),
        vue.createElementVNode("span", {
          class: vue.normalizeClass(`${_ctx.prefixCls}-suffix-icon`)
        }, [
          vue.renderSlot(_ctx.$slots, "suffix-icon")
        ], 2),
        _ctx.feedback ? (vue.openBlock(), vue.createBlock(_component_FeedbackIcon, {
          key: 1,
          type: _ctx.feedback
        }, null, 8, ["type"])) : vue.createCommentVNode("v-if", true)
      ], 2)
    ], 2);
  }
  var DateRangeInput = /* @__PURE__ */ _export_sfc(_sfc_main$1Q, [["render", _sfc_render$1P]]);
  const _sfc_main$1P = vue.defineComponent({
    name: "DateRangePikerPanel",
    components: {
      PanelShortcuts,
      PanelFooter,
      RenderFunction,
      DatePanel,
      WeekPanel,
      MonthPanel,
      YearPanel,
      QuarterPanel
    },
    props: {
      mode: {
        type: String,
        default: "date"
      },
      value: {
        type: Array,
        default: () => []
      },
      footerValue: {
        type: Array
      },
      timePickerValue: {
        type: Array
      },
      showTime: {
        type: Boolean
      },
      showConfirmBtn: {
        type: Boolean
      },
      prefixCls: {
        type: String,
        required: true
      },
      shortcuts: {
        type: Array,
        default: () => []
      },
      shortcutsPosition: {
        type: String,
        default: "bottom"
      },
      format: {
        type: String,
        required: true
      },
      dayStartOfWeek: {
        type: Number,
        default: 0
      },
      disabledDate: {
        type: Function
      },
      disabledTime: {
        type: Function
      },
      timePickerProps: {
        type: Object
      },
      extra: {
        type: Function
      },
      dateRender: {
        type: Function
      },
      hideTrigger: {
        type: Boolean
      },
      startHeaderProps: {
        type: Object,
        default: () => ({})
      },
      endHeaderProps: {
        type: Object,
        default: () => ({})
      },
      confirmBtnDisabled: {
        type: Boolean
      },
      disabled: {
        type: Array,
        default: () => [false, false]
      },
      visible: {
        type: Boolean
      },
      startHeaderMode: {
        type: String
      },
      endHeaderMode: {
        type: String
      },
      abbreviation: {
        type: Boolean
      }
    },
    emits: [
      "cell-click",
      "cell-mouse-enter",
      "time-picker-select",
      "shortcut-click",
      "shortcut-mouse-enter",
      "shortcut-mouse-leave",
      "confirm",
      "start-header-label-click",
      "end-header-label-click",
      "start-header-select",
      "end-header-select"
    ],
    setup(props, { emit }) {
      const {
        prefixCls,
        shortcuts,
        shortcutsPosition,
        format,
        hideTrigger,
        value,
        disabledDate,
        disabledTime,
        startHeaderProps,
        endHeaderProps,
        dateRender,
        visible,
        startHeaderMode,
        endHeaderMode
      } = vue.toRefs(props);
      const showShortcuts = vue.computed(() => isArray$1(shortcuts.value) && shortcuts.value.length);
      const classNames = vue.computed(() => [
        `${prefixCls.value}-range-container`,
        {
          [`${prefixCls.value}-range-container-panel-only`]: hideTrigger.value,
          [`${prefixCls.value}-range-container-shortcuts-placement-left`]: showShortcuts.value && shortcutsPosition.value === "left",
          [`${prefixCls.value}-range-container-shortcuts-placement-right`]: showShortcuts.value && shortcutsPosition.value === "right"
        }
      ]);
      const currentDateView = vue.ref("date");
      vue.watch(visible, (newVal, oldVal) => {
        if (newVal && !oldVal) {
          currentDateView.value = "date";
        }
      });
      function getShortcutValue(shortcut) {
        return getDayjsValue(normalizeRangeValue(isFunction$1(shortcut.value) ? shortcut.value() : shortcut.value), shortcut.format || format.value);
      }
      function onShortcutClick(shortcut) {
        emit("shortcut-click", getShortcutValue(shortcut), shortcut);
      }
      function onShortcutMouseEnter(shortcut) {
        emit("shortcut-mouse-enter", getShortcutValue(shortcut));
      }
      function onShortcutMouseLeave(shortcut) {
        emit("shortcut-mouse-leave", getShortcutValue(shortcut));
      }
      function onPanelCellClick(date) {
        emit("cell-click", date);
      }
      function onPanelCellMouseEnter(date) {
        emit("cell-mouse-enter", date);
      }
      function onConfirmBtnClick() {
        emit("confirm");
      }
      function onStartTimePickerSelect(time) {
        emit("time-picker-select", time, "start");
      }
      function onEndTimePickerSelect(time) {
        emit("time-picker-select", time, "end");
      }
      function onStartPanelHeaderLabelClick(type) {
        emit("start-header-label-click", type);
      }
      function onEndPanelHeaderLabelClick(type) {
        emit("end-header-label-click", type);
      }
      function onStartHeaderPanelSelect(date) {
        emit("start-header-select", date);
      }
      function onEndHeaderPanelSelect(date) {
        emit("end-header-select", date);
      }
      function getDisabledDateFunc(index2) {
        return isFunction$1(disabledDate == null ? void 0 : disabledDate.value) ? (current) => {
          var _a;
          return ((_a = disabledDate == null ? void 0 : disabledDate.value) == null ? void 0 : _a.call(disabledDate, current, index2 === 0 ? "start" : "end")) || false;
        } : void 0;
      }
      function getDisabledTimeFunc(index2) {
        return isFunction$1(disabledTime == null ? void 0 : disabledTime.value) ? (current) => {
          var _a;
          return ((_a = disabledTime == null ? void 0 : disabledTime.value) == null ? void 0 : _a.call(disabledTime, current, index2 === 0 ? "start" : "end")) || false;
        } : void 0;
      }
      function getDateRenderFunc(index2) {
        return isFunction$1(dateRender == null ? void 0 : dateRender.value) ? (props2) => {
          var _a;
          const mergeProps = __spreadProps(__spreadValues({}, props2), {
            type: index2 === 0 ? "start" : "end"
          });
          return (_a = dateRender == null ? void 0 : dateRender.value) == null ? void 0 : _a.call(dateRender, mergeProps);
        } : void 0;
      }
      const shortcutsProps = vue.reactive({
        prefixCls,
        shortcuts,
        onItemClick: onShortcutClick,
        onItemMouseEnter: onShortcutMouseEnter,
        onItemMouseLeave: onShortcutMouseLeave
      });
      const startPanelProps = vue.computed(() => __spreadProps(__spreadValues({}, startHeaderProps.value), {
        rangeValues: value.value,
        disabledDate: getDisabledDateFunc(0),
        dateRender: getDateRenderFunc(0),
        onSelect: startHeaderMode.value ? onStartHeaderPanelSelect : onPanelCellClick,
        onCellMouseEnter: onPanelCellMouseEnter,
        onHeaderLabelClick: onStartPanelHeaderLabelClick
      }));
      const endPanelProps = vue.computed(() => __spreadProps(__spreadValues({}, endHeaderProps.value), {
        rangeValues: value.value,
        disabledDate: getDisabledDateFunc(1),
        dateRender: getDateRenderFunc(1),
        onSelect: endHeaderMode.value ? onEndHeaderPanelSelect : onPanelCellClick,
        onCellMouseEnter: onPanelCellMouseEnter,
        onHeaderLabelClick: onEndPanelHeaderLabelClick
      }));
      return {
        pick,
        classNames,
        showShortcuts,
        shortcutsProps,
        startPanelProps,
        endPanelProps,
        getDisabledTimeFunc,
        onConfirmBtnClick,
        currentDateView,
        onStartTimePickerSelect,
        onEndTimePickerSelect,
        onStartHeaderPanelSelect,
        onEndHeaderPanelSelect
      };
    }
  });
  function _sfc_render$1O(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_PanelShortcuts = vue.resolveComponent("PanelShortcuts");
    const _component_YearPanel = vue.resolveComponent("YearPanel");
    const _component_MonthPanel = vue.resolveComponent("MonthPanel");
    const _component_WeekPanel = vue.resolveComponent("WeekPanel");
    const _component_QuarterPanel = vue.resolveComponent("QuarterPanel");
    const _component_DatePanel = vue.resolveComponent("DatePanel");
    const _component_RenderFunction = vue.resolveComponent("RenderFunction");
    const _component_PanelFooter = vue.resolveComponent("PanelFooter");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.classNames)
    }, [
      _ctx.showShortcuts && _ctx.shortcutsPosition === "left" ? (vue.openBlock(), vue.createBlock(_component_PanelShortcuts, vue.normalizeProps(vue.mergeProps({ key: 0 }, _ctx.shortcutsProps)), null, 16)) : vue.createCommentVNode("v-if", true),
      vue.createElementVNode("div", {
        class: vue.normalizeClass(`${_ctx.prefixCls}-range-panel-wrapper`)
      }, [
        vue.createCommentVNode(" panel "),
        vue.createElementVNode("div", {
          class: vue.normalizeClass(`${_ctx.prefixCls}-range`)
        }, [
          vue.createElementVNode("div", {
            class: vue.normalizeClass(`${_ctx.prefixCls}-range-wrapper`)
          }, [
            _ctx.startHeaderMode || _ctx.endHeaderMode ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
              _ctx.startHeaderMode === "year" ? (vue.openBlock(), vue.createBlock(_component_YearPanel, vue.normalizeProps(vue.mergeProps({ key: 0 }, _ctx.startPanelProps)), null, 16)) : vue.createCommentVNode("v-if", true),
              _ctx.endHeaderMode === "year" ? (vue.openBlock(), vue.createBlock(_component_YearPanel, vue.normalizeProps(vue.mergeProps({ key: 1 }, _ctx.endPanelProps)), null, 16)) : _ctx.startHeaderMode === "month" ? (vue.openBlock(), vue.createBlock(_component_MonthPanel, vue.mergeProps({ key: 2 }, _ctx.startPanelProps, { abbreviation: _ctx.abbreviation }), null, 16, ["abbreviation"])) : _ctx.endHeaderMode === "month" ? (vue.openBlock(), vue.createBlock(_component_MonthPanel, vue.mergeProps({ key: 3 }, _ctx.endPanelProps, { abbreviation: _ctx.abbreviation }), null, 16, ["abbreviation"])) : vue.createCommentVNode("v-if", true)
            ], 64)) : (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 1 }, [
              vue.createCommentVNode(" week "),
              _ctx.mode === "week" ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
                vue.createVNode(_component_WeekPanel, vue.mergeProps(_ctx.startPanelProps, { "day-start-of-week": _ctx.dayStartOfWeek }), null, 16, ["day-start-of-week"]),
                vue.createVNode(_component_WeekPanel, vue.mergeProps(_ctx.endPanelProps, { "day-start-of-week": _ctx.dayStartOfWeek }), null, 16, ["day-start-of-week"])
              ], 64)) : _ctx.mode === "month" ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 1 }, [
                vue.createCommentVNode(" month "),
                vue.createVNode(_component_MonthPanel, vue.mergeProps(_ctx.startPanelProps, { abbreviation: _ctx.abbreviation }), null, 16, ["abbreviation"]),
                vue.createVNode(_component_MonthPanel, vue.mergeProps(_ctx.endPanelProps, { abbreviation: _ctx.abbreviation }), null, 16, ["abbreviation"])
              ], 64)) : _ctx.mode === "year" ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 2 }, [
                vue.createCommentVNode(" year "),
                vue.createVNode(_component_YearPanel, vue.normalizeProps(vue.guardReactiveProps(_ctx.startPanelProps)), null, 16),
                vue.createVNode(_component_YearPanel, vue.normalizeProps(vue.guardReactiveProps(_ctx.endPanelProps)), null, 16)
              ], 64)) : _ctx.mode === "quarter" ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 3 }, [
                vue.createCommentVNode(" quarter "),
                vue.createVNode(_component_QuarterPanel, vue.normalizeProps(vue.guardReactiveProps(_ctx.startPanelProps)), null, 16),
                vue.createVNode(_component_QuarterPanel, vue.normalizeProps(vue.guardReactiveProps(_ctx.endPanelProps)), null, 16)
              ], 64)) : (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 4 }, [
                vue.createCommentVNode(" date "),
                vue.createVNode(_component_DatePanel, vue.mergeProps({
                  currentView: _ctx.currentDateView,
                  "onUpdate:currentView": _cache[0] || (_cache[0] = ($event) => _ctx.currentDateView = $event)
                }, _ctx.startPanelProps, {
                  "is-range": "",
                  value: _ctx.value && _ctx.value[0],
                  "footer-value": _ctx.footerValue && _ctx.footerValue[0],
                  "time-picker-value": _ctx.timePickerValue && _ctx.timePickerValue[0],
                  "day-start-of-week": _ctx.dayStartOfWeek,
                  "show-time": _ctx.showTime,
                  "time-picker-props": _ctx.timePickerProps,
                  "disabled-time": _ctx.getDisabledTimeFunc(0),
                  disabled: _ctx.disabled[0],
                  onTimePickerSelect: _ctx.onStartTimePickerSelect
                }), null, 16, ["currentView", "value", "footer-value", "time-picker-value", "day-start-of-week", "show-time", "time-picker-props", "disabled-time", "disabled", "onTimePickerSelect"]),
                vue.createVNode(_component_DatePanel, vue.mergeProps({
                  currentView: _ctx.currentDateView,
                  "onUpdate:currentView": _cache[1] || (_cache[1] = ($event) => _ctx.currentDateView = $event)
                }, _ctx.endPanelProps, {
                  "is-range": "",
                  value: _ctx.value && _ctx.value[1],
                  "footer-value": _ctx.footerValue && _ctx.footerValue[1],
                  "time-picker-value": _ctx.timePickerValue && _ctx.timePickerValue[1],
                  "day-start-of-week": _ctx.dayStartOfWeek,
                  "show-time": _ctx.showTime,
                  "time-picker-props": _ctx.timePickerProps,
                  "disabled-time": _ctx.getDisabledTimeFunc(1),
                  disabled: _ctx.disabled[1],
                  onTimePickerSelect: _ctx.onEndTimePickerSelect
                }), null, 16, ["currentView", "value", "footer-value", "time-picker-value", "day-start-of-week", "show-time", "time-picker-props", "disabled-time", "disabled", "onTimePickerSelect"])
              ], 64))
            ], 2112))
          ], 2)
        ], 2),
        vue.createCommentVNode(" footer "),
        vue.createVNode(_component_PanelFooter, {
          "prefix-cls": _ctx.prefixCls,
          "show-today-btn": false,
          "show-confirm-btn": _ctx.showConfirmBtn,
          "confirm-btn-disabled": _ctx.confirmBtnDisabled,
          onConfirmBtnClick: _ctx.onConfirmBtnClick
        }, vue.createSlots({ _: 2 }, [
          _ctx.extra || _ctx.$slots.extra ? {
            name: "extra",
            fn: vue.withCtx(() => [
              _ctx.$slots.extra ? vue.renderSlot(_ctx.$slots, "extra", { key: 0 }) : (vue.openBlock(), vue.createBlock(_component_RenderFunction, {
                key: 1,
                "render-func": _ctx.extra
              }, null, 8, ["render-func"]))
            ])
          } : void 0,
          _ctx.showShortcuts && _ctx.shortcutsPosition === "bottom" ? {
            name: "btn",
            fn: vue.withCtx(() => [
              vue.createVNode(_component_PanelShortcuts, vue.normalizeProps(vue.guardReactiveProps(_ctx.shortcutsProps)), null, 16)
            ])
          } : void 0
        ]), 1032, ["prefix-cls", "show-confirm-btn", "confirm-btn-disabled", "onConfirmBtnClick"])
      ], 2),
      _ctx.showShortcuts && _ctx.shortcutsPosition === "right" ? (vue.openBlock(), vue.createBlock(_component_PanelShortcuts, vue.normalizeProps(vue.mergeProps({ key: 1 }, _ctx.shortcutsProps)), null, 16)) : vue.createCommentVNode("v-if", true)
    ], 2);
  }
  var RangePickerPanel = /* @__PURE__ */ _export_sfc(_sfc_main$1P, [["render", _sfc_render$1O]]);
  function useRangeTimePickerValue(props) {
    const { timePickerProps, selectedValue } = vue.toRefs(props);
    const startValue = vue.computed(() => {
      var _a;
      return (_a = selectedValue == null ? void 0 : selectedValue.value) == null ? void 0 : _a[0];
    });
    const endValue = vue.computed(() => {
      var _a;
      return (_a = selectedValue == null ? void 0 : selectedValue.value) == null ? void 0 : _a[1];
    });
    const timePickerDefaultValue = vue.computed(() => {
      var _a;
      return (_a = timePickerProps == null ? void 0 : timePickerProps.value) == null ? void 0 : _a.defaultValue;
    });
    const startTimePickerProps = vue.computed(() => isArray$1(timePickerDefaultValue.value) ? __spreadProps(__spreadValues({}, timePickerProps == null ? void 0 : timePickerProps.value), {
      defaultValue: timePickerDefaultValue.value[0]
    }) : timePickerProps == null ? void 0 : timePickerProps.value);
    const endTimePickerProps = vue.computed(() => isArray$1(timePickerDefaultValue.value) ? __spreadProps(__spreadValues({}, timePickerProps == null ? void 0 : timePickerProps.value), {
      defaultValue: timePickerDefaultValue.value[1]
    }) : timePickerProps == null ? void 0 : timePickerProps.value);
    const [startTimeValue, setStartTimeValue, resetStartTimeValue] = useTimePickerValue(vue.reactive({
      timePickerProps: startTimePickerProps,
      selectedValue: startValue
    }));
    const [endTimeValue, setEndTimeValue, resetEndTimeValue] = useTimePickerValue(vue.reactive({
      timePickerProps: endTimePickerProps,
      selectedValue: endValue
    }));
    const rangeTimePickerValue = vue.computed(() => [
      startTimeValue.value,
      endTimeValue.value
    ]);
    function setTimeValue(val) {
      if (!val)
        return;
      setStartTimeValue(val[0]);
      setEndTimeValue(val[1]);
    }
    function resetTimeValue() {
      resetStartTimeValue();
      resetEndTimeValue();
    }
    return [rangeTimePickerValue, setTimeValue, resetTimeValue];
  }
  const _sfc_main$1O = vue.defineComponent({
    name: "RangePicker",
    components: {
      RangePickerPanel,
      DateRangeInput,
      Trigger,
      IconCalendar
    },
    inheritAttrs: false,
    props: {
      mode: {
        type: String,
        default: "date"
      },
      modelValue: {
        type: Array
      },
      defaultValue: {
        type: Array
      },
      pickerValue: {
        type: Array
      },
      defaultPickerValue: {
        type: Array
      },
      disabled: {
        type: [Boolean, Array],
        default: false
      },
      dayStartOfWeek: {
        type: Number,
        default: 0
      },
      format: {
        type: String
      },
      valueFormat: {
        type: String
      },
      showTime: {
        type: Boolean
      },
      timePickerProps: {
        type: Object
      },
      placeholder: {
        type: Array
      },
      disabledDate: {
        type: Function
      },
      disabledTime: {
        type: Function
      },
      separator: {
        type: String
      },
      exchangeTime: {
        type: Boolean,
        default: true
      },
      popupContainer: {
        type: [String, Object]
      },
      locale: {
        type: Object
      },
      hideTrigger: {
        type: Boolean
      },
      allowClear: {
        type: Boolean,
        default: true
      },
      readonly: {
        type: Boolean
      },
      error: {
        type: Boolean
      },
      size: {
        type: String
      },
      shortcuts: {
        type: Array,
        default: () => []
      },
      shortcutsPosition: {
        type: String,
        default: "bottom"
      },
      position: {
        type: String,
        default: "bl"
      },
      popupVisible: {
        type: Boolean,
        default: void 0
      },
      defaultPopupVisible: {
        type: Boolean
      },
      triggerProps: {
        type: Object
      },
      unmountOnClose: {
        type: Boolean
      },
      previewShortcut: {
        type: Boolean,
        default: true
      },
      showConfirmBtn: {
        type: Boolean
      },
      disabledInput: {
        type: Boolean,
        default: false
      },
      abbreviation: {
        type: Boolean,
        default: true
      }
    },
    emits: {
      "change": (value, date, dateString) => {
        return true;
      },
      "update:modelValue": (value) => {
        return true;
      },
      "select": (value, date, dateString) => {
        return true;
      },
      "popup-visible-change": (visible) => {
        return true;
      },
      "update:popupVisible": (visible) => {
        return true;
      },
      "ok": (value, date, dateString) => {
        return true;
      },
      "clear": () => {
        return true;
      },
      "select-shortcut": (shortcut) => {
        return true;
      },
      "picker-value-change": (value, date, dateString) => {
        return true;
      },
      "update:pickerValue": (value) => {
        return true;
      }
    },
    setup(props, { emit, slots }) {
      const {
        mode,
        showTime,
        format,
        modelValue,
        defaultValue,
        popupVisible,
        defaultPopupVisible,
        placeholder,
        timePickerProps,
        disabled,
        disabledDate,
        disabledTime,
        locale,
        pickerValue,
        defaultPickerValue,
        valueFormat,
        size,
        error,
        dayStartOfWeek,
        exchangeTime,
        previewShortcut,
        showConfirmBtn
      } = vue.toRefs(props);
      const { locale: globalLocal } = useI18n();
      const configCtx = vue.inject(configProviderInjectionKey, void 0);
      vue.watchEffect(() => {
        initializeDateLocale(globalLocal.value, dayStartOfWeek.value);
      });
      const mergedExchangeTime = vue.computed(() => {
        var _a;
        return !(!exchangeTime.value || !((_a = configCtx == null ? void 0 : configCtx.exchangeTime) != null ? _a : true));
      });
      const {
        mergedSize,
        mergedDisabled: formDisabled,
        mergedError,
        eventHandlers
      } = useFormItem({
        size,
        error
      });
      const datePickerT = useDatePickerTransform(vue.reactive({
        locale
      }));
      const prefixCls = getPrefixCls("picker");
      const computedPlaceholder = vue.computed(() => (placeholder == null ? void 0 : placeholder.value) || {
        date: datePickerT("datePicker.rangePlaceholder.date"),
        month: datePickerT("datePicker.rangePlaceholder.month"),
        year: datePickerT("datePicker.rangePlaceholder.year"),
        week: datePickerT("datePicker.rangePlaceholder.week"),
        quarter: datePickerT("datePicker.rangePlaceholder.quarter")
      }[mode.value] || datePickerT("datePicker.rangePlaceholder.date"));
      const {
        format: computedFormat,
        valueFormat: returnValueFormat,
        parseValueFormat
      } = useFormat(vue.reactive({
        mode,
        format,
        showTime,
        valueFormat
      }));
      const disabledArray = vue.computed(() => {
        const disabled0 = disabled.value === true || formDisabled.value || isArray$1(disabled.value) && disabled.value[0] === true;
        const disabled1 = disabled.value === true || formDisabled.value || isArray$1(disabled.value) && disabled.value[1] === true;
        return [disabled0, disabled1];
      });
      const triggerDisabled = vue.computed(() => disabledArray.value[0] && disabledArray.value[1]);
      function getFocusedIndex(cur = 0) {
        return disabledArray.value[cur] ? cur ^ 1 : cur;
      }
      const refInput = vue.ref();
      const focusedIndex = vue.ref(getFocusedIndex());
      const nextFocusedIndex = vue.computed(() => {
        const cur = focusedIndex.value;
        const next = cur ^ 1;
        return disabledArray.value[next] ? cur : next;
      });
      const isNextDisabled = vue.computed(() => disabledArray.value[focusedIndex.value ^ 1]);
      const { value: selectedValue, setValue: setSelectedValue } = useRangePickerState(vue.reactive({
        modelValue,
        defaultValue,
        format: parseValueFormat
      }));
      const [processValue, setProcessValue] = useState();
      const [previewValue, setPreviewValue] = useState();
      const forSelectedValue = vue.computed(() => {
        var _a;
        return (_a = processValue.value) != null ? _a : selectedValue.value;
      });
      const panelValue = vue.computed(() => {
        var _a, _b;
        return (_b = (_a = previewValue.value) != null ? _a : processValue.value) != null ? _b : selectedValue.value;
      });
      const [inputValue, setInputValue] = useState();
      const startHeaderMode = vue.ref();
      const endHeaderMode = vue.ref();
      const [panelVisible, setLocalPanelVisible] = useMergeState(defaultPopupVisible.value, vue.reactive({ value: popupVisible }));
      const setPanelVisible = (newVisible) => {
        if (panelVisible.value !== newVisible) {
          setLocalPanelVisible(newVisible);
          emit("popup-visible-change", newVisible);
          emit("update:popupVisible", newVisible);
        }
      };
      const {
        startHeaderValue,
        endHeaderValue,
        startHeaderOperations,
        endHeaderOperations,
        resetHeaderValue,
        setHeaderValue
      } = useRangeHeaderValue(vue.reactive({
        mode,
        startHeaderMode,
        endHeaderMode,
        value: pickerValue,
        defaultValue: defaultPickerValue,
        selectedValue: panelValue,
        format: parseValueFormat,
        onChange: (newVal) => {
          const returnValue = getReturnRangeValue(newVal, returnValueFormat.value);
          const formattedValue = getFormattedValue(newVal, parseValueFormat.value);
          const dateValue = getDateValue$1(newVal);
          emit("picker-value-change", returnValue, dateValue, formattedValue);
          emit("update:pickerValue", returnValue);
        }
      }));
      function onStartPanelHeaderLabelClick(type) {
        startHeaderMode.value = type;
      }
      function onEndPanelHeaderLabelClick(type) {
        endHeaderMode.value = type;
      }
      function onStartPanelHeaderSelect(date) {
        let newStartValue = startHeaderValue.value;
        newStartValue = newStartValue.set("year", date.year());
        if (startHeaderMode.value === "month") {
          newStartValue = newStartValue.set("month", date.month());
        }
        setHeaderValue([newStartValue, endHeaderValue.value]);
        startHeaderMode.value = void 0;
      }
      function onEndPanelHeaderSelect(date) {
        let newEndValue = endHeaderValue.value;
        newEndValue = newEndValue.set("year", date.year());
        if (endHeaderMode.value === "month") {
          newEndValue = newEndValue.set("month", date.month());
        }
        setHeaderValue([startHeaderValue.value, newEndValue]);
        endHeaderMode.value = void 0;
      }
      const footerValue = vue.ref([
        panelValue.value[0] || getNow(),
        panelValue.value[1] || getNow()
      ]);
      vue.watch(panelValue, () => {
        const [value0, value1] = panelValue.value;
        footerValue.value[0] = value0 || footerValue.value[0];
        footerValue.value[1] = value1 || footerValue.value[1];
      });
      const [timePickerValue, setTimePickerValue, resetTimePickerValue] = useRangeTimePickerValue(vue.reactive({
        timePickerProps,
        selectedValue: panelValue
      }));
      const isDateTime = vue.computed(() => mode.value === "date" && showTime.value);
      const hasTime = vue.computed(() => isDateTime.value || timePickerProps.value);
      const isDisabledDate = useIsDisabledDate(vue.reactive({
        mode,
        isRange: true,
        showTime,
        disabledDate,
        disabledTime
      }));
      const needConfirm = vue.computed(() => isDateTime.value || showConfirmBtn.value);
      const confirmBtnDisabled = vue.computed(() => needConfirm.value && (!isCompleteRangeValue(forSelectedValue.value) || isDisabledDate(forSelectedValue.value[0], "start") || isDisabledDate(forSelectedValue.value[1], "end")));
      vue.watch(panelVisible, (newVisible) => {
        startHeaderMode.value = void 0;
        endHeaderMode.value = void 0;
        setProcessValue(void 0);
        setPreviewValue(void 0);
        if (newVisible) {
          resetHeaderValue();
          resetTimePickerValue();
          focusedIndex.value = getFocusedIndex(focusedIndex.value);
          vue.nextTick(() => focusInput(focusedIndex.value));
        }
        if (!newVisible) {
          setInputValue(void 0);
        }
      });
      vue.watch(focusedIndex, () => {
        if (props.disabledInput) {
          focusInput(focusedIndex.value);
          setInputValue(void 0);
        }
      });
      function emitChange(value, emitOk) {
        var _a, _b;
        const returnValue = value ? getReturnRangeValue(value, returnValueFormat.value) : void 0;
        const formattedValue = getFormattedValue(value, parseValueFormat.value);
        const dateValue = getDateValue$1(value);
        if (isValueChange(value, selectedValue.value)) {
          emit("update:modelValue", returnValue);
          emit("change", returnValue, dateValue, formattedValue);
          (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a);
        }
        if (emitOk) {
          emit("ok", returnValue, dateValue, formattedValue);
        }
      }
      function getSortedDayjsArrayByExchangeTimeOrNot(newValue) {
        let sortedValue = getSortedDayjsArray(newValue);
        if (hasTime.value && !mergedExchangeTime.value) {
          sortedValue = [
            getMergedOpValue(sortedValue[0], newValue[0]),
            getMergedOpValue(sortedValue[1], newValue[1])
          ];
        }
        return sortedValue;
      }
      function confirm(value, showPanel, emitOk) {
        if (isDisabledDate(value == null ? void 0 : value[0], "start") || isDisabledDate(value == null ? void 0 : value[1], "end")) {
          return;
        }
        let newValue = value ? [...value] : void 0;
        if (isCompleteRangeValue(newValue)) {
          newValue = getSortedDayjsArrayByExchangeTimeOrNot(newValue);
        }
        emitChange(newValue, emitOk);
        setSelectedValue(newValue || []);
        setProcessValue(void 0);
        setPreviewValue(void 0);
        setInputValue(void 0);
        startHeaderMode.value = void 0;
        endHeaderMode.value = void 0;
        if (isBoolean$1(showPanel)) {
          setPanelVisible(showPanel);
        }
      }
      function emitSelectEvent(value) {
        const returnValue = getReturnRangeValue(value, returnValueFormat.value);
        const formattedValue = getFormattedValue(value, parseValueFormat.value);
        const dateValue = getDateValue$1(value);
        emit("select", returnValue, dateValue, formattedValue);
      }
      function select(value, options) {
        const { emitSelect = false, updateHeader = false } = options || {};
        let newValue = [...value];
        if (isCompleteRangeValue(newValue)) {
          newValue = getSortedDayjsArrayByExchangeTimeOrNot(newValue);
        }
        setProcessValue(newValue);
        setPreviewValue(void 0);
        setInputValue(void 0);
        startHeaderMode.value = void 0;
        endHeaderMode.value = void 0;
        if (emitSelect) {
          emitSelectEvent(newValue);
        }
        if (updateHeader) {
          resetHeaderValue();
        }
      }
      function preview(value, options) {
        const { updateHeader = false } = options || {};
        setPreviewValue(value);
        setInputValue(void 0);
        if (updateHeader) {
          resetHeaderValue();
        }
      }
      function focusInput(index2) {
        refInput.value && refInput.value.focus && refInput.value.focus(index2);
      }
      function getMergedOpValue(date, time) {
        if (!hasTime.value)
          return date;
        return mergeValueWithTime(getNow(), date, time);
      }
      function onPanelVisibleChange(visible) {
        setPanelVisible(visible);
      }
      function onPanelCellMouseEnter(date) {
        if (processValue.value && panelValue.value[nextFocusedIndex.value] && (!needConfirm.value || !isCompleteRangeValue(processValue.value))) {
          const newValue = [...panelValue.value];
          const mergedOpValue = getMergedOpValue(date, timePickerValue.value[focusedIndex.value]);
          newValue[focusedIndex.value] = mergedOpValue;
          preview(newValue);
        }
      }
      function getValueToModify(isTime = false) {
        if (isNextDisabled.value)
          return [...selectedValue.value];
        if (processValue.value) {
          return isTime || !isCompleteRangeValue(processValue.value) ? [...processValue.value] : [];
        }
        return isTime ? [...selectedValue.value] : [];
      }
      function onPanelCellClick(date) {
        const newValue = getValueToModify();
        const mergedOpValue = getMergedOpValue(date, timePickerValue.value[focusedIndex.value]);
        newValue[focusedIndex.value] = mergedOpValue;
        emitSelectEvent(newValue);
        if (!needConfirm.value && isCompleteRangeValue(newValue)) {
          confirm(newValue, false);
        } else {
          select(newValue);
          if (!isCompleteRangeValue(newValue)) {
            focusedIndex.value = nextFocusedIndex.value;
          } else {
            focusedIndex.value = 0;
          }
        }
      }
      function onTimePickerSelect(time, type) {
        const updateIndex = type === "start" ? 0 : 1;
        const mergedOpValue = getMergedOpValue(timePickerValue.value[updateIndex], time);
        const newTimeValue = [...timePickerValue.value];
        newTimeValue[updateIndex] = mergedOpValue;
        setTimePickerValue(newTimeValue);
        const newValue = getValueToModify(true);
        if (newValue[updateIndex]) {
          newValue[updateIndex] = mergedOpValue;
          select(newValue, { emitSelect: true });
        }
      }
      let clearShortcutPreviewTimer;
      vue.onUnmounted(() => {
        clearTimeout(clearShortcutPreviewTimer);
      });
      function onPanelShortcutMouseEnter(value) {
        clearTimeout(clearShortcutPreviewTimer);
        preview(value, { updateHeader: true });
      }
      function onPanelShortcutMouseLeave() {
        clearTimeout(clearShortcutPreviewTimer);
        clearShortcutPreviewTimer = setTimeout(() => {
          setPreviewValue(void 0);
          setInputValue(void 0);
          resetHeaderValue();
        }, 100);
      }
      function onPanelShortcutClick(value, shortcut) {
        emit("select-shortcut", shortcut);
        confirm(value, false);
      }
      function onPanelConfirm() {
        confirm(panelValue.value, false, true);
      }
      function onInputClear(e2) {
        e2.stopPropagation();
        confirm(void 0);
        emit("clear");
      }
      function onInputChange(e2) {
        setPanelVisible(true);
        const targetValue = e2.target.value;
        if (!targetValue) {
          setInputValue(void 0);
          return;
        }
        const formattedPanelValue = getFormattedValue(panelValue.value, computedFormat.value);
        const newInputValue = isArray$1(inputValue.value) ? [...inputValue.value] : formattedPanelValue || [];
        newInputValue[focusedIndex.value] = targetValue;
        setInputValue(newInputValue);
        if (!isValidInputValue(targetValue, computedFormat.value))
          return;
        const targetValueDayjs = dayjs(targetValue, computedFormat.value);
        if (isDisabledDate(targetValueDayjs, focusedIndex.value === 0 ? "start" : "end"))
          return;
        const newValue = isArray$1(panelValue.value) ? [...panelValue.value] : [];
        newValue[focusedIndex.value] = targetValueDayjs;
        select(newValue, { updateHeader: true });
      }
      function onInputPressEnter() {
        if (isValidRangeValue(panelValue.value)) {
          confirm(panelValue.value, false);
        } else {
          focusedIndex.value = nextFocusedIndex.value;
        }
      }
      const computedTimePickerProps = vue.computed(() => __spreadProps(__spreadValues({
        format: computedFormat.value
      }, omit((timePickerProps == null ? void 0 : timePickerProps.value) || {}, ["defaultValue"])), {
        visible: panelVisible.value
      }));
      const headerIcons = vue.computed(() => ({
        prev: slots["icon-prev"],
        prevDouble: slots["icon-prev-double"],
        next: slots["icon-next"],
        nextDouble: slots["icon-next-double"]
      }));
      const startHeaderProps = vue.reactive({
        headerValue: startHeaderValue,
        headerOperations: startHeaderOperations,
        headerIcons
      });
      const endHeaderProps = vue.reactive({
        headerValue: endHeaderValue,
        headerOperations: endHeaderOperations,
        headerIcons
      });
      const rangePanelProps = vue.computed(() => __spreadProps(__spreadValues({}, pick(props, [
        "mode",
        "showTime",
        "shortcuts",
        "shortcutsPosition",
        "dayStartOfWeek",
        "disabledDate",
        "disabledTime",
        "hideTrigger",
        "abbreviation"
      ])), {
        prefixCls,
        format: parseValueFormat.value,
        value: panelValue.value,
        showConfirmBtn: needConfirm.value,
        confirmBtnDisabled: confirmBtnDisabled.value,
        timePickerValue: timePickerValue.value,
        timePickerProps: computedTimePickerProps.value,
        extra: slots.extra,
        dateRender: slots.cell,
        startHeaderProps,
        endHeaderProps,
        footerValue: footerValue.value,
        disabled: disabledArray.value,
        visible: panelVisible.value,
        onCellClick: onPanelCellClick,
        onCellMouseEnter: onPanelCellMouseEnter,
        onShortcutClick: onPanelShortcutClick,
        onShortcutMouseEnter: previewShortcut.value ? onPanelShortcutMouseEnter : void 0,
        onShortcutMouseLeave: previewShortcut.value ? onPanelShortcutMouseLeave : void 0,
        onConfirm: onPanelConfirm,
        onTimePickerSelect,
        startHeaderMode: startHeaderMode.value,
        endHeaderMode: endHeaderMode.value,
        onStartHeaderLabelClick: onStartPanelHeaderLabelClick,
        onEndHeaderLabelClick: onEndPanelHeaderLabelClick,
        onStartHeaderSelect: onStartPanelHeaderSelect,
        onEndHeaderSelect: onEndPanelHeaderSelect
      }));
      return {
        prefixCls,
        refInput,
        computedFormat,
        computedPlaceholder,
        panelVisible,
        panelValue,
        inputValue,
        focusedIndex,
        triggerDisabled,
        mergedSize,
        mergedError,
        onPanelVisibleChange,
        onInputClear,
        onInputChange,
        onInputPressEnter,
        rangePanelProps
      };
    }
  });
  function _sfc_render$1N(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_IconCalendar = vue.resolveComponent("IconCalendar");
    const _component_DateRangeInput = vue.resolveComponent("DateRangeInput");
    const _component_RangePickerPanel = vue.resolveComponent("RangePickerPanel");
    const _component_Trigger = vue.resolveComponent("Trigger");
    return !_ctx.hideTrigger ? (vue.openBlock(), vue.createBlock(_component_Trigger, vue.mergeProps({
      key: 0,
      trigger: "click",
      "animation-name": "slide-dynamic-origin",
      "auto-fit-transform-origin": "",
      "click-to-close": false,
      "popup-offset": 4
    }, _ctx.triggerProps, {
      "unmount-on-close": _ctx.unmountOnClose,
      position: _ctx.position,
      disabled: _ctx.triggerDisabled || _ctx.readonly,
      "popup-visible": _ctx.panelVisible,
      "popup-container": _ctx.popupContainer,
      onPopupVisibleChange: _ctx.onPanelVisibleChange
    }), {
      content: vue.withCtx(() => [
        vue.createVNode(_component_RangePickerPanel, vue.normalizeProps(vue.guardReactiveProps(_ctx.rangePanelProps)), null, 16)
      ]),
      default: vue.withCtx(() => [
        vue.renderSlot(_ctx.$slots, "default", {}, () => [
          vue.createVNode(_component_DateRangeInput, vue.mergeProps({ ref: "refInput" }, _ctx.$attrs, {
            focusedIndex: _ctx.focusedIndex,
            "onUpdate:focusedIndex": _cache[0] || (_cache[0] = ($event) => _ctx.focusedIndex = $event),
            size: _ctx.size,
            focused: _ctx.panelVisible,
            visible: _ctx.panelVisible,
            error: _ctx.error,
            disabled: _ctx.disabled,
            readonly: _ctx.readonly || _ctx.disabledInput,
            "allow-clear": _ctx.allowClear && !_ctx.readonly,
            placeholder: _ctx.computedPlaceholder,
            "input-value": _ctx.inputValue,
            value: _ctx.panelValue,
            format: _ctx.computedFormat,
            onClear: _ctx.onInputClear,
            onChange: _ctx.onInputChange,
            onPressEnter: _ctx.onInputPressEnter
          }), vue.createSlots({
            "suffix-icon": vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "suffix-icon", {}, () => [
                vue.createVNode(_component_IconCalendar)
              ])
            ]),
            separator: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "separator", {}, () => [
                vue.createTextVNode(vue.toDisplayString(_ctx.separator || "-"), 1)
              ])
            ]),
            _: 2
          }, [
            _ctx.$slots.prefix ? {
              name: "prefix",
              fn: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "prefix")
              ])
            } : void 0
          ]), 1040, ["focusedIndex", "size", "focused", "visible", "error", "disabled", "readonly", "allow-clear", "placeholder", "input-value", "value", "format", "onClear", "onChange", "onPressEnter"])
        ])
      ]),
      _: 3
    }, 16, ["unmount-on-close", "position", "disabled", "popup-visible", "popup-container", "onPopupVisibleChange"])) : (vue.openBlock(), vue.createBlock(_component_RangePickerPanel, vue.normalizeProps(vue.mergeProps({ key: 1 }, __spreadValues(__spreadValues({}, _ctx.$attrs), _ctx.rangePanelProps))), null, 16));
  }
  var RangePicker = /* @__PURE__ */ _export_sfc(_sfc_main$1O, [["render", _sfc_render$1N]]);
  const DatePicker = Object.assign(_DatePicker, {
    WeekPicker,
    MonthPicker,
    YearPicker,
    QuarterPicker,
    RangePicker,
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _DatePicker.name, _DatePicker);
      app.component(componentPrefix + YearPicker.name, YearPicker);
      app.component(componentPrefix + QuarterPicker.name, QuarterPicker);
      app.component(componentPrefix + MonthPicker.name, MonthPicker);
      app.component(componentPrefix + WeekPicker.name, WeekPicker);
      app.component(componentPrefix + RangePicker.name, RangePicker);
    }
  });
  const descriptionsInjectionKey = Symbol("ArcoDescriptions");
  const responsiveArray = [
    "xxl",
    "xl",
    "lg",
    "md",
    "sm",
    "xs"
  ];
  const responsiveMap = {
    xs: "(max-width: 575px)",
    sm: "(min-width: 576px)",
    md: "(min-width: 768px)",
    lg: "(min-width: 992px)",
    xl: "(min-width: 1200px)",
    xxl: "(min-width: 1600px)"
  };
  let subscribers = [];
  let subUid = -1;
  let screens = {};
  const responsiveObserve = {
    matchHandlers: {},
    dispatch(pointMap, breakpointChecked) {
      screens = pointMap;
      if (subscribers.length < 1) {
        return false;
      }
      subscribers.forEach((item) => {
        item.func(screens, breakpointChecked);
      });
      return true;
    },
    subscribe(func) {
      if (subscribers.length === 0) {
        this.register();
      }
      const token = (++subUid).toString();
      subscribers.push({
        token,
        func
      });
      func(screens, null);
      return token;
    },
    unsubscribe(token) {
      subscribers = subscribers.filter((item) => item.token !== token);
      if (subscribers.length === 0) {
        this.unregister();
      }
    },
    unregister() {
      Object.keys(responsiveMap).forEach((screen) => {
        const matchMediaQuery = responsiveMap[screen];
        if (!matchMediaQuery)
          return;
        const handler = this.matchHandlers[matchMediaQuery];
        if (handler && handler.mql && handler.listener) {
          if (handler.mql.removeEventListener) {
            handler.mql.removeEventListener("change", handler.listener);
          } else {
            handler.mql.removeListener(handler.listener);
          }
        }
      });
    },
    register() {
      Object.keys(responsiveMap).forEach((screen) => {
        const matchMediaQuery = responsiveMap[screen];
        if (!matchMediaQuery)
          return;
        const listener = ({ matches }) => {
          this.dispatch(__spreadProps(__spreadValues({}, screens), {
            [screen]: matches
          }), screen);
        };
        const mql = window.matchMedia(matchMediaQuery);
        if (mql.addEventListener) {
          mql.addEventListener("change", listener);
        } else {
          mql.addListener(listener);
        }
        this.matchHandlers[matchMediaQuery] = {
          mql,
          listener
        };
        listener(mql);
      });
    }
  };
  function isResponsiveValue(val) {
    return isObject$1(val);
  }
  function useResponsiveState(val, defaultVal, fallbackToXs = false) {
    const screens2 = vue.ref({
      xs: true,
      sm: true,
      md: true,
      lg: true,
      xl: true,
      xxl: true
    });
    const result = vue.computed(() => {
      let res = defaultVal;
      if (isResponsiveValue(val.value)) {
        for (let i = 0; i < responsiveArray.length; i++) {
          const breakpoint = responsiveArray[i];
          if ((screens2.value[breakpoint] || breakpoint === "xs" && fallbackToXs) && val.value[breakpoint] !== void 0) {
            res = val.value[breakpoint];
            break;
          }
        }
      } else {
        res = val.value;
      }
      return res;
    });
    let subscribeToken = "";
    vue.onMounted(() => {
      subscribeToken = responsiveObserve.subscribe((screensVal) => {
        if (isResponsiveValue(val.value)) {
          screens2.value = screensVal;
        }
      });
    });
    vue.onUnmounted(() => {
      if (subscribeToken) {
        responsiveObserve.unsubscribe(subscribeToken);
      }
    });
    return result;
  }
  const getTotalSpan = (renderData) => {
    return renderData ? renderData.reduce((total, data) => total + data.span, 0) : 0;
  };
  var _Descriptions = vue.defineComponent({
    name: "Descriptions",
    props: {
      data: {
        type: Array,
        default: () => []
      },
      column: {
        type: [Number, Object],
        default: 3
      },
      title: String,
      layout: {
        type: String,
        default: "horizontal"
      },
      align: {
        type: [String, Object],
        default: "left"
      },
      size: {
        type: String
      },
      bordered: {
        type: Boolean,
        default: false
      },
      labelStyle: {
        type: Object
      },
      valueStyle: {
        type: Object
      },
      tableLayout: {
        type: String,
        default: "auto"
      }
    },
    setup(props, {
      slots
    }) {
      const {
        column,
        size
      } = vue.toRefs(props);
      const prefixCls = getPrefixCls("descriptions");
      const {
        mergedSize
      } = useSize$1(size);
      const computedColumn = useResponsiveState(column, 3, true);
      const labelAlign = vue.computed(() => {
        var _a;
        return (_a = isObject$1(props.align) ? props.align.label : props.align) != null ? _a : "left";
      });
      const valueAlign = vue.computed(() => {
        var _a;
        return (_a = isObject$1(props.align) ? props.align.value : props.align) != null ? _a : "left";
      });
      const labelStyle = vue.computed(() => __spreadValues({
        textAlign: labelAlign.value
      }, props.labelStyle));
      const valueStyle = vue.computed(() => __spreadValues({
        textAlign: valueAlign.value
      }, props.valueStyle));
      const descItemMap = vue.reactive(new Map());
      const sortedSpans = vue.computed(() => Array.from(descItemMap.values()).sort((a, b) => a.index - b.index).map((data) => data.span));
      const addItem = (id, data) => {
        descItemMap.set(id, data);
      };
      const removeItem = (id) => {
        descItemMap.delete(id);
      };
      vue.provide(descriptionsInjectionKey, vue.reactive({
        addItem,
        removeItem
      }));
      const getGroupedData = (data) => {
        const groupedData2 = [];
        data.forEach((item, index2) => {
          var _a;
          const itemSpan = Math.min((_a = vue.isVNode(item) ? sortedSpans.value[index2] : item.span) != null ? _a : 1, computedColumn.value);
          const lastData = groupedData2[groupedData2.length - 1];
          const lastDataTotalSpan = getTotalSpan(lastData);
          if (lastDataTotalSpan === 0 || lastDataTotalSpan >= computedColumn.value) {
            groupedData2.push([{
              data: item,
              span: itemSpan
            }]);
          } else {
            lastData.push({
              data: item,
              span: itemSpan + lastDataTotalSpan > computedColumn.value ? computedColumn.value - lastDataTotalSpan : itemSpan
            });
          }
        });
        if (groupedData2.length) {
          const lastData = groupedData2[groupedData2.length - 1];
          const lastDataTotalSpan = getTotalSpan(lastData);
          if (lastDataTotalSpan < computedColumn.value) {
            lastData[lastData.length - 1].span += computedColumn.value - lastDataTotalSpan;
          }
        }
        return groupedData2;
      };
      const groupedData = vue.computed(() => {
        var _a;
        return getGroupedData((_a = props.data) != null ? _a : []);
      });
      const renderLabel = (item, index2) => {
        var _a, _b, _c, _d, _e;
        if (vue.isVNode(item)) {
          return isSlotsChildren(item, item.children) && ((_b = (_a = item.children).label) == null ? void 0 : _b.call(_a)) || ((_c = item.props) == null ? void 0 : _c.label);
        }
        return (_e = (_d = slots.label) == null ? void 0 : _d.call(slots, {
          label: item.label,
          index: index2,
          data: item
        })) != null ? _e : isFunction$1(item.label) ? item.label() : item.label;
      };
      const renderValue = (item, index2) => {
        var _a, _b;
        if (vue.isVNode(item)) {
          return item;
        }
        return (_b = (_a = slots.value) == null ? void 0 : _a.call(slots, {
          value: item.value,
          index: index2,
          data: item
        })) != null ? _b : isFunction$1(item.value) ? item.value() : item.value;
      };
      const renderVerticalItems = (data) => vue.createVNode(vue.Fragment, null, [vue.createVNode("tr", {
        "class": `${prefixCls}-row`
      }, [data.map((item, index2) => vue.createVNode("td", {
        "key": `label-${index2}`,
        "class": [`${prefixCls}-item-label`, `${prefixCls}-item-label-block`],
        "style": labelStyle.value,
        "colspan": item.span
      }, [renderLabel(item.data, index2)]))]), vue.createVNode("tr", {
        "class": `${prefixCls}-row`
      }, [data.map((item, index2) => vue.createVNode("td", {
        "key": `value-${index2}`,
        "class": [`${prefixCls}-item-value`, `${prefixCls}-item-value-block`],
        "style": valueStyle.value,
        "colspan": item.span
      }, [renderValue(item.data, index2)]))])]);
      const renderHorizontalItems = (data, index2) => vue.createVNode("tr", {
        "class": `${prefixCls}-row`,
        "key": `tr-${index2}`
      }, [data.map((item) => vue.createVNode(vue.Fragment, null, [vue.createVNode("td", {
        "class": [`${prefixCls}-item-label`, `${prefixCls}-item-label-block`],
        "style": labelStyle.value
      }, [renderLabel(item.data, index2)]), vue.createVNode("td", {
        "class": [`${prefixCls}-item-value`, `${prefixCls}-item-value-block`],
        "style": valueStyle.value,
        "colspan": item.span * 2 - 1
      }, [renderValue(item.data, index2)])]))]);
      const renderInlineItems = (data, index2) => vue.createVNode("tr", {
        "class": `${prefixCls}-row`,
        "key": `inline-${index2}`
      }, [data.map((item, index3) => vue.createVNode("td", {
        "key": `item-${index3}`,
        "class": `${prefixCls}-item`,
        "colspan": item.span
      }, [vue.createVNode("div", {
        "class": [`${prefixCls}-item-label`, `${prefixCls}-item-label-inline`],
        "style": labelStyle.value
      }, [renderLabel(item.data, index3)]), vue.createVNode("div", {
        "class": [`${prefixCls}-item-value`, `${prefixCls}-item-value-inline`],
        "style": valueStyle.value
      }, [renderValue(item.data, index3)])]))]);
      const renderItems = (data, index2) => {
        if (["inline-horizontal", "inline-vertical"].includes(props.layout)) {
          return renderInlineItems(data, index2);
        }
        if (props.layout === "vertical") {
          return renderVerticalItems(data);
        }
        return renderHorizontalItems(data, index2);
      };
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-layout-${props.layout}`, `${prefixCls}-size-${mergedSize.value}`, {
        [`${prefixCls}-border`]: props.bordered
      }, {
        [`${prefixCls}-table-layout-fixed`]: props.tableLayout === "fixed"
      }]);
      const renderTitle = () => {
        var _a, _b;
        const title = (_b = (_a = slots.title) == null ? void 0 : _a.call(slots)) != null ? _b : props.title;
        if (title) {
          return vue.createVNode("div", {
            "class": `${prefixCls}-title`
          }, [title]);
        }
        return null;
      };
      return () => {
        const _groupedData = slots.default ? getGroupedData(getAllElements(slots.default())) : groupedData.value;
        return vue.createVNode("div", {
          "class": cls.value
        }, [renderTitle(), vue.createVNode("div", {
          "class": `${prefixCls}-body`
        }, [vue.createVNode("table", {
          "class": `${prefixCls}-table`
        }, [vue.createVNode("tbody", null, [_groupedData.map((data, index2) => renderItems(data, index2))])])])]);
      };
    }
  });
  const _sfc_main$1N = vue.defineComponent({
    name: "DescriptionsItem",
    props: {
      span: {
        type: Number,
        default: 1
      },
      label: String
    },
    setup(props) {
      var _a;
      const { span } = vue.toRefs(props);
      const prefixCls = getPrefixCls("descriptions");
      const descCtx = vue.inject(descriptionsInjectionKey, {});
      const instance = vue.getCurrentInstance();
      const itemRef = vue.ref();
      const { computedIndex } = useIndex({
        itemRef,
        selector: `.${prefixCls}-item-value`,
        parentClassName: `${prefixCls}-table`
      });
      const itemData = vue.reactive({
        index: computedIndex,
        span
      });
      if (instance == null ? void 0 : instance.uid) {
        (_a = descCtx.addItem) == null ? void 0 : _a.call(descCtx, instance.uid, itemData);
      }
      const getItemRef = () => {
        var _a2;
        const itemEle = ((_a2 = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a2.$el).parentElement;
        if (itemEle && itemEle !== itemRef.value) {
          itemRef.value = itemEle;
        }
      };
      vue.onMounted(() => getItemRef());
      vue.onUpdated(() => getItemRef());
      vue.onBeforeUnmount(() => {
        var _a2;
        if (instance == null ? void 0 : instance.uid) {
          (_a2 = descCtx.removeItem) == null ? void 0 : _a2.call(descCtx, instance.uid);
        }
      });
      return {
        prefixCls
      };
    }
  });
  function _sfc_render$1M(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.renderSlot(_ctx.$slots, "default");
  }
  var DescriptionsItem = /* @__PURE__ */ _export_sfc(_sfc_main$1N, [["render", _sfc_render$1M]]);
  const Descriptions = Object.assign(_Descriptions, {
    DescriptionsItem,
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Descriptions.name, _Descriptions);
      app.component(componentPrefix + DescriptionsItem.name, DescriptionsItem);
    }
  });
  var _Divider = vue.defineComponent({
    name: "Divider",
    props: {
      direction: {
        type: String,
        default: "horizontal"
      },
      orientation: {
        type: String,
        default: "center"
      },
      type: {
        type: String
      },
      size: {
        type: Number
      },
      margin: {
        type: [Number, String]
      }
    },
    setup(props, {
      slots
    }) {
      const prefixCls = getPrefixCls("divider");
      const isHorizontal2 = vue.computed(() => props.direction === "horizontal");
      const mergedStyles = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles[isHorizontal2.value ? "border-bottom-width" : "border-left-width"] = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.type) {
          styles[isHorizontal2.value ? "border-bottom-style" : "border-left-style"] = props.type;
        }
        if (!isUndefined(props.margin)) {
          const margin = isNumber$1(props.margin) ? `${props.margin}px` : props.margin;
          styles.margin = isHorizontal2.value ? `${margin} 0` : `0 ${margin}`;
        }
        return styles;
      });
      return () => {
        var _a;
        const children = (_a = slots.default) == null ? void 0 : _a.call(slots);
        const classNames = [prefixCls, `${prefixCls}-${props.direction}`, {
          [`${prefixCls}-with-text`]: children
        }];
        return vue.createVNode("div", {
          "role": "separator",
          "class": classNames,
          "style": mergedStyles.value
        }, [children && props.direction === "horizontal" && vue.createVNode("span", {
          "class": [`${prefixCls}-text`, `${prefixCls}-text-${props.orientation}`]
        }, [children])]);
      };
    }
  });
  const Divider = Object.assign(_Divider, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Divider.name, _Divider);
    }
  });
  const useOverflow = (elementRef) => {
    const isSetOverflow = vue.ref(false);
    const originStyle = {
      overflow: "",
      width: "",
      boxSizing: ""
    };
    const setOverflowHidden = () => {
      if (elementRef.value) {
        const element = elementRef.value;
        if (!isSetOverflow.value && element.style.overflow !== "hidden") {
          const scrollBarWidth = getScrollBarWidth(element);
          if (scrollBarWidth > 0 || isScroll(element)) {
            originStyle.overflow = element.style.overflow;
            originStyle.width = element.style.width;
            originStyle.boxSizing = element.style.boxSizing;
            element.style.overflow = "hidden";
            element.style.width = `${element.offsetWidth - scrollBarWidth}px`;
            element.style.boxSizing = "border-box";
            isSetOverflow.value = true;
          }
        }
      }
    };
    const resetOverflow = () => {
      if (elementRef.value && isSetOverflow.value) {
        const element = elementRef.value;
        element.style.overflow = originStyle.overflow;
        element.style.width = originStyle.width;
        element.style.boxSizing = originStyle.boxSizing;
        isSetOverflow.value = false;
      }
    };
    return {
      setOverflowHidden,
      resetOverflow
    };
  };
  const DRAWER_PLACEMENTS = ["top", "right", "bottom", "left"];
  const _sfc_main$1M = vue.defineComponent({
    name: "Drawer",
    components: {
      ClientOnly,
      ArcoButton: Button,
      IconHover,
      IconClose
    },
    inheritAttrs: false,
    props: {
      visible: {
        type: Boolean,
        default: false
      },
      defaultVisible: {
        type: Boolean,
        default: false
      },
      placement: {
        type: String,
        default: "right",
        validator: (value) => DRAWER_PLACEMENTS.includes(value)
      },
      title: String,
      mask: {
        type: Boolean,
        default: true
      },
      maskClosable: {
        type: Boolean,
        default: true
      },
      closable: {
        type: Boolean,
        default: true
      },
      okText: String,
      cancelText: String,
      okLoading: {
        type: Boolean,
        default: false
      },
      okButtonProps: {
        type: Object
      },
      cancelButtonProps: {
        type: Object
      },
      unmountOnClose: Boolean,
      width: {
        type: [Number, String],
        default: 250
      },
      height: {
        type: [Number, String],
        default: 250
      },
      popupContainer: {
        type: [String, Object],
        default: "body"
      },
      drawerStyle: {
        type: Object
      },
      onBeforeOk: {
        type: Function
      },
      onBeforeCancel: {
        type: Function
      },
      escToClose: {
        type: Boolean,
        default: true
      },
      renderToBody: {
        type: Boolean,
        default: true
      },
      header: {
        type: Boolean,
        default: true
      },
      footer: {
        type: Boolean,
        default: true
      },
      hideCancel: {
        type: Boolean,
        default: false
      }
    },
    emits: {
      "update:visible": (visible) => true,
      "ok": (e2) => true,
      "cancel": (e2) => true,
      "open": () => true,
      "close": () => true,
      "beforeOpen": () => true,
      "beforeClose": () => true
    },
    setup(props, { emit }) {
      const { popupContainer } = vue.toRefs(props);
      const prefixCls = getPrefixCls("drawer");
      const { t: t2 } = useI18n();
      const _visible = vue.ref(props.defaultVisible);
      const computedVisible = vue.computed(() => {
        var _a;
        return (_a = props.visible) != null ? _a : _visible.value;
      });
      const _okLoading = vue.ref(false);
      const mergedOkLoading = vue.computed(() => props.okLoading || _okLoading.value);
      const { teleportContainer, containerRef } = useTeleportContainer({
        popupContainer,
        visible: computedVisible
      });
      const mounted = vue.ref(computedVisible.value);
      let globalKeyDownListener = false;
      const handleGlobalKeyDown = (ev) => {
        if (props.escToClose && ev.key === KEYBOARD_KEY.ESC && isLastDialog()) {
          handleCancel(ev);
        }
      };
      const addGlobalKeyDownListener = () => {
        if (props.escToClose && !globalKeyDownListener) {
          globalKeyDownListener = true;
          on(document.documentElement, "keydown", handleGlobalKeyDown);
        }
      };
      const removeGlobalKeyDownListener = () => {
        if (globalKeyDownListener) {
          globalKeyDownListener = false;
          off(document.documentElement, "keydown", handleGlobalKeyDown);
        }
      };
      const { zIndex, isLastDialog } = usePopupManager("dialog", {
        visible: computedVisible
      });
      const isFixed = vue.computed(() => {
        return (containerRef == null ? void 0 : containerRef.value) === document.body;
      });
      let promiseNumber = 0;
      const close = () => {
        promiseNumber++;
        if (_okLoading.value) {
          _okLoading.value = false;
        }
        _visible.value = false;
        emit("update:visible", false);
      };
      const handleOk = async (e2) => {
        const currentPromiseNumber = promiseNumber;
        const closed = await new Promise(async (resolve) => {
          var _a;
          if (isFunction$1(props.onBeforeOk)) {
            let result = props.onBeforeOk((closed2 = true) => resolve(closed2));
            if (isPromise(result) || !isBoolean$1(result)) {
              _okLoading.value = true;
            }
            if (isPromise(result)) {
              try {
                result = (_a = await result) != null ? _a : true;
              } catch (error) {
                result = false;
              }
            }
            if (isBoolean$1(result)) {
              resolve(result);
            }
          } else {
            resolve(true);
          }
        });
        if (currentPromiseNumber === promiseNumber) {
          if (closed) {
            emit("ok", e2);
            close();
          } else if (_okLoading.value) {
            _okLoading.value = false;
          }
        }
      };
      const handleCancel = (e2) => {
        var _a;
        let result = true;
        if (isFunction$1(props.onBeforeCancel)) {
          result = (_a = props.onBeforeCancel()) != null ? _a : false;
        }
        if (result) {
          emit("cancel", e2);
          close();
        }
      };
      const handleMask = (e2) => {
        if (props.maskClosable) {
          handleCancel(e2);
        }
      };
      const handleOpen = () => {
        if (computedVisible.value) {
          emit("open");
        }
      };
      const handleClose = () => {
        if (!computedVisible.value) {
          mounted.value = false;
          resetOverflow();
          emit("close");
        }
      };
      const { setOverflowHidden, resetOverflow } = useOverflow(containerRef);
      vue.onMounted(() => {
        if (computedVisible.value) {
          mounted.value = true;
          setOverflowHidden();
          addGlobalKeyDownListener();
        }
      });
      vue.onBeforeUnmount(() => {
        resetOverflow();
        removeGlobalKeyDownListener();
      });
      vue.watch(computedVisible, (visible) => {
        if (_visible.value !== visible) {
          _visible.value = visible;
        }
        if (visible) {
          emit("beforeOpen");
          mounted.value = true;
          setOverflowHidden();
          addGlobalKeyDownListener();
        } else {
          emit("beforeClose");
          removeGlobalKeyDownListener();
        }
      });
      const style = vue.computed(() => {
        var _a;
        const style2 = __spreadValues({
          [props.placement]: 0
        }, (_a = props.drawerStyle) != null ? _a : {});
        if (["right", "left"].includes(props.placement)) {
          style2.width = isNumber$1(props.width) ? `${props.width}px` : props.width;
        } else {
          style2.height = isNumber$1(props.height) ? `${props.height}px` : props.height;
        }
        return style2;
      });
      return {
        prefixCls,
        style,
        t: t2,
        mounted,
        computedVisible,
        mergedOkLoading,
        zIndex,
        handleOk,
        handleCancel,
        handleOpen,
        handleClose,
        handleMask,
        isFixed,
        teleportContainer
      };
    }
  });
  function _sfc_render$1L(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_icon_close = vue.resolveComponent("icon-close");
    const _component_icon_hover = vue.resolveComponent("icon-hover");
    const _component_arco_button = vue.resolveComponent("arco-button");
    const _component_client_only = vue.resolveComponent("client-only");
    return vue.openBlock(), vue.createBlock(_component_client_only, null, {
      default: vue.withCtx(() => [
        (vue.openBlock(), vue.createBlock(vue.Teleport, {
          to: _ctx.teleportContainer,
          disabled: !_ctx.renderToBody
        }, [
          !_ctx.unmountOnClose || _ctx.computedVisible || _ctx.mounted ? vue.withDirectives((vue.openBlock(), vue.createElementBlock("div", vue.mergeProps({
            key: 0,
            class: `${_ctx.prefixCls}-container`,
            style: _ctx.isFixed ? { zIndex: _ctx.zIndex } : { zIndex: "inherit", position: "absolute" }
          }, _ctx.$attrs), [
            vue.createVNode(vue.Transition, {
              name: "fade-drawer",
              appear: ""
            }, {
              default: vue.withCtx(() => [
                _ctx.mask ? vue.withDirectives((vue.openBlock(), vue.createElementBlock("div", {
                  key: 0,
                  class: vue.normalizeClass(`${_ctx.prefixCls}-mask`),
                  onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleMask && _ctx.handleMask(...args))
                }, null, 2)), [
                  [vue.vShow, _ctx.computedVisible]
                ]) : vue.createCommentVNode("v-if", true)
              ]),
              _: 1
            }),
            vue.createVNode(vue.Transition, {
              name: `slide-${_ctx.placement}-drawer`,
              appear: "",
              onAfterEnter: _ctx.handleOpen,
              onAfterLeave: _ctx.handleClose
            }, {
              default: vue.withCtx(() => [
                vue.withDirectives(vue.createElementVNode("div", {
                  class: vue.normalizeClass(_ctx.prefixCls),
                  style: vue.normalizeStyle(_ctx.style)
                }, [
                  _ctx.header ? (vue.openBlock(), vue.createElementBlock("div", {
                    key: 0,
                    class: vue.normalizeClass(`${_ctx.prefixCls}-header`)
                  }, [
                    vue.renderSlot(_ctx.$slots, "header", {}, () => [
                      _ctx.$slots.title || _ctx.title ? (vue.openBlock(), vue.createElementBlock("div", {
                        key: 0,
                        class: vue.normalizeClass(`${_ctx.prefixCls}-title`)
                      }, [
                        vue.renderSlot(_ctx.$slots, "title", {}, () => [
                          vue.createTextVNode(vue.toDisplayString(_ctx.title), 1)
                        ])
                      ], 2)) : vue.createCommentVNode("v-if", true),
                      _ctx.closable ? (vue.openBlock(), vue.createElementBlock("div", {
                        key: 1,
                        tabindex: "-1",
                        role: "button",
                        "aria-label": "Close",
                        class: vue.normalizeClass(`${_ctx.prefixCls}-close-btn`),
                        onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleCancel && _ctx.handleCancel(...args))
                      }, [
                        vue.createVNode(_component_icon_hover, null, {
                          default: vue.withCtx(() => [
                            vue.createVNode(_component_icon_close)
                          ]),
                          _: 1
                        })
                      ], 2)) : vue.createCommentVNode("v-if", true)
                    ])
                  ], 2)) : vue.createCommentVNode("v-if", true),
                  vue.createElementVNode("div", {
                    class: vue.normalizeClass(`${_ctx.prefixCls}-body`)
                  }, [
                    vue.renderSlot(_ctx.$slots, "default")
                  ], 2),
                  _ctx.footer ? (vue.openBlock(), vue.createElementBlock("div", {
                    key: 1,
                    class: vue.normalizeClass(`${_ctx.prefixCls}-footer`)
                  }, [
                    vue.renderSlot(_ctx.$slots, "footer", {}, () => [
                      !_ctx.hideCancel ? (vue.openBlock(), vue.createBlock(_component_arco_button, vue.mergeProps({ key: 0 }, _ctx.cancelButtonProps, { onClick: _ctx.handleCancel }), {
                        default: vue.withCtx(() => [
                          vue.createTextVNode(vue.toDisplayString(_ctx.cancelText || _ctx.t("drawer.cancelText")), 1)
                        ]),
                        _: 1
                      }, 16, ["onClick"])) : vue.createCommentVNode("v-if", true),
                      vue.createVNode(_component_arco_button, vue.mergeProps({
                        type: "primary",
                        loading: _ctx.mergedOkLoading
                      }, _ctx.okButtonProps, { onClick: _ctx.handleOk }), {
                        default: vue.withCtx(() => [
                          vue.createTextVNode(vue.toDisplayString(_ctx.okText || _ctx.t("drawer.okText")), 1)
                        ]),
                        _: 1
                      }, 16, ["loading", "onClick"])
                    ])
                  ], 2)) : vue.createCommentVNode("v-if", true)
                ], 6), [
                  [vue.vShow, _ctx.computedVisible]
                ])
              ]),
              _: 3
            }, 8, ["name", "onAfterEnter", "onAfterLeave"])
          ], 16)), [
            [vue.vShow, _ctx.computedVisible || _ctx.mounted]
          ]) : vue.createCommentVNode("v-if", true)
        ], 8, ["to", "disabled"]))
      ]),
      _: 3
    });
  }
  var _Drawer = /* @__PURE__ */ _export_sfc(_sfc_main$1M, [["render", _sfc_render$1L]]);
  const open$1 = (config, appContext) => {
    let container2 = getOverlay("drawer");
    const handleOk = () => {
      if (vm.component) {
        vm.component.props.visible = false;
      }
      if (isFunction$1(config.onOk)) {
        config.onOk();
      }
    };
    const handleCancel = () => {
      if (vm.component) {
        vm.component.props.visible = false;
      }
      if (isFunction$1(config.onCancel)) {
        config.onCancel();
      }
    };
    const handleClose = async () => {
      await vue.nextTick();
      if (container2) {
        vue.render(null, container2);
        document.body.removeChild(container2);
      }
      container2 = null;
      if (isFunction$1(config.onClose)) {
        config.onClose();
      }
    };
    const handleReturnClose = () => {
      if (vm.component) {
        vm.component.props.visible = false;
      }
    };
    const handleUpdateConfig = (config2) => {
      if (vm.component) {
        Object.entries(config2).forEach(([key, value]) => {
          vm.component.props[key] = value;
        });
      }
    };
    const defaultConfig = {
      visible: true,
      renderToBody: false,
      unmountOnClose: true,
      onOk: handleOk,
      onCancel: handleCancel,
      onClose: handleClose
    };
    const vm = vue.createVNode(_Drawer, __spreadValues(__spreadValues(__spreadValues({}, defaultConfig), omit(config, [
      "content",
      "title",
      "footer",
      "visible",
      "unmountOnClose",
      "onOk",
      "onCancel",
      "onClose"
    ])), {
      header: typeof config.header === "boolean" ? config.header : void 0,
      footer: typeof config.footer === "boolean" ? config.footer : void 0
    }), {
      default: getSlotFunction(config.content),
      header: typeof config.header !== "boolean" ? getSlotFunction(config.header) : void 0,
      title: getSlotFunction(config.title),
      footer: typeof config.footer !== "boolean" ? getSlotFunction(config.footer) : void 0
    });
    if (appContext != null ? appContext : Drawer._context) {
      vm.appContext = appContext != null ? appContext : Drawer._context;
    }
    vue.render(vm, container2);
    document.body.appendChild(container2);
    return {
      close: handleReturnClose,
      update: handleUpdateConfig
    };
  };
  const Drawer = Object.assign(_Drawer, {
    open: open$1,
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Drawer.name, _Drawer);
      const drawerWithContext = {
        open: (config, appContext = app._context) => open$1(config, appContext)
      };
      app.config.globalProperties.$drawer = drawerWithContext;
    },
    _context: null
  });
  const _sfc_main$1L = vue.defineComponent({
    name: "Form",
    props: {
      model: {
        type: Object,
        required: true
      },
      layout: {
        type: String,
        default: "horizontal"
      },
      size: {
        type: String
      },
      labelColProps: {
        type: Object,
        default: () => ({ span: 5, offset: 0 })
      },
      wrapperColProps: {
        type: Object,
        default: () => ({ span: 19, offset: 0 })
      },
      labelColStyle: Object,
      wrapperColStyle: Object,
      labelAlign: {
        type: String,
        default: "right"
      },
      disabled: {
        type: Boolean,
        default: void 0
      },
      rules: {
        type: Object
      },
      autoLabelWidth: {
        type: Boolean,
        default: false
      }
    },
    emits: {
      submit: (data, ev) => true,
      submitSuccess: (values, ev) => true,
      submitFailed: (data, ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("form");
      const {
        model,
        layout,
        disabled,
        labelAlign,
        labelColProps,
        wrapperColProps,
        labelColStyle,
        wrapperColStyle,
        size,
        rules
      } = vue.toRefs(props);
      const { mergedSize } = useSize$1(size);
      const autoLabelWidth = vue.computed(() => props.layout === "horizontal" && props.autoLabelWidth);
      const fields = [];
      const touchedFields = [];
      const labelWidth = vue.reactive({});
      const maxLabelWidth = vue.computed(() => Math.max(...Object.values(labelWidth)));
      const addField = (formItemInfo) => {
        if (formItemInfo && formItemInfo.field) {
          fields.push(formItemInfo);
        }
      };
      const removeField = (formItemInfo) => {
        if (formItemInfo && formItemInfo.field) {
          fields.splice(fields.indexOf(formItemInfo), 1);
        }
      };
      const setFields = (data) => {
        fields.forEach((field) => {
          if (data[field.field]) {
            field.setField(data[field.field]);
          }
        });
      };
      const setLabelWidth = (width, uid) => {
        if (uid && labelWidth[uid] !== width) {
          labelWidth[uid] = width;
        }
      };
      const removeLabelWidth = (uid) => {
        if (uid) {
          delete labelWidth[uid];
        }
      };
      const resetFields = (field) => {
        const _fields = field ? [].concat(field) : [];
        fields.forEach((field2) => {
          if (_fields.length === 0 || _fields.includes(field2.field)) {
            field2.resetField();
          }
        });
      };
      const clearValidate = (field) => {
        const _fields = field ? [].concat(field) : [];
        fields.forEach((field2) => {
          if (_fields.length === 0 || _fields.includes(field2.field)) {
            field2.clearValidate();
          }
        });
      };
      const validate = (callback) => {
        const list = [];
        fields.forEach((field) => {
          list.push(field.validate());
        });
        return Promise.all(list).then((result) => {
          const errors = {};
          let hasError = false;
          result.forEach((item) => {
            if (item) {
              hasError = true;
              errors[item.field] = item;
            }
          });
          if (isFunction$1(callback)) {
            callback(hasError ? errors : void 0);
          }
          return hasError ? errors : void 0;
        });
      };
      const validateField = (field, callback) => {
        const list = [];
        for (const ctx of fields) {
          if (isArray$1(field) && field.includes(ctx.field) || field === ctx.field) {
            list.push(ctx.validate());
          }
        }
        return Promise.all(list).then((result) => {
          const errors = {};
          let hasError = false;
          result.forEach((item) => {
            if (item) {
              hasError = true;
              errors[item.field] = item;
            }
          });
          if (isFunction$1(callback)) {
            callback(hasError ? errors : void 0);
          }
          return hasError ? errors : void 0;
        });
      };
      const handleSubmit = (e2) => {
        const list = [];
        fields.forEach((field) => {
          list.push(field.validate());
        });
        Promise.all(list).then((result) => {
          const errors = {};
          let hasError = false;
          result.forEach((item) => {
            if (item) {
              hasError = true;
              errors[item.field] = item;
            }
          });
          if (hasError) {
            emit("submitFailed", { values: model.value, errors }, e2);
          } else {
            emit("submitSuccess", model.value, e2);
          }
          emit("submit", { values: model.value, errors: hasError ? errors : void 0 }, e2);
        });
      };
      vue.provide(formInjectionKey, vue.reactive({
        layout,
        disabled,
        labelAlign,
        labelColProps,
        wrapperColProps,
        labelColStyle,
        wrapperColStyle,
        model,
        size: mergedSize,
        rules,
        fields,
        touchedFields,
        addField,
        removeField,
        validateField,
        setLabelWidth,
        removeLabelWidth,
        maxLabelWidth,
        autoLabelWidth
      }));
      const cls = vue.computed(() => [
        prefixCls,
        `${prefixCls}-layout-${props.layout}`,
        `${prefixCls}-size-${mergedSize.value}`,
        {
          [`${prefixCls}-auto-label-width`]: props.autoLabelWidth
        }
      ]);
      return {
        cls,
        handleSubmit,
        innerValidate: validate,
        innerValidateField: validateField,
        innerResetFields: resetFields,
        innerClearValidate: clearValidate,
        innerSetFields: setFields
      };
    },
    methods: {
      validate(callback) {
        return this.innerValidate(callback);
      },
      validateField(field, callback) {
        return this.innerValidateField(field, callback);
      },
      resetFields(field) {
        return this.innerResetFields(field);
      },
      clearValidate(field) {
        return this.innerClearValidate(field);
      },
      setFields(data) {
        return this.innerSetFields(data);
      }
    }
  });
  function _sfc_render$1K(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("form", {
      class: vue.normalizeClass(_ctx.cls),
      onSubmit: _cache[0] || (_cache[0] = vue.withModifiers((...args) => _ctx.handleSubmit && _ctx.handleSubmit(...args), ["prevent"]))
    }, [
      vue.renderSlot(_ctx.$slots, "default")
    ], 34);
  }
  var _Form = /* @__PURE__ */ _export_sfc(_sfc_main$1L, [["render", _sfc_render$1K]]);
  var opt = Object.prototype.toString;
  function isArray(obj) {
    return opt.call(obj) === "[object Array]";
  }
  function isObject(obj) {
    return opt.call(obj) === "[object Object]";
  }
  function isString(obj) {
    return opt.call(obj) === "[object String]";
  }
  function isNumber(obj) {
    return opt.call(obj) === "[object Number]" && obj === obj;
  }
  function isBoolean(obj) {
    return opt.call(obj) === "[object Boolean]";
  }
  function isFunction(obj) {
    return opt.call(obj) === "[object Function]";
  }
  function isEmptyObject(obj) {
    return isObject(obj) && Object.keys(obj).length === 0;
  }
  function isEmptyValue(obj) {
    return obj === void 0 || obj === null || obj === "";
  }
  function isEmptyArray(obj) {
    return isArray(obj) && !obj.length;
  }
  var isEqual = function(obj, other) {
    if (typeof obj !== "object" || typeof other !== "object") {
      return obj === other;
    }
    if (isFunction(obj) && isFunction(other)) {
      return obj === other || obj.toString() === other.toString();
    }
    if (Object.keys(obj).length !== Object.keys(other).length) {
      return false;
    }
    for (var key in obj) {
      var result = isEqual(obj[key], other[key]);
      if (!result) {
        return false;
      }
    }
    return true;
  };
  var mergeTemplate = function(defaultValidateMessages, validateMessages2) {
    var result = {};
    Object.keys(defaultValidateMessages).forEach(function(key) {
      var defaultValue = defaultValidateMessages[key];
      var propsValue = validateMessages2 && validateMessages2[key];
      result[key] = isObject(defaultValue) ? Object.assign(Object.assign({}, defaultValue), propsValue) : propsValue || defaultValue;
    });
    return result;
  };
  var getTemplate = function(validateMessages2, keyPath) {
    var keys = keyPath.split(".");
    var result = validateMessages2;
    for (var i = 0; i < keys.length; i++) {
      result = result && result[keys[i]];
      if (result === void 0) {
        return result;
      }
    }
    return result;
  };
  var defaultTypeTemplate = "#{field} is not a #{type} type";
  var validateMessages = {
    required: "#{field} is required",
    type: {
      ip: defaultTypeTemplate,
      email: defaultTypeTemplate,
      url: defaultTypeTemplate,
      string: defaultTypeTemplate,
      number: defaultTypeTemplate,
      array: defaultTypeTemplate,
      object: defaultTypeTemplate,
      boolean: defaultTypeTemplate
    },
    number: {
      min: "`#{value}` is not greater than `#{min}`",
      max: "`#{value}` is not less than `#{max}`",
      equal: "`#{value}` is not equal to `#{equal}`",
      range: "`#{value}` is not in range `#{min} ~ #{max}`",
      positive: "`#{value}` is not a positive number",
      negative: "`#{value}` is not a negative number"
    },
    string: {
      maxLength: "#{field} cannot be longer than #{maxLength} characters",
      minLength: "#{field} must be at least #{minLength} characters",
      length: "#{field} must be exactly #{length} characters",
      match: "`#{value}` does not match pattern #{pattern}",
      uppercase: "`#{value}` must be all uppercase",
      lowercase: "`#{value}` must be all lowercased"
    },
    array: {
      length: "#{field} must be exactly #{length} in length",
      minLength: "#{field} cannot be less than #{minLength} in length",
      maxLength: "#{field} cannot be greater than #{maxLength} in length",
      includes: "#{field} is not includes #{includes}",
      deepEqual: "#{field} is not deep equal with #{deepEqual}",
      empty: "#{field} is not an empty array"
    },
    object: {
      deepEqual: "#{field} is not deep equal to expected value",
      hasKeys: "#{field} does not contain required fields",
      empty: "`#{field} is not an empty object"
    },
    boolean: {
      true: "Expect true but got `#{value}`",
      false: "Expect false but got `#{value}`"
    }
  };
  var Base$1 = function Base2(obj, options) {
    var this$1$1 = this;
    this.getValidateMsg = function(keyPath, info) {
      if (info === void 0)
        info = {};
      var data = Object.assign(Object.assign({}, info), { value: this$1$1.obj, field: this$1$1.field, type: this$1$1.type });
      var template = getTemplate(this$1$1.validateMessages, keyPath);
      if (isFunction(template)) {
        return template(data);
      }
      if (isString(template)) {
        return template.replace(/\#\{.+?\}/g, function(variable) {
          var key = variable.slice(2, -1);
          if (key in data) {
            if (isObject(data[key]) || isArray(data[key])) {
              try {
                return JSON.stringify(data[key]);
              } catch (_) {
                return data[key];
              }
            }
            return String(data[key]);
          }
          return variable;
        });
      }
      return template;
    };
    if (isObject(options) && isString(obj) && options.trim) {
      this.obj = obj.trim();
    } else if (isObject(options) && options.ignoreEmptyString && obj === "") {
      this.obj = void 0;
    } else {
      this.obj = obj;
    }
    this.message = options.message;
    this.type = options.type;
    this.error = null;
    this.field = options.field || options.type;
    this.validateMessages = mergeTemplate(validateMessages, options.validateMessages);
  };
  var prototypeAccessors = { not: { configurable: true }, isRequired: { configurable: true }, end: { configurable: true } };
  prototypeAccessors.not.get = function() {
    this._not = !this._not;
    return this;
  };
  prototypeAccessors.isRequired.get = function() {
    if (isEmptyValue(this.obj) || isEmptyArray(this.obj)) {
      var message2 = this.getValidateMsg("required");
      this.error = {
        value: this.obj,
        type: this.type,
        requiredError: true,
        message: this.message || (isObject(message2) ? message2 : "" + (this._not ? "[NOT MODE]:" : "") + message2)
      };
    }
    return this;
  };
  prototypeAccessors.end.get = function() {
    return this.error;
  };
  Base$1.prototype.addError = function addError(message2) {
    if (!this.error && message2) {
      this.error = {
        value: this.obj,
        type: this.type,
        message: this.message || (isObject(message2) ? message2 : "" + (this._not ? "[NOT MODE]:" : "") + message2)
      };
    }
  };
  Base$1.prototype.validate = function validate(expression, errorMessage) {
    var _expression = this._not ? expression : !expression;
    if (_expression) {
      this.addError(errorMessage);
    }
    return this;
  };
  Base$1.prototype.collect = function collect(callback) {
    callback && callback(this.error);
  };
  Object.defineProperties(Base$1.prototype, prototypeAccessors);
  var StringValidator = /* @__PURE__ */ function(Base2) {
    function StringValidator2(obj, options) {
      Base2.call(this, obj, Object.assign(Object.assign({}, options), { type: "string" }));
      this.validate(options && options.strict ? isString(this.obj) : true, this.getValidateMsg("type.string"));
    }
    if (Base2)
      StringValidator2.__proto__ = Base2;
    StringValidator2.prototype = Object.create(Base2 && Base2.prototype);
    StringValidator2.prototype.constructor = StringValidator2;
    var prototypeAccessors2 = { uppercase: { configurable: true }, lowercase: { configurable: true } };
    StringValidator2.prototype.maxLength = function maxLength(length) {
      return this.obj ? this.validate(this.obj.length <= length, this.getValidateMsg("string.maxLength", { maxLength: length })) : this;
    };
    StringValidator2.prototype.minLength = function minLength(length) {
      return this.obj ? this.validate(this.obj.length >= length, this.getValidateMsg("string.minLength", { minLength: length })) : this;
    };
    StringValidator2.prototype.length = function length(length$1) {
      return this.obj ? this.validate(this.obj.length === length$1, this.getValidateMsg("string.length", { length: length$1 })) : this;
    };
    StringValidator2.prototype.match = function match(pattern) {
      var isRegex = pattern instanceof RegExp;
      if (isRegex) {
        pattern.lastIndex = 0;
      }
      return this.validate(this.obj === void 0 || isRegex && pattern.test(this.obj), this.getValidateMsg("string.match", { pattern }));
    };
    prototypeAccessors2.uppercase.get = function() {
      return this.obj ? this.validate(this.obj.toUpperCase() === this.obj, this.getValidateMsg("string.uppercase")) : this;
    };
    prototypeAccessors2.lowercase.get = function() {
      return this.obj ? this.validate(this.obj.toLowerCase() === this.obj, this.getValidateMsg("string.lowercase")) : this;
    };
    Object.defineProperties(StringValidator2.prototype, prototypeAccessors2);
    return StringValidator2;
  }(Base$1);
  var NumberValidator = /* @__PURE__ */ function(Base2) {
    function NumberValidator2(obj, options) {
      Base2.call(this, obj, Object.assign(Object.assign({}, options), { type: "number" }));
      this.validate(options && options.strict ? isNumber(this.obj) : true, this.getValidateMsg("type.number"));
    }
    if (Base2)
      NumberValidator2.__proto__ = Base2;
    NumberValidator2.prototype = Object.create(Base2 && Base2.prototype);
    NumberValidator2.prototype.constructor = NumberValidator2;
    var prototypeAccessors2 = { positive: { configurable: true }, negative: { configurable: true } };
    NumberValidator2.prototype.min = function min(num) {
      return !isEmptyValue(this.obj) ? this.validate(this.obj >= num, this.getValidateMsg("number.min", { min: num })) : this;
    };
    NumberValidator2.prototype.max = function max(num) {
      return !isEmptyValue(this.obj) ? this.validate(this.obj <= num, this.getValidateMsg("number.max", { max: num })) : this;
    };
    NumberValidator2.prototype.equal = function equal(num) {
      return !isEmptyValue(this.obj) ? this.validate(this.obj === num, this.getValidateMsg("number.equal", { equal: num })) : this;
    };
    NumberValidator2.prototype.range = function range(min, max) {
      return !isEmptyValue(this.obj) ? this.validate(this.obj >= min && this.obj <= max, this.getValidateMsg("number.range", { min, max })) : this;
    };
    prototypeAccessors2.positive.get = function() {
      return !isEmptyValue(this.obj) ? this.validate(this.obj > 0, this.getValidateMsg("number.positive")) : this;
    };
    prototypeAccessors2.negative.get = function() {
      return !isEmptyValue(this.obj) ? this.validate(this.obj < 0, this.getValidateMsg("number.negative")) : this;
    };
    Object.defineProperties(NumberValidator2.prototype, prototypeAccessors2);
    return NumberValidator2;
  }(Base$1);
  var ArrayValidator = /* @__PURE__ */ function(Base2) {
    function ArrayValidator2(obj, options) {
      Base2.call(this, obj, Object.assign(Object.assign({}, options), { type: "array" }));
      this.validate(options && options.strict ? isArray(this.obj) : true, this.getValidateMsg("type.array", { value: this.obj, type: this.type }));
    }
    if (Base2)
      ArrayValidator2.__proto__ = Base2;
    ArrayValidator2.prototype = Object.create(Base2 && Base2.prototype);
    ArrayValidator2.prototype.constructor = ArrayValidator2;
    var prototypeAccessors2 = { empty: { configurable: true } };
    ArrayValidator2.prototype.length = function length(num) {
      return this.obj ? this.validate(this.obj.length === num, this.getValidateMsg("array.length", { value: this.obj, length: num })) : this;
    };
    ArrayValidator2.prototype.minLength = function minLength(num) {
      return this.obj ? this.validate(this.obj.length >= num, this.getValidateMsg("array.minLength", { value: this.obj, minLength: num })) : this;
    };
    ArrayValidator2.prototype.maxLength = function maxLength(num) {
      return this.obj ? this.validate(this.obj.length <= num, this.getValidateMsg("array.maxLength", { value: this.obj, maxLength: num })) : this;
    };
    ArrayValidator2.prototype.includes = function includes(arrays) {
      var this$1$1 = this;
      return this.obj ? this.validate(arrays.every(function(el) {
        return this$1$1.obj.indexOf(el) !== -1;
      }), this.getValidateMsg("array.includes", {
        value: this.obj,
        includes: arrays
      })) : this;
    };
    ArrayValidator2.prototype.deepEqual = function deepEqual(other) {
      return this.obj ? this.validate(isEqual(this.obj, other), this.getValidateMsg("array.deepEqual", { value: this.obj, deepEqual: other })) : this;
    };
    prototypeAccessors2.empty.get = function() {
      return this.validate(isEmptyArray(this.obj), this.getValidateMsg("array.empty", { value: this.obj }));
    };
    Object.defineProperties(ArrayValidator2.prototype, prototypeAccessors2);
    return ArrayValidator2;
  }(Base$1);
  var ObjectValidator = /* @__PURE__ */ function(Base2) {
    function ObjectValidator2(obj, options) {
      Base2.call(this, obj, Object.assign(Object.assign({}, options), { type: "object" }));
      this.validate(options && options.strict ? isObject(this.obj) : true, this.getValidateMsg("type.object"));
    }
    if (Base2)
      ObjectValidator2.__proto__ = Base2;
    ObjectValidator2.prototype = Object.create(Base2 && Base2.prototype);
    ObjectValidator2.prototype.constructor = ObjectValidator2;
    var prototypeAccessors2 = { empty: { configurable: true } };
    ObjectValidator2.prototype.deepEqual = function deepEqual(other) {
      return this.obj ? this.validate(isEqual(this.obj, other), this.getValidateMsg("object.deepEqual", { deepEqual: other })) : this;
    };
    ObjectValidator2.prototype.hasKeys = function hasKeys(keys) {
      var this$1$1 = this;
      return this.obj ? this.validate(keys.every(function(el) {
        return this$1$1.obj[el];
      }), this.getValidateMsg("object.hasKeys", { keys })) : this;
    };
    prototypeAccessors2.empty.get = function() {
      return this.validate(isEmptyObject(this.obj), this.getValidateMsg("object.empty"));
    };
    Object.defineProperties(ObjectValidator2.prototype, prototypeAccessors2);
    return ObjectValidator2;
  }(Base$1);
  var BooleanValidator = /* @__PURE__ */ function(Base2) {
    function BooleanValidator2(obj, options) {
      Base2.call(this, obj, Object.assign(Object.assign({}, options), { type: "boolean" }));
      this.validate(options && options.strict ? isBoolean(this.obj) : true, this.getValidateMsg("type.boolean"));
    }
    if (Base2)
      BooleanValidator2.__proto__ = Base2;
    BooleanValidator2.prototype = Object.create(Base2 && Base2.prototype);
    BooleanValidator2.prototype.constructor = BooleanValidator2;
    var prototypeAccessors2 = { true: { configurable: true }, false: { configurable: true } };
    prototypeAccessors2.true.get = function() {
      return this.validate(this.obj === true, this.getValidateMsg("boolean.true"));
    };
    prototypeAccessors2.false.get = function() {
      return this.validate(this.obj === false, this.getValidateMsg("boolean.false"));
    };
    Object.defineProperties(BooleanValidator2.prototype, prototypeAccessors2);
    return BooleanValidator2;
  }(Base$1);
  var regexEmail = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
  var regexUrl = new RegExp("^(?!mailto:)(?:(?:http|https|ftp)://)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$", "i");
  var regexIp = /^(2(5[0-5]{1}|[0-4]\d{1})|[0-1]?\d{1,2})(\.(2(5[0-5]{1}|[0-4]\d{1})|[0-1]?\d{1,2})){3}$/;
  var TypeValidator = /* @__PURE__ */ function(Base2) {
    function TypeValidator2(obj, options) {
      Base2.call(this, obj, Object.assign(Object.assign({}, options), { type: "type" }));
    }
    if (Base2)
      TypeValidator2.__proto__ = Base2;
    TypeValidator2.prototype = Object.create(Base2 && Base2.prototype);
    TypeValidator2.prototype.constructor = TypeValidator2;
    var prototypeAccessors2 = { email: { configurable: true }, url: { configurable: true }, ip: { configurable: true } };
    prototypeAccessors2.email.get = function() {
      this.type = "email";
      return this.validate(this.obj === void 0 || regexEmail.test(this.obj), this.getValidateMsg("type.email"));
    };
    prototypeAccessors2.url.get = function() {
      this.type = "url";
      return this.validate(this.obj === void 0 || regexUrl.test(this.obj), this.getValidateMsg("type.url"));
    };
    prototypeAccessors2.ip.get = function() {
      this.type = "ip";
      return this.validate(this.obj === void 0 || regexIp.test(this.obj), this.getValidateMsg("type.ip"));
    };
    Object.defineProperties(TypeValidator2.prototype, prototypeAccessors2);
    return TypeValidator2;
  }(Base$1);
  var CustomValidator = /* @__PURE__ */ function(Base2) {
    function CustomValidator2(obj, options) {
      Base2.call(this, obj, Object.assign(Object.assign({}, options), { type: "custom" }));
    }
    if (Base2)
      CustomValidator2.__proto__ = Base2;
    CustomValidator2.prototype = Object.create(Base2 && Base2.prototype);
    CustomValidator2.prototype.constructor = CustomValidator2;
    var prototypeAccessors2 = { validate: { configurable: true } };
    prototypeAccessors2.validate.get = function() {
      var _this = this;
      return function(validator, callback) {
        var ret;
        if (validator) {
          ret = validator(_this.obj, _this.addError.bind(_this));
          if (ret && ret.then) {
            if (callback) {
              ret.then(function() {
                callback && callback(_this.error);
              }, function(e2) {
                console.error(e2);
              });
            }
            return [ret, _this];
          } else {
            callback && callback(_this.error);
            return _this.error;
          }
        }
      };
    };
    Object.defineProperties(CustomValidator2.prototype, prototypeAccessors2);
    return CustomValidator2;
  }(Base$1);
  var Validate = function Validate2(obj, options) {
    this.string = new StringValidator(obj, options);
    this.number = new NumberValidator(obj, options);
    this.array = new ArrayValidator(obj, options);
    this.object = new ObjectValidator(obj, options);
    this.boolean = new BooleanValidator(obj, options);
    this.type = new TypeValidator(obj, options);
    this.custom = new CustomValidator(obj, options);
  };
  var Schema = function Schema2(schema, options) {
    if (options === void 0)
      options = {};
    this.schema = schema;
    this.options = options;
  };
  Schema.prototype.validate = function validate(values, callback) {
    var this$1$1 = this;
    if (!isObject(values)) {
      return;
    }
    var promises = [];
    var errors = null;
    function setError(key, error) {
      if (!errors) {
        errors = {};
      }
      if (!errors[key] || error.requiredError) {
        errors[key] = error;
      }
    }
    if (this.schema) {
      Object.keys(this.schema).forEach(function(key) {
        if (isArray(this$1$1.schema[key])) {
          var loop = function(i2) {
            var rule = this$1$1.schema[key][i2];
            var type = rule.type;
            var message2 = rule.message;
            if (!type && !rule.validator) {
              throw "You must specify a type to field " + key + "!";
            }
            var validator = new Validate(values[key], Object.assign(Object.assign({}, this$1$1.options), { message: message2, field: key }));
            var bv = validator.type[type] || null;
            if (!bv) {
              if (rule.validator) {
                bv = validator.custom.validate(rule.validator);
                if (Object.prototype.toString.call(bv) === "[object Array]" && bv[0].then) {
                  promises.push({
                    function: bv[0],
                    _this: bv[1],
                    key
                  });
                } else if (bv) {
                  setError(key, bv);
                }
                return;
              } else {
                bv = validator[type];
              }
            }
            Object.keys(rule).forEach(function(r2) {
              if (rule.required) {
                bv = bv.isRequired;
              }
              if (r2 !== "message" && bv[r2] && rule[r2] && typeof bv[r2] === "object") {
                bv = bv[r2];
              }
              if (bv[r2] && rule[r2] !== void 0 && typeof bv[r2] === "function") {
                bv = bv[r2](rule[r2]);
              }
            });
            bv.collect(function(error) {
              if (error) {
                setError(key, error);
              }
            });
            if (errors) {
              return "break";
            }
          };
          for (var i = 0; i < this$1$1.schema[key].length; i++) {
            var returned = loop(i);
            if (returned === "break")
              break;
          }
        }
      });
    }
    if (promises.length > 0) {
      Promise.all(promises.map(function(a) {
        return a.function;
      })).then(function() {
        promises.forEach(function(promise) {
          if (promise._this.error) {
            setError(promise.key, promise._this.error);
          }
        });
        callback && callback(errors);
      });
    } else {
      callback && callback(errors);
    }
  };
  const RowContextInjectionKey = Symbol("RowContextInjectionKey");
  const GridContextInjectionKey = Symbol("GridContextInjectionKey");
  const GridDataCollectorInjectionKey = Symbol("GridDataCollectorInjectionKey");
  const _sfc_main$1K = vue.defineComponent({
    name: "Row",
    props: {
      gutter: {
        type: [Number, Object, Array],
        default: 0
      },
      justify: {
        type: String,
        default: "start"
      },
      align: {
        type: String,
        default: "start"
      },
      div: {
        type: Boolean
      },
      wrap: {
        type: Boolean,
        default: true
      }
    },
    setup(props) {
      const { gutter, align, justify, div, wrap } = vue.toRefs(props);
      const prefixCls = getPrefixCls("row");
      const classNames = vue.computed(() => {
        return {
          [`${prefixCls}`]: !div.value,
          [`${prefixCls}-nowrap`]: !wrap.value,
          [`${prefixCls}-align-${align.value}`]: align.value,
          [`${prefixCls}-justify-${justify.value}`]: justify.value
        };
      });
      const propGutterHorizontal = vue.computed(() => Array.isArray(gutter.value) ? gutter.value[0] : gutter.value);
      const propGutterVertical = vue.computed(() => Array.isArray(gutter.value) ? gutter.value[1] : 0);
      const gutterHorizontal = useResponsiveState(propGutterHorizontal, 0);
      const gutterVertical = useResponsiveState(propGutterVertical, 0);
      const styles = vue.computed(() => {
        const result = {};
        if ((gutterHorizontal.value || gutterVertical.value) && !div.value) {
          const marginHorizontal = -gutterHorizontal.value / 2;
          const marginVertical = -gutterVertical.value / 2;
          if (marginHorizontal) {
            result.marginLeft = `${marginHorizontal}px`;
            result.marginRight = `${marginHorizontal}px`;
          }
          if (marginVertical) {
            result.marginTop = `${marginVertical}px`;
            result.marginBottom = `${marginVertical}px`;
          }
        }
        return result;
      });
      const resultGutter = vue.computed(() => [
        gutterHorizontal.value,
        gutterVertical.value
      ]);
      vue.provide(RowContextInjectionKey, vue.reactive({
        gutter: resultGutter,
        div
      }));
      return {
        classNames,
        styles
      };
    }
  });
  function _sfc_render$1J(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.classNames),
      style: vue.normalizeStyle(_ctx.styles)
    }, [
      vue.renderSlot(_ctx.$slots, "default")
    ], 6);
  }
  var Row = /* @__PURE__ */ _export_sfc(_sfc_main$1K, [["render", _sfc_render$1J]]);
  function useResponsiveValue(props) {
    const value = vue.computed(() => {
      const { val, key, xs, sm, md, lg, xl, xxl } = props.value;
      if (!xs && !sm && !md && !lg && !xl && !xxl) {
        return val;
      }
      const result = {};
      responsiveArray.forEach((breakpoint) => {
        const config = props.value[breakpoint];
        if (isNumber$1(config)) {
          result[breakpoint] = config;
        } else if (isObject$1(config) && isNumber$1(config[key])) {
          result[breakpoint] = config[key];
        }
      });
      return result;
    });
    return value;
  }
  function getAllowableFlexValue(flexValue) {
    if (isString$1(flexValue) && (["initial", "auto", "none"].includes(flexValue) || /^\d+$/.test(flexValue)) || isNumber$1(flexValue)) {
      return flexValue;
    }
    if (isString$1(flexValue) && /^\d+(px|em|rem|%)$/.test(flexValue)) {
      return `0 0 ${flexValue}`;
    }
    return void 0;
  }
  const _sfc_main$1J = vue.defineComponent({
    name: "Col",
    props: {
      span: {
        type: Number,
        default: 24
      },
      offset: {
        type: Number
      },
      order: {
        type: Number
      },
      xs: {
        type: [Number, Object]
      },
      sm: {
        type: [Number, Object]
      },
      md: {
        type: [Number, Object]
      },
      lg: {
        type: [Number, Object]
      },
      xl: {
        type: [Number, Object]
      },
      xxl: {
        type: [Number, Object]
      },
      flex: {
        type: [Number, String]
      }
    },
    setup(props) {
      const prefixCls = getPrefixCls("col");
      const rowContext = vue.inject(RowContextInjectionKey, {});
      const flexValue = vue.computed(() => getAllowableFlexValue(props.flex));
      const mergeClassName = vue.computed(() => {
        const { div } = rowContext;
        const { span: span2, offset, order, xs, sm, md, lg, xl, xxl } = props;
        const result = {
          [`${prefixCls}`]: !div,
          [`${prefixCls}-order-${order}`]: order,
          [`${prefixCls}-${span2}`]: !div && !xs && !sm && !md && !lg && !xl && !xxl,
          [`${prefixCls}-offset-${offset}`]: offset && offset > 0
        };
        const screenList = { xs, sm, md, lg, xl, xxl };
        Object.keys(screenList).forEach((screen) => {
          const screenValue = screenList[screen];
          if (screenValue && isNumber$1(screenValue)) {
            result[`${prefixCls}-${screen}-${screenValue}`] = true;
          } else if (screenValue && isObject$1(screenValue)) {
            result[`${prefixCls}-${screen}-${screenValue.span}`] = screenValue.span;
            result[`${prefixCls}-${screen}-offset-${screenValue.offset}`] = screenValue.offset;
            result[`${prefixCls}-${screen}-order-${screenValue.order}`] = screenValue.order;
          }
        });
        return result;
      });
      const classNames = vue.computed(() => {
        return flexValue.value ? prefixCls : mergeClassName.value;
      });
      const paddingStyles = vue.computed(() => {
        const { gutter, div } = rowContext;
        const result = {};
        if (Array.isArray(gutter) && !div) {
          const paddingHorizontal = gutter[0] && gutter[0] / 2 || 0;
          const paddingVertical = gutter[1] && gutter[1] / 2 || 0;
          if (paddingHorizontal) {
            result.paddingLeft = `${paddingHorizontal}px`;
            result.paddingRight = `${paddingHorizontal}px`;
          }
          if (paddingVertical) {
            result.paddingTop = `${paddingVertical}px`;
            result.paddingBottom = `${paddingVertical}px`;
          }
        }
        return result;
      });
      const flexStyles = vue.computed(() => flexValue.value ? { flex: flexValue.value } : {});
      const responsiveConfig = vue.computed(() => pick(props, responsiveArray));
      const propSpan = useResponsiveValue(vue.computed(() => __spreadValues({
        val: props.span,
        key: "span"
      }, responsiveConfig.value)));
      const span = useResponsiveState(propSpan, 24, true);
      return {
        visible: vue.computed(() => !!span.value),
        classNames,
        styles: vue.computed(() => __spreadValues(__spreadValues({}, paddingStyles.value), flexStyles.value))
      };
    }
  });
  function _sfc_render$1I(_ctx, _cache, $props, $setup, $data, $options) {
    return _ctx.visible ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass(_ctx.classNames),
      style: vue.normalizeStyle(_ctx.styles)
    }, [
      vue.renderSlot(_ctx.$slots, "default")
    ], 6)) : vue.createCommentVNode("v-if", true);
  }
  var Col = /* @__PURE__ */ _export_sfc(_sfc_main$1J, [["render", _sfc_render$1I]]);
  function resolveItemData(cols, props) {
    var _a, _b;
    const originSpan = (_a = props.span) != null ? _a : 1;
    const originOffset = (_b = props.offset) != null ? _b : 0;
    const offset = Math.min(originOffset, cols);
    const span = Math.min(offset > 0 ? originSpan + originOffset : originSpan, cols);
    return {
      span,
      offset,
      suffix: "suffix" in props ? props.suffix !== false : false
    };
  }
  function setItemVisible({
    cols,
    collapsed,
    collapsedRows,
    itemDataList
  }) {
    let overflow = false;
    let displayIndexList = [];
    function isOverflow(span) {
      return Math.ceil(span / cols) > collapsedRows;
    }
    if (collapsed) {
      let spanSum = 0;
      for (let i = 0; i < itemDataList.length; i++) {
        if (itemDataList[i].suffix) {
          spanSum += itemDataList[i].span;
          displayIndexList.push(i);
        }
      }
      if (!isOverflow(spanSum)) {
        let current = 0;
        while (current < itemDataList.length) {
          const item = itemDataList[current];
          if (!item.suffix) {
            spanSum += item.span;
            if (isOverflow(spanSum)) {
              break;
            }
            displayIndexList.push(current);
          }
          current++;
        }
      }
      overflow = itemDataList.some((item, index2) => !item.suffix && !displayIndexList.includes(index2));
    } else {
      displayIndexList = itemDataList.map((_, index2) => index2);
    }
    return {
      overflow,
      displayIndexList
    };
  }
  const _sfc_main$1I = vue.defineComponent({
    name: "Grid",
    props: {
      cols: {
        type: [Number, Object],
        default: 24
      },
      rowGap: {
        type: [Number, Object],
        default: 0
      },
      colGap: {
        type: [Number, Object],
        default: 0
      },
      collapsed: {
        type: Boolean,
        default: false
      },
      collapsedRows: {
        type: Number,
        default: 1
      }
    },
    setup(props) {
      const {
        cols: propCols,
        rowGap: propRowGap,
        colGap: propColGap,
        collapsedRows,
        collapsed
      } = vue.toRefs(props);
      const cols = useResponsiveState(propCols, 24);
      const colGap = useResponsiveState(propColGap, 0);
      const rowGap = useResponsiveState(propRowGap, 0);
      const prefixCls = getPrefixCls("grid");
      const classNames = vue.computed(() => [prefixCls]);
      const style = vue.computed(() => [
        {
          "gap": `${rowGap.value}px ${colGap.value}px`,
          "grid-template-columns": `repeat(${cols.value}, minmax(0px, 1fr))`
        }
      ]);
      const itemDataMap = vue.reactive(new Map());
      const itemDataList = vue.computed(() => {
        const list = [];
        for (const [index2, itemData] of itemDataMap.entries()) {
          list[index2] = itemData;
        }
        return list;
      });
      const gridContext = vue.reactive({
        overflow: false,
        displayIndexList: [],
        cols: cols.value,
        colGap: colGap.value
      });
      vue.watchEffect(() => {
        gridContext.cols = cols.value;
        gridContext.colGap = colGap.value;
      });
      vue.watchEffect(() => {
        const displayInfo = setItemVisible({
          cols: cols.value,
          collapsed: collapsed.value,
          collapsedRows: collapsedRows.value,
          itemDataList: itemDataList.value
        });
        gridContext.overflow = displayInfo.overflow;
        gridContext.displayIndexList = displayInfo.displayIndexList;
      });
      vue.provide(GridContextInjectionKey, gridContext);
      vue.provide(GridDataCollectorInjectionKey, {
        collectItemData(index2, itemData) {
          itemDataMap.set(index2, itemData);
        },
        removeItemData(index2) {
          itemDataMap.delete(index2);
        }
      });
      return {
        classNames,
        style
      };
    }
  });
  function _sfc_render$1H(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.classNames),
      style: vue.normalizeStyle(_ctx.style)
    }, [
      vue.renderSlot(_ctx.$slots, "default")
    ], 6);
  }
  var _Grid = /* @__PURE__ */ _export_sfc(_sfc_main$1I, [["render", _sfc_render$1H]]);
  const _sfc_main$1H = vue.defineComponent({
    name: "GridItem",
    props: {
      span: {
        type: [Number, Object],
        default: 1
      },
      offset: {
        type: [Number, Object],
        default: 0
      },
      suffix: {
        type: Boolean,
        default: false
      }
    },
    setup(props) {
      const prefixCls = getPrefixCls("grid-item");
      const domRef = vue.ref();
      const { computedIndex } = useIndex({
        itemRef: domRef,
        selector: `.${prefixCls}`
      });
      const gridContext = vue.inject(GridContextInjectionKey, {
        overflow: false,
        displayIndexList: [],
        cols: 24,
        colGap: 0
      });
      const gridDataCollector = vue.inject(GridDataCollectorInjectionKey);
      const visible = vue.computed(() => {
        var _a;
        return (_a = gridContext == null ? void 0 : gridContext.displayIndexList) == null ? void 0 : _a.includes(computedIndex.value);
      });
      const { span: propSpan, offset: propOffset } = vue.toRefs(props);
      const rSpan = useResponsiveState(propSpan, 1);
      const rOffset = useResponsiveState(propOffset, 0);
      const itemData = vue.computed(() => resolveItemData(gridContext.cols, __spreadProps(__spreadValues({}, props), {
        span: rSpan.value,
        offset: rOffset.value
      })));
      const classNames = vue.computed(() => [prefixCls]);
      const offsetStyle = vue.computed(() => {
        const { offset, span } = itemData.value;
        const { colGap } = gridContext;
        if (offset > 0) {
          const oneSpan = `(100% - ${colGap * (span - 1)}px) / ${span}`;
          return {
            "margin-left": `calc((${oneSpan} * ${offset}) + ${colGap * offset}px)`
          };
        }
        return {};
      });
      const columnStart = vue.computed(() => {
        const { suffix, span } = itemData.value;
        const { cols } = gridContext;
        if (suffix) {
          return `${cols - span + 1}`;
        }
        return `span ${span}`;
      });
      const style = vue.computed(() => {
        const { span } = itemData.value;
        if (domRef.value) {
          return [
            {
              "grid-column": `${columnStart.value} / span ${span}`
            },
            offsetStyle.value,
            !visible.value || span === 0 ? { display: "none" } : {}
          ];
        }
        return [];
      });
      vue.watchEffect(() => {
        if (computedIndex.value !== -1) {
          gridDataCollector == null ? void 0 : gridDataCollector.collectItemData(computedIndex.value, itemData.value);
        }
      });
      vue.onUnmounted(() => {
        if (computedIndex.value !== -1) {
          gridDataCollector == null ? void 0 : gridDataCollector.removeItemData(computedIndex.value);
        }
      });
      return {
        classNames,
        style,
        domRef,
        overflow: vue.computed(() => gridContext.overflow)
      };
    }
  });
  function _sfc_render$1G(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      ref: "domRef",
      class: vue.normalizeClass(_ctx.classNames),
      style: vue.normalizeStyle(_ctx.style)
    }, [
      vue.renderSlot(_ctx.$slots, "default", { overflow: _ctx.overflow })
    ], 6);
  }
  var GridItem = /* @__PURE__ */ _export_sfc(_sfc_main$1H, [["render", _sfc_render$1G]]);
  const Grid = Object.assign(_Grid, {
    Row,
    Col,
    Item: GridItem,
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + Row.name, Row);
      app.component(componentPrefix + Col.name, Col);
      app.component(componentPrefix + _Grid.name, _Grid);
      app.component(componentPrefix + GridItem.name, GridItem);
    }
  });
  const _sfc_main$1G = vue.defineComponent({
    name: "Tooltip",
    components: {
      Trigger
    },
    props: {
      popupVisible: {
        type: Boolean,
        default: void 0
      },
      defaultPopupVisible: {
        type: Boolean,
        default: false
      },
      content: String,
      position: {
        type: String,
        default: "top"
      },
      mini: {
        type: Boolean,
        default: false
      },
      backgroundColor: {
        type: String
      },
      contentClass: {
        type: [String, Array, Object]
      },
      contentStyle: {
        type: Object
      },
      arrowClass: {
        type: [String, Array, Object]
      },
      arrowStyle: {
        type: Object
      },
      popupContainer: {
        type: [String, Object]
      }
    },
    emits: {
      "update:popupVisible": (visible) => true,
      "popupVisibleChange": (visible) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("tooltip");
      const _popupVisible = vue.ref(props.defaultPopupVisible);
      const computedPopupVisible = vue.computed(() => {
        var _a;
        return (_a = props.popupVisible) != null ? _a : _popupVisible.value;
      });
      const handlePopupVisibleChange = (visible) => {
        _popupVisible.value = visible;
        emit("update:popupVisible", visible);
        emit("popupVisibleChange", visible);
      };
      const contentCls = vue.computed(() => [
        `${prefixCls}-content`,
        props.contentClass,
        { [`${prefixCls}-mini`]: props.mini }
      ]);
      const computedContentStyle = vue.computed(() => {
        if (props.backgroundColor || props.contentStyle) {
          return __spreadValues({
            backgroundColor: props.backgroundColor
          }, props.contentStyle);
        }
        return void 0;
      });
      const arrowCls = vue.computed(() => [
        `${prefixCls}-popup-arrow`,
        props.arrowClass
      ]);
      const computedArrowStyle = vue.computed(() => {
        if (props.backgroundColor || props.arrowStyle) {
          return __spreadValues({
            backgroundColor: props.backgroundColor
          }, props.arrowStyle);
        }
        return void 0;
      });
      return {
        prefixCls,
        computedPopupVisible,
        contentCls,
        computedContentStyle,
        arrowCls,
        computedArrowStyle,
        handlePopupVisibleChange
      };
    }
  });
  function _sfc_render$1F(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Trigger = vue.resolveComponent("Trigger");
    return vue.openBlock(), vue.createBlock(_component_Trigger, {
      class: vue.normalizeClass(_ctx.prefixCls),
      trigger: "hover",
      position: _ctx.position,
      "popup-visible": _ctx.computedPopupVisible,
      "popup-offset": 10,
      "show-arrow": "",
      "content-class": _ctx.contentCls,
      "content-style": _ctx.computedContentStyle,
      "arrow-class": _ctx.arrowCls,
      "arrow-style": _ctx.computedArrowStyle,
      "popup-container": _ctx.popupContainer,
      "animation-name": "zoom-in-fade-out",
      "auto-fit-transform-origin": "",
      role: "tooltip",
      onPopupVisibleChange: _ctx.handlePopupVisibleChange
    }, {
      content: vue.withCtx(() => [
        vue.renderSlot(_ctx.$slots, "content", {}, () => [
          vue.createTextVNode(vue.toDisplayString(_ctx.content), 1)
        ])
      ]),
      default: vue.withCtx(() => [
        vue.renderSlot(_ctx.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "position", "popup-visible", "content-class", "content-style", "arrow-class", "arrow-style", "popup-container", "onPopupVisibleChange"]);
  }
  var _Tooltip = /* @__PURE__ */ _export_sfc(_sfc_main$1G, [["render", _sfc_render$1F]]);
  const Tooltip = Object.assign(_Tooltip, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Tooltip.name, _Tooltip);
    }
  });
  const _sfc_main$1F = vue.defineComponent({
    name: "IconQuestionCircle",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-question-circle`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$K = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$C = /* @__PURE__ */ vue.createElementVNode("path", { d: "M42 24c0 9.941-8.059 18-18 18S6 33.941 6 24 14.059 6 24 6s18 8.059 18 18Z" }, null, -1);
  const _hoisted_3$z = /* @__PURE__ */ vue.createElementVNode("path", { d: "M24.006 31v4.008m0-6.008L24 28c0-3 3-4 4.78-6.402C30.558 19.195 28.288 15 23.987 15c-4.014 0-5.382 2.548-5.388 4.514v.465" }, null, -1);
  const _hoisted_4$b = [
    _hoisted_2$C,
    _hoisted_3$z
  ];
  function _sfc_render$1E(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_4$b, 14, _hoisted_1$K);
  }
  var _IconQuestionCircle = /* @__PURE__ */ _export_sfc(_sfc_main$1F, [["render", _sfc_render$1E]]);
  const IconQuestionCircle = Object.assign(_IconQuestionCircle, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconQuestionCircle.name, _IconQuestionCircle);
    }
  });
  const _sfc_main$1E = vue.defineComponent({
    name: "FormItemLabel",
    components: {
      ResizeObserver,
      Tooltip,
      IconQuestionCircle
    },
    props: {
      required: {
        type: Boolean,
        default: false
      },
      showColon: {
        type: Boolean,
        default: false
      },
      component: {
        type: String,
        default: "label"
      },
      asteriskPosition: {
        type: String,
        default: "start"
      },
      tooltip: {
        type: String
      },
      attrs: Object
    },
    setup() {
      const prefixCls = getPrefixCls("form-item-label");
      const formCtx = vue.inject(formInjectionKey, void 0);
      const instance = vue.getCurrentInstance();
      const labelRef = vue.ref();
      const handleResize = () => {
        if (labelRef.value && isNumber$1(labelRef.value.offsetWidth)) {
          formCtx == null ? void 0 : formCtx.setLabelWidth(labelRef.value.offsetWidth, instance == null ? void 0 : instance.uid);
        }
      };
      vue.onMounted(() => {
        if (labelRef.value && isNumber$1(labelRef.value.offsetWidth)) {
          formCtx == null ? void 0 : formCtx.setLabelWidth(labelRef.value.offsetWidth, instance == null ? void 0 : instance.uid);
        }
      });
      vue.onBeforeUnmount(() => {
        formCtx == null ? void 0 : formCtx.removeLabelWidth(instance == null ? void 0 : instance.uid);
      });
      return {
        prefixCls,
        labelRef,
        handleResize
      };
    }
  });
  const _hoisted_1$J = /* @__PURE__ */ vue.createElementVNode("svg", {
    fill: "currentColor",
    viewBox: "0 0 1024 1024",
    width: "1em",
    height: "1em"
  }, [
    /* @__PURE__ */ vue.createElementVNode("path", { d: "M583.338667 17.066667c18.773333 0 34.133333 15.36 34.133333 34.133333v349.013333l313.344-101.888a34.133333 34.133333 0 0 1 43.008 22.016l42.154667 129.706667a34.133333 34.133333 0 0 1-21.845334 43.178667l-315.733333 102.4 208.896 287.744a34.133333 34.133333 0 0 1-7.509333 47.786666l-110.421334 80.213334a34.133333 34.133333 0 0 1-47.786666-7.509334L505.685333 706.218667 288.426667 1005.226667a34.133333 34.133333 0 0 1-47.786667 7.509333l-110.421333-80.213333a34.133333 34.133333 0 0 1-7.509334-47.786667l214.186667-295.253333L29.013333 489.813333a34.133333 34.133333 0 0 1-22.016-43.008l42.154667-129.877333a34.133333 34.133333 0 0 1 43.008-22.016l320.512 104.106667L412.672 51.2c0-18.773333 15.36-34.133333 34.133333-34.133333h136.533334z" })
  ], -1);
  const _hoisted_2$B = [
    _hoisted_1$J
  ];
  const _hoisted_3$y = /* @__PURE__ */ vue.createElementVNode("svg", {
    fill: "currentColor",
    viewBox: "0 0 1024 1024",
    width: "1em",
    height: "1em"
  }, [
    /* @__PURE__ */ vue.createElementVNode("path", { d: "M583.338667 17.066667c18.773333 0 34.133333 15.36 34.133333 34.133333v349.013333l313.344-101.888a34.133333 34.133333 0 0 1 43.008 22.016l42.154667 129.706667a34.133333 34.133333 0 0 1-21.845334 43.178667l-315.733333 102.4 208.896 287.744a34.133333 34.133333 0 0 1-7.509333 47.786666l-110.421334 80.213334a34.133333 34.133333 0 0 1-47.786666-7.509334L505.685333 706.218667 288.426667 1005.226667a34.133333 34.133333 0 0 1-47.786667 7.509333l-110.421333-80.213333a34.133333 34.133333 0 0 1-7.509334-47.786667l214.186667-295.253333L29.013333 489.813333a34.133333 34.133333 0 0 1-22.016-43.008l42.154667-129.877333a34.133333 34.133333 0 0 1 43.008-22.016l320.512 104.106667L412.672 51.2c0-18.773333 15.36-34.133333 34.133333-34.133333h136.533334z" })
  ], -1);
  const _hoisted_4$a = [
    _hoisted_3$y
  ];
  function _sfc_render$1D(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_icon_question_circle = vue.resolveComponent("icon-question-circle");
    const _component_Tooltip = vue.resolveComponent("Tooltip");
    const _component_ResizeObserver = vue.resolveComponent("ResizeObserver");
    return vue.openBlock(), vue.createBlock(_component_ResizeObserver, { onResize: _ctx.handleResize }, {
      default: vue.withCtx(() => [
        (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.component), vue.mergeProps({
          ref: "labelRef",
          class: _ctx.prefixCls
        }, _ctx.attrs), {
          default: vue.withCtx(() => [
            _ctx.required && _ctx.asteriskPosition === "start" ? (vue.openBlock(), vue.createElementBlock("strong", {
              key: 0,
              class: vue.normalizeClass(`${_ctx.prefixCls}-required-symbol`)
            }, _hoisted_2$B, 2)) : vue.createCommentVNode("v-if", true),
            vue.renderSlot(_ctx.$slots, "default"),
            _ctx.tooltip ? (vue.openBlock(), vue.createBlock(_component_Tooltip, {
              key: 1,
              content: _ctx.tooltip
            }, {
              default: vue.withCtx(() => [
                vue.createVNode(_component_icon_question_circle, {
                  class: vue.normalizeClass(`${_ctx.prefixCls}-tooltip`)
                }, null, 8, ["class"])
              ]),
              _: 1
            }, 8, ["content"])) : vue.createCommentVNode("v-if", true),
            _ctx.required && _ctx.asteriskPosition === "end" ? (vue.openBlock(), vue.createElementBlock("strong", {
              key: 2,
              class: vue.normalizeClass(`${_ctx.prefixCls}-required-symbol`)
            }, _hoisted_4$a, 2)) : vue.createCommentVNode("v-if", true),
            vue.createTextVNode(" " + vue.toDisplayString(_ctx.showColon ? ":" : ""), 1)
          ]),
          _: 3
        }, 16, ["class"]))
      ]),
      _: 3
    }, 8, ["onResize"]);
  }
  var FormItemLabel = /* @__PURE__ */ _export_sfc(_sfc_main$1E, [["render", _sfc_render$1D]]);
  const _sfc_main$1D = vue.defineComponent({
    name: "FormItemMessage",
    props: {
      error: Array,
      help: String
    },
    setup() {
      const prefixCls = getPrefixCls("form-item-message");
      return {
        prefixCls
      };
    }
  });
  function _sfc_render$1C(_ctx, _cache, $props, $setup, $data, $options) {
    return _ctx.help || _ctx.$slots.help ? (vue.openBlock(), vue.createBlock(vue.Transition, {
      key: 0,
      name: "form-blink",
      appear: ""
    }, {
      default: vue.withCtx(() => [
        vue.createElementVNode("div", {
          class: vue.normalizeClass([_ctx.prefixCls, `${_ctx.prefixCls}-help`])
        }, [
          vue.renderSlot(_ctx.$slots, "help", {}, () => [
            vue.createTextVNode(vue.toDisplayString(_ctx.help), 1)
          ])
        ], 2)
      ]),
      _: 3
    })) : (vue.openBlock(true), vue.createElementBlock(vue.Fragment, { key: 1 }, vue.renderList(_ctx.error, (item) => {
      return vue.openBlock(), vue.createBlock(vue.Transition, {
        key: item,
        name: "form-blink",
        appear: ""
      }, {
        default: vue.withCtx(() => [
          vue.createElementVNode("div", {
            role: "alert",
            class: vue.normalizeClass([_ctx.prefixCls])
          }, vue.toDisplayString(item), 3)
        ]),
        _: 2
      }, 1024);
    }), 128));
  }
  var FormItemMessage = /* @__PURE__ */ _export_sfc(_sfc_main$1D, [["render", _sfc_render$1C]]);
  const VALIDATE_STATUSES = [
    "success",
    "warning",
    "error",
    "validating"
  ];
  const getFinalValidateStatus = (validateStatus) => {
    let status = "";
    for (const key of Object.keys(validateStatus)) {
      const _status = validateStatus[key];
      if (_status) {
        if (!status || VALIDATE_STATUSES.indexOf(_status) > VALIDATE_STATUSES.indexOf(status)) {
          status = validateStatus[key];
        }
      }
    }
    return status;
  };
  const getFinalValidateMessage = (validateMessage) => {
    const messages = [];
    for (const key of Object.keys(validateMessage)) {
      const _message = validateMessage[key];
      if (_message) {
        messages.push(_message);
      }
    }
    return messages;
  };
  const _sfc_main$1C = vue.defineComponent({
    name: "FormItem",
    components: {
      ArcoRow: Row,
      ArcoCol: Col,
      FormItemLabel,
      FormItemMessage
    },
    props: {
      field: {
        type: String,
        default: ""
      },
      label: String,
      tooltip: {
        type: String
      },
      showColon: {
        type: Boolean,
        default: false
      },
      noStyle: {
        type: Boolean,
        default: false
      },
      disabled: {
        type: Boolean,
        default: void 0
      },
      help: String,
      extra: String,
      required: {
        type: Boolean,
        default: false
      },
      asteriskPosition: {
        type: String,
        default: "start"
      },
      rules: {
        type: [Object, Array]
      },
      validateStatus: {
        type: String
      },
      validateTrigger: {
        type: [String, Array],
        default: "change"
      },
      labelColProps: Object,
      wrapperColProps: Object,
      hideLabel: {
        type: Boolean,
        default: false
      },
      hideAsterisk: {
        type: Boolean,
        default: false
      },
      labelColStyle: Object,
      wrapperColStyle: Object,
      rowProps: Object,
      rowClass: [String, Array, Object],
      contentClass: [String, Array, Object],
      contentFlex: {
        type: Boolean,
        default: true
      },
      mergeProps: {
        type: [Boolean, Function],
        default: true
      },
      labelColFlex: {
        type: [Number, String]
      },
      feedback: {
        type: Boolean,
        default: false
      },
      labelComponent: {
        type: String,
        default: "label"
      },
      labelAttrs: Object
    },
    setup(props) {
      const prefixCls = getPrefixCls("form-item");
      const { field } = vue.toRefs(props);
      const formCtx = vue.inject(formInjectionKey, {});
      const { autoLabelWidth, layout } = vue.toRefs(formCtx);
      const { i18nMessage } = useI18n();
      const mergedLabelCol = vue.computed(() => {
        var _a;
        const colProps = __spreadValues({}, (_a = props.labelColProps) != null ? _a : formCtx.labelColProps);
        if (props.labelColFlex) {
          colProps.flex = props.labelColFlex;
        } else if (formCtx.autoLabelWidth) {
          colProps.flex = `${formCtx.maxLabelWidth}px`;
        }
        return colProps;
      });
      const mergedWrapperCol = vue.computed(() => {
        var _a;
        const colProps = __spreadValues({}, (_a = props.wrapperColProps) != null ? _a : formCtx.wrapperColProps);
        if (props.labelColFlex || formCtx.autoLabelWidth) {
          colProps.flex = "auto";
        }
        return colProps;
      });
      const mergedLabelStyle = vue.computed(() => {
        var _a;
        return (_a = props.labelColStyle) != null ? _a : formCtx.labelColStyle;
      });
      const mergedWrapperStyle = vue.computed(() => {
        var _a;
        return (_a = props.wrapperColStyle) != null ? _a : formCtx.wrapperColStyle;
      });
      const initialValue = getValueByPath(formCtx.model, props.field);
      const validateStatus = vue.reactive({});
      const validateMessage = vue.reactive({});
      const finalStatus = vue.computed(() => getFinalValidateStatus(validateStatus));
      const finalMessage = vue.computed(() => getFinalValidateMessage(validateMessage));
      const validateDisabled = vue.ref(false);
      const fieldValue = vue.computed(() => getValueByPath(formCtx.model, props.field));
      const computedDisabled = vue.computed(() => {
        var _a;
        return Boolean((_a = props.disabled) != null ? _a : formCtx == null ? void 0 : formCtx.disabled);
      });
      const computedValidateStatus = vue.computed(() => {
        var _a;
        return (_a = props.validateStatus) != null ? _a : finalStatus.value;
      });
      const isError = vue.computed(() => computedValidateStatus.value === "error");
      const mergedRules = vue.computed(() => {
        var _a, _b, _c;
        const baseRules = [].concat((_c = (_b = props.rules) != null ? _b : (_a = formCtx == null ? void 0 : formCtx.rules) == null ? void 0 : _a[props.field]) != null ? _c : []);
        const hasRequiredRule = baseRules.some((item) => item.required);
        if (props.required && !hasRequiredRule) {
          return [{ required: true }].concat(baseRules);
        }
        return baseRules;
      });
      const isRequired = vue.computed(() => mergedRules.value.some((item) => item.required));
      const formItemCtx = props.noStyle ? vue.inject(formItemInjectionKey, void 0) : void 0;
      const updateValidateState = (field2, { status, message: message2 }) => {
        validateStatus[field2] = status;
        validateMessage[field2] = message2;
        if (props.noStyle) {
          formItemCtx == null ? void 0 : formItemCtx.updateValidateState(field2, { status, message: message2 });
        }
      };
      const computedFeedback = vue.computed(() => props.feedback && computedValidateStatus.value ? computedValidateStatus.value : void 0);
      const validateField = () => {
        var _b;
        if (validateDisabled.value) {
          return Promise.resolve();
        }
        const rules = mergedRules.value;
        if (!field.value || rules.length === 0) {
          if (finalStatus.value) {
            clearValidate();
          }
          return Promise.resolve();
        }
        const _field = field.value;
        const _value = fieldValue.value;
        updateValidateState(_field, {
          status: "",
          message: ""
        });
        const schema = new Schema({
          [_field]: rules.map((_a) => {
            var rule = __objRest(_a, []);
            if (!rule.type && !rule.validator) {
              rule.type = "string";
            }
            return rule;
          })
        }, {
          ignoreEmptyString: true,
          validateMessages: (_b = i18nMessage.value.form) == null ? void 0 : _b.validateMessages
        });
        return new Promise((resolve) => {
          schema.validate({ [_field]: _value }, (err) => {
            var _a;
            const isError2 = Boolean(err == null ? void 0 : err[_field]);
            updateValidateState(_field, {
              status: isError2 ? "error" : "",
              message: (_a = err == null ? void 0 : err[_field].message) != null ? _a : ""
            });
            const error = isError2 ? {
              label: props.label,
              field: field.value,
              value: err[_field].value,
              type: err[_field].type,
              isRequiredError: Boolean(err[_field].requiredError),
              message: err[_field].message
            } : void 0;
            resolve(error);
          });
        });
      };
      const validateTriggers = vue.computed(() => [].concat(props.validateTrigger));
      const eventHandlers = vue.computed(() => validateTriggers.value.reduce((event, trigger) => {
        switch (trigger) {
          case "change":
            event.onChange = () => {
              validateField();
            };
            return event;
          case "input":
            event.onInput = () => {
              vue.nextTick(() => {
                validateField();
              });
            };
            return event;
          case "focus":
            event.onFocus = () => {
              validateField();
            };
            return event;
          case "blur":
            event.onBlur = () => {
              validateField();
            };
            return event;
          default:
            return event;
        }
      }, {}));
      vue.provide(formItemInjectionKey, vue.reactive({
        eventHandlers,
        size: formCtx && vue.toRef(formCtx, "size"),
        disabled: computedDisabled,
        error: isError,
        feedback: computedFeedback,
        updateValidateState
      }));
      const clearValidate = () => {
        if (field.value) {
          updateValidateState(field.value, {
            status: "",
            message: ""
          });
        }
      };
      const setField = (data) => {
        var _a, _b;
        if (field.value) {
          validateDisabled.value = true;
          if ("value" in data && (formCtx == null ? void 0 : formCtx.model) && field.value) {
            setValueByPath(formCtx.model, field.value, data.value);
          }
          if (data.status || data.message) {
            updateValidateState(field.value, {
              status: (_a = data.status) != null ? _a : "",
              message: (_b = data.message) != null ? _b : ""
            });
          }
          vue.nextTick(() => {
            validateDisabled.value = false;
          });
        }
      };
      const resetField = () => {
        clearValidate();
        validateDisabled.value = true;
        if ((formCtx == null ? void 0 : formCtx.model) && field.value) {
          setValueByPath(formCtx.model, field.value, initialValue);
        }
        vue.nextTick(() => {
          validateDisabled.value = false;
        });
      };
      const formItemInfo = vue.reactive({
        field,
        disabled: computedDisabled,
        error: isError,
        validate: validateField,
        clearValidate,
        resetField,
        setField
      });
      vue.onMounted(() => {
        var _a;
        if (formItemInfo.field) {
          (_a = formCtx.addField) == null ? void 0 : _a.call(formCtx, formItemInfo);
        }
      });
      vue.onBeforeUnmount(() => {
        var _a;
        if (formItemInfo.field) {
          (_a = formCtx.removeField) == null ? void 0 : _a.call(formCtx, formItemInfo);
        }
      });
      const cls = vue.computed(() => [
        prefixCls,
        `${prefixCls}-layout-${formCtx.layout}`,
        {
          [`${prefixCls}-error`]: isError.value,
          [`${prefixCls}-status-${computedValidateStatus.value}`]: Boolean(computedValidateStatus.value)
        },
        props.rowClass
      ]);
      const labelColCls = vue.computed(() => [
        `${prefixCls}-label-col`,
        {
          [`${prefixCls}-label-col-left`]: formCtx.labelAlign === "left",
          [`${prefixCls}-label-col-flex`]: formCtx.autoLabelWidth || props.labelColFlex
        }
      ]);
      const wrapperColCls = vue.computed(() => [
        `${prefixCls}-wrapper-col`,
        {
          [`${prefixCls}-wrapper-col-flex`]: !mergedWrapperCol.value
        }
      ]);
      return {
        prefixCls,
        cls,
        isRequired,
        isError,
        finalMessage,
        mergedLabelCol,
        mergedWrapperCol,
        labelColCls,
        autoLabelWidth,
        layout,
        mergedLabelStyle,
        wrapperColCls,
        mergedWrapperStyle
      };
    }
  });
  function _sfc_render$1B(_ctx, _cache, $props, $setup, $data, $options) {
    var _a;
    const _component_FormItemLabel = vue.resolveComponent("FormItemLabel");
    const _component_ArcoCol = vue.resolveComponent("ArcoCol");
    const _component_FormItemMessage = vue.resolveComponent("FormItemMessage");
    const _component_ArcoRow = vue.resolveComponent("ArcoRow");
    return _ctx.noStyle ? vue.renderSlot(_ctx.$slots, "default", { key: 0 }) : (vue.openBlock(), vue.createBlock(_component_ArcoRow, vue.mergeProps({
      key: 1,
      class: [
        _ctx.cls,
        {
          [`${_ctx.prefixCls}-has-help`]: Boolean((_a = _ctx.$slots.help) != null ? _a : _ctx.help)
        }
      ],
      wrap: !(_ctx.labelColFlex || _ctx.autoLabelWidth),
      div: _ctx.layout !== "horizontal" || _ctx.hideLabel
    }, _ctx.rowProps), {
      default: vue.withCtx(() => [
        !_ctx.hideLabel ? (vue.openBlock(), vue.createBlock(_component_ArcoCol, vue.mergeProps({
          key: 0,
          class: _ctx.labelColCls,
          style: _ctx.mergedLabelStyle
        }, _ctx.mergedLabelCol), {
          default: vue.withCtx(() => [
            vue.createVNode(_component_FormItemLabel, {
              required: _ctx.hideAsterisk ? false : _ctx.isRequired,
              "show-colon": _ctx.showColon,
              "asterisk-position": _ctx.asteriskPosition,
              component: _ctx.labelComponent,
              attrs: _ctx.labelAttrs,
              tooltip: _ctx.tooltip
            }, {
              default: vue.withCtx(() => [
                _ctx.$slots.label || _ctx.label ? vue.renderSlot(_ctx.$slots, "label", { key: 0 }, () => [
                  vue.createTextVNode(vue.toDisplayString(_ctx.label), 1)
                ]) : vue.createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 8, ["required", "show-colon", "asterisk-position", "component", "attrs", "tooltip"])
          ]),
          _: 3
        }, 16, ["class", "style"])) : vue.createCommentVNode("v-if", true),
        vue.createVNode(_component_ArcoCol, vue.mergeProps({
          class: _ctx.wrapperColCls,
          style: _ctx.mergedWrapperStyle
        }, _ctx.mergedWrapperCol), {
          default: vue.withCtx(() => [
            vue.createElementVNode("div", {
              class: vue.normalizeClass(`${_ctx.prefixCls}-content-wrapper`)
            }, [
              vue.createElementVNode("div", {
                class: vue.normalizeClass([
                  `${_ctx.prefixCls}-content`,
                  {
                    [`${_ctx.prefixCls}-content-flex`]: _ctx.contentFlex
                  },
                  _ctx.contentClass
                ])
              }, [
                vue.renderSlot(_ctx.$slots, "default")
              ], 2)
            ], 2),
            _ctx.isError || _ctx.$slots.help || _ctx.help ? (vue.openBlock(), vue.createBlock(_component_FormItemMessage, {
              key: 0,
              error: _ctx.finalMessage,
              help: _ctx.help
            }, vue.createSlots({ _: 2 }, [
              _ctx.$slots.help ? {
                name: "help",
                fn: vue.withCtx(() => [
                  vue.renderSlot(_ctx.$slots, "help")
                ])
              } : void 0
            ]), 1032, ["error", "help"])) : vue.createCommentVNode("v-if", true),
            _ctx.$slots.extra || _ctx.extra ? (vue.openBlock(), vue.createElementBlock("div", {
              key: 1,
              class: vue.normalizeClass(`${_ctx.prefixCls}-extra`)
            }, [
              vue.renderSlot(_ctx.$slots, "extra", {}, () => [
                vue.createTextVNode(vue.toDisplayString(_ctx.extra), 1)
              ])
            ], 2)) : vue.createCommentVNode("v-if", true)
          ]),
          _: 3
        }, 16, ["class", "style"])
      ]),
      _: 3
    }, 16, ["class", "wrap", "div"]));
  }
  var FormItem = /* @__PURE__ */ _export_sfc(_sfc_main$1C, [["render", _sfc_render$1B]]);
  const Form = Object.assign(_Form, {
    Item: FormItem,
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Form.name, _Form);
      app.component(componentPrefix + FormItem.name, FormItem);
    }
  });
  const _sfc_main$1B = vue.defineComponent({
    name: "Icon",
    props: {
      type: String,
      size: [Number, String],
      rotate: Number,
      spin: Boolean
    },
    setup(props) {
      const prefixCls = getPrefixCls("icon");
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const cls = vue.computed(() => [
        prefixCls,
        {
          [`${prefixCls}-loading`]: props.spin
        },
        props.type
      ]);
      return {
        cls,
        innerStyle
      };
    }
  });
  function _sfc_render$1A(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      fill: "currentColor"
    }, [
      vue.renderSlot(_ctx.$slots, "default")
    ], 6);
  }
  var _Icon = /* @__PURE__ */ _export_sfc(_sfc_main$1B, [["render", _sfc_render$1A]]);
  function _isSlot$c(s) {
    return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !vue.isVNode(s);
  }
  const scriptUrlCache = [];
  const addFromIconFontCn = (options) => {
    const {
      src,
      extraProps = {}
    } = options;
    if (!isServerRendering && (src == null ? void 0 : src.length) && !scriptUrlCache.includes(src)) {
      const script = document.createElement("script");
      script.setAttribute("src", src);
      script.setAttribute("data-namespace", src);
      scriptUrlCache.push(src);
      document.body.appendChild(script);
    }
    return vue.defineComponent({
      name: "IconFont",
      props: {
        type: String,
        size: [Number, String],
        rotate: Number,
        spin: Boolean
      },
      setup(props, {
        slots
      }) {
        return () => {
          var _a;
          const children = props.type ? vue.createVNode("use", {
            "xlink:href": `#${props.type}`
          }, null) : (_a = slots.default) == null ? void 0 : _a.call(slots);
          return vue.createVNode(_Icon, vue.mergeProps(props, extraProps), _isSlot$c(children) ? children : {
            default: () => [children]
          });
        };
      }
    });
  };
  const Icon = Object.assign(_Icon, {
    addFromIconFontCn,
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Icon.name, _Icon);
    }
  });
  const _sfc_main$1A = vue.defineComponent({
    name: "ImageFooter",
    props: {
      title: {
        type: String
      },
      description: {
        type: String
      }
    },
    setup() {
      const prefixCls = getPrefixCls("image-footer");
      return {
        prefixCls
      };
    }
  });
  const _hoisted_1$I = ["title"];
  const _hoisted_2$A = ["title"];
  function _sfc_render$1z(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.prefixCls)
    }, [
      _ctx.title || _ctx.description ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: vue.normalizeClass(`${_ctx.prefixCls}-caption`)
      }, [
        _ctx.title ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 0,
          class: vue.normalizeClass(`${_ctx.prefixCls}-caption-title`),
          title: _ctx.title
        }, vue.toDisplayString(_ctx.title), 11, _hoisted_1$I)) : vue.createCommentVNode("v-if", true),
        _ctx.description ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 1,
          class: vue.normalizeClass(`${_ctx.prefixCls}-caption-description`),
          title: _ctx.description
        }, vue.toDisplayString(_ctx.description), 11, _hoisted_2$A)) : vue.createCommentVNode("v-if", true)
      ], 2)) : vue.createCommentVNode("v-if", true),
      _ctx.$slots.extra ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 1,
        class: vue.normalizeClass(`${_ctx.prefixCls}-extra`)
      }, [
        vue.renderSlot(_ctx.$slots, "extra")
      ], 2)) : vue.createCommentVNode("v-if", true)
    ], 2);
  }
  var ImageFooter = /* @__PURE__ */ _export_sfc(_sfc_main$1A, [["render", _sfc_render$1z]]);
  const _sfc_main$1z = vue.defineComponent({
    name: "ImagePreviewArrow",
    components: {
      IconLeft,
      IconRight
    },
    props: {
      onPrev: {
        type: Function
      },
      onNext: {
        type: Function
      }
    },
    setup() {
      const prefixCls = getPrefixCls("image-preview-arrow");
      return {
        prefixCls
      };
    }
  });
  function _sfc_render$1y(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_icon_left = vue.resolveComponent("icon-left");
    const _component_icon_right = vue.resolveComponent("icon-right");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.prefixCls)
    }, [
      vue.createElementVNode("div", {
        class: vue.normalizeClass([
          `${_ctx.prefixCls}-left`,
          {
            [`${_ctx.prefixCls}-disabled`]: !_ctx.onPrev
          }
        ]),
        onClick: _cache[0] || (_cache[0] = (e2) => {
          e2.preventDefault();
          _ctx.onPrev && _ctx.onPrev();
        })
      }, [
        vue.createVNode(_component_icon_left)
      ], 2),
      vue.createElementVNode("div", {
        class: vue.normalizeClass([
          `${_ctx.prefixCls}-right`,
          {
            [`${_ctx.prefixCls}-disabled`]: !_ctx.onNext
          }
        ]),
        onClick: _cache[1] || (_cache[1] = (e2) => {
          e2.preventDefault();
          _ctx.onNext && _ctx.onNext();
        })
      }, [
        vue.createVNode(_component_icon_right)
      ], 2)
    ], 2);
  }
  var PreviewArrow = /* @__PURE__ */ _export_sfc(_sfc_main$1z, [["render", _sfc_render$1y]]);
  function _isSlot$b(s) {
    return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !vue.isVNode(s);
  }
  var ImagePreviewAction = vue.defineComponent({
    name: "ImagePreviewAction",
    components: {
      Tooltip
    },
    inheritAttrs: false,
    props: {
      name: {
        type: String
      },
      disabled: {
        type: Boolean
      }
    },
    setup(props, {
      slots,
      attrs
    }) {
      const prefixCls = getPrefixCls("image-preview-toolbar-action");
      return () => {
        var _a;
        const {
          name,
          disabled
        } = props;
        const children = (_a = slots.default) == null ? void 0 : _a.call(slots);
        if (!children || !children.length)
          return null;
        const content = vue.createVNode("div", vue.mergeProps({
          "class": [`${prefixCls}`, {
            [`${prefixCls}-disabled`]: disabled
          }],
          "onMousedown": (e2) => {
            e2.preventDefault();
          }
        }, attrs), [vue.createVNode("span", {
          "class": `${prefixCls}-content`
        }, [children])]);
        return name ? vue.createVNode(Tooltip, {
          "class": `${prefixCls}-tooltip`,
          "content": name
        }, _isSlot$b(content) ? content : {
          default: () => [content]
        }) : content;
      };
    }
  });
  var _sfc_main$1y = vue.defineComponent({
    name: "ImagePreviewToolbar",
    components: {
      RenderFunction,
      PreviewAction: ImagePreviewAction
    },
    props: {
      actions: {
        type: Array,
        default: () => []
      },
      actionsLayout: {
        type: Array,
        default: () => []
      }
    },
    setup(props) {
      const {
        actions,
        actionsLayout
      } = vue.toRefs(props);
      const prefixCls = getPrefixCls("image-preview-toolbar");
      const resultActions = vue.computed(() => {
        const actionsLayoutSet = new Set(actionsLayout.value);
        const filterWithLayout = (item) => actionsLayoutSet.has(item.key);
        const filteredActions = actions.value.filter(filterWithLayout);
        return filteredActions.sort((pre, cur) => {
          const preIndex = actionsLayout.value.indexOf(pre.key);
          const curIndex = actionsLayout.value.indexOf(cur.key);
          return preIndex > curIndex ? 1 : -1;
        });
      });
      return {
        prefixCls,
        resultActions
      };
    }
  });
  function _sfc_render$1x(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_RenderFunction = vue.resolveComponent("RenderFunction");
    const _component_PreviewAction = vue.resolveComponent("PreviewAction");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.prefixCls)
    }, [
      (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.resultActions, (action) => {
        return vue.openBlock(), vue.createBlock(_component_PreviewAction, {
          key: action.key,
          name: action.name,
          disabled: action.disabled,
          onClick: action.onClick
        }, {
          default: vue.withCtx(() => [
            vue.createVNode(_component_RenderFunction, {
              "render-func": action.content
            }, null, 8, ["render-func"])
          ]),
          _: 2
        }, 1032, ["name", "disabled", "onClick"]);
      }), 128)),
      vue.renderSlot(_ctx.$slots, "default")
    ], 2);
  }
  var PreviewToolbar = /* @__PURE__ */ _export_sfc(_sfc_main$1y, [["render", _sfc_render$1x]]);
  function useImageLoadStatus(defaultValue) {
    const status = vue.ref(defaultValue || "beforeLoad");
    const isBeforeLoad = vue.computed(() => status.value === "beforeLoad");
    const isLoading = vue.computed(() => status.value === "loading");
    const isError = vue.computed(() => status.value === "error");
    const isLoaded = vue.computed(() => status.value === "loaded");
    return {
      status,
      isBeforeLoad,
      isLoading,
      isError,
      isLoaded,
      setLoadStatus: (newStatus) => {
        status.value = newStatus;
      }
    };
  }
  function getFixTranslate(wrapperRect, imgRect, translateX, translateY, scale) {
    let fixTranslateX = translateX;
    let fixTranslateY = translateY;
    if (translateX) {
      if (wrapperRect.width > imgRect.width) {
        fixTranslateX = 0;
      } else {
        if (imgRect.left > wrapperRect.left) {
          fixTranslateX -= Math.abs(wrapperRect.left - imgRect.left) / scale;
        }
        if (imgRect.right < wrapperRect.right) {
          fixTranslateX += Math.abs(wrapperRect.right - imgRect.right) / scale;
        }
      }
    }
    if (translateY) {
      if (wrapperRect.height > imgRect.height) {
        fixTranslateY = 0;
      } else {
        if (imgRect.top > wrapperRect.top) {
          fixTranslateY -= Math.abs(wrapperRect.top - imgRect.top) / scale;
        }
        if (imgRect.bottom < wrapperRect.bottom) {
          fixTranslateY += Math.abs(wrapperRect.bottom - imgRect.bottom) / scale;
        }
      }
    }
    return [fixTranslateX, fixTranslateY];
  }
  function useImageDrag(props) {
    const { wrapperEl, imageEl, scale } = vue.toRefs(props);
    const translate = vue.ref([0, 0]);
    const moving = vue.ref(false);
    let startPageX = 0;
    let startPageY = 0;
    let startTranslate = [0, 0];
    const checkAndFixTranslate = () => {
      if (!wrapperEl.value || !imageEl.value)
        return;
      const wrapperRect = wrapperEl.value.getBoundingClientRect();
      const imgRect = imageEl.value.getBoundingClientRect();
      const [x, y] = getFixTranslate(wrapperRect, imgRect, translate.value[0], translate.value[1], scale.value);
      if (x !== translate.value[0] || y !== translate.value[1]) {
        translate.value = [x, y];
      }
    };
    const onMoving = (e2) => {
      e2.preventDefault && e2.preventDefault();
      const nextX = startTranslate[0] + (e2.pageX - startPageX) / scale.value;
      const nextY = startTranslate[1] + (e2.pageY - startPageY) / scale.value;
      translate.value = [nextX, nextY];
    };
    const onMoveEnd = (e2) => {
      e2.preventDefault && e2.preventDefault();
      moving.value = false;
      checkAndFixTranslate();
      offEvents();
    };
    const onMoveStart = (e2) => {
      if (e2.target !== e2.currentTarget)
        return;
      e2.preventDefault && e2.preventDefault();
      moving.value = true;
      startPageX = e2.pageX;
      startPageY = e2.pageY;
      startTranslate = [...translate.value];
      on(window, "mousemove", onMoving, false);
      on(window, "mouseup", onMoveEnd, false);
    };
    function offEvents() {
      off(window, "mousemove", onMoving, false);
      off(window, "mouseup", onMoveEnd, false);
    }
    vue.watchEffect((onInvalidate) => {
      imageEl.value && on(imageEl.value, "mousedown", onMoveStart);
      onInvalidate(() => {
        imageEl.value && off(imageEl.value, "mousedown", onMoveStart);
        offEvents();
      });
    });
    vue.watch([scale], () => {
      vue.nextTick(() => checkAndFixTranslate());
    });
    return {
      translate,
      moving,
      resetTranslate() {
        translate.value = [0, 0];
      }
    };
  }
  const _sfc_main$1x = vue.defineComponent({
    name: "IconZoomOut",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-zoom-out`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$H = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$z = /* @__PURE__ */ vue.createElementVNode("path", { d: "M32.607 32.607A14.953 14.953 0 0 0 37 22c0-8.284-6.716-15-15-15-8.284 0-15 6.716-15 15 0 8.284 6.716 15 15 15 4.142 0 7.892-1.679 10.607-4.393Zm0 0L41.5 41.5M29 22H15" }, null, -1);
  const _hoisted_3$x = [
    _hoisted_2$z
  ];
  function _sfc_render$1w(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$x, 14, _hoisted_1$H);
  }
  var _IconZoomOut = /* @__PURE__ */ _export_sfc(_sfc_main$1x, [["render", _sfc_render$1w]]);
  const IconZoomOut = Object.assign(_IconZoomOut, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconZoomOut.name, _IconZoomOut);
    }
  });
  const _sfc_main$1w = vue.defineComponent({
    name: "IconZoomIn",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-zoom-in`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$G = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$y = /* @__PURE__ */ vue.createElementVNode("path", { d: "M32.607 32.607A14.953 14.953 0 0 0 37 22c0-8.284-6.716-15-15-15-8.284 0-15 6.716-15 15 0 8.284 6.716 15 15 15 4.142 0 7.892-1.679 10.607-4.393Zm0 0L41.5 41.5M29 22H15m7 7V15" }, null, -1);
  const _hoisted_3$w = [
    _hoisted_2$y
  ];
  function _sfc_render$1v(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$w, 14, _hoisted_1$G);
  }
  var _IconZoomIn = /* @__PURE__ */ _export_sfc(_sfc_main$1w, [["render", _sfc_render$1v]]);
  const IconZoomIn = Object.assign(_IconZoomIn, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconZoomIn.name, _IconZoomIn);
    }
  });
  const _sfc_main$1v = vue.defineComponent({
    name: "IconFullscreen",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-fullscreen`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$F = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$x = /* @__PURE__ */ vue.createElementVNode("path", { d: "M42 17V9a1 1 0 0 0-1-1h-8M6 17V9a1 1 0 0 1 1-1h8m27 23v8a1 1 0 0 1-1 1h-8M6 31v8a1 1 0 0 0 1 1h8" }, null, -1);
  const _hoisted_3$v = [
    _hoisted_2$x
  ];
  function _sfc_render$1u(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$v, 14, _hoisted_1$F);
  }
  var _IconFullscreen = /* @__PURE__ */ _export_sfc(_sfc_main$1v, [["render", _sfc_render$1u]]);
  const IconFullscreen = Object.assign(_IconFullscreen, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconFullscreen.name, _IconFullscreen);
    }
  });
  const _sfc_main$1u = vue.defineComponent({
    name: "IconRotateLeft",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-rotate-left`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$E = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$w = /* @__PURE__ */ vue.createElementVNode("path", { d: "M10 22a1 1 0 0 1 1-1h20a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H11a1 1 0 0 1-1-1V22ZM23 11h11a6 6 0 0 1 6 6v6M22.5 12.893 19.587 11 22.5 9.107v3.786Z" }, null, -1);
  const _hoisted_3$u = [
    _hoisted_2$w
  ];
  function _sfc_render$1t(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$u, 14, _hoisted_1$E);
  }
  var _IconRotateLeft = /* @__PURE__ */ _export_sfc(_sfc_main$1u, [["render", _sfc_render$1t]]);
  const IconRotateLeft = Object.assign(_IconRotateLeft, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconRotateLeft.name, _IconRotateLeft);
    }
  });
  const _sfc_main$1t = vue.defineComponent({
    name: "IconRotateRight",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-rotate-right`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$D = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$v = /* @__PURE__ */ vue.createElementVNode("path", { d: "M38 22a1 1 0 0 0-1-1H17a1 1 0 0 0-1 1v16a1 1 0 0 0 1 1h20a1 1 0 0 0 1-1V22ZM25 11H14a6 6 0 0 0-6 6v6M25.5 12.893 28.413 11 25.5 9.107v3.786Z" }, null, -1);
  const _hoisted_3$t = [
    _hoisted_2$v
  ];
  function _sfc_render$1s(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$t, 14, _hoisted_1$D);
  }
  var _IconRotateRight = /* @__PURE__ */ _export_sfc(_sfc_main$1t, [["render", _sfc_render$1s]]);
  const IconRotateRight = Object.assign(_IconRotateRight, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconRotateRight.name, _IconRotateRight);
    }
  });
  const _sfc_main$1s = vue.defineComponent({
    name: "IconOriginalSize",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-original-size`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$C = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$u = /* @__PURE__ */ vue.createElementVNode("path", { d: "m5.5 11.5 5-2.5h1v32M34 11.5 39 9h1v32" }, null, -1);
  const _hoisted_3$s = /* @__PURE__ */ vue.createElementVNode("path", {
    d: "M24 17h1v1h-1v-1ZM24 30h1v1h-1v-1Z",
    fill: "currentColor",
    stroke: "none"
  }, null, -1);
  const _hoisted_4$9 = /* @__PURE__ */ vue.createElementVNode("path", { d: "M24 17h1v1h-1v-1ZM24 30h1v1h-1v-1Z" }, null, -1);
  const _hoisted_5$4 = [
    _hoisted_2$u,
    _hoisted_3$s,
    _hoisted_4$9
  ];
  function _sfc_render$1r(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_5$4, 14, _hoisted_1$C);
  }
  var _IconOriginalSize = /* @__PURE__ */ _export_sfc(_sfc_main$1s, [["render", _sfc_render$1r]]);
  const IconOriginalSize = Object.assign(_IconOriginalSize, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconOriginalSize.name, _IconOriginalSize);
    }
  });
  function usePopupOverflowHidden(props) {
    const { container: container2, hidden } = vue.toRefs(props);
    let needResetContainerStyle = false;
    let originContainerStyle = {};
    const getScrollBarWidth2 = (element) => {
      return element.tagName === "BODY" ? window.innerWidth - (document.body.clientWidth || document.documentElement.clientWidth) : element.offsetWidth - element.clientWidth;
    };
    const setContainerStyle = () => {
      if (container2.value && container2.value.style.overflow !== "hidden") {
        const originStyle = container2.value.style;
        needResetContainerStyle = true;
        const containerScrollBarWidth = getScrollBarWidth2(container2.value);
        if (containerScrollBarWidth) {
          originContainerStyle.width = originStyle.width;
          container2.value.style.width = `calc(${container2.value.style.width || "100%"} - ${containerScrollBarWidth}px)`;
        }
        originContainerStyle.overflow = originStyle.overflow;
        container2.value.style.overflow = "hidden";
      }
    };
    const resetContainerStyle = () => {
      if (container2.value && needResetContainerStyle) {
        const originStyle = originContainerStyle;
        Object.keys(originStyle).forEach((i) => {
          container2.value.style[i] = originStyle[i];
        });
      }
      needResetContainerStyle = false;
      originContainerStyle = {};
    };
    vue.watchEffect((onInvalidate) => {
      hidden.value ? setContainerStyle() : resetContainerStyle();
      onInvalidate(() => {
        resetContainerStyle();
      });
    });
    return [resetContainerStyle, setContainerStyle];
  }
  function usePopupContainer(defaultPopupContainer, props) {
    const { popupContainer } = vue.toRefs(props);
    const container2 = vue.computed(() => (isString$1(popupContainer.value) ? querySelector(popupContainer.value) : popupContainer.value) || defaultPopupContainer);
    return container2;
  }
  const scaleAttr = [
    25,
    33,
    50,
    67,
    75,
    80,
    90,
    100,
    110,
    125,
    150,
    175,
    200,
    250,
    300,
    400,
    500
  ].map((item) => +(item / 100).toFixed(2));
  const minScale = scaleAttr[0];
  const maxScale = scaleAttr[scaleAttr.length - 1];
  function getScale(cur = 1, type = "zoomIn") {
    let index2 = scaleAttr.indexOf(cur);
    if (index2 === -1) {
      index2 = findClosestIndex(cur);
    }
    if (type === "zoomIn") {
      return index2 === scaleAttr.length - 1 ? cur : scaleAttr[index2 + 1];
    }
    return index2 === 0 ? cur : scaleAttr[index2 - 1];
  }
  function findClosestIndex(scale) {
    let closestIndex = scaleAttr.length - 1;
    for (let i = 0; i < scaleAttr.length; i++) {
      const current = scaleAttr[i];
      if (scale === current) {
        closestIndex = i;
        break;
      }
      if (scale < current) {
        const pre = scaleAttr[i - 1];
        closestIndex = pre === void 0 || Math.abs(pre - scale) <= Math.abs(current - scale) ? i - 1 : i;
        break;
      }
    }
    return closestIndex;
  }
  const ROTATE_STEP = 90;
  var _sfc_main$1r = vue.defineComponent({
    name: "ImagePreview",
    components: {
      PreviewArrow,
      PreviewToolbar,
      IconLoading,
      IconClose
    },
    props: {
      renderToBody: {
        type: Boolean,
        default: true
      },
      src: {
        type: String
      },
      visible: {
        type: Boolean,
        default: void 0
      },
      defaultVisible: {
        type: Boolean,
        default: false
      },
      maskClosable: {
        type: Boolean,
        default: true
      },
      closable: {
        type: Boolean,
        default: true
      },
      actionsLayout: {
        type: Array,
        default: () => ["fullScreen", "rotateRight", "rotateLeft", "zoomIn", "zoomOut", "originalSize"]
      },
      popupContainer: {
        type: [Object, String]
      },
      inGroup: {
        type: Boolean,
        default: false
      },
      groupArrowProps: {
        type: Object,
        default: () => ({})
      }
    },
    emits: [
      "close",
      "update:visible"
    ],
    setup(props, {
      emit
    }) {
      const {
        t: t2
      } = useI18n();
      const {
        src,
        popupContainer,
        visible,
        defaultVisible,
        maskClosable
      } = vue.toRefs(props);
      const refWrapper = vue.ref();
      const refImage = vue.ref();
      const prefixCls = getPrefixCls("image-preview");
      const [mergedVisible, setVisible] = useMergeState(defaultVisible.value, vue.reactive({
        value: visible
      }));
      const classNames = vue.computed(() => [prefixCls, {
        [`${prefixCls}-hide`]: !mergedVisible.value
      }]);
      const container2 = usePopupContainer(document.body, vue.reactive({
        popupContainer
      }));
      const isFixed = vue.computed(() => container2.value === document.body);
      const {
        zIndex
      } = usePopupManager("dialog", {
        visible: mergedVisible
      });
      const wrapperStyles = vue.computed(() => {
        const positionStyles = isFixed.value ? {
          zIndex: zIndex.value,
          position: "fixed"
        } : {
          zIndex: "inherit",
          position: "absolute"
        };
        return __spreadValues({}, positionStyles);
      });
      const {
        isLoading,
        isLoaded,
        setLoadStatus
      } = useImageLoadStatus();
      const rotate = vue.ref(0);
      const scale = vue.ref(1);
      const {
        translate,
        moving,
        resetTranslate
      } = useImageDrag(vue.reactive({
        wrapperEl: refWrapper,
        imageEl: refImage,
        visible: mergedVisible,
        scale
      }));
      const scaleValueVisible = vue.ref(false);
      let hideScaleTimer = null;
      const showScaleValue = () => {
        !scaleValueVisible.value && (scaleValueVisible.value = true);
        hideScaleTimer && clearTimeout(hideScaleTimer);
        hideScaleTimer = setTimeout(() => {
          scaleValueVisible.value = false;
        }, 1e3);
      };
      usePopupOverflowHidden(vue.reactive({
        container: container2,
        hidden: mergedVisible
      }));
      function reset() {
        rotate.value = 0;
        scale.value = 1;
        resetTranslate();
      }
      vue.watch([src, mergedVisible], () => {
        if (mergedVisible.value) {
          reset();
          setLoadStatus("loading");
        }
      });
      function close() {
        if (mergedVisible.value) {
          emit("close");
          emit("update:visible", false);
          setVisible(false);
        }
      }
      function onMaskClick(e2) {
        if (maskClosable.value && e2.target === e2.currentTarget) {
          close();
        }
      }
      function changeScale(newScale) {
        if (scale.value !== newScale) {
          scale.value = newScale;
          showScaleValue();
        }
      }
      return {
        prefixCls,
        classNames,
        container: container2,
        wrapperStyles,
        scale,
        translate,
        rotate,
        moving,
        mergedVisible,
        isLoading,
        isLoaded,
        scaleValueVisible,
        refWrapper,
        refImage,
        onMaskClick,
        onCloseClick: close,
        onImgLoad() {
          setLoadStatus("loaded");
        },
        onImgError() {
          setLoadStatus("error");
        },
        actions: vue.computed(() => [
          {
            key: "fullScreen",
            name: t2("imagePreview.fullScreen"),
            content: () => vue.h(IconFullscreen),
            onClick: () => {
              const wrapperRect = refWrapper.value.getBoundingClientRect();
              const imgRect = refImage.value.getBoundingClientRect();
              const newHeightScale = wrapperRect.height / (imgRect.height / scale.value);
              const newWidthScale = wrapperRect.width / (imgRect.width / scale.value);
              const newScale = Math.max(newHeightScale, newWidthScale);
              changeScale(newScale);
            }
          },
          {
            key: "rotateRight",
            name: t2("imagePreview.rotateRight"),
            content: () => vue.h(IconRotateRight),
            onClick: () => {
              rotate.value = (rotate.value + ROTATE_STEP) % 360;
            }
          },
          {
            key: "rotateLeft",
            name: t2("imagePreview.rotateLeft"),
            content: () => vue.h(IconRotateLeft),
            onClick: () => {
              rotate.value = rotate.value === 0 ? 360 - ROTATE_STEP : rotate.value - ROTATE_STEP;
            }
          },
          {
            key: "zoomIn",
            name: t2("imagePreview.zoomIn"),
            content: () => vue.h(IconZoomIn),
            onClick: () => {
              const newScale = getScale(scale.value, "zoomIn");
              changeScale(newScale);
            },
            disabled: scale.value === maxScale
          },
          {
            key: "zoomOut",
            name: t2("imagePreview.zoomOut"),
            content: () => vue.h(IconZoomOut),
            onClick: () => {
              const newScale = getScale(scale.value, "zoomOut");
              changeScale(newScale);
            },
            disabled: scale.value === minScale
          },
          {
            key: "originalSize",
            name: t2("imagePreview.originalSize"),
            content: () => vue.h(IconOriginalSize),
            onClick: () => {
              changeScale(1);
            }
          }
        ])
      };
    }
  });
  const _hoisted_1$B = ["src"];
  function _sfc_render$1q(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_IconLoading = vue.resolveComponent("IconLoading");
    const _component_PreviewToolbar = vue.resolveComponent("PreviewToolbar");
    const _component_IconClose = vue.resolveComponent("IconClose");
    const _component_PreviewArrow = vue.resolveComponent("PreviewArrow");
    return vue.openBlock(), vue.createBlock(vue.Teleport, {
      to: _ctx.container,
      disabled: !_ctx.renderToBody
    }, [
      vue.createElementVNode("div", {
        class: vue.normalizeClass(_ctx.classNames),
        style: vue.normalizeStyle(_ctx.wrapperStyles)
      }, [
        vue.createVNode(vue.Transition, {
          name: "image-fade",
          onBeforeEnter: _cache[0] || (_cache[0] = (el) => {
            el.parentNode.style.display = "block";
          }),
          onAfterLeave: _cache[1] || (_cache[1] = (el) => {
            el.parentNode.style.display = "";
          })
        }, {
          default: vue.withCtx(() => [
            vue.withDirectives(vue.createElementVNode("div", {
              class: vue.normalizeClass(`${_ctx.prefixCls}-mask`)
            }, null, 2), [
              [vue.vShow, _ctx.mergedVisible]
            ])
          ]),
          _: 1
        }),
        _ctx.mergedVisible ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 0,
          ref: "refWrapper",
          class: vue.normalizeClass(`${_ctx.prefixCls}-wrapper`),
          onClick: _cache[6] || (_cache[6] = (...args) => _ctx.onMaskClick && _ctx.onMaskClick(...args))
        }, [
          vue.createCommentVNode(" img "),
          vue.createElementVNode("div", {
            class: vue.normalizeClass(`${_ctx.prefixCls}-img-container`),
            style: vue.normalizeStyle({ transform: `scale(${_ctx.scale}, ${_ctx.scale})` }),
            onClick: _cache[4] || (_cache[4] = (...args) => _ctx.onMaskClick && _ctx.onMaskClick(...args))
          }, [
            (vue.openBlock(), vue.createElementBlock("img", {
              ref: "refImage",
              key: _ctx.src,
              src: _ctx.src,
              class: vue.normalizeClass([
                `${_ctx.prefixCls}-img`,
                {
                  [`${_ctx.prefixCls}-img-moving`]: _ctx.moving
                }
              ]),
              style: vue.normalizeStyle({
                transform: `translate(${_ctx.translate[0]}px, ${_ctx.translate[1]}px) rotate(${_ctx.rotate}deg)`
              }),
              onLoad: _cache[2] || (_cache[2] = (...args) => _ctx.onImgLoad && _ctx.onImgLoad(...args)),
              onError: _cache[3] || (_cache[3] = (...args) => _ctx.onImgError && _ctx.onImgError(...args))
            }, null, 46, _hoisted_1$B))
          ], 6),
          vue.createCommentVNode(" loading "),
          _ctx.isLoading ? (vue.openBlock(), vue.createElementBlock("div", {
            key: 0,
            class: vue.normalizeClass(`${_ctx.prefixCls}-loading`)
          }, [
            vue.createVNode(_component_IconLoading)
          ], 2)) : vue.createCommentVNode("v-if", true),
          vue.createCommentVNode(" scale value "),
          vue.createVNode(vue.Transition, { name: "image-fade" }, {
            default: vue.withCtx(() => [
              _ctx.scaleValueVisible ? (vue.openBlock(), vue.createElementBlock("div", {
                key: 0,
                class: vue.normalizeClass(`${_ctx.prefixCls}-scale-value`)
              }, vue.toDisplayString((_ctx.scale * 100).toFixed(0)) + "% ", 3)) : vue.createCommentVNode("v-if", true)
            ]),
            _: 1
          }),
          vue.createCommentVNode(" toolbar "),
          _ctx.isLoaded && _ctx.actionsLayout.length ? (vue.openBlock(), vue.createBlock(_component_PreviewToolbar, {
            key: 1,
            actions: _ctx.actions,
            "actions-layout": _ctx.actionsLayout
          }, {
            default: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "actions")
            ]),
            _: 3
          }, 8, ["actions", "actions-layout"])) : vue.createCommentVNode("v-if", true),
          vue.createCommentVNode(" close btn "),
          _ctx.closable ? (vue.openBlock(), vue.createElementBlock("div", {
            key: 2,
            class: vue.normalizeClass(`${_ctx.prefixCls}-close-btn`),
            onClick: _cache[5] || (_cache[5] = (...args) => _ctx.onCloseClick && _ctx.onCloseClick(...args))
          }, [
            vue.createVNode(_component_IconClose)
          ], 2)) : vue.createCommentVNode("v-if", true),
          vue.createCommentVNode(" group arrow "),
          _ctx.inGroup ? (vue.openBlock(), vue.createBlock(_component_PreviewArrow, vue.normalizeProps(vue.mergeProps({ key: 3 }, _ctx.groupArrowProps)), null, 16)) : vue.createCommentVNode("v-if", true)
        ], 2)) : vue.createCommentVNode("v-if", true)
      ], 6)
    ], 8, ["to", "disabled"]);
  }
  var ImagePreview = /* @__PURE__ */ _export_sfc(_sfc_main$1r, [["render", _sfc_render$1q]]);
  function normalizeImageSizeProp(size) {
    if (isUndefined(size))
      return void 0;
    if (!isNumber$1(size) && /^\d+(%)$/.test(size))
      return size;
    const num = parseInt(size, 10);
    return isNumber$1(num) ? `${num}px` : void 0;
  }
  const PreviewGroupInjectionKey = Symbol("PreviewGroupInjectionKey");
  let uuid = 0;
  const _sfc_main$1q = vue.defineComponent({
    name: "Image",
    components: {
      IconImageClose,
      IconLoading,
      ImageFooter,
      ImagePreview
    },
    inheritAttrs: false,
    props: {
      renderToBody: {
        type: Boolean,
        default: true
      },
      src: {
        type: String
      },
      width: {
        type: [String, Number]
      },
      height: {
        type: [String, Number]
      },
      title: {
        type: String
      },
      description: {
        type: String
      },
      fit: {
        type: String
      },
      alt: {
        type: String
      },
      hideFooter: {
        type: [Boolean, String],
        default: false
      },
      footerPosition: {
        type: String,
        default: "inner"
      },
      showLoader: {
        type: Boolean,
        default: false
      },
      preview: {
        type: Boolean,
        default: true
      },
      previewVisible: {
        type: Boolean,
        default: void 0
      },
      defaultPreviewVisible: {
        type: Boolean,
        default: false
      },
      previewProps: {
        type: Object
      },
      footerClass: {
        type: [String, Array, Object]
      }
    },
    emits: [
      "preview-visible-change",
      "update:previewVisible"
    ],
    setup(props, { attrs, slots, emit }) {
      const { t: t2 } = useI18n();
      const {
        height,
        width,
        hideFooter,
        title,
        description,
        src,
        footerPosition,
        defaultPreviewVisible,
        previewVisible,
        preview,
        previewProps
      } = vue.toRefs(props);
      const groupContext = vue.inject(PreviewGroupInjectionKey, void 0);
      const prefixCls = getPrefixCls("image");
      const refImg = vue.ref();
      const { isLoaded, isError, isLoading, setLoadStatus } = useImageLoadStatus();
      const sizeStyle = vue.computed(() => ({
        width: normalizeImageSizeProp(width == null ? void 0 : width.value),
        height: normalizeImageSizeProp(height == null ? void 0 : height.value)
      }));
      const fitStyle = vue.computed(() => {
        if (props.fit) {
          return { objectFit: props.fit };
        }
        return {};
      });
      const wrapperClassNames = vue.computed(() => [
        `${prefixCls}`,
        {
          [`${prefixCls}-loading`]: isLoading.value,
          [`${prefixCls}-loading-error`]: isError.value,
          [`${prefixCls}-with-footer-inner`]: isLoaded && showFooter && footerPosition.value === "inner",
          [`${prefixCls}-with-footer-outer`]: isLoaded && showFooter && footerPosition.value === "outer"
        },
        attrs.class
      ]);
      const wrapperStyles = vue.computed(() => [
        sizeStyle.value,
        attrs.style
      ]);
      const showFooter = vue.computed(() => {
        if (!((title == null ? void 0 : title.value) || (description == null ? void 0 : description.value) || slots.extra)) {
          return false;
        }
        if (isBoolean$1(hideFooter.value))
          return !hideFooter.value && isLoaded.value;
        return hideFooter.value === "never";
      });
      const imgProps = vue.computed(() => omit(attrs, ["class", "style"]));
      const [mergedPreviewVisible, setPreviewVisible] = useMergeState(defaultPreviewVisible.value, vue.reactive({
        value: previewVisible
      }));
      const mergePreview = vue.computed(() => !(groupContext == null ? void 0 : groupContext.preview) && preview.value);
      vue.watchEffect(() => {
        if (isServerRendering || !refImg.value)
          return;
        refImg.value.src = src == null ? void 0 : src.value;
        setLoadStatus("loading");
      });
      const imageId = uuid++;
      vue.watchEffect((onInvalidate) => {
        var _a, _b, _c;
        const unRegister = (_c = groupContext == null ? void 0 : groupContext.registerImageUrl) == null ? void 0 : _c.call(groupContext, imageId, ((_b = (_a = previewProps == null ? void 0 : previewProps.value) == null ? void 0 : _a.src) != null ? _b : src == null ? void 0 : src.value) || "", preview.value);
        onInvalidate(() => {
          unRegister == null ? void 0 : unRegister();
        });
      });
      function onImgLoaded() {
        setLoadStatus("loaded");
      }
      function onImgLoadError() {
        setLoadStatus("error");
      }
      function onImgClick() {
        if (!preview.value)
          return;
        if (groupContext == null ? void 0 : groupContext.preview) {
          groupContext.preview(imageId);
        } else {
          emit("preview-visible-change", true);
          setPreviewVisible(true);
        }
      }
      function onPreviewClose() {
        emit("preview-visible-change", false);
        setPreviewVisible(false);
      }
      return {
        t: t2,
        refImg,
        prefixCls,
        wrapperClassNames,
        wrapperStyles,
        showFooter,
        imgProps,
        imgStyle: sizeStyle,
        isLoaded,
        isError,
        isLoading,
        mergedPreviewVisible,
        mergePreview,
        onImgLoaded,
        onImgLoadError,
        onImgClick,
        onPreviewClose,
        fitStyle
      };
    }
  });
  const _hoisted_1$A = ["title", "alt"];
  function _sfc_render$1p(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_IconImageClose = vue.resolveComponent("IconImageClose");
    const _component_IconLoading = vue.resolveComponent("IconLoading");
    const _component_ImageFooter = vue.resolveComponent("ImageFooter");
    const _component_ImagePreview = vue.resolveComponent("ImagePreview");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.wrapperClassNames),
      style: vue.normalizeStyle(_ctx.wrapperStyles)
    }, [
      vue.createElementVNode("img", vue.mergeProps({
        ref: "refImg",
        class: `${_ctx.prefixCls}-img`
      }, _ctx.imgProps, {
        style: __spreadValues(__spreadValues({}, _ctx.imgStyle), _ctx.fitStyle),
        title: _ctx.title,
        alt: _ctx.alt,
        onLoad: _cache[0] || (_cache[0] = (...args) => _ctx.onImgLoaded && _ctx.onImgLoaded(...args)),
        onError: _cache[1] || (_cache[1] = (...args) => _ctx.onImgLoadError && _ctx.onImgLoadError(...args)),
        onClick: _cache[2] || (_cache[2] = (...args) => _ctx.onImgClick && _ctx.onImgClick(...args))
      }), null, 16, _hoisted_1$A),
      !_ctx.isLoaded ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: vue.normalizeClass(`${_ctx.prefixCls}-overlay`)
      }, [
        _ctx.isError ? vue.renderSlot(_ctx.$slots, "error", { key: 0 }, () => [
          vue.createElementVNode("div", {
            class: vue.normalizeClass(`${_ctx.prefixCls}-error`)
          }, [
            vue.createElementVNode("div", {
              class: vue.normalizeClass(`${_ctx.prefixCls}-error-icon`)
            }, [
              vue.renderSlot(_ctx.$slots, "error-icon", {}, () => [
                vue.createVNode(_component_IconImageClose)
              ])
            ], 2),
            _ctx.alt || _ctx.description ? (vue.openBlock(), vue.createElementBlock("div", {
              key: 0,
              class: vue.normalizeClass(`${_ctx.prefixCls}-error-alt`)
            }, vue.toDisplayString(_ctx.alt || _ctx.description), 3)) : vue.createCommentVNode("v-if", true)
          ], 2)
        ]) : vue.createCommentVNode("v-if", true),
        _ctx.isLoading && (_ctx.showLoader || _ctx.$slots.loader) ? vue.renderSlot(_ctx.$slots, "loader", { key: 1 }, () => [
          vue.createElementVNode("div", {
            class: vue.normalizeClass([`${_ctx.prefixCls}-loader`])
          }, [
            vue.createElementVNode("div", {
              class: vue.normalizeClass(`${_ctx.prefixCls}-loader-spin`)
            }, [
              vue.createVNode(_component_IconLoading),
              vue.createElementVNode("div", {
                class: vue.normalizeClass(`${_ctx.prefixCls}-loader-spin-text`)
              }, vue.toDisplayString(_ctx.t("image.loading")), 3)
            ], 2)
          ], 2)
        ]) : vue.createCommentVNode("v-if", true)
      ], 2)) : vue.createCommentVNode("v-if", true),
      _ctx.showFooter ? (vue.openBlock(), vue.createBlock(_component_ImageFooter, {
        key: 1,
        class: vue.normalizeClass(_ctx.footerClass),
        "prefix-cls": _ctx.prefixCls,
        title: _ctx.title,
        description: _ctx.description
      }, vue.createSlots({ _: 2 }, [
        _ctx.$slots.extra ? {
          name: "extra",
          fn: vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "extra")
          ])
        } : void 0
      ]), 1032, ["class", "prefix-cls", "title", "description"])) : vue.createCommentVNode("v-if", true),
      _ctx.isLoaded && _ctx.mergePreview ? (vue.openBlock(), vue.createBlock(_component_ImagePreview, vue.mergeProps({
        key: 2,
        src: _ctx.src
      }, _ctx.previewProps, {
        visible: _ctx.mergedPreviewVisible,
        "render-to-body": _ctx.renderToBody,
        onClose: _ctx.onPreviewClose
      }), {
        actions: vue.withCtx(() => [
          vue.renderSlot(_ctx.$slots, "preview-actions")
        ]),
        _: 3
      }, 16, ["src", "visible", "render-to-body", "onClose"])) : vue.createCommentVNode("v-if", true)
    ], 6);
  }
  var _Image = /* @__PURE__ */ _export_sfc(_sfc_main$1q, [["render", _sfc_render$1p]]);
  var _sfc_main$1p = vue.defineComponent({
    name: "ImagePreviewGroup",
    components: {
      ImagePreview
    },
    inheritAttrs: false,
    props: {
      renderToBody: {
        type: Boolean,
        default: true
      },
      srcList: {
        type: Array
      },
      current: {
        type: Number
      },
      defaultCurrent: {
        type: Number,
        default: 0
      },
      infinite: {
        type: Boolean,
        default: false
      },
      visible: {
        type: Boolean,
        default: void 0
      },
      defaultVisible: {
        type: Boolean,
        default: false
      },
      maskClosable: {
        type: Boolean,
        default: true
      },
      closable: {
        type: Boolean,
        default: true
      },
      actionsLayout: {
        type: Array,
        default: () => ["fullScreen", "rotateRight", "rotateLeft", "zoomIn", "zoomOut", "originalSize"]
      },
      popupContainer: {
        type: [Object, String]
      }
    },
    emits: [
      "change",
      "update:current",
      "visible-change",
      "update:visible"
    ],
    setup(props, {
      emit
    }) {
      const {
        srcList,
        visible,
        defaultVisible,
        current,
        defaultCurrent,
        infinite
      } = vue.toRefs(props);
      const [mergedVisible, setLocalVisible] = useMergeState(defaultVisible.value, vue.reactive({
        value: visible
      }));
      const setVisible = (newVisible) => {
        if (newVisible !== mergedVisible.value) {
          emit("visible-change", newVisible);
          emit("update:visible", newVisible);
          setLocalVisible(newVisible);
        }
      };
      const propImageUrlMap = vue.computed(() => new Map(isArray$1(srcList == null ? void 0 : srcList.value) ? srcList == null ? void 0 : srcList.value.map((url, index2) => [index2, {
        url,
        canPreview: true
      }]) : []));
      const imageUrlMap = vue.ref(new Map(propImageUrlMap.value || []));
      const imageIdList = vue.computed(() => Array.from(imageUrlMap.value.keys()));
      const imageCount = vue.computed(() => imageIdList.value.length);
      function registerImageUrl(id, url, canPreview) {
        if (!propImageUrlMap.value.has(id))
          imageUrlMap.value.set(id, {
            url,
            canPreview
          });
        return function unRegisterPreviewUrl() {
          if (!propImageUrlMap.value.has(id)) {
            imageUrlMap.value.delete(id);
          }
        };
      }
      vue.watch(propImageUrlMap, () => {
        imageUrlMap.value = new Map(propImageUrlMap.value || []);
      });
      const [currentIndex, setLocalCurrentIndex] = useMergeState(defaultCurrent.value, vue.reactive({
        value: current
      }));
      const setCurrentIndex = (index2) => {
        if (index2 !== currentIndex.value) {
          emit("change", index2);
          emit("update:current", index2);
          setLocalCurrentIndex(index2);
        }
      };
      const currentId = vue.computed(() => imageIdList.value[currentIndex.value]);
      const setCurrentId = (nextId) => {
        const nextIndex2 = imageIdList.value.indexOf(nextId);
        if (nextIndex2 !== currentIndex.value) {
          setCurrentIndex(nextIndex2);
        }
      };
      const currentUrl = vue.computed(() => {
        var _a;
        return (_a = imageUrlMap.value.get(currentId.value)) == null ? void 0 : _a.url;
      });
      vue.provide(PreviewGroupInjectionKey, vue.reactive({
        registerImageUrl,
        preview: (imageId) => {
          setVisible(true);
          setCurrentId(imageId);
        }
      }));
      const nextIndex = vue.computed(() => {
        const findNext = (start, end) => {
          var _a;
          for (let i = start; i <= end; i++) {
            const id = imageIdList.value[i];
            if ((_a = imageUrlMap.value.get(id)) == null ? void 0 : _a.canPreview) {
              return i;
            }
          }
          return void 0;
        };
        const next = findNext(currentIndex.value + 1, imageCount.value - 1);
        return isUndefined(next) && infinite.value ? findNext(0, currentIndex.value - 1) : next;
      });
      const prevIndex = vue.computed(() => {
        const findPrev = (start, end) => {
          var _a;
          for (let i = start; i >= end; i--) {
            const id = imageIdList.value[i];
            if ((_a = imageUrlMap.value.get(id)) == null ? void 0 : _a.canPreview) {
              return i;
            }
          }
          return void 0;
        };
        const prev = findPrev(currentIndex.value - 1, 0);
        return isUndefined(prev) && infinite.value ? findPrev(imageCount.value - 1, currentIndex.value + 1) : prev;
      });
      const onPrev = vue.computed(() => !isUndefined(prevIndex.value) ? () => {
        !isUndefined(prevIndex.value) && setCurrentIndex(prevIndex.value);
      } : void 0);
      const onNext = vue.computed(() => !isUndefined(nextIndex.value) ? () => {
        !isUndefined(nextIndex.value) && setCurrentIndex(nextIndex.value);
      } : void 0);
      return {
        mergedVisible,
        currentUrl,
        prevIndex,
        nextIndex,
        onClose() {
          setVisible(false);
        },
        groupArrowProps: vue.reactive({
          onPrev,
          onNext
        })
      };
    }
  });
  function _sfc_render$1o(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_ImagePreview = vue.resolveComponent("ImagePreview");
    return vue.openBlock(), vue.createElementBlock(vue.Fragment, null, [
      vue.renderSlot(_ctx.$slots, "default"),
      vue.createVNode(_component_ImagePreview, vue.mergeProps(__spreadProps(__spreadValues({}, _ctx.$attrs), { groupArrowProps: _ctx.groupArrowProps }), {
        "in-group": "",
        src: _ctx.currentUrl,
        visible: _ctx.mergedVisible,
        "mask-closable": _ctx.maskClosable,
        closable: _ctx.closable,
        "actions-layout": _ctx.actionsLayout,
        "popup-container": _ctx.popupContainer,
        "render-to-body": _ctx.renderToBody,
        onClose: _ctx.onClose
      }), vue.createSlots({ _: 2 }, [
        _ctx.$slots.actions ? {
          name: "actions",
          fn: vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "actions", { url: _ctx.currentUrl })
          ])
        } : void 0
      ]), 1040, ["src", "visible", "mask-closable", "closable", "actions-layout", "popup-container", "render-to-body", "onClose"])
    ], 64);
  }
  var ImagePreviewGroup = /* @__PURE__ */ _export_sfc(_sfc_main$1p, [["render", _sfc_render$1o]]);
  const Image = Object.assign(_Image, {
    Preview: ImagePreview,
    PreviewGroup: ImagePreviewGroup,
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Image.name, _Image);
      app.component(componentPrefix + ImagePreview.name, ImagePreview);
      app.component(componentPrefix + ImagePreviewGroup.name, ImagePreviewGroup);
      app.component(componentPrefix + ImagePreviewAction.name, ImagePreviewAction);
    }
  });
  function strip(num, precision) {
    if (precision === void 0) {
      precision = 15;
    }
    return +parseFloat(Number(num).toPrecision(precision));
  }
  function digitLength(num) {
    var eSplit = num.toString().split(/[eE]/);
    var len = (eSplit[0].split(".")[1] || "").length - +(eSplit[1] || 0);
    return len > 0 ? len : 0;
  }
  function float2Fixed(num) {
    if (num.toString().indexOf("e") === -1) {
      return Number(num.toString().replace(".", ""));
    }
    var dLen = digitLength(num);
    return dLen > 0 ? strip(Number(num) * Math.pow(10, dLen)) : Number(num);
  }
  function checkBoundary(num) {
    if (_boundaryCheckingState) {
      if (num > Number.MAX_SAFE_INTEGER || num < Number.MIN_SAFE_INTEGER) {
        console.warn(num + " is beyond boundary when transfer to integer, the results may not be accurate");
      }
    }
  }
  function iteratorOperation(arr, operation) {
    var num1 = arr[0], num2 = arr[1], others = arr.slice(2);
    var res = operation(num1, num2);
    others.forEach(function(num) {
      res = operation(res, num);
    });
    return res;
  }
  function times() {
    var nums = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      nums[_i] = arguments[_i];
    }
    if (nums.length > 2) {
      return iteratorOperation(nums, times);
    }
    var num1 = nums[0], num2 = nums[1];
    var num1Changed = float2Fixed(num1);
    var num2Changed = float2Fixed(num2);
    var baseNum = digitLength(num1) + digitLength(num2);
    var leftValue = num1Changed * num2Changed;
    checkBoundary(leftValue);
    return leftValue / Math.pow(10, baseNum);
  }
  function plus() {
    var nums = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      nums[_i] = arguments[_i];
    }
    if (nums.length > 2) {
      return iteratorOperation(nums, plus);
    }
    var num1 = nums[0], num2 = nums[1];
    var baseNum = Math.pow(10, Math.max(digitLength(num1), digitLength(num2)));
    return (times(num1, baseNum) + times(num2, baseNum)) / baseNum;
  }
  function minus() {
    var nums = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      nums[_i] = arguments[_i];
    }
    if (nums.length > 2) {
      return iteratorOperation(nums, minus);
    }
    var num1 = nums[0], num2 = nums[1];
    var baseNum = Math.pow(10, Math.max(digitLength(num1), digitLength(num2)));
    return (times(num1, baseNum) - times(num2, baseNum)) / baseNum;
  }
  function divide() {
    var nums = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      nums[_i] = arguments[_i];
    }
    if (nums.length > 2) {
      return iteratorOperation(nums, divide);
    }
    var num1 = nums[0], num2 = nums[1];
    var num1Changed = float2Fixed(num1);
    var num2Changed = float2Fixed(num2);
    checkBoundary(num1Changed);
    checkBoundary(num2Changed);
    return times(num1Changed / num2Changed, strip(Math.pow(10, digitLength(num2) - digitLength(num1))));
  }
  function round(num, ratio) {
    var base = Math.pow(10, ratio);
    var result = divide(Math.round(Math.abs(times(num, base))), base);
    if (num < 0 && result !== 0) {
      result = times(result, -1);
    }
    return result;
  }
  var _boundaryCheckingState = true;
  function enableBoundaryChecking(flag) {
    if (flag === void 0) {
      flag = true;
    }
    _boundaryCheckingState = flag;
  }
  var index = {
    strip,
    plus,
    minus,
    times,
    divide,
    round,
    digitLength,
    float2Fixed,
    enableBoundaryChecking
  };
  const _sfc_main$1o = vue.defineComponent({
    name: "IconPlus",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-plus`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$z = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$t = /* @__PURE__ */ vue.createElementVNode("path", { d: "M5 24h38M24 5v38" }, null, -1);
  const _hoisted_3$r = [
    _hoisted_2$t
  ];
  function _sfc_render$1n(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$r, 14, _hoisted_1$z);
  }
  var _IconPlus = /* @__PURE__ */ _export_sfc(_sfc_main$1o, [["render", _sfc_render$1n]]);
  const IconPlus = Object.assign(_IconPlus, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconPlus.name, _IconPlus);
    }
  });
  const _sfc_main$1n = vue.defineComponent({
    name: "IconMinus",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-minus`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$y = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$s = /* @__PURE__ */ vue.createElementVNode("path", { d: "M5 24h38" }, null, -1);
  const _hoisted_3$q = [
    _hoisted_2$s
  ];
  function _sfc_render$1m(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$q, 14, _hoisted_1$y);
  }
  var _IconMinus = /* @__PURE__ */ _export_sfc(_sfc_main$1n, [["render", _sfc_render$1m]]);
  const IconMinus = Object.assign(_IconMinus, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconMinus.name, _IconMinus);
    }
  });
  const SPEED = 150;
  index.enableBoundaryChecking(false);
  var _InputNumber = vue.defineComponent({
    name: "InputNumber",
    props: {
      modelValue: Number,
      defaultValue: Number,
      mode: {
        type: String,
        default: "embed"
      },
      precision: Number,
      step: {
        type: Number,
        default: 1
      },
      disabled: {
        type: Boolean,
        default: false
      },
      error: {
        type: Boolean,
        default: false
      },
      max: {
        type: Number,
        default: Infinity
      },
      min: {
        type: Number,
        default: -Infinity
      },
      formatter: {
        type: Function
      },
      parser: {
        type: Function
      },
      placeholder: String,
      hideButton: {
        type: Boolean,
        default: false
      },
      size: {
        type: String
      },
      allowClear: {
        type: Boolean,
        default: false
      },
      modelEvent: {
        type: String,
        default: "change"
      },
      readOnly: {
        type: Boolean,
        default: false
      }
    },
    emits: {
      "update:modelValue": (value) => true,
      "change": (value, ev) => true,
      "focus": (ev) => true,
      "blur": (ev) => true,
      "clear": (ev) => true,
      "input": (value, inputValue, ev) => true
    },
    setup(props, {
      emit,
      slots
    }) {
      var _a;
      const {
        size,
        disabled
      } = vue.toRefs(props);
      const prefixCls = getPrefixCls("input-number");
      const inputRef = vue.ref();
      const {
        mergedSize: _mergedSize,
        mergedDisabled,
        eventHandlers
      } = useFormItem({
        size,
        disabled
      });
      const {
        mergedSize
      } = useSize$1(_mergedSize);
      const mergedPrecision = vue.computed(() => {
        if (isNumber$1(props.precision)) {
          const decimal = `${props.step}`.split(".")[1];
          const stepPrecision = decimal && decimal.length || 0;
          return Math.max(stepPrecision, props.precision);
        }
        return void 0;
      });
      const getStringValue = (number) => {
        var _a2, _b;
        if (!isNumber$1(number)) {
          return "";
        }
        const numString = mergedPrecision.value ? number.toFixed(mergedPrecision.value) : String(number);
        return (_b = (_a2 = props.formatter) == null ? void 0 : _a2.call(props, numString)) != null ? _b : numString;
      };
      const _value = vue.ref(getStringValue((_a = props.modelValue) != null ? _a : props.defaultValue));
      const valueNumber = vue.computed(() => {
        var _a2, _b;
        if (!_value.value) {
          return void 0;
        }
        const number = Number((_b = (_a2 = props.parser) == null ? void 0 : _a2.call(props, _value.value)) != null ? _b : _value.value);
        return Number.isNaN(number) ? void 0 : number;
      });
      const isMin = vue.ref(isNumber$1(valueNumber.value) && valueNumber.value <= props.min);
      const isMax = vue.ref(isNumber$1(valueNumber.value) && valueNumber.value >= props.max);
      let repeatTimer = 0;
      const clearRepeatTimer = () => {
        if (repeatTimer) {
          window.clearTimeout(repeatTimer);
          repeatTimer = 0;
        }
      };
      const getLegalValue = (value) => {
        if (isUndefined(value)) {
          return void 0;
        }
        if (isNumber$1(props.min) && value < props.min) {
          value = props.min;
        }
        if (isNumber$1(props.max) && value > props.max) {
          value = props.max;
        }
        return isNumber$1(mergedPrecision.value) ? index.round(value, mergedPrecision.value) : value;
      };
      const updateNumberStatus = (number) => {
        let _isMin = false;
        let _isMax = false;
        if (isNumber$1(number)) {
          if (number <= props.min) {
            _isMin = true;
          }
          if (number >= props.max) {
            _isMax = true;
          }
        }
        if (isMax.value !== _isMax) {
          isMax.value = _isMax;
        }
        if (isMin.value !== _isMin) {
          isMin.value = _isMin;
        }
      };
      const handleExceedRange = () => {
        const finalValue = getLegalValue(valueNumber.value);
        const stringValue = getStringValue(finalValue);
        if (finalValue !== valueNumber.value || _value.value !== stringValue) {
          _value.value = stringValue;
        }
        emit("update:modelValue", finalValue);
      };
      vue.watch(() => props.min, (newVal) => {
        const _isMin = isNumber$1(valueNumber.value) && valueNumber.value <= newVal;
        if (isMin.value !== _isMin) {
          isMin.value = _isMin;
        }
        const isExceedMinValue = isNumber$1(valueNumber.value) && valueNumber.value < newVal;
        if (isExceedMinValue) {
          handleExceedRange();
        }
      });
      vue.watch(() => props.max, (newVal) => {
        const _isMax = isNumber$1(valueNumber.value) && valueNumber.value >= newVal;
        if (isMax.value !== _isMax) {
          isMax.value = _isMax;
        }
        const isExceedMaxValue = isNumber$1(valueNumber.value) && valueNumber.value > newVal;
        if (isExceedMaxValue) {
          handleExceedRange();
        }
      });
      const nextStep = (method, event) => {
        if (mergedDisabled.value || method === "plus" && isMax.value || method === "minus" && isMin.value) {
          return;
        }
        let nextValue;
        if (isNumber$1(valueNumber.value)) {
          nextValue = getLegalValue(index[method](valueNumber.value, props.step));
        } else {
          nextValue = props.min === -Infinity ? 0 : props.min;
        }
        _value.value = getStringValue(nextValue);
        updateNumberStatus(nextValue);
        emit("update:modelValue", nextValue);
        emit("change", nextValue, event);
      };
      const handleStepButton = (event, method, needRepeat = false) => {
        var _a2;
        event.preventDefault();
        (_a2 = inputRef.value) == null ? void 0 : _a2.focus();
        nextStep(method, event);
        if (needRepeat) {
          repeatTimer = window.setTimeout(() => event.target.dispatchEvent(event), SPEED);
        }
      };
      const handleInput = (value, ev) => {
        var _a2, _b, _c, _d;
        value = value.trim().replace(//g, ".");
        value = (_b = (_a2 = props.parser) == null ? void 0 : _a2.call(props, value)) != null ? _b : value;
        if (isNumber$1(Number(value)) || /^(\.|-)$/.test(value)) {
          _value.value = (_d = (_c = props.formatter) == null ? void 0 : _c.call(props, value)) != null ? _d : value;
          updateNumberStatus(valueNumber.value);
          if (props.modelEvent === "input") {
            emit("update:modelValue", valueNumber.value);
          }
          emit("input", valueNumber.value, _value.value, ev);
        }
      };
      const handleFocus = (ev) => {
        emit("focus", ev);
      };
      const handleChange = (value, ev) => {
        const finalValue = getLegalValue(valueNumber.value);
        const stringValue = getStringValue(finalValue);
        if (finalValue !== valueNumber.value || _value.value !== stringValue) {
          _value.value = stringValue;
          updateNumberStatus(finalValue);
        }
        vue.nextTick(() => {
          if (isNumber$1(props.modelValue) && props.modelValue !== finalValue) {
            _value.value = getStringValue(props.modelValue);
            updateNumberStatus(props.modelValue);
          }
        });
        emit("update:modelValue", finalValue);
        emit("change", finalValue, ev);
      };
      const handleBlur = (ev) => {
        emit("blur", ev);
      };
      const handleClear = (ev) => {
        var _a2, _b;
        _value.value = "";
        emit("update:modelValue", void 0);
        emit("change", void 0, ev);
        (_b = (_a2 = eventHandlers.value) == null ? void 0 : _a2.onChange) == null ? void 0 : _b.call(_a2, ev);
        emit("clear", ev);
      };
      const onKeyDown = getKeyDownHandler(new Map([[KEYBOARD_KEY.ARROW_UP, (ev) => {
        ev.preventDefault();
        !props.readOnly && nextStep("plus", ev);
      }], [KEYBOARD_KEY.ARROW_DOWN, (ev) => {
        ev.preventDefault();
        !props.readOnly && nextStep("minus", ev);
      }]]));
      vue.watch(() => props.modelValue, (value) => {
        if (value !== valueNumber.value) {
          _value.value = getStringValue(value);
          updateNumberStatus(value);
        }
      });
      const renderSuffix = () => {
        var _a2, _b, _c;
        if (props.readOnly) {
          return null;
        }
        return vue.createVNode(vue.Fragment, null, [(_a2 = slots.suffix) == null ? void 0 : _a2.call(slots), vue.createVNode("div", {
          "class": `${prefixCls}-step`
        }, [vue.createVNode("button", {
          "class": [`${prefixCls}-step-button`, {
            [`${prefixCls}-step-button-disabled`]: mergedDisabled.value || isMax.value
          }],
          "type": "button",
          "tabindex": "-1",
          "disabled": mergedDisabled.value || isMax.value,
          "onMousedown": (e2) => handleStepButton(e2, "plus", true),
          "onMouseup": clearRepeatTimer,
          "onMouseleave": clearRepeatTimer
        }, [slots.plus ? (_b = slots.plus) == null ? void 0 : _b.call(slots) : vue.createVNode(IconUp, null, null)]), vue.createVNode("button", {
          "class": [`${prefixCls}-step-button`, {
            [`${prefixCls}-step-button-disabled`]: mergedDisabled.value || isMin.value
          }],
          "type": "button",
          "tabindex": "-1",
          "disabled": mergedDisabled.value || isMin.value,
          "onMousedown": (e2) => handleStepButton(e2, "minus", true),
          "onMouseup": clearRepeatTimer,
          "onMouseleave": clearRepeatTimer
        }, [slots.minus ? (_c = slots.minus) == null ? void 0 : _c.call(slots) : vue.createVNode(IconDown, null, null)])])]);
      };
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-mode-${props.mode}`, `${prefixCls}-size-${mergedSize.value}`, {
        [`${prefixCls}-readonly`]: props.readOnly
      }]);
      const renderPrependButton = () => {
        return vue.createVNode(Button, {
          "size": mergedSize.value,
          "tabindex": "-1",
          "class": `${prefixCls}-step-button`,
          "disabled": mergedDisabled.value || isMin.value,
          "onMousedown": (ev) => handleStepButton(ev, "minus", true),
          "onMouseup": clearRepeatTimer,
          "onMouseleave": clearRepeatTimer
        }, {
          icon: () => vue.createVNode(IconMinus, null, null)
        });
      };
      const renderAppendButton = () => {
        return vue.createVNode(Button, {
          "size": mergedSize.value,
          "tabindex": "-1",
          "class": `${prefixCls}-step-button`,
          "disabled": mergedDisabled.value || isMax.value,
          "onMousedown": (ev) => handleStepButton(ev, "plus", true),
          "onMouseup": clearRepeatTimer,
          "onMouseleave": clearRepeatTimer
        }, {
          icon: () => vue.createVNode(IconPlus, null, null)
        });
      };
      const render = () => {
        const _slots = props.mode === "embed" ? {
          prepend: slots.prepend,
          prefix: slots.prefix,
          suffix: props.hideButton ? slots.suffix : renderSuffix,
          append: slots.append
        } : {
          prepend: props.hideButton ? slots.prepend : renderPrependButton,
          prefix: slots.prefix,
          suffix: slots.suffix,
          append: props.hideButton ? slots.append : renderAppendButton
        };
        return vue.createVNode(Input, {
          "key": `__arco__${props.mode}`,
          "ref": inputRef,
          "class": cls.value,
          "type": "text",
          "allowClear": props.allowClear,
          "size": mergedSize.value,
          "modelValue": _value.value,
          "placeholder": props.placeholder,
          "disabled": mergedDisabled.value,
          "readonly": props.readOnly,
          "error": props.error,
          "inputAttrs": {
            "role": "spinbutton",
            "aria-valuemax": props.max,
            "aria-valuemin": props.min,
            "aria-valuenow": _value.value
          },
          "onInput": handleInput,
          "onFocus": handleFocus,
          "onBlur": handleBlur,
          "onClear": handleClear,
          "onChange": handleChange,
          "onKeydown": onKeyDown
        }, _slots);
      };
      return {
        inputRef,
        render
      };
    },
    methods: {
      focus() {
        var _a;
        (_a = this.inputRef) == null ? void 0 : _a.focus();
      },
      blur() {
        var _a;
        (_a = this.inputRef) == null ? void 0 : _a.blur();
      }
    },
    render() {
      return this.render();
    }
  });
  const InputNumber = Object.assign(_InputNumber, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _InputNumber.name, _InputNumber);
    }
  });
  const LayoutSiderInjectionKey = Symbol("LayoutSiderInjectionKey");
  const SiderInjectionKey = Symbol("SiderInjectionKey");
  var _sfc_main$1m = vue.defineComponent({
    name: "Layout",
    props: {
      hasSider: {
        type: Boolean
      }
    },
    setup(props) {
      const siderIds = vue.ref([]);
      const prefixCls = getPrefixCls("layout");
      const classNames = vue.computed(() => [prefixCls, {
        [`${prefixCls}-has-sider`]: props.hasSider || siderIds.value.length
      }]);
      vue.provide(LayoutSiderInjectionKey, {
        onSiderMount: (id) => siderIds.value.push(id),
        onSiderUnMount: (id) => {
          siderIds.value = siderIds.value.filter((_id) => _id !== id);
        }
      });
      return {
        classNames
      };
    }
  });
  function _sfc_render$1l(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("section", {
      class: vue.normalizeClass(_ctx.classNames)
    }, [
      vue.renderSlot(_ctx.$slots, "default")
    ], 2);
  }
  var _Layout = /* @__PURE__ */ _export_sfc(_sfc_main$1m, [["render", _sfc_render$1l]]);
  const _sfc_main$1l = vue.defineComponent({
    name: "LayoutHeader",
    setup() {
      const prefixCls = getPrefixCls("layout-header");
      const classNames = [prefixCls];
      return {
        classNames
      };
    }
  });
  function _sfc_render$1k(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("header", {
      class: vue.normalizeClass(_ctx.classNames)
    }, [
      vue.renderSlot(_ctx.$slots, "default")
    ], 2);
  }
  var LayoutHeader = /* @__PURE__ */ _export_sfc(_sfc_main$1l, [["render", _sfc_render$1k]]);
  const _sfc_main$1k = vue.defineComponent({
    name: "LayoutContent",
    setup() {
      const prefixCls = getPrefixCls("layout-content");
      const classNames = [prefixCls];
      return {
        classNames
      };
    }
  });
  function _sfc_render$1j(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("main", {
      class: vue.normalizeClass(_ctx.classNames)
    }, [
      vue.renderSlot(_ctx.$slots, "default")
    ], 2);
  }
  var LayoutContent = /* @__PURE__ */ _export_sfc(_sfc_main$1k, [["render", _sfc_render$1j]]);
  const _sfc_main$1j = vue.defineComponent({
    name: "LayoutFooter",
    setup() {
      const prefixCls = getPrefixCls("layout-footer");
      const classNames = [prefixCls];
      return {
        classNames
      };
    }
  });
  function _sfc_render$1i(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("footer", {
      class: vue.normalizeClass(_ctx.classNames)
    }, [
      vue.renderSlot(_ctx.$slots, "default")
    ], 2);
  }
  var LayoutFooter = /* @__PURE__ */ _export_sfc(_sfc_main$1j, [["render", _sfc_render$1i]]);
  const _sfc_main$1i = vue.defineComponent({
    name: "IconDragDot",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-drag-dot`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$x = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$r = /* @__PURE__ */ vue.createElementVNode("path", {
    d: "M40 17v2h-2v-2h2ZM25 17v2h-2v-2h2ZM10 17v2H8v-2h2ZM40 29v2h-2v-2h2ZM25 29v2h-2v-2h2ZM10 29v2H8v-2h2Z",
    fill: "currentColor",
    stroke: "none"
  }, null, -1);
  const _hoisted_3$p = /* @__PURE__ */ vue.createElementVNode("path", { d: "M40 17v2h-2v-2h2ZM25 17v2h-2v-2h2ZM10 17v2H8v-2h2ZM40 29v2h-2v-2h2ZM25 29v2h-2v-2h2ZM10 29v2H8v-2h2Z" }, null, -1);
  const _hoisted_4$8 = [
    _hoisted_2$r,
    _hoisted_3$p
  ];
  function _sfc_render$1h(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_4$8, 14, _hoisted_1$x);
  }
  var _IconDragDot = /* @__PURE__ */ _export_sfc(_sfc_main$1i, [["render", _sfc_render$1h]]);
  const IconDragDot = Object.assign(_IconDragDot, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconDragDot.name, _IconDragDot);
    }
  });
  const _sfc_main$1h = vue.defineComponent({
    name: "IconDragDotVertical",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-drag-dot-vertical`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$w = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$q = /* @__PURE__ */ vue.createElementVNode("path", {
    d: "M17 8h2v2h-2V8ZM17 23h2v2h-2v-2ZM17 38h2v2h-2v-2ZM29 8h2v2h-2V8ZM29 23h2v2h-2v-2ZM29 38h2v2h-2v-2Z",
    fill: "currentColor",
    stroke: "none"
  }, null, -1);
  const _hoisted_3$o = /* @__PURE__ */ vue.createElementVNode("path", { d: "M17 8h2v2h-2V8ZM17 23h2v2h-2v-2ZM17 38h2v2h-2v-2ZM29 8h2v2h-2V8ZM29 23h2v2h-2v-2ZM29 38h2v2h-2v-2Z" }, null, -1);
  const _hoisted_4$7 = [
    _hoisted_2$q,
    _hoisted_3$o
  ];
  function _sfc_render$1g(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_4$7, 14, _hoisted_1$w);
  }
  var _IconDragDotVertical = /* @__PURE__ */ _export_sfc(_sfc_main$1h, [["render", _sfc_render$1g]]);
  const IconDragDotVertical = Object.assign(_IconDragDotVertical, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconDragDotVertical.name, _IconDragDotVertical);
    }
  });
  var _sfc_main$1g = vue.defineComponent({
    name: "ResizeTrigger",
    components: {
      ResizeObserver: ResizeObserver$1,
      IconDragDot,
      IconDragDotVertical
    },
    props: {
      prefixCls: {
        type: String,
        required: true
      },
      direction: {
        type: String,
        default: "horizontal"
      }
    },
    emits: ["resize"],
    setup(props, {
      emit
    }) {
      const {
        direction,
        prefixCls
      } = vue.toRefs(props);
      const isHorizontal2 = vue.computed(() => (direction == null ? void 0 : direction.value) === "horizontal");
      const classNames = vue.computed(() => [prefixCls.value, {
        [`${prefixCls.value}-horizontal`]: isHorizontal2.value,
        [`${prefixCls.value}-vertical`]: !isHorizontal2.value
      }]);
      const onResize = (entry) => {
        emit("resize", entry);
      };
      return {
        classNames,
        onResize,
        isHorizontal: isHorizontal2
      };
    }
  });
  function _sfc_render$1f(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_IconDragDot = vue.resolveComponent("IconDragDot");
    const _component_IconDragDotVertical = vue.resolveComponent("IconDragDotVertical");
    const _component_ResizeObserver = vue.resolveComponent("ResizeObserver");
    return vue.openBlock(), vue.createBlock(_component_ResizeObserver, { onResize: _ctx.onResize }, {
      default: vue.withCtx(() => [
        vue.createElementVNode("div", {
          class: vue.normalizeClass(_ctx.classNames)
        }, [
          vue.createCommentVNode(" @slot \u81EA\u5B9A\u4E49\u5185\u5BB9 "),
          vue.renderSlot(_ctx.$slots, "default", {}, () => [
            vue.createElementVNode("div", {
              class: vue.normalizeClass(`${_ctx.prefixCls}-icon-wrapper`)
            }, [
              vue.createCommentVNode(" @slot \u81EA\u5B9A\u4E49 icon "),
              vue.renderSlot(_ctx.$slots, "icon", {}, () => [
                _ctx.isHorizontal ? (vue.openBlock(), vue.createBlock(_component_IconDragDot, {
                  key: 0,
                  class: vue.normalizeClass(`${_ctx.prefixCls}-icon`)
                }, null, 8, ["class"])) : (vue.openBlock(), vue.createBlock(_component_IconDragDotVertical, {
                  key: 1,
                  class: vue.normalizeClass(`${_ctx.prefixCls}-icon`)
                }, null, 8, ["class"]))
              ])
            ], 2)
          ])
        ], 2)
      ]),
      _: 3
    }, 8, ["onResize"]);
  }
  var ResizeTrigger = /* @__PURE__ */ _export_sfc(_sfc_main$1g, [["render", _sfc_render$1f]]);
  const DIRECTION_LEFT = "left";
  const DIRECTION_RIGHT = "right";
  const DIRECTION_TOP = "top";
  const DIRECTION_BOTTOM = "bottom";
  const allDirections = [
    DIRECTION_LEFT,
    DIRECTION_RIGHT,
    DIRECTION_TOP,
    DIRECTION_BOTTOM
  ];
  function getRealSize(pageSize, padding) {
    if (pageSize === 0)
      return 0;
    const res = pageSize - padding;
    return res <= 0 ? 0 : res;
  }
  function isHorizontal(direction) {
    return [DIRECTION_TOP, DIRECTION_BOTTOM].indexOf(direction) > -1;
  }
  const _sfc_main$1f = vue.defineComponent({
    name: "ResizeBox",
    components: {
      ResizeTrigger
    },
    inheritAttrs: false,
    props: {
      width: {
        type: Number
      },
      height: {
        type: Number
      },
      component: {
        type: String,
        default: "div"
      },
      directions: {
        type: Array,
        default: () => ["right"]
      }
    },
    emits: {
      "update:width": (width) => true,
      "update:height": (height) => true,
      "movingStart": (ev) => true,
      "moving": (size, ev) => true,
      "movingEnd": (ev) => true
    },
    setup(props, { emit }) {
      const { height: propHeight, width: propWidth, directions } = vue.toRefs(props);
      const [width, setWidth] = useMergeState(null, vue.reactive({
        value: propWidth
      }));
      const [height, setHeight] = useMergeState(null, vue.reactive({
        value: propHeight
      }));
      const wrapperRef = vue.ref();
      const paddingStyles = vue.reactive({});
      const prefixCls = getPrefixCls("resizebox");
      const classNames = vue.computed(() => [prefixCls]);
      const styles = vue.computed(() => {
        return __spreadValues(__spreadValues(__spreadValues({}, isNumber$1(width.value) ? { width: `${width.value}px` } : {}), isNumber$1(height.value) ? { height: `${height.value}px` } : {}), paddingStyles);
      });
      const allowDirections = vue.computed(() => directions.value.filter((direction) => allDirections.includes(direction)));
      const record = {
        direction: "",
        startPageX: 0,
        startPageY: 0,
        startWidth: 0,
        startHeight: 0,
        moving: false,
        padding: {
          left: 0,
          right: 0,
          top: 0,
          bottom: 0
        }
      };
      function onMoving(e2) {
        if (!record.moving)
          return;
        const { startPageX, startPageY, startWidth, startHeight, direction } = record;
        let newWidth = startWidth;
        let newHeight = startHeight;
        const offsetX = e2.pageX - startPageX;
        const offsetY = e2.pageY - startPageY;
        switch (direction) {
          case DIRECTION_LEFT:
            newWidth = startWidth - offsetX;
            setWidth(newWidth);
            emit("update:width", newWidth);
            break;
          case DIRECTION_RIGHT:
            newWidth = startWidth + offsetX;
            setWidth(newWidth);
            emit("update:width", newWidth);
            break;
          case DIRECTION_TOP:
            newHeight = startHeight - offsetY;
            setHeight(newHeight);
            emit("update:height", newHeight);
            break;
          case DIRECTION_BOTTOM:
            newHeight = startHeight + offsetY;
            setHeight(newHeight);
            emit("update:height", newHeight);
            break;
        }
        emit("moving", {
          width: newWidth,
          height: newHeight
        }, e2);
      }
      function onMoveEnd(e2) {
        record.moving = false;
        off(window, "mousemove", onMoving);
        off(window, "mouseup", onMoveEnd);
        off(window, "contextmenu", onMoveEnd);
        document.body.style.cursor = "default";
        emit("movingEnd", e2);
      }
      function onMoveStart(direction, e2) {
        var _a, _b;
        emit("movingStart", e2);
        record.moving = true;
        record.startPageX = e2.pageX;
        record.startPageY = e2.pageY;
        record.direction = direction;
        const { top, left, right, bottom } = record.padding;
        record.startWidth = getRealSize(((_a = wrapperRef.value) == null ? void 0 : _a.clientWidth) || 0, left + right);
        record.startHeight = getRealSize(((_b = wrapperRef.value) == null ? void 0 : _b.clientHeight) || 0, top + bottom);
        on(window, "mousemove", onMoving);
        on(window, "mouseup", onMoveEnd);
        on(window, "contextmenu", onMoveEnd);
        document.body.style.cursor = isHorizontal(direction) ? "row-resize" : "col-resize";
      }
      function onTiggerResize(direction, entry) {
        const { width: width2, height: height2 } = entry.contentRect;
        const size = isHorizontal(direction) ? height2 : width2;
        record.padding[direction] = size;
        paddingStyles[`padding-${direction}`] = `${size}px`;
      }
      return {
        prefixCls,
        classNames,
        styles,
        wrapperRef,
        onMoveStart,
        isHorizontal,
        allowDirections,
        onTiggerResize
      };
    }
  });
  function _sfc_render$1e(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_ResizeTrigger = vue.resolveComponent("ResizeTrigger");
    return vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.component), vue.mergeProps({
      ref: "wrapperRef",
      class: _ctx.classNames
    }, _ctx.$attrs, { style: _ctx.styles }), {
      default: vue.withCtx(() => [
        vue.renderSlot(_ctx.$slots, "default"),
        (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.allowDirections, (direction) => {
          return vue.openBlock(), vue.createBlock(_component_ResizeTrigger, {
            key: direction,
            "prefix-cls": `${_ctx.prefixCls}-trigger`,
            class: vue.normalizeClass(`${_ctx.prefixCls}-direction-${direction}`),
            direction: _ctx.isHorizontal(direction) ? "horizontal" : "vertical",
            onMousedown: (e2) => {
              _ctx.onMoveStart(direction, e2);
            },
            onResize: (entry) => {
              _ctx.onTiggerResize(direction, entry);
            }
          }, vue.createSlots({
            default: vue.withCtx(() => [
              _ctx.$slots["resize-trigger"] ? vue.renderSlot(_ctx.$slots, "resize-trigger", {
                key: 0,
                direction
              }) : vue.createCommentVNode("v-if", true)
            ]),
            _: 2
          }, [
            _ctx.$slots["resize-trigger-icon"] ? {
              name: "icon",
              fn: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "resize-trigger-icon", { direction })
              ])
            } : void 0
          ]), 1032, ["prefix-cls", "class", "direction", "onMousedown", "onResize"]);
        }), 128))
      ]),
      _: 3
    }, 16, ["class", "style"]);
  }
  var _ResizeBox = /* @__PURE__ */ _export_sfc(_sfc_main$1f, [["render", _sfc_render$1e]]);
  const ResizeBox = Object.assign(_ResizeBox, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _ResizeBox.name, _ResizeBox);
    }
  });
  function useResponsive(breakpoint, callback) {
    const resultBreakpoint = vue.computed(() => vue.isRef(breakpoint) ? breakpoint.value : breakpoint);
    let subscribeToken = "";
    vue.onMounted(() => {
      subscribeToken = responsiveObserve.subscribe((screens2, breakpointChecked) => {
        if (!resultBreakpoint.value)
          return;
        if (!breakpointChecked || breakpointChecked === resultBreakpoint.value) {
          callback(!!screens2[resultBreakpoint.value]);
        }
      });
    });
    vue.onUnmounted(() => {
      if (subscribeToken) {
        responsiveObserve.unsubscribe(subscribeToken);
      }
    });
  }
  const generateId$1 = (() => {
    let i = 0;
    return (prefix = "") => {
      i += 1;
      return `${prefix}${i}`;
    };
  })();
  var _sfc_main$1e = vue.defineComponent({
    name: "LayoutSider",
    components: {
      IconLeft,
      IconRight,
      ResizeBox
    },
    props: {
      theme: {
        type: String,
        default: "light"
      },
      collapsed: {
        type: Boolean,
        default: void 0
      },
      defaultCollapsed: {
        type: Boolean
      },
      collapsible: {
        type: Boolean
      },
      width: {
        type: Number,
        default: 200
      },
      collapsedWidth: {
        type: Number,
        default: 48
      },
      reverseArrow: {
        type: Boolean
      },
      breakpoint: {
        type: String
      },
      resizeDirections: {
        type: Array,
        default: void 0
      },
      hideTrigger: {
        type: Boolean
      }
    },
    emits: [
      "collapse",
      "update:collapsed",
      "breakpoint"
    ],
    setup(props, {
      emit
    }) {
      const {
        theme,
        collapsed,
        defaultCollapsed,
        collapsible,
        hideTrigger,
        breakpoint,
        collapsedWidth,
        resizeDirections
      } = vue.toRefs(props);
      const [localCollapsed, setLocalCollapsed] = useMergeState(defaultCollapsed.value, vue.reactive({
        value: collapsed
      }));
      const componentTag = vue.computed(() => resizeDirections.value ? "ResizeBox" : "div");
      const showTrigger = vue.computed(() => collapsible.value && !hideTrigger.value);
      const prefixCls = getPrefixCls("layout-sider");
      const classNames = vue.computed(() => [prefixCls, {
        [`${prefixCls}-light`]: theme.value === "light",
        [`${prefixCls}-has-trigger`]: showTrigger.value,
        [`${prefixCls}-collapsed`]: collapsed.value
      }]);
      const siderWidth = vue.computed(() => {
        const {
          width,
          collapsedWidth: collapsedWidth2
        } = props;
        const rawWidth = localCollapsed.value ? collapsedWidth2 : width;
        return isNumber$1(rawWidth) ? `${rawWidth}px` : String(rawWidth);
      });
      const triggerClassNames = vue.computed(() => [`${prefixCls}-trigger`, {
        [`${prefixCls}-trigger-light`]: theme.value === "light"
      }]);
      const toggleTrigger = () => {
        const newCollapsed = !localCollapsed.value;
        setLocalCollapsed(newCollapsed);
        emit("update:collapsed", newCollapsed);
        emit("collapse", newCollapsed, "clickTrigger");
      };
      useResponsive(breakpoint, (checked) => {
        const newCollapsed = !checked;
        if (newCollapsed !== localCollapsed.value) {
          setLocalCollapsed(newCollapsed);
          emit("update:collapsed", newCollapsed);
          emit("collapse", newCollapsed, "responsive");
          emit("breakpoint", newCollapsed);
        }
      });
      const uniqueId = generateId$1("__arco_layout_sider");
      const siderHook = vue.inject(LayoutSiderInjectionKey, void 0);
      vue.onMounted(() => {
        var _a;
        (_a = siderHook == null ? void 0 : siderHook.onSiderMount) == null ? void 0 : _a.call(siderHook, uniqueId);
      });
      vue.onUnmounted(() => {
        var _a;
        (_a = siderHook == null ? void 0 : siderHook.onSiderUnMount) == null ? void 0 : _a.call(siderHook, uniqueId);
      });
      vue.provide(SiderInjectionKey, vue.reactive({
        theme,
        collapsed: localCollapsed,
        collapsedWidth
      }));
      return {
        componentTag,
        prefixCls,
        classNames,
        triggerClassNames,
        localCollapsed,
        siderWidth,
        showTrigger,
        toggleTrigger
      };
    }
  });
  const _hoisted_1$v = { key: 0 };
  const _hoisted_2$p = { key: 1 };
  function _sfc_render$1d(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_IconLeft = vue.resolveComponent("IconLeft");
    const _component_IconRight = vue.resolveComponent("IconRight");
    return vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.componentTag), vue.mergeProps({
      class: _ctx.classNames,
      style: { width: _ctx.siderWidth }
    }, _ctx.resizeDirections ? { directions: _ctx.resizeDirections } : {}), {
      default: vue.withCtx(() => [
        vue.createElementVNode("div", {
          class: vue.normalizeClass(`${_ctx.prefixCls}-children`)
        }, [
          vue.renderSlot(_ctx.$slots, "default")
        ], 2),
        _ctx.showTrigger ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 0,
          class: vue.normalizeClass(_ctx.triggerClassNames),
          style: vue.normalizeStyle({ width: _ctx.siderWidth }),
          onClick: _cache[0] || (_cache[0] = (...args) => _ctx.toggleTrigger && _ctx.toggleTrigger(...args))
        }, [
          vue.renderSlot(_ctx.$slots, "trigger", { collapsed: _ctx.localCollapsed }, () => [
            !_ctx.reverseArrow ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_1$v, [
              !_ctx.localCollapsed ? (vue.openBlock(), vue.createBlock(_component_IconLeft, { key: 0 })) : (vue.openBlock(), vue.createBlock(_component_IconRight, { key: 1 }))
            ])) : (vue.openBlock(), vue.createElementBlock("div", _hoisted_2$p, [
              _ctx.localCollapsed ? (vue.openBlock(), vue.createBlock(_component_IconLeft, { key: 0 })) : (vue.openBlock(), vue.createBlock(_component_IconRight, { key: 1 }))
            ]))
          ])
        ], 6)) : vue.createCommentVNode("v-if", true)
      ]),
      _: 3
    }, 16, ["class", "style"]);
  }
  var LayoutSider = /* @__PURE__ */ _export_sfc(_sfc_main$1e, [["render", _sfc_render$1d]]);
  const Layout = Object.assign(_Layout, {
    Header: LayoutHeader,
    Content: LayoutContent,
    Footer: LayoutFooter,
    Sider: LayoutSider,
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Layout.name, _Layout);
      app.component(componentPrefix + LayoutHeader.name, LayoutHeader);
      app.component(componentPrefix + LayoutContent.name, LayoutContent);
      app.component(componentPrefix + LayoutFooter.name, LayoutFooter);
      app.component(componentPrefix + LayoutSider.name, LayoutSider);
    }
  });
  const _sfc_main$1d = vue.defineComponent({
    name: "Pager",
    props: {
      pageNumber: {
        type: Number
      },
      current: {
        type: Number
      },
      disabled: {
        type: Boolean,
        default: false
      },
      style: {
        type: Object
      },
      activeStyle: {
        type: Object
      }
    },
    emits: ["click"],
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("pagination-item");
      const isActive = vue.computed(() => props.current === props.pageNumber);
      const handleClick = (e2) => {
        if (!props.disabled) {
          emit("click", props.pageNumber, e2);
        }
      };
      const cls = vue.computed(() => [
        prefixCls,
        {
          [`${prefixCls}-active`]: isActive.value
        }
      ]);
      const mergedStyle = vue.computed(() => {
        return isActive.value ? props.activeStyle : props.style;
      });
      return {
        prefixCls,
        cls,
        mergedStyle,
        handleClick
      };
    }
  });
  function _sfc_render$1c(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("li", {
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.mergedStyle),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    }, [
      vue.renderSlot(_ctx.$slots, "default", { page: _ctx.pageNumber }, () => [
        vue.createTextVNode(vue.toDisplayString(_ctx.pageNumber), 1)
      ])
    ], 6);
  }
  var Pager = /* @__PURE__ */ _export_sfc(_sfc_main$1d, [["render", _sfc_render$1c]]);
  const getLegalPage = (page, { min, max }) => {
    if (page < min) {
      return min;
    }
    if (page > max) {
      return max;
    }
    return page;
  };
  const _sfc_main$1c = vue.defineComponent({
    name: "StepPager",
    components: {
      IconLeft,
      IconRight
    },
    props: {
      pages: {
        type: Number,
        required: true
      },
      current: {
        type: Number,
        required: true
      },
      type: {
        type: String,
        required: true
      },
      disabled: {
        type: Boolean,
        default: false
      },
      simple: {
        type: Boolean,
        default: false
      }
    },
    emits: ["click"],
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("pagination-item");
      const isNext = props.type === "next";
      const mergedDisabled = vue.computed(() => {
        if (props.disabled) {
          return props.disabled;
        }
        if (!props.pages) {
          return true;
        }
        if (isNext && props.current === props.pages) {
          return true;
        }
        return !isNext && props.current <= 1;
      });
      const nextPage = vue.computed(() => getLegalPage(props.current + (isNext ? 1 : -1), {
        min: 1,
        max: props.pages
      }));
      const handleClick = (e2) => {
        if (!mergedDisabled.value) {
          emit("click", nextPage.value);
        }
      };
      const cls = vue.computed(() => [
        prefixCls,
        `${prefixCls}-${props.type}`,
        {
          [`${prefixCls}-disabled`]: mergedDisabled.value
        }
      ]);
      return {
        prefixCls,
        cls,
        isNext,
        handleClick
      };
    }
  });
  function _sfc_render$1b(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_icon_right = vue.resolveComponent("icon-right");
    const _component_icon_left = vue.resolveComponent("icon-left");
    return vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.simple ? "span" : "li"), {
      class: vue.normalizeClass(_ctx.cls),
      onClick: _ctx.handleClick
    }, {
      default: vue.withCtx(() => [
        vue.renderSlot(_ctx.$slots, "default", {
          type: _ctx.isNext ? "next" : "previous"
        }, () => [
          _ctx.isNext ? (vue.openBlock(), vue.createBlock(_component_icon_right, { key: 0 })) : (vue.openBlock(), vue.createBlock(_component_icon_left, { key: 1 }))
        ])
      ]),
      _: 3
    }, 8, ["class", "onClick"]);
  }
  var StepPager = /* @__PURE__ */ _export_sfc(_sfc_main$1c, [["render", _sfc_render$1b]]);
  const _sfc_main$1b = vue.defineComponent({
    name: "EllipsisPager",
    components: {
      IconMore
    },
    props: {
      current: {
        type: Number,
        required: true
      },
      step: {
        type: Number,
        default: 5
      },
      pages: {
        type: Number,
        required: true
      }
    },
    emits: ["click"],
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("pagination-item");
      const nextPage = vue.computed(() => getLegalPage(props.current + props.step, {
        min: 1,
        max: props.pages
      }));
      const handleClick = (e2) => {
        emit("click", nextPage.value);
      };
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-ellipsis`]);
      return {
        prefixCls,
        cls,
        handleClick
      };
    }
  });
  function _sfc_render$1a(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_icon_more = vue.resolveComponent("icon-more");
    return vue.openBlock(), vue.createElementBlock("li", {
      class: vue.normalizeClass(_ctx.cls),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    }, [
      vue.renderSlot(_ctx.$slots, "default", {}, () => [
        vue.createVNode(_component_icon_more)
      ])
    ], 2);
  }
  var EllipsisPager = /* @__PURE__ */ _export_sfc(_sfc_main$1b, [["render", _sfc_render$1a]]);
  const _sfc_main$1a = vue.defineComponent({
    name: "PageJumper",
    components: {
      InputNumber
    },
    props: {
      current: {
        type: Number,
        required: true
      },
      simple: {
        type: Boolean,
        default: false
      },
      disabled: {
        type: Boolean,
        default: false
      },
      pages: {
        type: Number,
        required: true
      },
      size: {
        type: String
      },
      onChange: {
        type: Function
      }
    },
    emits: ["change"],
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("pagination-jumper");
      const { t: t2 } = useI18n();
      const inputValue = vue.ref(props.simple ? props.current : void 0);
      const handleFormatter = (value) => {
        const parseIntVal = parseInt(value.toString(), 10);
        return Number.isNaN(parseIntVal) ? void 0 : String(parseIntVal);
      };
      const handleChange = (value) => {
        emit("change", inputValue.value);
        vue.nextTick(() => {
          if (!props.simple) {
            inputValue.value = void 0;
          }
        });
      };
      vue.watch(() => props.current, (value) => {
        if (props.simple && value !== inputValue.value) {
          inputValue.value = value;
        }
      });
      const cls = vue.computed(() => [
        prefixCls,
        {
          [`${prefixCls}-simple`]: props.simple
        }
      ]);
      return {
        prefixCls,
        cls,
        t: t2,
        inputValue,
        handleChange,
        handleFormatter
      };
    }
  });
  function _sfc_render$19(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_input_number = vue.resolveComponent("input-number");
    return vue.openBlock(), vue.createElementBlock("span", {
      class: vue.normalizeClass(_ctx.cls)
    }, [
      !_ctx.simple ? (vue.openBlock(), vue.createElementBlock("span", {
        key: 0,
        class: vue.normalizeClass([`${_ctx.prefixCls}-prepend`, `${_ctx.prefixCls}-text-goto`])
      }, [
        vue.renderSlot(_ctx.$slots, "jumper-prepend", {}, () => [
          vue.createTextVNode(vue.toDisplayString(_ctx.t("pagination.goto")), 1)
        ])
      ], 2)) : vue.createCommentVNode("v-if", true),
      vue.createVNode(_component_input_number, {
        modelValue: _ctx.inputValue,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.inputValue = $event),
        class: vue.normalizeClass(`${_ctx.prefixCls}-input`),
        min: 1,
        max: _ctx.pages,
        size: _ctx.size,
        disabled: _ctx.disabled,
        "hide-button": "",
        formatter: _ctx.handleFormatter,
        onChange: _ctx.handleChange
      }, null, 8, ["modelValue", "class", "max", "size", "disabled", "formatter", "onChange"]),
      _ctx.$slots["jumper-append"] ? (vue.openBlock(), vue.createElementBlock("span", {
        key: 1,
        class: vue.normalizeClass(`${_ctx.prefixCls}-append`)
      }, [
        vue.renderSlot(_ctx.$slots, "jumper-append")
      ], 2)) : vue.createCommentVNode("v-if", true),
      _ctx.simple ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 2 }, [
        vue.createElementVNode("span", {
          class: vue.normalizeClass(`${_ctx.prefixCls}-separator`)
        }, "/", 2),
        vue.createElementVNode("span", {
          class: vue.normalizeClass(`${_ctx.prefixCls}-total-page`)
        }, vue.toDisplayString(_ctx.pages), 3)
      ], 64)) : vue.createCommentVNode("v-if", true)
    ], 2);
  }
  var PageJumper = /* @__PURE__ */ _export_sfc(_sfc_main$1a, [["render", _sfc_render$19]]);
  const _sfc_main$19 = vue.defineComponent({
    name: "PageOptions",
    components: {
      ArcoSelect: Select
    },
    props: {
      sizeOptions: {
        type: Array,
        required: true
      },
      pageSize: Number,
      disabled: Boolean,
      size: {
        type: String
      },
      onChange: {
        type: Function
      },
      selectProps: {
        type: Object
      }
    },
    emits: ["change"],
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("pagination-options");
      const { t: t2 } = useI18n();
      const options = vue.computed(() => props.sizeOptions.map((value) => ({
        value,
        label: `${value} ${t2("pagination.countPerPage")}`
      })));
      const handleChange = (value) => {
        emit("change", value);
      };
      return {
        prefixCls,
        options,
        handleChange
      };
    }
  });
  function _sfc_render$18(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_arco_select = vue.resolveComponent("arco-select");
    return vue.openBlock(), vue.createElementBlock("span", {
      class: vue.normalizeClass(_ctx.prefixCls)
    }, [
      vue.createVNode(_component_arco_select, vue.mergeProps({
        "model-value": _ctx.pageSize,
        options: _ctx.options,
        size: _ctx.size,
        disabled: _ctx.disabled
      }, _ctx.selectProps, { onChange: _ctx.handleChange }), null, 16, ["model-value", "options", "size", "disabled", "onChange"])
    ], 2);
  }
  var PageOptions = /* @__PURE__ */ _export_sfc(_sfc_main$19, [["render", _sfc_render$18]]);
  var _Pagination = vue.defineComponent({
    name: "Pagination",
    props: {
      total: {
        type: Number,
        required: true
      },
      current: Number,
      defaultCurrent: {
        type: Number,
        default: 1
      },
      pageSize: Number,
      defaultPageSize: {
        type: Number,
        default: 10
      },
      disabled: {
        type: Boolean,
        default: false
      },
      hideOnSinglePage: {
        type: Boolean,
        default: false
      },
      simple: {
        type: Boolean,
        default: false
      },
      showTotal: {
        type: Boolean,
        default: false
      },
      showMore: {
        type: Boolean,
        default: false
      },
      showJumper: {
        type: Boolean,
        default: false
      },
      showPageSize: {
        type: Boolean,
        default: false
      },
      pageSizeOptions: {
        type: Array,
        default: () => [10, 20, 30, 40, 50]
      },
      pageSizeProps: {
        type: Object
      },
      size: {
        type: String
      },
      pageItemStyle: {
        type: Object
      },
      activePageItemStyle: {
        type: Object
      },
      baseSize: {
        type: Number,
        default: 6
      },
      bufferSize: {
        type: Number,
        default: 2
      },
      autoAdjust: {
        type: Boolean,
        default: true
      }
    },
    emits: {
      "update:current": (current) => true,
      "update:pageSize": (pageSize) => true,
      "change": (current) => true,
      "pageSizeChange": (pageSize) => true
    },
    setup(props, {
      emit,
      slots
    }) {
      const prefixCls = getPrefixCls("pagination");
      const {
        t: t2
      } = useI18n();
      const {
        disabled,
        pageItemStyle,
        activePageItemStyle,
        size
      } = vue.toRefs(props);
      const {
        mergedSize
      } = useSize$1(size);
      const _current = vue.ref(props.defaultCurrent);
      const _pageSize = vue.ref(props.defaultPageSize);
      const computedCurrent = vue.computed(() => {
        var _a;
        return (_a = props.current) != null ? _a : _current.value;
      });
      const computedPageSize = vue.computed(() => {
        var _a;
        return (_a = props.pageSize) != null ? _a : _pageSize.value;
      });
      const pages = vue.computed(() => Math.ceil(props.total / computedPageSize.value));
      const handleClick = (page) => {
        if (page !== computedCurrent.value && isNumber$1(page) && !props.disabled) {
          _current.value = page;
          emit("update:current", page);
          emit("change", page);
        }
      };
      const handlePageSizeChange = (pageSize) => {
        _pageSize.value = pageSize;
        emit("update:pageSize", pageSize);
        emit("pageSizeChange", pageSize);
      };
      const pagerProps = vue.reactive({
        current: computedCurrent,
        pages,
        disabled,
        style: pageItemStyle,
        activeStyle: activePageItemStyle,
        onClick: handleClick
      });
      const getPageItemElement = (type, props2 = {}) => {
        if (type === "more") {
          return vue.createVNode(EllipsisPager, vue.mergeProps(props2, pagerProps), {
            default: slots["page-item-ellipsis"]
          });
        }
        if (type === "previous") {
          return vue.createVNode(StepPager, vue.mergeProps({
            "type": "previous"
          }, props2, pagerProps), {
            default: slots["page-item-step"]
          });
        }
        if (type === "next") {
          return vue.createVNode(StepPager, vue.mergeProps({
            "type": "next"
          }, props2, pagerProps), {
            default: slots["page-item-step"]
          });
        }
        return vue.createVNode(Pager, vue.mergeProps(props2, pagerProps), {
          default: slots["page-item"]
        });
      };
      const pageList = vue.computed(() => {
        const pageList2 = [];
        if (pages.value < props.baseSize + props.bufferSize * 2) {
          for (let i = 1; i <= pages.value; i++) {
            pageList2.push(getPageItemElement("page", {
              key: i,
              pageNumber: i
            }));
          }
        } else {
          let left = 1;
          let right = pages.value;
          let hasLeftEllipsis = false;
          let hasRightEllipsis = false;
          if (computedCurrent.value > 2 + props.bufferSize) {
            hasLeftEllipsis = true;
            left = Math.min(computedCurrent.value - props.bufferSize, pages.value - 2 * props.bufferSize);
          }
          if (computedCurrent.value < pages.value - (props.bufferSize + 1)) {
            hasRightEllipsis = true;
            right = Math.max(computedCurrent.value + props.bufferSize, 2 * props.bufferSize + 1);
          }
          if (hasLeftEllipsis) {
            pageList2.push(getPageItemElement("page", {
              key: 1,
              pageNumber: 1
            }));
            pageList2.push(getPageItemElement("more", {
              key: "left-ellipsis-pager",
              step: -(props.bufferSize * 2 + 1)
            }));
          }
          for (let i = left; i <= right; i++) {
            pageList2.push(getPageItemElement("page", {
              key: i,
              pageNumber: i
            }));
          }
          if (hasRightEllipsis) {
            pageList2.push(getPageItemElement("more", {
              key: "right-ellipsis-pager",
              step: props.bufferSize * 2 + 1
            }));
            pageList2.push(getPageItemElement("page", {
              key: pages.value,
              pageNumber: pages.value
            }));
          }
        }
        return pageList2;
      });
      const renderPager = () => {
        if (props.simple) {
          return vue.createVNode("span", {
            "class": `${prefixCls}-simple`
          }, [getPageItemElement("previous", {
            simple: true
          }), vue.createVNode(PageJumper, {
            "disabled": props.disabled,
            "current": computedCurrent.value,
            "size": mergedSize.value,
            "pages": pages.value,
            "simple": true,
            "onChange": handleClick
          }, null), getPageItemElement("next", {
            simple: true
          })]);
        }
        return vue.createVNode("ul", {
          "class": `${prefixCls}-list`
        }, [getPageItemElement("previous", {
          simple: true
        }), pageList.value, props.showMore && getPageItemElement("more", {
          key: "more",
          step: props.bufferSize * 2 + 1
        }), getPageItemElement("next", {
          simple: true
        })]);
      };
      vue.watch(computedPageSize, (curPageSize, prePageSize) => {
        if (props.autoAdjust && curPageSize !== prePageSize && computedCurrent.value > 1) {
          const index2 = prePageSize * (computedCurrent.value - 1) + 1;
          const newPage = Math.ceil(index2 / curPageSize);
          if (newPage !== computedCurrent.value) {
            _current.value = newPage;
            emit("update:current", newPage);
            emit("change", newPage);
          }
        }
      });
      vue.watch(pages, (curPages, prePages) => {
        if (props.autoAdjust && curPages !== prePages && computedCurrent.value > 1 && computedCurrent.value > curPages) {
          _current.value = curPages;
          emit("update:current", curPages);
          emit("change", curPages);
        }
      });
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-size-${mergedSize.value}`, {
        [`${prefixCls}-simple`]: props.simple,
        [`${prefixCls}-disabled`]: props.disabled
      }]);
      return () => {
        var _a, _b;
        if (props.hideOnSinglePage && pages.value <= 1) {
          return null;
        }
        return vue.createVNode("div", {
          "class": cls.value
        }, [props.showTotal && vue.createVNode("span", {
          "class": `${prefixCls}-total`
        }, [(_b = (_a = slots.total) == null ? void 0 : _a.call(slots, {
          total: props.total
        })) != null ? _b : t2("pagination.total", props.total)]), renderPager(), props.showPageSize && vue.createVNode(PageOptions, {
          "disabled": props.disabled,
          "sizeOptions": props.pageSizeOptions,
          "pageSize": computedPageSize.value,
          "size": mergedSize.value,
          "onChange": handlePageSizeChange,
          "selectProps": props.pageSizeProps
        }, null), !props.simple && props.showJumper && vue.createVNode(PageJumper, {
          "disabled": props.disabled,
          "current": computedCurrent.value,
          "pages": pages.value,
          "size": mergedSize.value,
          "onChange": handleClick
        }, {
          "jumper-prepend": slots["jumper-prepend"],
          "jumper-append": slots["jumper-append"]
        })]);
      };
    }
  });
  const Pagination = Object.assign(_Pagination, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Pagination.name, _Pagination);
    }
  });
  const usePagination$1 = (props, { emit }) => {
    var _a, _b;
    const _current = vue.ref(isObject$1(props.paginationProps) ? (_a = props.paginationProps.defaultCurrent) != null ? _a : 1 : 1);
    const _pageSize = vue.ref(isObject$1(props.paginationProps) ? (_b = props.paginationProps.defaultPageSize) != null ? _b : 10 : 10);
    const current = vue.computed(() => {
      var _a2;
      return isObject$1(props.paginationProps) ? (_a2 = props.paginationProps.current) != null ? _a2 : _current.value : _current.value;
    });
    const pageSize = vue.computed(() => {
      var _a2;
      return isObject$1(props.paginationProps) ? (_a2 = props.paginationProps.pageSize) != null ? _a2 : _pageSize.value : _pageSize.value;
    });
    const handlePageChange = (page) => {
      _current.value = page;
      emit("pageChange", page);
    };
    const handlePageSizeChange = (pageSize2) => {
      _pageSize.value = pageSize2;
      emit("pageSizeChange", pageSize2);
    };
    return {
      current,
      pageSize,
      handlePageChange,
      handlePageSizeChange
    };
  };
  function _isSlot$a(s) {
    return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !vue.isVNode(s);
  }
  var _List = vue.defineComponent({
    name: "List",
    props: {
      data: {
        type: Array
      },
      size: {
        type: String,
        default: "medium"
      },
      bordered: {
        type: Boolean,
        default: true
      },
      split: {
        type: Boolean,
        default: true
      },
      loading: {
        type: Boolean,
        default: false
      },
      hoverable: {
        type: Boolean,
        default: false
      },
      paginationProps: {
        type: Object
      },
      gridProps: {
        type: Object
      },
      maxHeight: {
        type: [String, Number],
        default: 0
      },
      bottomOffset: {
        type: Number,
        default: 0
      },
      virtualListProps: {
        type: Object
      },
      scrollbar: {
        type: [Object, Boolean],
        default: true
      }
    },
    emits: {
      scroll: () => true,
      reachBottom: () => true,
      pageChange: (page) => true,
      pageSizeChange: (pageSize) => true
    },
    setup(props, {
      emit,
      slots
    }) {
      const {
        scrollbar
      } = vue.toRefs(props);
      const prefixCls = getPrefixCls("list");
      const configCtx = vue.inject(configProviderInjectionKey, void 0);
      const {
        componentRef,
        elementRef: listRef
      } = useComponentRef("containerRef");
      const isVirtualList = vue.computed(() => props.virtualListProps);
      const {
        displayScrollbar,
        scrollbarProps
      } = useScrollbar(scrollbar);
      let preScrollTop = 0;
      const handleScroll = (e2) => {
        const {
          scrollTop,
          scrollHeight,
          offsetHeight
        } = e2.target;
        const bottom = Math.floor(scrollHeight - (scrollTop + offsetHeight));
        if (scrollTop > preScrollTop && bottom <= props.bottomOffset) {
          emit("reachBottom");
        }
        emit("scroll");
        preScrollTop = scrollTop;
      };
      vue.onMounted(() => {
        if (listRef.value) {
          const {
            scrollTop,
            scrollHeight,
            offsetHeight
          } = listRef.value;
          if (scrollHeight <= scrollTop + offsetHeight) {
            emit("reachBottom");
          }
        }
      });
      const {
        current,
        pageSize,
        handlePageChange,
        handlePageSizeChange
      } = usePagination$1(props, {
        emit
      });
      const getCurrentPageItems = (data) => {
        if (!props.paginationProps) {
          return data;
        }
        if (props.paginationProps && data.length > pageSize.value) {
          const startIndex = (current.value - 1) * pageSize.value;
          return data.slice(startIndex, startIndex + pageSize.value);
        }
        return data;
      };
      const renderGridItems = (data) => {
        let _slot2;
        if (!props.gridProps) {
          return null;
        }
        const currentPageItems = getCurrentPageItems(data);
        if (props.gridProps.span) {
          const items = [];
          const rowSize = 24 / props.gridProps.span;
          for (let i = 0; i < currentPageItems.length; i += rowSize) {
            let _slot;
            const nextIndex = i + rowSize;
            const rowIndex = Math.floor(i / rowSize);
            items.push(vue.createVNode(Grid.Row, {
              "key": rowIndex,
              "class": `${prefixCls}-row`,
              "gutter": props.gridProps.gutter
            }, _isSlot$a(_slot = currentPageItems.slice(i, nextIndex).map((item, index2) => {
              var _a;
              return vue.createVNode(Grid.Col, {
                "key": `${rowIndex}-${index2}`,
                "class": `${prefixCls}-col`,
                "span": (_a = props.gridProps) == null ? void 0 : _a.span
              }, {
                default: () => {
                  var _a2;
                  return [vue.isVNode(item) ? item : (_a2 = slots.item) == null ? void 0 : _a2.call(slots, {
                    item,
                    index: index2
                  })];
                }
              });
            })) ? _slot : {
              default: () => [_slot]
            }));
          }
          return items;
        }
        return vue.createVNode(Grid.Row, {
          "class": `${prefixCls}-row`,
          "gutter": props.gridProps.gutter
        }, _isSlot$a(_slot2 = currentPageItems.map((item, index2) => vue.createVNode(Grid.Col, vue.mergeProps({
          "key": index2,
          "class": `${prefixCls}-col`
        }, omit(props.gridProps, ["gutter"])), {
          default: () => {
            var _a;
            return [vue.isVNode(item) ? item : (_a = slots.item) == null ? void 0 : _a.call(slots, {
              item,
              index: index2
            })];
          }
        }))) ? _slot2 : {
          default: () => [_slot2]
        });
      };
      const renderListItems = (data) => {
        const currentPageItems = getCurrentPageItems(data);
        return currentPageItems.map((item, index2) => {
          var _a;
          return vue.isVNode(item) ? item : (_a = slots.item) == null ? void 0 : _a.call(slots, {
            item,
            index: index2
          });
        });
      };
      const renderItems = () => {
        const data = slots.default ? getAllElements(slots.default()) : props.data;
        if (data && data.length > 0) {
          return props.gridProps ? renderGridItems(data) : renderListItems(data);
        }
        return renderEmpty();
      };
      const renderPagination = () => {
        if (!props.paginationProps) {
          return null;
        }
        const paginationProps = omit(props.paginationProps, ["current", "pageSize", "defaultCurrent", "defaultPageSize"]);
        return vue.createVNode(Pagination, vue.mergeProps({
          "class": `${prefixCls}-pagination`
        }, paginationProps, {
          "current": current.value,
          "pageSize": pageSize.value,
          "onChange": handlePageChange,
          "onPageSizeChange": handlePageSizeChange
        }), null);
      };
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-${props.size}`, {
        [`${prefixCls}-bordered`]: props.bordered,
        [`${prefixCls}-split`]: props.split,
        [`${prefixCls}-hover`]: props.hoverable
      }]);
      const contentStyle = vue.computed(() => {
        if (props.maxHeight) {
          const maxHeight = isNumber$1(props.maxHeight) ? `${props.maxHeight}px` : props.maxHeight;
          return {
            maxHeight,
            overflowY: "auto"
          };
        }
        return void 0;
      });
      const contentCls = vue.computed(() => [`${prefixCls}-content`, {
        [`${prefixCls}-virtual`]: isVirtualList.value
      }]);
      const virtualListRef = vue.ref();
      const renderVirtualList = () => {
        var _a;
        const currentPageItems = getCurrentPageItems((_a = props.data) != null ? _a : []);
        return currentPageItems.length ? vue.createVNode(VirtualList, vue.mergeProps({
          "ref": virtualListRef,
          "class": contentCls.value,
          "data": currentPageItems
        }, props.virtualListProps, {
          "onScroll": handleScroll
        }), {
          item: ({
            item,
            index: index2
          }) => {
            var _a2;
            return (_a2 = slots.item) == null ? void 0 : _a2.call(slots, {
              item,
              index: index2
            });
          }
        }) : renderEmpty();
      };
      const renderScrollLoading = () => {
        if (slots["scroll-loading"]) {
          return vue.createVNode("div", {
            "class": [`${prefixCls}-item`, `${prefixCls}-scroll-loading`]
          }, [slots["scroll-loading"]()]);
        }
        return null;
      };
      const renderEmpty = () => {
        var _a, _b, _c, _d, _e;
        if (slots["scroll-loading"]) {
          return null;
        }
        return (_e = (_d = (_a = slots.empty) == null ? void 0 : _a.call(slots)) != null ? _d : (_c = configCtx == null ? void 0 : (_b = configCtx.slots).empty) == null ? void 0 : _c.call(_b, {
          component: "list"
        })) != null ? _e : vue.createVNode(Empty, null, null);
      };
      const render = () => {
        const Component = displayScrollbar.value ? Scrollbar : "div";
        return vue.createVNode("div", {
          "class": `${prefixCls}-wrapper`
        }, [vue.createVNode(Spin, {
          "class": `${prefixCls}-spin`,
          "loading": props.loading
        }, {
          default: () => [vue.createVNode(Component, vue.mergeProps({
            "ref": componentRef,
            "class": cls.value,
            "style": contentStyle.value
          }, scrollbarProps.value, {
            "onScroll": handleScroll
          }), {
            default: () => [vue.createVNode("div", {
              "class": `${prefixCls}-content-wrapper`
            }, [slots.header && vue.createVNode("div", {
              "class": `${prefixCls}-header`
            }, [slots.header()]), isVirtualList.value && !props.gridProps ? vue.createVNode(vue.Fragment, null, [renderVirtualList(), renderScrollLoading()]) : vue.createVNode("div", {
              "role": "list",
              "class": contentCls.value
            }, [renderItems(), renderScrollLoading()]), slots.footer && vue.createVNode("div", {
              "class": `${prefixCls}-footer`
            }, [slots.footer()])])]
          }), renderPagination()]
        })]);
      };
      return {
        virtualListRef,
        render
      };
    },
    methods: {
      scrollIntoView(options) {
        if (this.virtualListRef) {
          this.virtualListRef.scrollTo(options);
        }
      }
    },
    render() {
      return this.render();
    }
  });
  var ListItem = vue.defineComponent({
    name: "ListItem",
    props: {
      actionLayout: {
        type: String,
        default: "horizontal"
      }
    },
    setup(props, {
      slots
    }) {
      const prefixCls = getPrefixCls("list-item");
      const renderAction = () => {
        var _a;
        const actions = (_a = slots.actions) == null ? void 0 : _a.call(slots);
        if (!actions || !actions.length) {
          return null;
        }
        return vue.createVNode("ul", {
          "class": `${prefixCls}-action`
        }, [actions.map((item, index2) => vue.createVNode("li", {
          "key": `${prefixCls}-action-${index2}`
        }, [item]))]);
      };
      return () => {
        var _a, _b;
        return vue.createVNode("div", {
          "role": "listitem",
          "class": prefixCls
        }, [vue.createVNode("div", {
          "class": `${prefixCls}-main`
        }, [(_a = slots.meta) == null ? void 0 : _a.call(slots), vue.createVNode("div", {
          "class": `${prefixCls}-content`
        }, [(_b = slots.default) == null ? void 0 : _b.call(slots)]), props.actionLayout === "vertical" && renderAction()]), props.actionLayout === "horizontal" && renderAction(), slots.extra && vue.createVNode("div", {
          "class": `${prefixCls}-extra`
        }, [slots.extra()])]);
      };
    }
  });
  const _sfc_main$18 = vue.defineComponent({
    name: "ListItemMeta",
    props: {
      title: String,
      description: String
    },
    setup(props, { slots }) {
      const prefixCls = getPrefixCls("list-item-meta");
      const hasContent = Boolean(props.title || props.description || slots.title || slots.description);
      return {
        prefixCls,
        hasContent
      };
    }
  });
  function _sfc_render$17(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.prefixCls)
    }, [
      _ctx.$slots.avatar ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: vue.normalizeClass(`${_ctx.prefixCls}-avatar`)
      }, [
        vue.renderSlot(_ctx.$slots, "avatar")
      ], 2)) : vue.createCommentVNode("v-if", true),
      _ctx.hasContent ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 1,
        class: vue.normalizeClass(`${_ctx.prefixCls}-content`)
      }, [
        _ctx.$slots.title || _ctx.title ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 0,
          class: vue.normalizeClass(`${_ctx.prefixCls}-title`)
        }, [
          vue.renderSlot(_ctx.$slots, "title", {}, () => [
            vue.createTextVNode(vue.toDisplayString(_ctx.title), 1)
          ])
        ], 2)) : vue.createCommentVNode("v-if", true),
        _ctx.$slots.description || _ctx.description ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 1,
          class: vue.normalizeClass(`${_ctx.prefixCls}-description`)
        }, [
          vue.renderSlot(_ctx.$slots, "description", {}, () => [
            vue.createTextVNode(vue.toDisplayString(_ctx.description), 1)
          ])
        ], 2)) : vue.createCommentVNode("v-if", true)
      ], 2)) : vue.createCommentVNode("v-if", true)
    ], 2);
  }
  var ListItemMeta = /* @__PURE__ */ _export_sfc(_sfc_main$18, [["render", _sfc_render$17]]);
  const List = Object.assign(_List, {
    Item: Object.assign(ListItem, {
      Meta: ListItemMeta
    }),
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _List.name, _List);
      app.component(componentPrefix + ListItem.name, ListItem);
      app.component(componentPrefix + ListItemMeta.name, ListItemMeta);
    }
  });
  const sizeStyles = [
    "border-width",
    "box-sizing",
    "font-family",
    "font-weight",
    "font-size",
    "font-variant",
    "letter-spacing",
    "line-height",
    "padding-top",
    "padding-bottom",
    "padding-left",
    "padding-right",
    "text-indent",
    "text-rendering",
    "text-transform",
    "white-space",
    "overflow-wrap",
    "width"
  ];
  const getSizeStyles = (styleDeclaration) => {
    const styles = {};
    sizeStyles.forEach((item) => {
      styles[item] = styleDeclaration.getPropertyValue(item);
    });
    return styles;
  };
  const _sfc_main$17 = vue.defineComponent({
    name: "Textarea",
    components: { ResizeObserver: ResizeObserver$1, IconHover, IconClose },
    inheritAttrs: false,
    props: {
      modelValue: String,
      defaultValue: {
        type: String,
        default: ""
      },
      placeholder: String,
      disabled: {
        type: Boolean,
        default: false
      },
      error: {
        type: Boolean,
        default: false
      },
      maxLength: {
        type: [Number, Object],
        default: 0
      },
      showWordLimit: {
        type: Boolean,
        default: false
      },
      allowClear: {
        type: Boolean,
        default: false
      },
      autoSize: {
        type: [Boolean, Object],
        default: false
      },
      wordLength: {
        type: Function
      },
      wordSlice: {
        type: Function
      }
    },
    emits: {
      "update:modelValue": (value) => true,
      "input": (value, ev) => true,
      "change": (value, ev) => true,
      "clear": (ev) => true,
      "focus": (ev) => true,
      "blur": (ev) => true
    },
    setup(props, { emit, attrs }) {
      const { disabled, error, modelValue } = vue.toRefs(props);
      const prefixCls = getPrefixCls("textarea");
      const {
        mergedDisabled,
        mergedError: _mergedError,
        eventHandlers
      } = useFormItem({ disabled, error });
      const textareaRef = vue.ref();
      const textareaStyle = vue.ref();
      const mirrorRef = vue.ref();
      const mirrorStyle = vue.ref();
      const _value = vue.ref(props.defaultValue);
      const computedValue = vue.computed(() => {
        var _a;
        return (_a = modelValue.value) != null ? _a : _value.value;
      });
      const [recordCursor, setCursor] = useCursor(textareaRef);
      vue.watch(modelValue, (value) => {
        if (isUndefined(value) || isNull(value)) {
          _value.value = "";
        }
      });
      const maxLengthErrorOnly = vue.computed(() => isObject$1(props.maxLength) && Boolean(props.maxLength.errorOnly));
      const computedMaxLength = vue.computed(() => {
        if (isObject$1(props.maxLength)) {
          return props.maxLength.length;
        }
        return props.maxLength;
      });
      const getValueLength = (value) => {
        var _a;
        if (isFunction$1(props.wordLength)) {
          return props.wordLength(value);
        }
        return (_a = value.length) != null ? _a : 0;
      };
      const valueLength = vue.computed(() => getValueLength(computedValue.value));
      const mergedError = vue.computed(() => _mergedError.value || Boolean(computedMaxLength.value && maxLengthErrorOnly.value && valueLength.value > computedMaxLength.value));
      const isScroll2 = vue.ref(false);
      const focused = vue.ref(false);
      const showClearBtn = vue.computed(() => props.allowClear && !mergedDisabled.value && computedValue.value);
      const isComposition = vue.ref(false);
      const compositionValue = vue.ref("");
      const keepControl = () => {
        recordCursor();
        vue.nextTick(() => {
          if (textareaRef.value && computedValue.value !== textareaRef.value.value) {
            textareaRef.value.value = computedValue.value;
            setCursor();
          }
        });
      };
      const updateValue = (value, inner = true) => {
        var _a, _b;
        if (computedMaxLength.value && !maxLengthErrorOnly.value && getValueLength(value) > computedMaxLength.value) {
          value = (_b = (_a = props.wordSlice) == null ? void 0 : _a.call(props, value, computedMaxLength.value)) != null ? _b : value.slice(0, computedMaxLength.value);
        }
        _value.value = value;
        if (inner) {
          emit("update:modelValue", value);
        }
        keepControl();
      };
      let preValue = computedValue.value;
      const emitChange = (value, ev) => {
        var _a, _b;
        if (value !== preValue) {
          preValue = value;
          emit("change", value, ev);
          (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a, ev);
        }
      };
      const handleFocus = (ev) => {
        var _a, _b;
        focused.value = true;
        preValue = computedValue.value;
        emit("focus", ev);
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onFocus) == null ? void 0 : _b.call(_a, ev);
      };
      const handleBlur = (ev) => {
        var _a, _b;
        focused.value = false;
        emit("blur", ev);
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onBlur) == null ? void 0 : _b.call(_a, ev);
        emitChange(computedValue.value, ev);
      };
      const handleComposition = (e2) => {
        var _a, _b;
        const { value } = e2.target;
        if (e2.type === "compositionend") {
          isComposition.value = false;
          compositionValue.value = "";
          if (computedMaxLength.value && !maxLengthErrorOnly.value && computedValue.value.length >= computedMaxLength.value && getValueLength(value) > computedMaxLength.value) {
            keepControl();
            return;
          }
          emit("input", value, e2);
          updateValue(value);
          (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onInput) == null ? void 0 : _b.call(_a, e2);
        } else {
          isComposition.value = true;
        }
      };
      const handleInput = (e2) => {
        var _a, _b;
        const { value } = e2.target;
        if (!isComposition.value) {
          if (computedMaxLength.value && !maxLengthErrorOnly.value && computedValue.value.length >= computedMaxLength.value && getValueLength(value) > computedMaxLength.value && e2.inputType === "insertText") {
            keepControl();
            return;
          }
          emit("input", value, e2);
          updateValue(value);
          (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onInput) == null ? void 0 : _b.call(_a, e2);
        } else {
          compositionValue.value = value;
        }
      };
      const handleClear = (ev) => {
        updateValue("");
        emitChange("", ev);
        emit("clear", ev);
      };
      vue.watch(modelValue, (value) => {
        if (value !== computedValue.value) {
          updateValue(value != null ? value : "", false);
        }
      });
      const getWrapperAttrs = (attr) => omit(attrs, INPUT_EVENTS);
      const getTextareaAttrs = (attr) => pick(attrs, INPUT_EVENTS);
      const wrapperCls = vue.computed(() => [
        `${prefixCls}-wrapper`,
        {
          [`${prefixCls}-focus`]: focused.value,
          [`${prefixCls}-disabled`]: mergedDisabled.value,
          [`${prefixCls}-error`]: mergedError.value,
          [`${prefixCls}-scroll`]: isScroll2.value
        }
      ]);
      let styleDeclaration;
      const lineHeight = vue.ref(0);
      const outerHeight = vue.ref(0);
      const minHeight = vue.computed(() => {
        if (!isObject$1(props.autoSize) || !props.autoSize.minRows) {
          return 0;
        }
        return props.autoSize.minRows * lineHeight.value + outerHeight.value;
      });
      const maxHeight = vue.computed(() => {
        if (!isObject$1(props.autoSize) || !props.autoSize.maxRows) {
          return 0;
        }
        return props.autoSize.maxRows * lineHeight.value + outerHeight.value;
      });
      const getMirrorStyle = () => {
        const styles = getSizeStyles(styleDeclaration);
        lineHeight.value = Number.parseInt(styles["line-height"] || 0, 10);
        outerHeight.value = Number.parseInt(styles["border-width"] || 0, 10) * 2 + Number.parseInt(styles["padding-top"] || 0, 10) + Number.parseInt(styles["padding-bottom"] || 0, 10);
        mirrorStyle.value = styles;
        vue.nextTick(() => {
          var _a;
          const mirrorHeight = (_a = mirrorRef.value) == null ? void 0 : _a.offsetHeight;
          let height = mirrorHeight != null ? mirrorHeight : 0;
          let overflow = "hidden";
          if (minHeight.value && height < minHeight.value) {
            height = minHeight.value;
          }
          if (maxHeight.value && height > maxHeight.value) {
            height = maxHeight.value;
            overflow = "auto";
          }
          textareaStyle.value = {
            height: `${height}px`,
            resize: "none",
            overflow
          };
        });
      };
      vue.onMounted(() => {
        if (textareaRef.value) {
          styleDeclaration = window.getComputedStyle(textareaRef.value);
          if (props.autoSize) {
            getMirrorStyle();
          }
        }
        computeIsScroll();
      });
      const handleResize = () => {
        if (props.autoSize && mirrorRef.value) {
          getMirrorStyle();
        }
        computeIsScroll();
      };
      const handleMousedown = (e2) => {
        if (textareaRef.value && e2.target !== textareaRef.value) {
          e2.preventDefault();
          textareaRef.value.focus();
        }
      };
      const computeIsScroll = () => {
        if (textareaRef.value) {
          if (textareaRef.value.scrollHeight > textareaRef.value.offsetHeight) {
            if (!isScroll2.value)
              isScroll2.value = true;
          } else if (isScroll2.value) {
            isScroll2.value = false;
          }
        }
      };
      vue.watch(computedValue, () => {
        if (props.autoSize && mirrorRef.value) {
          getMirrorStyle();
        }
        computeIsScroll();
      });
      return {
        prefixCls,
        wrapperCls,
        textareaRef,
        textareaStyle,
        mirrorRef,
        mirrorStyle,
        computedValue,
        showClearBtn,
        valueLength,
        computedMaxLength,
        mergedDisabled,
        getWrapperAttrs,
        getTextareaAttrs,
        handleInput,
        handleFocus,
        handleBlur,
        handleComposition,
        handleClear,
        handleResize,
        handleMousedown
      };
    },
    methods: {
      focus() {
        var _a;
        (_a = this.$refs.textareaRef) == null ? void 0 : _a.focus();
      },
      blur() {
        var _a;
        (_a = this.$refs.textareaRef) == null ? void 0 : _a.blur();
      }
    }
  });
  const _hoisted_1$u = ["disabled", "value", "placeholder"];
  function _sfc_render$16(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_resize_observer = vue.resolveComponent("resize-observer");
    const _component_icon_close = vue.resolveComponent("icon-close");
    const _component_icon_hover = vue.resolveComponent("icon-hover");
    return vue.openBlock(), vue.createElementBlock("div", vue.mergeProps(_ctx.getWrapperAttrs(_ctx.$attrs), {
      class: _ctx.wrapperCls,
      onMousedown: _cache[7] || (_cache[7] = (...args) => _ctx.handleMousedown && _ctx.handleMousedown(...args))
    }), [
      _ctx.autoSize ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        ref: "mirrorRef",
        class: vue.normalizeClass(`${_ctx.prefixCls}-mirror`),
        style: vue.normalizeStyle(_ctx.mirrorStyle)
      }, vue.toDisplayString(`${_ctx.computedValue}
`), 7)) : vue.createCommentVNode("v-if", true),
      vue.createVNode(_component_resize_observer, { onResize: _ctx.handleResize }, {
        default: vue.withCtx(() => [
          vue.createElementVNode("textarea", vue.mergeProps({ ref: "textareaRef" }, _ctx.getTextareaAttrs(_ctx.$attrs), {
            disabled: _ctx.mergedDisabled,
            class: _ctx.prefixCls,
            style: _ctx.textareaStyle,
            value: _ctx.computedValue,
            placeholder: _ctx.placeholder,
            onInput: _cache[0] || (_cache[0] = (...args) => _ctx.handleInput && _ctx.handleInput(...args)),
            onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
            onBlur: _cache[2] || (_cache[2] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
            onCompositionstart: _cache[3] || (_cache[3] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
            onCompositionupdate: _cache[4] || (_cache[4] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
            onCompositionend: _cache[5] || (_cache[5] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args))
          }), null, 16, _hoisted_1$u)
        ]),
        _: 1
      }, 8, ["onResize"]),
      vue.renderSlot(_ctx.$slots, "suffix"),
      _ctx.computedMaxLength && _ctx.showWordLimit ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 1,
        class: vue.normalizeClass(`${_ctx.prefixCls}-word-limit`)
      }, vue.toDisplayString(_ctx.valueLength) + "/" + vue.toDisplayString(_ctx.computedMaxLength), 3)) : vue.createCommentVNode("v-if", true),
      _ctx.showClearBtn ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 2,
        class: vue.normalizeClass(`${_ctx.prefixCls}-clear-btn`),
        onClick: _cache[6] || (_cache[6] = (...args) => _ctx.handleClear && _ctx.handleClear(...args))
      }, [
        vue.createVNode(_component_icon_hover, null, {
          default: vue.withCtx(() => [
            vue.createVNode(_component_icon_close)
          ]),
          _: 1
        })
      ], 2)) : vue.createCommentVNode("v-if", true)
    ], 16);
  }
  var _Textarea = /* @__PURE__ */ _export_sfc(_sfc_main$17, [["render", _sfc_render$16]]);
  const Textarea = Object.assign(_Textarea, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Textarea.name, _Textarea);
    }
  });
  const getTextBeforeSelection = (element) => {
    const { value, selectionStart } = element;
    return value.slice(0, selectionStart);
  };
  const getLastMeasureIndex = (text, prefix) => {
    const _prefix = [].concat(prefix);
    return _prefix.reduce((pre, value) => {
      const lastIndex = text.lastIndexOf(value);
      if (lastIndex > pre.location) {
        return {
          location: lastIndex,
          prefix: value
        };
      }
      return pre;
    }, {
      location: -1,
      prefix: ""
    });
  };
  const isValidSearch = (text, split) => {
    return !split || !text.includes(split);
  };
  function _isSlot$9(s) {
    return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !vue.isVNode(s);
  }
  var _Mention = vue.defineComponent({
    name: "Mention",
    inheritAttrs: false,
    props: {
      modelValue: String,
      defaultValue: {
        type: String,
        default: ""
      },
      data: {
        type: Array,
        default: () => []
      },
      prefix: {
        type: [String, Array],
        default: "@"
      },
      split: {
        type: String,
        default: " "
      },
      type: {
        type: String,
        default: "input"
      },
      disabled: {
        type: Boolean,
        default: false
      },
      allowClear: {
        type: Boolean,
        default: false
      }
    },
    emits: {
      "update:modelValue": (value) => true,
      "change": (value) => true,
      "search": (value, prefix) => true,
      "select": (value) => true,
      "clear": (ev) => true,
      "focus": (ev) => true,
      "blur": (ev) => true
    },
    setup(props, {
      emit,
      attrs,
      slots
    }) {
      const prefixCls = getPrefixCls("mention");
      let styleDeclaration;
      const {
        mergedDisabled,
        eventHandlers
      } = useFormItem({
        disabled: vue.toRef(props, "disabled")
      });
      const {
        data,
        modelValue
      } = vue.toRefs(props);
      const dropdownRef = vue.ref();
      const optionRefs = vue.ref({});
      const _value = vue.ref(props.defaultValue);
      const computedValue = vue.computed(() => {
        var _a;
        return (_a = props.modelValue) != null ? _a : _value.value;
      });
      vue.watch(modelValue, (value) => {
        if (isUndefined(value) || isNull(value)) {
          _value.value = "";
        }
      });
      const computedValueKeys = vue.computed(() => computedValue.value ? [getKeyFromValue(computedValue.value)] : []);
      const measureInfo = vue.ref({
        measuring: false,
        location: -1,
        prefix: "",
        text: ""
      });
      const resetMeasureInfo = () => {
        measureInfo.value = {
          measuring: false,
          location: -1,
          prefix: "",
          text: ""
        };
      };
      const inputRef = vue.ref();
      const measureText = vue.computed(() => measureInfo.value.text);
      const filterOption = vue.ref(true);
      const handleInput = (value, e2) => {
        var _a, _b;
        const text = getTextBeforeSelection(e2.target);
        const lastMeasure = getLastMeasureIndex(text, props.prefix);
        if (lastMeasure.location > -1) {
          const measureText2 = text.slice(lastMeasure.location + lastMeasure.prefix.length);
          if (isValidSearch(measureText2, props.split)) {
            _popupVisible.value = true;
            measureInfo.value = __spreadValues({
              measuring: true,
              text: measureText2
            }, lastMeasure);
            emit("search", measureText2, lastMeasure.prefix);
          } else if (measureInfo.value.location > -1) {
            resetMeasureInfo();
          }
        } else if (measureInfo.value.location > -1) {
          resetMeasureInfo();
        }
        _value.value = value;
        emit("update:modelValue", value);
        emit("change", value);
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a);
      };
      const handleClear = (ev) => {
        var _a, _b;
        _value.value = "";
        emit("update:modelValue", "");
        emit("change", "");
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a);
        emit("clear", ev);
      };
      const _popupVisible = vue.ref(false);
      const computedPopupVisible = vue.computed(() => _popupVisible.value && measureInfo.value.measuring && validOptionInfos.value.length > 0);
      const handleResize = () => {
        mirrorStyle.value = getSizeStyles(styleDeclaration);
      };
      const handlePopupVisibleChange = (popupVisible) => {
        _popupVisible.value = popupVisible;
      };
      const handleSelect = (key, e2) => {
        var _a, _b, _c;
        const {
          value
        } = (_a = optionInfoMap.get(key)) != null ? _a : {};
        const measureStart = measureInfo.value.location;
        const measureEnd = measureInfo.value.location + measureInfo.value.text.length;
        let head = _value.value.slice(0, measureStart);
        let tail = _value.value.slice(measureEnd + 1);
        head += !head || head.endsWith(props.split) || head.endsWith("\n") ? "" : props.split;
        tail = (!tail || tail.startsWith(props.split) || tail.startsWith("\n") ? "" : props.split) + tail;
        const match = `${measureInfo.value.prefix}${value}`;
        const nextValue = `${head}${match}${tail}`;
        _value.value = nextValue;
        emit("select", value);
        emit("update:modelValue", nextValue);
        emit("change", nextValue);
        resetMeasureInfo();
        (_c = (_b = eventHandlers.value) == null ? void 0 : _b.onChange) == null ? void 0 : _c.call(_b);
      };
      const {
        validOptions,
        optionInfoMap,
        validOptionInfos,
        handleKeyDown
      } = useSelect({
        options: data,
        inputValue: measureText,
        filterOption,
        popupVisible: computedPopupVisible,
        valueKeys: computedValueKeys,
        dropdownRef,
        optionRefs,
        onSelect: handleSelect,
        onPopupVisibleChange: handlePopupVisibleChange,
        enterToOpen: false
      });
      const mirrorStyle = vue.ref();
      vue.onMounted(() => {
        var _a;
        if (props.type === "textarea" && ((_a = inputRef.value) == null ? void 0 : _a.textareaRef)) {
          styleDeclaration = window.getComputedStyle(inputRef.value.textareaRef);
          mirrorStyle.value = getSizeStyles(styleDeclaration);
        }
      });
      const getOptionContentFunc = (item) => {
        if (isFunction$1(slots.option) && item.value) {
          const optionInfo = optionInfoMap.get(item.key);
          const optionSlot = slots.option;
          return () => optionSlot({
            data: optionInfo
          });
        }
        return () => item.label;
      };
      const renderOption = (item) => {
        return vue.createVNode(Option, {
          "ref": (ref) => {
            if (ref == null ? void 0 : ref.$el) {
              optionRefs.value[item.key] = ref.$el;
            }
          },
          "key": item.key,
          "value": item.value,
          "disabled": item.disabled,
          "internal": true
        }, {
          default: getOptionContentFunc(item)
        });
      };
      const renderDropdown = () => {
        let _slot;
        return vue.createVNode(SelectDropdown, {
          "ref": dropdownRef
        }, _isSlot$9(_slot = validOptions.value.map((info) => renderOption(info))) ? _slot : {
          default: () => [_slot]
        });
      };
      const mirrorRef = vue.ref();
      vue.watch(computedPopupVisible, (visible) => {
        if (props.type === "textarea" && visible) {
          vue.nextTick(() => {
            var _a, _b;
            if (((_a = inputRef.value) == null ? void 0 : _a.textareaRef) && inputRef.value.textareaRef.scrollTop > 0) {
              (_b = mirrorRef.value) == null ? void 0 : _b.scrollTo(0, inputRef.value.textareaRef.scrollTop);
            }
          });
        }
      });
      const onFocus = (ev) => {
        emit("focus", ev);
      };
      const onBlur = (ev) => {
        emit("blur", ev);
      };
      const render = () => {
        var _a;
        if (props.type === "textarea") {
          return vue.createVNode("div", {
            "class": prefixCls
          }, [vue.createVNode(ResizeObserver$1, {
            "onResize": handleResize
          }, {
            default: () => [vue.createVNode(Textarea, vue.mergeProps(attrs, {
              "ref": inputRef,
              "allowClear": props.allowClear,
              "modelValue": computedValue.value,
              "onInput": handleInput,
              "onClear": handleClear,
              "onFocus": onFocus,
              "onBlur": onBlur,
              "onKeydown": handleKeyDown
            }), null)]
          }), measureInfo.value.measuring && validOptionInfos.value.length > 0 && vue.createVNode("div", {
            "ref": mirrorRef,
            "style": mirrorStyle.value,
            "class": `${prefixCls}-measure`
          }, [(_a = computedValue.value) == null ? void 0 : _a.slice(0, measureInfo.value.location), vue.createVNode(Trigger, {
            "trigger": "focus",
            "position": "bl",
            "popupOffset": 4,
            "preventFocus": true,
            "popupVisible": computedPopupVisible.value,
            "clickToClose": false,
            "onPopupVisibleChange": handlePopupVisibleChange
          }, {
            default: () => [vue.createVNode("span", null, [vue.createTextVNode("@")])],
            content: renderDropdown
          })])]);
        }
        return vue.createVNode(Trigger, {
          "trigger": "focus",
          "position": "bl",
          "animationName": "slide-dynamic-origin",
          "popupOffset": 4,
          "preventFocus": true,
          "popupVisible": computedPopupVisible.value,
          "clickToClose": false,
          "autoFitPopupWidth": true,
          "autoFitTransformOrigin": true,
          "disabled": mergedDisabled.value,
          "onPopupVisibleChange": handlePopupVisibleChange
        }, {
          default: () => [vue.createVNode(Input, vue.mergeProps(attrs, {
            "ref": inputRef,
            "allowClear": props.allowClear,
            "modelValue": computedValue.value,
            "disabled": mergedDisabled.value,
            "onInput": handleInput,
            "onClear": handleClear,
            "onFocus": onFocus,
            "onBlur": onBlur,
            "onKeydown": handleKeyDown
          }), slots)],
          content: renderDropdown
        });
      };
      return {
        inputRef,
        render
      };
    },
    methods: {
      focus() {
        var _a;
        (_a = this.inputRef) == null ? void 0 : _a.focus();
      },
      blur() {
        var _a;
        (_a = this.inputRef) == null ? void 0 : _a.blur();
      }
    },
    render() {
      return this.render();
    }
  });
  const Mention = Object.assign(_Mention, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Mention.name, _Mention);
    }
  });
  const MenuInjectionKey = Symbol("MenuInjectionKey");
  const LevelInjectionKey = Symbol("LevelInjectionKey");
  const DataCollectorInjectionKey = Symbol("DataCollectorInjectionKey");
  const _sfc_main$16 = vue.defineComponent({
    name: "IconMenuFold",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-menu-fold`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$t = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$o = /* @__PURE__ */ vue.createElementVNode("path", { d: "M42 11H6M42 24H22M42 37H6M13.66 26.912l-4.82-3.118 4.82-3.118v6.236Z" }, null, -1);
  const _hoisted_3$n = [
    _hoisted_2$o
  ];
  function _sfc_render$15(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$n, 14, _hoisted_1$t);
  }
  var _IconMenuFold = /* @__PURE__ */ _export_sfc(_sfc_main$16, [["render", _sfc_render$15]]);
  const IconMenuFold = Object.assign(_IconMenuFold, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconMenuFold.name, _IconMenuFold);
    }
  });
  const _sfc_main$15 = vue.defineComponent({
    name: "IconMenuUnfold",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-menu-unfold`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$s = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$n = /* @__PURE__ */ vue.createElementVNode("path", { d: "M6 11h36M22 24h20M6 37h36M8 20.882 12.819 24 8 27.118v-6.236Z" }, null, -1);
  const _hoisted_3$m = [
    _hoisted_2$n
  ];
  function _sfc_render$14(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$m, 14, _hoisted_1$s);
  }
  var _IconMenuUnfold = /* @__PURE__ */ _export_sfc(_sfc_main$15, [["render", _sfc_render$14]]);
  const IconMenuUnfold = Object.assign(_IconMenuUnfold, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconMenuUnfold.name, _IconMenuUnfold);
    }
  });
  function provideLevel(level) {
    const computedLevel = vue.computed(() => vue.isRef(level) ? level.value : level);
    vue.provide(LevelInjectionKey, vue.reactive({
      level: computedLevel
    }));
  }
  function useLevel(props) {
    const { provideNextLevel } = props || {};
    const levelContext = vue.inject(LevelInjectionKey);
    const level = vue.computed(() => (levelContext == null ? void 0 : levelContext.level) || 1);
    if (provideNextLevel) {
      const nextLevel = vue.computed(() => level.value + 1);
      provideLevel(nextLevel);
    }
    return {
      level
    };
  }
  function getKeys$1(data, condition) {
    const keys = [];
    const loop = (list) => {
      list.forEach((item) => {
        if (condition(item)) {
          keys.push(item.key);
        }
        if (item.children) {
          loop(item.children);
        }
      });
    };
    loop(data);
    return keys;
  }
  function useMenuDataCollectorContext(isRoot = false) {
    const menuContext = isRoot ? void 0 : vue.inject(DataCollectorInjectionKey);
    return menuContext;
  }
  function useMenuDataCollector(props) {
    const { key, type } = props;
    const data = vue.ref([]);
    const menuContext = useMenuDataCollectorContext(type === "menu");
    const provideContext = {
      collectSubMenu(key2, children, isReport = false) {
        const item = {
          key: key2,
          children
        };
        if (isReport) {
          const oldOne = data.value.find((i) => i.key === key2);
          if (oldOne) {
            oldOne.children = children;
          } else {
            data.value.push(item);
          }
        } else {
          data.value = [...data.value, item];
        }
        if (isReport) {
          if (type === "popupMenu") {
            menuContext == null ? void 0 : menuContext.reportMenuData(data.value);
          } else if (type === "subMenu" && !isUndefined(key2)) {
            menuContext == null ? void 0 : menuContext.collectSubMenu(key2, data.value, true);
          }
        }
      },
      removeSubMenu(key2) {
        data.value = data.value.filter((item) => item.key !== key2);
      },
      collectMenuItem(key2) {
        data.value.push({ key: key2 });
      },
      removeMenuItem(key2) {
        data.value = data.value.filter((item) => item.key !== key2);
      },
      reportMenuData(reportData) {
        data.value = reportData;
        if (type === "subMenu" && !isUndefined(key)) {
          menuContext == null ? void 0 : menuContext.collectSubMenu(key, data.value, true);
        }
      }
    };
    vue.provide(DataCollectorInjectionKey, provideContext);
    if (type === "subMenu" && !isUndefined(key)) {
      vue.onMounted(() => {
        menuContext == null ? void 0 : menuContext.collectSubMenu(key, data.value);
      });
      vue.onUnmounted(() => {
        menuContext == null ? void 0 : menuContext.removeSubMenu(key);
      });
    } else if (type === "popupMenu") {
      vue.onMounted(() => {
        menuContext == null ? void 0 : menuContext.reportMenuData(data.value);
      });
    }
    return {
      menuData: data,
      subMenuKeys: vue.computed(() => getKeys$1(data.value, (item) => !!item.children)),
      menuItemKeys: vue.computed(() => getKeys$1(data.value, (item) => !item.children))
    };
  }
  function getPath(data, key) {
    const path = [];
    const loop = (list) => {
      for (let i = 0; i < list.length; i++) {
        const item = list[i];
        if (item.key === key) {
          return true;
        }
        if (item.children) {
          path.push(item.key);
          const matched = loop(item.children);
          if (matched) {
            return true;
          }
          path.pop();
        }
      }
      return false;
    };
    loop(data);
    return path;
  }
  function isSameKeys(keys1, keys2) {
    if (keys1.length !== keys2.length)
      return false;
    return keys1.toString() === keys2.toString();
  }
  function useMenuOpenState(props) {
    const {
      modelValue,
      defaultValue,
      autoOpen,
      autoOpenSelected,
      subMenuKeys,
      selectedKeys,
      menuData,
      accordion
    } = vue.toRefs(props);
    const localValue = vue.ref(!isUndefined(modelValue.value) ? modelValue.value : !isUndefined(defaultValue.value) ? defaultValue.value : []);
    const setLocalValue = (val) => {
      localValue.value = val;
    };
    vue.watch(modelValue, () => {
      if (isUndefined(modelValue.value)) {
        setLocalValue([]);
      }
    });
    let mountedSubMenuKeys = [];
    vue.onMounted(() => {
      mountedSubMenuKeys = [...subMenuKeys.value];
      let newOpenKeys = [];
      if (autoOpen.value) {
        newOpenKeys = accordion.value ? subMenuKeys.value.slice(0, 1) : [...subMenuKeys.value];
      }
      if (autoOpenSelected.value) {
        const pathList = selectedKeys.value.map((key) => getPath(menuData.value, key));
        if (pathList.length && (!autoOpen.value || accordion.value)) {
          newOpenKeys = accordion.value ? pathList[0] : [...new Set([].concat(...pathList))];
        }
      }
      if (newOpenKeys.length) {
        setLocalValue(newOpenKeys);
      }
    });
    let hasTriggered = false;
    vue.watch(subMenuKeys, (currentKeys, prevKeys = []) => {
      if (hasTriggered || !isSameKeys(currentKeys, mountedSubMenuKeys)) {
        const newOpenKeys = openKeys.value.filter((key) => currentKeys.includes(key));
        if (autoOpen.value) {
          const keysAdded = currentKeys.filter((key) => !prevKeys.includes(key));
          newOpenKeys.push(...keysAdded);
        }
        setLocalValue(accordion.value ? newOpenKeys.slice(0, 1) : newOpenKeys);
      }
      hasTriggered = true;
    });
    const openKeys = vue.computed(() => modelValue.value || localValue.value);
    return {
      openKeys,
      localOpenKeys: localValue,
      setOpenKeys: setLocalValue,
      open(key, level) {
        let newOpenKeys = [];
        if (openKeys.value.indexOf(key) > -1) {
          if (accordion.value && level === 1) {
            newOpenKeys = [];
          } else {
            newOpenKeys = openKeys.value.filter((i) => i !== key);
          }
        } else if (accordion.value && level === 1) {
          newOpenKeys = [key];
        } else {
          newOpenKeys = openKeys.value.concat([key]);
        }
        setLocalValue(newOpenKeys);
        return newOpenKeys;
      }
    };
  }
  const _sfc_main$14 = vue.defineComponent({
    name: "BaseMenu",
    components: {
      IconMenuFold,
      IconMenuUnfold
    },
    inheritAttrs: false,
    props: {
      style: {
        type: Object
      },
      theme: {
        type: String,
        default: "light"
      },
      mode: {
        type: String,
        default: "vertical"
      },
      levelIndent: {
        type: Number
      },
      autoOpen: {
        type: Boolean
      },
      collapsed: {
        type: Boolean,
        default: void 0
      },
      defaultCollapsed: {
        type: Boolean
      },
      collapsedWidth: {
        type: Number
      },
      accordion: {
        type: Boolean
      },
      autoScrollIntoView: {
        type: Boolean
      },
      showCollapseButton: {
        type: Boolean
      },
      selectedKeys: {
        type: Array
      },
      defaultSelectedKeys: {
        type: Array,
        default: () => []
      },
      openKeys: {
        type: Array
      },
      defaultOpenKeys: {
        type: Array,
        default: () => []
      },
      scrollConfig: {
        type: Object
      },
      triggerProps: {
        type: Object
      },
      tooltipProps: {
        type: Object
      },
      autoOpenSelected: {
        type: Boolean
      },
      breakpoint: {
        type: String
      },
      popupMaxHeight: {
        type: [Boolean, Number],
        default: true
      },
      prefixCls: {
        type: String
      },
      inTrigger: {
        type: Boolean
      },
      siderCollapsed: {
        type: Boolean
      },
      isRoot: {
        type: Boolean
      }
    },
    emits: [
      "update:collapsed",
      "update:selectedKeys",
      "update:openKeys",
      "collapse",
      "menu-item-click",
      "sub-menu-click"
    ],
    setup(props, { emit, slots }) {
      const {
        style,
        mode,
        theme,
        levelIndent,
        accordion,
        showCollapseButton,
        scrollConfig,
        autoScrollIntoView,
        collapsedWidth,
        autoOpen,
        collapsed: propCollapsed,
        defaultCollapsed,
        selectedKeys: propSelectedKeys,
        defaultSelectedKeys,
        openKeys: propOpenKeys,
        defaultOpenKeys,
        triggerProps,
        tooltipProps,
        autoOpenSelected,
        breakpoint,
        popupMaxHeight,
        prefixCls,
        inTrigger,
        siderCollapsed,
        isRoot
      } = vue.toRefs(props);
      const { subMenuKeys, menuData } = useMenuDataCollector({
        type: isRoot.value ? "menu" : "popupMenu"
      });
      const [selectedKeys, setSelectedKeys] = useMergeState(defaultSelectedKeys.value, vue.reactive({
        value: propSelectedKeys
      }));
      const { openKeys, setOpenKeys, open: open2 } = useMenuOpenState(vue.reactive({
        modelValue: propOpenKeys,
        defaultValue: defaultOpenKeys,
        autoOpen,
        autoOpenSelected,
        selectedKeys,
        subMenuKeys,
        menuData,
        accordion
      }));
      const [collapsed, setCollapsed] = useMergeState(defaultCollapsed.value, vue.reactive({
        value: propCollapsed
      }));
      const computedCollapsed = vue.computed(() => siderCollapsed.value || collapsed.value || mode.value === "popButton");
      const computedHasCollapseButton = vue.computed(() => ["horizontal", "popButton"].indexOf(mode.value) < 0 && !inTrigger.value && showCollapseButton.value);
      const changeCollapsed = (newVal, type) => {
        if (newVal === collapsed.value)
          return;
        setCollapsed(newVal);
        emit("update:collapsed", newVal);
        emit("collapse", newVal, type);
      };
      const onCollapseBtnClick = () => {
        changeCollapsed(!collapsed.value, "clickTrigger");
      };
      useResponsive(breakpoint, (checked) => {
        changeCollapsed(!checked, "responsive");
      });
      const computedPrefixCls = vue.computed(() => (prefixCls == null ? void 0 : prefixCls.value) || getPrefixCls("menu"));
      const classNames = vue.computed(() => [
        computedPrefixCls.value,
        `${computedPrefixCls.value}-${theme == null ? void 0 : theme.value}`,
        {
          [`${computedPrefixCls.value}-horizontal`]: mode.value === "horizontal",
          [`${computedPrefixCls.value}-vertical`]: mode.value !== "horizontal",
          [`${computedPrefixCls.value}-collapsed`]: computedCollapsed.value,
          [`${computedPrefixCls.value}-pop`]: mode.value === "pop" || computedCollapsed.value,
          [`${computedPrefixCls.value}-pop-button`]: mode.value === "popButton"
        }
      ]);
      const computedStyle = vue.computed(() => {
        const pxCollapsedWidth = isNumber$1(collapsedWidth.value) ? `${collapsedWidth.value}px` : void 0;
        const objectStyle = isObject$1(style.value) ? style.value : void 0;
        const width = computedCollapsed.value ? pxCollapsedWidth : objectStyle == null ? void 0 : objectStyle.width;
        return [
          objectStyle ? omit(objectStyle, ["width"]) : style.value,
          { width }
        ];
      });
      const expandIconDown = usePickSlots(slots, "expand-icon-down");
      const expandIconRight = usePickSlots(slots, "expand-icon-right");
      const menuContext = vue.reactive({
        theme,
        mode,
        levelIndent,
        autoScrollIntoView,
        selectedKeys,
        openKeys,
        prefixCls: computedPrefixCls,
        scrollConfig,
        inTrigger,
        collapsed: computedCollapsed,
        triggerProps,
        tooltipProps,
        popupMaxHeight,
        expandIconDown,
        expandIconRight,
        onMenuItemClick: (key) => {
          setSelectedKeys([key]);
          emit("update:selectedKeys", [key]);
          emit("menu-item-click", key);
        },
        onSubMenuClick: (key, level) => {
          const newOpenKeys = open2(key, level);
          setOpenKeys(newOpenKeys);
          emit("update:openKeys", newOpenKeys);
          emit("sub-menu-click", key, newOpenKeys);
        }
      });
      vue.provide(MenuInjectionKey, menuContext);
      provideLevel(1);
      return {
        computedPrefixCls,
        classNames,
        computedStyle,
        computedCollapsed,
        computedHasCollapseButton,
        onCollapseBtnClick
      };
    }
  });
  function _sfc_render$13(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_IconMenuUnfold = vue.resolveComponent("IconMenuUnfold");
    const _component_IconMenuFold = vue.resolveComponent("IconMenuFold");
    return vue.openBlock(), vue.createElementBlock("div", vue.mergeProps({ class: _ctx.classNames }, _ctx.$attrs, { style: _ctx.computedStyle }), [
      vue.createElementVNode("div", {
        class: vue.normalizeClass(`${_ctx.computedPrefixCls}-inner`)
      }, [
        vue.renderSlot(_ctx.$slots, "default")
      ], 2),
      _ctx.computedHasCollapseButton ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: vue.normalizeClass(`${_ctx.computedPrefixCls}-collapse-button`),
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onCollapseBtnClick && _ctx.onCollapseBtnClick(...args))
      }, [
        vue.renderSlot(_ctx.$slots, "collapse-icon", { collapsed: _ctx.computedCollapsed }, () => [
          _ctx.computedCollapsed ? (vue.openBlock(), vue.createBlock(_component_IconMenuUnfold, { key: 0 })) : (vue.openBlock(), vue.createBlock(_component_IconMenuFold, { key: 1 }))
        ])
      ], 2)) : vue.createCommentVNode("v-if", true)
    ], 16);
  }
  var BaseMenu = /* @__PURE__ */ _export_sfc(_sfc_main$14, [["render", _sfc_render$13]]);
  function getStyle$1(element, prop) {
    if (!element || !prop)
      return null;
    let styleName = prop;
    if (styleName === "float") {
      styleName = "cssFloat";
    }
    try {
      if (document.defaultView) {
        const computed = document.defaultView.getComputedStyle(element, "");
        return element.style[styleName] || computed ? computed[styleName] : "";
      }
    } catch (e2) {
      return element.style[styleName];
    }
    return null;
  }
  function useMenuContext() {
    const menuContext = vue.inject(MenuInjectionKey);
    return menuContext || {};
  }
  const generateId = (() => {
    let i = 0;
    return (prefix = "") => {
      i += 1;
      return `${prefix}${i}`;
    };
  })();
  function useMenu() {
    const instance = vue.getCurrentInstance();
    const key = vue.computed(() => (instance == null ? void 0 : instance.vnode.key) || generateId("__arco_menu"));
    return {
      key
    };
  }
  const _sfc_main$13 = vue.defineComponent({
    name: "MenuIndent",
    props: {
      level: {
        type: Number,
        default: 1
      }
    },
    setup() {
      const prefixCls = getPrefixCls("menu");
      const menuContext = useMenuContext();
      return {
        prefixCls,
        levelIndent: vue.toRef(menuContext, "levelIndent")
      };
    }
  });
  function _sfc_render$12(_ctx, _cache, $props, $setup, $data, $options) {
    return _ctx.level > 1 ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 0,
      class: vue.normalizeClass(`${_ctx.prefixCls}-indent-list`)
    }, [
      (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.level - 1, (index2) => {
        return vue.openBlock(), vue.createElementBlock("span", {
          key: index2,
          class: vue.normalizeClass(`${_ctx.prefixCls}-indent`),
          style: vue.normalizeStyle(`width: ${_ctx.levelIndent}px`)
        }, null, 6);
      }), 128))
    ], 2)) : vue.createCommentVNode("v-if", true);
  }
  var MenuIndent = /* @__PURE__ */ _export_sfc(_sfc_main$13, [["render", _sfc_render$12]]);
  const _sfc_main$12 = vue.defineComponent({
    name: "ExpandTransition",
    setup() {
      return {
        onBeforeEnter(el) {
          el.style.height = "0";
        },
        onEnter(el) {
          el.style.height = `${el.scrollHeight}px`;
        },
        onAfterEnter(el) {
          el.style.height = "";
        },
        onBeforeLeave(el) {
          el.style.height = `${el.scrollHeight}px`;
        },
        onLeave(el) {
          el.style.height = `0`;
        },
        onAfterLeave(el) {
          el.style.height = ``;
        }
      };
    }
  });
  function _sfc_render$11(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createBlock(vue.Transition, {
      onBeforeEnter: _ctx.onBeforeEnter,
      onEnter: _ctx.onEnter,
      onAfterEnter: _ctx.onAfterEnter,
      onBeforeLeave: _ctx.onBeforeLeave,
      onLeave: _ctx.onLeave,
      onAfterLeave: _ctx.onAfterLeave
    }, {
      default: vue.withCtx(() => [
        vue.renderSlot(_ctx.$slots, "default")
      ]),
      _: 3
    }, 8, ["onBeforeEnter", "onEnter", "onAfterEnter", "onBeforeLeave", "onLeave", "onAfterLeave"]);
  }
  var ExpandTransition$1 = /* @__PURE__ */ _export_sfc(_sfc_main$12, [["render", _sfc_render$11]]);
  const _sfc_main$11 = vue.defineComponent({
    name: "SubMenuInline",
    components: {
      MenuIndent,
      ExpandTransition: ExpandTransition$1
    },
    props: {
      title: {
        type: String
      },
      isChildrenSelected: {
        type: Boolean
      }
    },
    setup(props) {
      const { key } = useMenu();
      const { level } = useLevel({
        provideNextLevel: true
      });
      const menuContext = useMenuContext();
      const menuPrefixCls = vue.computed(() => menuContext.prefixCls);
      const prefixCls = vue.computed(() => `${menuPrefixCls.value}-inline`);
      const classNames = vue.computed(() => [prefixCls.value]);
      const isSelected = vue.computed(() => props.isChildrenSelected);
      const isOpen = vue.computed(() => (menuContext.openKeys || []).indexOf(key.value) > -1);
      return {
        prefixCls,
        menuPrefixCls,
        classNames,
        level,
        isSelected,
        isOpen,
        onHeaderClick: () => {
          menuContext.onSubMenuClick && menuContext.onSubMenuClick(key.value, level.value);
        }
      };
    }
  });
  function _sfc_render$10(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_MenuIndent = vue.resolveComponent("MenuIndent");
    const _component_ExpandTransition = vue.resolveComponent("ExpandTransition");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.classNames)
    }, [
      vue.createElementVNode("div", {
        class: vue.normalizeClass([
          `${_ctx.prefixCls}-header`,
          {
            [`${_ctx.menuPrefixCls}-selected`]: _ctx.isSelected,
            [`${_ctx.menuPrefixCls}-has-icon`]: _ctx.$slots.icon
          }
        ]),
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onHeaderClick && _ctx.onHeaderClick(...args))
      }, [
        vue.createVNode(_component_MenuIndent, { level: _ctx.level }, null, 8, ["level"]),
        _ctx.$slots.icon ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
          vue.createElementVNode("span", {
            class: vue.normalizeClass(`${_ctx.menuPrefixCls}-icon`)
          }, [
            vue.renderSlot(_ctx.$slots, "icon")
          ], 2),
          vue.createElementVNode("span", {
            class: vue.normalizeClass(`${_ctx.menuPrefixCls}-title`)
          }, [
            vue.renderSlot(_ctx.$slots, "title", {}, () => [
              vue.createTextVNode(vue.toDisplayString(_ctx.title), 1)
            ])
          ], 2)
        ], 64)) : vue.renderSlot(_ctx.$slots, "title", { key: 1 }, () => [
          vue.createTextVNode(vue.toDisplayString(_ctx.title), 1)
        ]),
        vue.createElementVNode("span", {
          class: vue.normalizeClass([
            `${_ctx.menuPrefixCls}-icon-suffix`,
            {
              [`is-open`]: _ctx.isOpen
            }
          ])
        }, [
          vue.renderSlot(_ctx.$slots, "expand-icon-down")
        ], 2)
      ], 2),
      vue.createVNode(_component_ExpandTransition, null, {
        default: vue.withCtx(() => [
          vue.withDirectives(vue.createElementVNode("div", {
            class: vue.normalizeClass(`${_ctx.prefixCls}-content`)
          }, [
            vue.renderSlot(_ctx.$slots, "default")
          ], 2), [
            [vue.vShow, _ctx.isOpen]
          ])
        ]),
        _: 3
      })
    ], 2);
  }
  var SubMenuInline = /* @__PURE__ */ _export_sfc(_sfc_main$11, [["render", _sfc_render$10]]);
  const _sfc_main$10 = vue.defineComponent({
    name: "SubMenuPop",
    components: {
      Menu: BaseMenu,
      Trigger,
      MenuIndent,
      RenderFunction
    },
    inheritAttrs: false,
    props: {
      title: {
        type: String
      },
      selectable: {
        type: Boolean
      },
      isChildrenSelected: {
        type: Boolean
      },
      popupMaxHeight: {
        type: [Boolean, Number],
        default: void 0
      }
    },
    setup(props) {
      const { key } = useMenu();
      const { level } = useLevel();
      const { selectable, isChildrenSelected, popupMaxHeight } = vue.toRefs(props);
      const menuContext = useMenuContext();
      const { onSubMenuClick, onMenuItemClick } = menuContext;
      const menuPrefixCls = vue.computed(() => menuContext.prefixCls);
      const mode = vue.computed(() => menuContext.mode);
      const selectedKeys = vue.computed(() => menuContext.selectedKeys || []);
      const prefixCls = vue.computed(() => `${menuPrefixCls.value}-pop`);
      const isSelected = vue.computed(() => selectable.value && selectedKeys.value.includes(key.value) || isChildrenSelected.value);
      const classNames = vue.computed(() => [
        `${prefixCls.value}`,
        `${prefixCls.value}-header`,
        {
          [`${menuPrefixCls.value}-selected`]: isSelected.value
        }
      ]);
      const needPopOnBottom = vue.computed(() => mode.value === "horizontal" && !menuContext.inTrigger);
      const popVisible = vue.ref(false);
      const setPopVisible = (val) => {
        popVisible.value = val;
      };
      const triggerPrefixCls = getPrefixCls("trigger");
      const triggerClassNames = vue.computed(() => {
        var _a;
        return [
          `${prefixCls.value}-trigger`,
          {
            [`${prefixCls.value}-trigger-dark`]: menuContext.theme === "dark"
          },
          (_a = menuContext.triggerProps) == null ? void 0 : _a.class
        ];
      });
      const triggerProps = vue.computed(() => omit(menuContext.triggerProps || {}, ["class"]));
      return {
        menuPrefixCls,
        mode,
        level,
        classNames,
        isSelected,
        selectedKeys,
        needPopOnBottom,
        popVisible,
        triggerPrefixCls,
        triggerClassNames,
        triggerProps,
        menuContext,
        popupMenuStyles: vue.computed(() => {
          var _a;
          const maxHeight = (_a = popupMaxHeight.value) != null ? _a : menuContext.popupMaxHeight;
          if (isNumber$1(maxHeight))
            return { maxHeight: `${maxHeight}px` };
          return maxHeight ? {} : { maxHeight: "unset" };
        }),
        onClick: () => {
          onSubMenuClick && onSubMenuClick(key.value, level.value);
          selectable.value && onMenuItemClick && onMenuItemClick(key.value);
        },
        onMenuItemClick: (key2) => {
          onMenuItemClick && onMenuItemClick(key2);
          setPopVisible(false);
        },
        onVisibleChange: (visible) => {
          setPopVisible(visible);
        }
      };
    }
  });
  function _sfc_render$$(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_MenuIndent = vue.resolveComponent("MenuIndent");
    const _component_RenderFunction = vue.resolveComponent("RenderFunction");
    const _component_Menu = vue.resolveComponent("Menu");
    const _component_Trigger = vue.resolveComponent("Trigger");
    return vue.openBlock(), vue.createBlock(_component_Trigger, vue.mergeProps({
      trigger: "hover",
      class: _ctx.triggerClassNames,
      position: _ctx.needPopOnBottom ? "bl" : "rt",
      "show-arrow": "",
      "animation-class": "fade-in",
      "mouse-enter-delay": 50,
      "mouse-leave-delay": 50,
      "popup-offset": 4,
      "auto-fit-popup-min-width": true,
      duration: 100
    }, _ctx.triggerProps, {
      "unmount-on-close": false,
      "popup-visible": _ctx.popVisible,
      onPopupVisibleChange: _ctx.onVisibleChange
    }), {
      content: vue.withCtx(() => [
        vue.createVNode(_component_Menu, {
          "in-trigger": "",
          "prefix-cls": `${_ctx.triggerPrefixCls}-menu`,
          "selected-keys": _ctx.selectedKeys,
          theme: _ctx.menuContext.theme,
          "trigger-props": _ctx.menuContext.triggerProps,
          style: vue.normalizeStyle(_ctx.popupMenuStyles),
          onMenuItemClick: _ctx.onMenuItemClick
        }, vue.createSlots({
          default: vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "default")
          ]),
          _: 2
        }, [
          _ctx.menuContext.expandIconDown ? {
            name: "expand-icon-down",
            fn: vue.withCtx(() => [
              vue.createVNode(_component_RenderFunction, {
                "render-func": _ctx.menuContext.expandIconDown
              }, null, 8, ["render-func"])
            ])
          } : void 0,
          _ctx.menuContext.expandIconRight ? {
            name: "expand-icon-right",
            fn: vue.withCtx(() => [
              vue.createVNode(_component_RenderFunction, {
                "render-func": _ctx.menuContext.expandIconRight
              }, null, 8, ["render-func"])
            ])
          } : void 0
        ]), 1032, ["prefix-cls", "selected-keys", "theme", "trigger-props", "style", "onMenuItemClick"])
      ]),
      default: vue.withCtx(() => [
        vue.createElementVNode("div", vue.mergeProps({
          class: [
            _ctx.classNames,
            {
              [`${_ctx.menuPrefixCls}-has-icon`]: _ctx.$slots.icon
            }
          ],
          "aria-haspopup": "true"
        }, _ctx.$attrs, {
          onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
        }), [
          vue.createCommentVNode(" header "),
          vue.createVNode(_component_MenuIndent, { level: _ctx.level }, null, 8, ["level"]),
          _ctx.$slots.icon ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
            vue.createElementVNode("span", {
              class: vue.normalizeClass(`${_ctx.menuPrefixCls}-icon`)
            }, [
              vue.renderSlot(_ctx.$slots, "icon")
            ], 2),
            vue.createElementVNode("span", {
              class: vue.normalizeClass(`${_ctx.menuPrefixCls}-title`)
            }, [
              vue.renderSlot(_ctx.$slots, "title", {}, () => [
                vue.createTextVNode(vue.toDisplayString(_ctx.title), 1)
              ])
            ], 2)
          ], 64)) : vue.renderSlot(_ctx.$slots, "title", { key: 1 }, () => [
            vue.createTextVNode(vue.toDisplayString(_ctx.title), 1)
          ]),
          vue.createCommentVNode(" suffix "),
          vue.createElementVNode("span", {
            class: vue.normalizeClass(`${_ctx.menuPrefixCls}-icon-suffix`)
          }, [
            _ctx.needPopOnBottom ? vue.renderSlot(_ctx.$slots, "expand-icon-down", { key: 0 }) : vue.renderSlot(_ctx.$slots, "expand-icon-right", { key: 1 })
          ], 2),
          _ctx.isSelected && _ctx.mode === "horizontal" ? (vue.openBlock(), vue.createElementBlock("div", {
            key: 2,
            class: vue.normalizeClass(`${_ctx.menuPrefixCls}-selected-label`)
          }, null, 2)) : vue.createCommentVNode("v-if", true)
        ], 16)
      ]),
      _: 3
    }, 16, ["class", "position", "popup-visible", "onPopupVisibleChange"]);
  }
  var SubMenuPop = /* @__PURE__ */ _export_sfc(_sfc_main$10, [["render", _sfc_render$$]]);
  var SubMenu = vue.defineComponent({
    name: "SubMenu",
    props: {
      key: {
        type: String
      },
      title: {
        type: String
      },
      selectable: {
        type: Boolean
      },
      popup: {
        type: [Boolean, Function],
        default: false
      },
      popupMaxHeight: {
        type: [Boolean, Number],
        default: void 0
      }
    },
    setup(props, {
      attrs
    }) {
      const {
        key
      } = useMenu();
      const {
        level
      } = useLevel();
      const {
        popup
      } = vue.toRefs(props);
      const menuContext = useMenuContext();
      const computedPopup = vue.computed(() => {
        const {
          mode,
          collapsed,
          inTrigger
        } = menuContext;
        const forcePopup = !!(typeof popup.value === "function" ? popup.value(level.value) : popup.value);
        return forcePopup || collapsed || inTrigger || mode !== "vertical";
      });
      const {
        subMenuKeys,
        menuItemKeys
      } = useMenuDataCollector({
        key: key.value,
        type: "subMenu"
      });
      const isChildrenSelected = vue.computed(() => {
        const selectedKeys = menuContext.selectedKeys || [];
        const checkSelected = (menuKeys) => {
          for (let i = 0; i < selectedKeys.length; i++) {
            const selectedKey = selectedKeys[i];
            if (menuKeys.includes(selectedKey)) {
              return true;
            }
          }
          return false;
        };
        return checkSelected(subMenuKeys.value) || checkSelected(menuItemKeys.value);
      });
      return {
        subMenuKeys,
        menuItemKeys,
        isChildrenSelected,
        props,
        attrs,
        computedKey: key,
        computedPopup,
        expandIconDown: vue.toRef(menuContext, "expandIconDown"),
        expandIconRight: vue.toRef(menuContext, "expandIconRight")
      };
    },
    render() {
      const {
        props,
        attrs,
        computedKey,
        computedPopup,
        expandIconDown,
        expandIconRight,
        isChildrenSelected
      } = this;
      const _slots = __spreadProps(__spreadValues({}, this.$slots), {
        "expand-icon-down": this.$slots["expand-icon-down"] || expandIconDown || (() => [vue.createVNode(IconDown, null, null)]),
        "expand-icon-right": this.$slots["expand-icon-right"] || expandIconRight || (() => [vue.createVNode(IconRight, null, null)])
      });
      return computedPopup ? vue.createVNode(SubMenuPop, vue.mergeProps({
        "key": computedKey,
        "title": props.title,
        "selectable": props.selectable,
        "isChildrenSelected": isChildrenSelected,
        "popupMaxHeight": props.popupMaxHeight
      }, attrs), _slots) : vue.createVNode(SubMenuInline, vue.mergeProps({
        "key": computedKey,
        "title": props.title,
        "isChildrenSelected": isChildrenSelected
      }, attrs), _slots);
    }
  });
  const OVERFLOW_THRESHOLD = 10;
  function getNodeWidth(el) {
    return el && +el.getBoundingClientRect().width.toFixed(2);
  }
  function translatePxToNumber(str) {
    const result = Number(str.replace("px", ""));
    return Number.isNaN(result) ? 0 : result;
  }
  var OverflowWrap = vue.defineComponent({
    name: "MenuOverflowWrap",
    setup(_, {
      slots
    }) {
      const menuContext = useMenuContext();
      const overflowPrefixCls = `${menuContext.prefixCls}-overflow`;
      const overflowSubMenuClass = `${overflowPrefixCls}-sub-menu`;
      const overflowMenuItemClass = `${overflowPrefixCls}-hidden-menu-item`;
      const overflowSubMenuMirrorClass = `${overflowPrefixCls}-sub-menu-mirror`;
      const refWrapper = vue.ref();
      const lastVisibleIndex = vue.ref(null);
      const refResizeObserver = vue.ref();
      function computeLastVisibleIndex() {
        const wrapperElement = refWrapper.value;
        const wrapperWidth = getNodeWidth(wrapperElement);
        const childNodeList = [].slice.call(wrapperElement.children);
        let menuItemIndex = 0;
        let currentRightWidth = 0;
        let overflowSubMenuWidth = 0;
        for (let i = 0; i < childNodeList.length; i++) {
          const node = childNodeList[i];
          const classNames = node.className.split(" ");
          const isOverflowSubMenu = classNames.indexOf(overflowSubMenuClass) > -1;
          const isOverflowSubMenuMirror = classNames.indexOf(overflowSubMenuMirrorClass) > -1;
          if (isOverflowSubMenu) {
            continue;
          }
          const nodeWidth = getNodeWidth(node) + translatePxToNumber(getStyle$1(node, "marginLeft")) + translatePxToNumber(getStyle$1(node, "marginRight"));
          if (isOverflowSubMenuMirror) {
            overflowSubMenuWidth = nodeWidth;
            continue;
          }
          currentRightWidth += nodeWidth;
          if (currentRightWidth + overflowSubMenuWidth + OVERFLOW_THRESHOLD > wrapperWidth) {
            lastVisibleIndex.value = menuItemIndex - 1;
            return;
          }
          menuItemIndex++;
        }
        lastVisibleIndex.value = null;
      }
      vue.onMounted(() => {
        computeLastVisibleIndex();
        refResizeObserver.value = new index$1((entries) => {
          entries.forEach(computeLastVisibleIndex);
        });
        if (refWrapper.value) {
          refResizeObserver.value.observe(refWrapper.value);
        }
      });
      vue.onUnmounted(() => {
        refResizeObserver.value && refResizeObserver.value.disconnect();
      });
      return () => {
        const renderSubMenu = (children, options) => {
          const {
            isMirror = false,
            props = {}
          } = options || {};
          return vue.createVNode(SubMenu, vue.mergeProps({
            "key": `__arco-menu-overflow-sub-menu${isMirror ? "-mirror" : ""}`,
            "class": isMirror ? overflowSubMenuMirrorClass : overflowSubMenuClass
          }, props), {
            title: () => vue.createVNode("span", null, [vue.createTextVNode("...")]),
            default: () => children
          });
        };
        const renderChildren = () => {
          var _a;
          const originChildren = ((_a = slots.default) == null ? void 0 : _a.call(slots)) || [];
          const children = unFragment(originChildren);
          let overflowSubMenu = null;
          const overflowSubMenuMirror = renderSubMenu(null, {
            isMirror: true
          });
          const menuItems = children.map((child, index2) => {
            const item = vue.cloneVNode(child, lastVisibleIndex.value !== null && index2 > lastVisibleIndex.value ? {
              class: overflowMenuItemClass
            } : {
              class: ""
            });
            if (lastVisibleIndex.value !== null && index2 === lastVisibleIndex.value + 1) {
              const overflowMenuItems = children.slice(index2).map((child2) => vue.cloneVNode(child2));
              overflowSubMenu = renderSubMenu(overflowMenuItems);
            }
            return item;
          });
          return [overflowSubMenuMirror, ...menuItems, overflowSubMenu];
        };
        return vue.createVNode("div", {
          "class": `${overflowPrefixCls}-wrap`,
          "ref": refWrapper
        }, [renderChildren()]);
      };
    }
  });
  var _Menu = vue.defineComponent({
    name: "Menu",
    components: {
      BaseMenu
    },
    inheritAttrs: false,
    props: {
      theme: {
        type: String
      },
      mode: {
        type: String,
        default: "vertical"
      }
    },
    setup(props, {
      attrs,
      slots
    }) {
      const {
        theme: propTheme,
        mode
      } = vue.toRefs(props);
      const siderContext = vue.inject(SiderInjectionKey, void 0);
      const siderCollapsed = vue.computed(() => (siderContext == null ? void 0 : siderContext.collapsed) || false);
      const theme = vue.computed(() => (propTheme == null ? void 0 : propTheme.value) || (siderContext == null ? void 0 : siderContext.theme) || "light");
      vue.provide(MenuInjectionKey, void 0);
      vue.provide(LevelInjectionKey, void 0);
      return () => vue.createVNode(BaseMenu, vue.mergeProps(props, attrs, {
        "theme": theme.value,
        "inTrigger": false,
        "siderCollapsed": siderCollapsed.value,
        "isRoot": true
      }), __spreadProps(__spreadValues({}, slots), {
        default: mode.value === "horizontal" && slots.default ? () => vue.createVNode(OverflowWrap, null, {
          default: () => {
            var _a;
            return [(_a = slots.default) == null ? void 0 : _a.call(slots)];
          }
        }) : slots.default
      }));
    }
  });
  function isOptionsObject(options) {
    return options === Object(options) && Object.keys(options).length !== 0;
  }
  function defaultBehavior(actions, behavior) {
    if (behavior === void 0) {
      behavior = "auto";
    }
    var canSmoothScroll = "scrollBehavior" in document.body.style;
    actions.forEach(function(_ref) {
      var el = _ref.el, top = _ref.top, left = _ref.left;
      if (el.scroll && canSmoothScroll) {
        el.scroll({
          top,
          left,
          behavior
        });
      } else {
        el.scrollTop = top;
        el.scrollLeft = left;
      }
    });
  }
  function getOptions(options) {
    if (options === false) {
      return {
        block: "end",
        inline: "nearest"
      };
    }
    if (isOptionsObject(options)) {
      return options;
    }
    return {
      block: "start",
      inline: "nearest"
    };
  }
  function scrollIntoView(target2, options) {
    var targetIsDetached = !target2.ownerDocument.documentElement.contains(target2);
    if (isOptionsObject(options) && typeof options.behavior === "function") {
      return options.behavior(targetIsDetached ? [] : compute(target2, options));
    }
    if (targetIsDetached) {
      return;
    }
    var computeOptions = getOptions(options);
    return defaultBehavior(compute(target2, computeOptions), computeOptions.behavior);
  }
  var MenuItem = vue.defineComponent({
    name: "MenuItem",
    inheritAttrs: false,
    props: {
      key: {
        type: String
      },
      disabled: {
        type: Boolean,
        default: false
      }
    },
    emits: ["click"],
    setup(props, {
      emit
    }) {
      const {
        key
      } = useMenu();
      const {
        level
      } = useLevel();
      const menuContext = useMenuContext();
      const refItemElement = vue.ref();
      const isSelected = vue.computed(() => (menuContext.selectedKeys || []).indexOf(key.value) > -1);
      const menuDataCollector = useMenuDataCollectorContext();
      vue.onMounted(() => {
        menuDataCollector == null ? void 0 : menuDataCollector.collectMenuItem(key.value);
      });
      vue.onUnmounted(() => {
        menuDataCollector == null ? void 0 : menuDataCollector.removeMenuItem(key.value);
      });
      function scrollTo2() {
        if (menuContext.autoScrollIntoView && refItemElement.value && isSelected.value) {
          scrollIntoView(refItemElement.value, __spreadValues({
            behavior: "smooth",
            block: "nearest",
            scrollMode: "if-needed",
            boundary: document.documentElement
          }, menuContext.scrollConfig || {}));
        }
      }
      let timer;
      vue.onMounted(() => {
        timer = setTimeout(() => {
          scrollTo2();
        }, 500);
      });
      vue.onUnmounted(() => {
        clearTimeout(timer);
      });
      vue.watch([isSelected], () => {
        scrollTo2();
      });
      return {
        menuContext,
        level,
        isSelected,
        refItemElement,
        onClick(e2) {
          if (props.disabled)
            return;
          menuContext.onMenuItemClick && menuContext.onMenuItemClick(key.value);
          emit("click", e2);
        }
      };
    },
    render() {
      var _a, _b;
      const {
        level,
        menuContext,
        disabled,
        isSelected,
        onClick
      } = this;
      const {
        prefixCls,
        collapsed,
        inTrigger,
        mode,
        tooltipProps
      } = menuContext;
      const needTooltip = collapsed && !inTrigger && level === 1;
      const needTextIndent = mode === "vertical" && level > 1;
      const children = ((_b = (_a = this.$slots).default) == null ? void 0 : _b.call(_a)) || [];
      const showIndent = needTextIndent && !inTrigger && !collapsed;
      const iconElement = this.$slots.icon && this.$slots.icon();
      const content = [showIndent && vue.createVNode(MenuIndent, {
        "level": level
      }, null), iconElement && vue.createVNode("span", {
        "class": `${prefixCls}-icon`
      }, [iconElement]), showIndent || iconElement ? vue.createVNode("span", {
        "class": [`${prefixCls}-item-inner`, {
          [`${prefixCls}-title`]: iconElement
        }]
      }, [children]) : children].filter(Boolean);
      const itemElement = vue.createVNode("div", vue.mergeProps({
        "ref": "refItemElement",
        "class": [`${prefixCls}-item`, {
          [`${prefixCls}-disabled`]: disabled,
          [`${prefixCls}-selected`]: isSelected,
          [`${prefixCls}-has-icon`]: iconElement
        }]
      }, this.$attrs, {
        "onClick": onClick
      }), [content, isSelected && mode === "horizontal" && vue.createVNode("div", {
        "class": `${prefixCls}-selected-label`
      }, null)]);
      if (needTooltip) {
        const tooltipClassNames = [`${prefixCls}-item-tooltip`, tooltipProps == null ? void 0 : tooltipProps.class];
        return vue.createVNode(Tooltip, vue.mergeProps({
          "trigger": "hover",
          "position": "right",
          "class": tooltipClassNames
        }, omit(tooltipProps || {}, ["class"])), {
          default: () => itemElement,
          content: () => children
        });
      }
      return itemElement;
    }
  });
  const _sfc_main$$ = vue.defineComponent({
    name: "MenuItemGroup",
    components: {
      MenuIndent
    },
    props: {
      title: {
        type: String
      }
    },
    setup() {
      const { level } = useLevel();
      const nextLevel = vue.computed(() => level.value === 1 ? level.value + 1 : level.value);
      provideLevel(nextLevel);
      const menuContext = useMenuContext();
      const prefixCls = vue.computed(() => menuContext.prefixCls);
      const classNames = vue.computed(() => [`${prefixCls.value}-group`]);
      return {
        prefixCls,
        classNames,
        level
      };
    }
  });
  function _sfc_render$_(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_MenuIndent = vue.resolveComponent("MenuIndent");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.classNames)
    }, [
      vue.createElementVNode("div", {
        class: vue.normalizeClass(`${_ctx.prefixCls}-group-title`)
      }, [
        vue.createVNode(_component_MenuIndent, { level: _ctx.level }, null, 8, ["level"]),
        vue.renderSlot(_ctx.$slots, "title", {}, () => [
          vue.createTextVNode(vue.toDisplayString(_ctx.title), 1)
        ])
      ], 2),
      vue.renderSlot(_ctx.$slots, "default")
    ], 2);
  }
  var MenuItemGroup = /* @__PURE__ */ _export_sfc(_sfc_main$$, [["render", _sfc_render$_]]);
  const Menu = Object.assign(_Menu, {
    Item: MenuItem,
    ItemGroup: MenuItemGroup,
    SubMenu,
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Menu.name, _Menu);
      app.component(componentPrefix + MenuItem.name, MenuItem);
      app.component(componentPrefix + MenuItemGroup.name, MenuItemGroup);
      app.component(componentPrefix + SubMenu.name, SubMenu);
    }
  });
  const _sfc_main$_ = vue.defineComponent({
    name: "Message",
    components: {
      AIconHover: IconHover,
      IconInfoCircleFill,
      IconCheckCircleFill,
      IconExclamationCircleFill,
      IconCloseCircleFill,
      IconClose,
      IconLoading
    },
    props: {
      type: {
        type: String,
        default: "info"
      },
      closable: {
        type: Boolean,
        default: false
      },
      showIcon: {
        type: Boolean,
        default: true
      },
      duration: {
        type: Number,
        default: 3e3
      },
      resetOnUpdate: {
        type: Boolean,
        default: false
      },
      resetOnHover: {
        type: Boolean,
        default: false
      }
    },
    emits: ["close"],
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("message");
      let timer = 0;
      const handleClose = () => {
        emit("close");
      };
      const startTimer = () => {
        if (props.duration > 0) {
          timer = window.setTimeout(handleClose, props.duration);
        }
      };
      const clearTimer = () => {
        if (timer) {
          window.clearTimeout(timer);
          timer = 0;
        }
      };
      vue.onMounted(() => {
        startTimer();
      });
      vue.onUpdated(() => {
        if (props.resetOnUpdate) {
          clearTimer();
          startTimer();
        }
      });
      vue.onUnmounted(() => {
        clearTimer();
      });
      const handleMouseEnter = () => {
        if (props.resetOnHover) {
          clearTimer();
        }
      };
      const handleMouseLeave = () => {
        if (props.resetOnHover) {
          startTimer();
        }
      };
      return {
        handleMouseEnter,
        handleMouseLeave,
        prefixCls,
        handleClose
      };
    }
  });
  function _sfc_render$Z(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_icon_info_circle_fill = vue.resolveComponent("icon-info-circle-fill");
    const _component_icon_check_circle_fill = vue.resolveComponent("icon-check-circle-fill");
    const _component_icon_exclamation_circle_fill = vue.resolveComponent("icon-exclamation-circle-fill");
    const _component_icon_close_circle_fill = vue.resolveComponent("icon-close-circle-fill");
    const _component_icon_loading = vue.resolveComponent("icon-loading");
    const _component_icon_close = vue.resolveComponent("icon-close");
    const _component_a_icon_hover = vue.resolveComponent("a-icon-hover");
    return vue.openBlock(), vue.createElementBlock("li", {
      role: "alert",
      class: vue.normalizeClass([
        _ctx.prefixCls,
        `${_ctx.prefixCls}-${_ctx.type}`,
        { [`${_ctx.prefixCls}-closable`]: _ctx.closable }
      ]),
      onMouseenter: _cache[1] || (_cache[1] = (...args) => _ctx.handleMouseEnter && _ctx.handleMouseEnter(...args)),
      onMouseleave: _cache[2] || (_cache[2] = (...args) => _ctx.handleMouseLeave && _ctx.handleMouseLeave(...args))
    }, [
      _ctx.showIcon && !(_ctx.type === "normal" && !_ctx.$slots.icon) ? (vue.openBlock(), vue.createElementBlock("span", {
        key: 0,
        class: vue.normalizeClass(`${_ctx.prefixCls}-icon`)
      }, [
        vue.renderSlot(_ctx.$slots, "icon", {}, () => [
          _ctx.type === "info" ? (vue.openBlock(), vue.createBlock(_component_icon_info_circle_fill, { key: 0 })) : _ctx.type === "success" ? (vue.openBlock(), vue.createBlock(_component_icon_check_circle_fill, { key: 1 })) : _ctx.type === "warning" ? (vue.openBlock(), vue.createBlock(_component_icon_exclamation_circle_fill, { key: 2 })) : _ctx.type === "error" ? (vue.openBlock(), vue.createBlock(_component_icon_close_circle_fill, { key: 3 })) : _ctx.type === "loading" ? (vue.openBlock(), vue.createBlock(_component_icon_loading, { key: 4 })) : vue.createCommentVNode("v-if", true)
        ])
      ], 2)) : vue.createCommentVNode("v-if", true),
      vue.createElementVNode("span", {
        class: vue.normalizeClass(`${_ctx.prefixCls}-content`)
      }, [
        vue.renderSlot(_ctx.$slots, "default")
      ], 2),
      _ctx.closable ? (vue.openBlock(), vue.createElementBlock("span", {
        key: 1,
        class: vue.normalizeClass(`${_ctx.prefixCls}-close-btn`),
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClose && _ctx.handleClose(...args))
      }, [
        vue.createVNode(_component_a_icon_hover, null, {
          default: vue.withCtx(() => [
            vue.createVNode(_component_icon_close)
          ]),
          _: 1
        })
      ], 2)) : vue.createCommentVNode("v-if", true)
    ], 34);
  }
  var Message$1 = /* @__PURE__ */ _export_sfc(_sfc_main$_, [["render", _sfc_render$Z]]);
  function _isSlot$8(s) {
    return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !vue.isVNode(s);
  }
  var MessageList = vue.defineComponent({
    name: "MessageList",
    props: {
      messages: {
        type: Array,
        default: () => []
      },
      position: {
        type: String,
        default: "top"
      }
    },
    emits: ["close", "afterClose"],
    setup(props, context) {
      const prefixCls = getPrefixCls("message-list");
      const {
        zIndex
      } = usePopupManager("message", {
        runOnMounted: true
      });
      return () => {
        let _slot;
        return vue.createVNode(vue.TransitionGroup, {
          "class": [prefixCls, `${prefixCls}-${props.position}`],
          "name": "fade-message",
          "tag": "ul",
          "style": {
            zIndex: zIndex.value
          },
          "onAfterLeave": () => context.emit("afterClose")
        }, _isSlot$8(_slot = props.messages.map((item) => {
          const slots = {
            default: getSlotFunction(item.content),
            icon: getSlotFunction(item.icon)
          };
          return vue.createVNode(Message$1, {
            "key": item.id,
            "type": item.type,
            "duration": item.duration,
            "closable": item.closable,
            "resetOnUpdate": item.resetOnUpdate,
            "resetOnHover": item.resetOnHover,
            "onClose": () => context.emit("close", item.id)
          }, slots);
        })) ? _slot : {
          default: () => [_slot]
        });
      };
    }
  });
  class MessageManger {
    constructor(config, appContext) {
      this.messageCount = 0;
      this.add = (config2) => {
        var _a;
        this.messageCount++;
        const id = (_a = config2.id) != null ? _a : `__arco_message_${this.messageCount}`;
        if (this.messageIds.has(id)) {
          return this.update(id, config2);
        }
        const message2 = vue.reactive(__spreadValues({ id }, config2));
        this.messages.value.push(message2);
        this.messageIds.add(id);
        return {
          close: () => this.remove(id)
        };
      };
      this.update = (id, config2) => {
        for (let i = 0; i < this.messages.value.length; i++) {
          if (this.messages.value[i].id === id) {
            const resetOnUpdate = !isUndefined(config2.duration);
            Object.assign(this.messages.value[i], __spreadProps(__spreadValues({}, config2), { id, resetOnUpdate }));
            break;
          }
        }
        return {
          close: () => this.remove(id)
        };
      };
      this.remove = (id) => {
        for (let i = 0; i < this.messages.value.length; i++) {
          const item = this.messages.value[i];
          if (item.id === id) {
            if (isFunction$1(item.onClose)) {
              item.onClose(id);
            }
            this.messages.value.splice(i, 1);
            this.messageIds.delete(id);
            break;
          }
        }
      };
      this.clear = () => {
        this.messages.value.splice(0);
      };
      this.destroy = () => {
        if (this.messages.value.length === 0 && this.container) {
          vue.render(null, this.container);
          document.body.removeChild(this.container);
          this.container = null;
          messageInstance[this.position] = void 0;
        }
      };
      const { position = "top" } = config;
      this.container = getOverlay("message");
      this.messageIds = new Set();
      this.messages = vue.ref([]);
      this.position = position;
      const vm = vue.createVNode(MessageList, {
        messages: this.messages.value,
        position,
        onClose: this.remove,
        onAfterClose: this.destroy
      });
      if (appContext != null ? appContext : Message._context) {
        vm.appContext = appContext != null ? appContext : Message._context;
      }
      vue.render(vm, this.container);
      document.body.appendChild(this.container);
    }
  }
  const messageInstance = {};
  const types = [...MESSAGE_TYPES, "loading", "normal"];
  const message = types.reduce((pre, value) => {
    pre[value] = (config, appContext) => {
      if (isString$1(config)) {
        config = { content: config };
      }
      const _config = __spreadValues({ type: value }, config);
      const { position = "top" } = _config;
      if (!messageInstance[position]) {
        messageInstance[position] = new MessageManger(_config, appContext);
      }
      return messageInstance[position].add(_config);
    };
    return pre;
  }, {});
  message.clear = (position) => {
    var _a;
    if (position) {
      (_a = messageInstance[position]) == null ? void 0 : _a.clear();
    } else {
      Object.values(messageInstance).forEach((item) => item == null ? void 0 : item.clear());
    }
  };
  const Message = __spreadProps(__spreadValues({}, message), {
    install: (app) => {
      const _message = {
        clear: message.clear
      };
      for (const key of types) {
        _message[key] = (config, appContext = app._context) => message[key](config, appContext);
      }
      app.config.globalProperties.$message = _message;
    },
    _context: null
  });
  const useDraggable$1 = ({
    modalRef,
    wrapperRef,
    draggable,
    alignCenter
  }) => {
    const isDragging = vue.ref(false);
    const startMouse = vue.ref([0, 0]);
    const initialPosition = vue.ref([0, 0]);
    const position = vue.ref();
    const minPosition = vue.ref([0, 0]);
    const maxPosition = vue.ref([0, 0]);
    const getInitialPosition = () => {
      var _a, _b, _c;
      if (wrapperRef.value && modalRef.value) {
        const { top: wrapperTop, left: wrapperLeft } = wrapperRef.value.getBoundingClientRect();
        const { clientWidth: wrapperWidth, clientHeight: wrapperHeight } = wrapperRef.value;
        const { top, left, width, height } = modalRef.value.getBoundingClientRect();
        const offsetTop = alignCenter.value ? 0 : (_a = modalRef.value) == null ? void 0 : _a.offsetTop;
        const initialX = left - wrapperLeft;
        const initialY = top - wrapperTop - offsetTop;
        if (initialX !== ((_b = initialPosition.value) == null ? void 0 : _b[0]) || initialY !== ((_c = initialPosition.value) == null ? void 0 : _c[1])) {
          initialPosition.value = [initialX, initialY];
        }
        const maxX = wrapperWidth > width ? wrapperWidth - width : 0;
        const maxY = wrapperHeight > height ? wrapperHeight - height - offsetTop : 0;
        if (maxX !== maxPosition.value[0] || maxY !== maxPosition.value[1]) {
          maxPosition.value = [maxX, maxY];
        }
        if (offsetTop) {
          minPosition.value = [0, 0 - offsetTop];
        }
      }
    };
    const handleMoveDown = (ev) => {
      if (draggable.value) {
        ev.preventDefault();
        isDragging.value = true;
        getInitialPosition();
        startMouse.value = [ev.x, ev.y];
        on(window, "mousemove", handleMouseMove);
        on(window, "mouseup", handleMouseUp);
        on(window, "contextmenu", handleMouseUp);
      }
    };
    const handleMouseMove = (ev) => {
      if (isDragging.value) {
        const diffX = ev.x - startMouse.value[0];
        const diffY = ev.y - startMouse.value[1];
        let x = initialPosition.value[0] + diffX;
        let y = initialPosition.value[1] + diffY;
        if (x < minPosition.value[0])
          x = minPosition.value[0];
        if (x > maxPosition.value[0])
          x = maxPosition.value[0];
        if (y < minPosition.value[1])
          y = minPosition.value[1];
        if (y > maxPosition.value[1])
          y = maxPosition.value[1];
        position.value = [x, y];
      }
    };
    const handleMouseUp = () => {
      isDragging.value = false;
      off(window, "mousemove", handleMouseMove);
      off(window, "mouseup", handleMouseUp);
    };
    return {
      position,
      handleMoveDown
    };
  };
  var _sfc_main$Z = vue.defineComponent({
    name: "Modal",
    components: {
      ClientOnly,
      ArcoButton: Button,
      IconHover,
      IconClose,
      IconInfoCircleFill,
      IconCheckCircleFill,
      IconExclamationCircleFill,
      IconCloseCircleFill
    },
    inheritAttrs: false,
    props: {
      visible: {
        type: Boolean,
        default: void 0
      },
      defaultVisible: {
        type: Boolean,
        default: false
      },
      width: {
        type: [Number, String]
      },
      top: {
        type: [Number, String]
      },
      mask: {
        type: Boolean,
        default: true
      },
      title: {
        type: String
      },
      titleAlign: {
        type: String,
        default: "center"
      },
      alignCenter: {
        type: Boolean,
        default: true
      },
      unmountOnClose: Boolean,
      maskClosable: {
        type: Boolean,
        default: true
      },
      hideCancel: {
        type: Boolean,
        default: false
      },
      simple: {
        type: Boolean,
        default: (props) => {
          return props.notice;
        }
      },
      closable: {
        type: Boolean,
        default: true
      },
      okText: String,
      cancelText: String,
      okLoading: {
        type: Boolean,
        default: false
      },
      okButtonProps: {
        type: Object
      },
      cancelButtonProps: {
        type: Object
      },
      footer: {
        type: Boolean,
        default: true
      },
      renderToBody: {
        type: Boolean,
        default: true
      },
      popupContainer: {
        type: [String, Object],
        default: "body"
      },
      maskStyle: {
        type: Object
      },
      modalClass: {
        type: [String, Array]
      },
      modalStyle: {
        type: Object
      },
      onBeforeOk: {
        type: Function
      },
      onBeforeCancel: {
        type: Function
      },
      escToClose: {
        type: Boolean,
        default: true
      },
      draggable: {
        type: Boolean,
        default: false
      },
      fullscreen: {
        type: Boolean,
        default: false
      },
      maskAnimationName: {
        type: String,
        default: (props) => {
          if (props.fullscreen) {
            return "fade-in-standard";
          }
          return "fade-modal";
        }
      },
      modalAnimationName: {
        type: String,
        default: (props) => {
          if (props.fullscreen) {
            return "zoom-in";
          }
          return "zoom-modal";
        }
      },
      bodyClass: {
        type: [String, Array]
      },
      bodyStyle: {
        type: [String, Object, Array]
      },
      messageType: {
        type: String
      }
    },
    emits: {
      "update:visible": (visible) => true,
      "ok": (e2) => true,
      "cancel": (e2) => true,
      "open": () => true,
      "close": () => true,
      "beforeOpen": () => true,
      "beforeClose": () => true
    },
    setup(props, {
      emit
    }) {
      const {
        fullscreen,
        popupContainer,
        alignCenter
      } = vue.toRefs(props);
      const prefixCls = getPrefixCls("modal");
      const {
        t: t2
      } = useI18n();
      const wrapperRef = vue.ref();
      const modalRef = vue.ref();
      const _visible = vue.ref(props.defaultVisible);
      const computedVisible = vue.computed(() => {
        var _a;
        return (_a = props.visible) != null ? _a : _visible.value;
      });
      const _okLoading = vue.ref(false);
      const mergedOkLoading = vue.computed(() => props.okLoading || _okLoading.value);
      const mergedDraggable = vue.computed(() => props.draggable && !props.fullscreen);
      const {
        teleportContainer,
        containerRef
      } = useTeleportContainer({
        popupContainer,
        visible: computedVisible
      });
      const mounted = vue.ref(computedVisible.value);
      const okDisplayText = vue.computed(() => props.okText || t2("modal.okText"));
      const cancelDisplayText = vue.computed(() => props.cancelText || t2("modal.cancelText"));
      const {
        zIndex,
        isLastDialog
      } = usePopupManager("dialog", {
        visible: computedVisible
      });
      let globalKeyDownListener = false;
      const handleGlobalKeyDown = (ev) => {
        if (props.escToClose && ev.key === KEYBOARD_KEY.ESC && isLastDialog()) {
          handleCancel(ev);
        }
      };
      const addGlobalKeyDownListener = () => {
        if (props.escToClose && !globalKeyDownListener) {
          globalKeyDownListener = true;
          on(document.documentElement, "keydown", handleGlobalKeyDown);
        }
      };
      const removeGlobalKeyDownListener = () => {
        globalKeyDownListener = false;
        off(document.documentElement, "keydown", handleGlobalKeyDown);
      };
      let promiseNumber = 0;
      const {
        position,
        handleMoveDown
      } = useDraggable$1({
        wrapperRef,
        modalRef,
        draggable: mergedDraggable,
        alignCenter
      });
      const close = () => {
        promiseNumber++;
        if (_okLoading.value) {
          _okLoading.value = false;
        }
        _visible.value = false;
        emit("update:visible", false);
      };
      const handleOk = async (e2) => {
        const currentPromiseNumber = promiseNumber;
        const closed = await new Promise(async (resolve) => {
          var _a;
          if (isFunction$1(props.onBeforeOk)) {
            let result = props.onBeforeOk((closed2 = true) => resolve(closed2));
            if (isPromise(result) || !isBoolean$1(result)) {
              _okLoading.value = true;
            }
            if (isPromise(result)) {
              try {
                result = (_a = await result) != null ? _a : true;
              } catch (error) {
                result = false;
              }
            }
            if (isBoolean$1(result)) {
              resolve(result);
            }
          } else {
            resolve(true);
          }
        });
        if (currentPromiseNumber === promiseNumber) {
          if (closed) {
            emit("ok", e2);
            close();
          } else if (_okLoading.value) {
            _okLoading.value = false;
          }
        }
      };
      const handleCancel = (e2) => {
        var _a;
        let result = true;
        if (isFunction$1(props.onBeforeCancel)) {
          result = (_a = props.onBeforeCancel()) != null ? _a : false;
        }
        if (result) {
          emit("cancel", e2);
          close();
        }
      };
      const currentIsMask = vue.ref(false);
      const handleMaskMouseDown = (ev) => {
        if (ev.target === wrapperRef.value) {
          currentIsMask.value = true;
        }
      };
      const handleMaskClick = (e2) => {
        if (props.mask && props.maskClosable && currentIsMask.value) {
          handleCancel(e2);
        }
      };
      const handleOpen = () => {
        if (computedVisible.value) {
          if (!contains(wrapperRef.value, document.activeElement) && document.activeElement instanceof HTMLElement) {
            document.activeElement.blur();
          }
          emit("open");
        }
      };
      const handleClose = () => {
        if (!computedVisible.value) {
          if (mergedDraggable.value) {
            position.value = void 0;
          }
          mounted.value = false;
          resetOverflow();
          emit("close");
        }
      };
      const {
        setOverflowHidden,
        resetOverflow
      } = useOverflow(containerRef);
      vue.onMounted(() => {
        containerRef.value = getElement(props.popupContainer);
        if (computedVisible.value) {
          setOverflowHidden();
          if (props.escToClose) {
            addGlobalKeyDownListener();
          }
        }
      });
      vue.onBeforeUnmount(() => {
        resetOverflow();
        removeGlobalKeyDownListener();
      });
      vue.watch(computedVisible, (value) => {
        if (_visible.value !== value) {
          _visible.value = value;
        }
        if (value) {
          emit("beforeOpen");
          mounted.value = true;
          currentIsMask.value = false;
          setOverflowHidden();
          addGlobalKeyDownListener();
        } else {
          emit("beforeClose");
          removeGlobalKeyDownListener();
        }
      });
      vue.watch(fullscreen, () => {
        if (position.value) {
          position.value = void 0;
        }
      });
      const wrapperCls = vue.computed(() => [`${prefixCls}-wrapper`, {
        [`${prefixCls}-wrapper-align-center`]: props.alignCenter && !props.fullscreen,
        [`${prefixCls}-wrapper-moved`]: Boolean(position.value)
      }]);
      const modalCls = vue.computed(() => [`${prefixCls}`, props.modalClass, {
        [`${prefixCls}-simple`]: props.simple,
        [`${prefixCls}-draggable`]: mergedDraggable.value,
        [`${prefixCls}-fullscreen`]: props.fullscreen
      }]);
      const mergedModalStyle = vue.computed(() => {
        var _a;
        const style = __spreadValues({}, (_a = props.modalStyle) != null ? _a : {});
        if (props.width && !props.fullscreen) {
          style.width = isNumber$1(props.width) ? `${props.width}px` : props.width;
        }
        if (!props.alignCenter && props.top) {
          style.top = isNumber$1(props.top) ? `${props.top}px` : props.top;
        }
        if (position.value) {
          style.transform = `translate(${position.value[0]}px, ${position.value[1]}px)`;
        }
        return style;
      });
      return {
        prefixCls,
        mounted,
        computedVisible,
        containerRef,
        wrapperRef,
        mergedModalStyle,
        okDisplayText,
        cancelDisplayText,
        zIndex,
        handleOk,
        handleCancel,
        handleMaskClick,
        handleMaskMouseDown,
        handleOpen,
        handleClose,
        mergedOkLoading,
        modalRef,
        wrapperCls,
        modalCls,
        teleportContainer,
        handleMoveDown
      };
    }
  });
  function _sfc_render$Y(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_icon_info_circle_fill = vue.resolveComponent("icon-info-circle-fill");
    const _component_icon_check_circle_fill = vue.resolveComponent("icon-check-circle-fill");
    const _component_icon_exclamation_circle_fill = vue.resolveComponent("icon-exclamation-circle-fill");
    const _component_icon_close_circle_fill = vue.resolveComponent("icon-close-circle-fill");
    const _component_icon_close = vue.resolveComponent("icon-close");
    const _component_icon_hover = vue.resolveComponent("icon-hover");
    const _component_arco_button = vue.resolveComponent("arco-button");
    const _component_client_only = vue.resolveComponent("client-only");
    return vue.openBlock(), vue.createBlock(_component_client_only, null, {
      default: vue.withCtx(() => [
        (vue.openBlock(), vue.createBlock(vue.Teleport, {
          to: _ctx.teleportContainer,
          disabled: !_ctx.renderToBody
        }, [
          !_ctx.unmountOnClose || _ctx.computedVisible || _ctx.mounted ? vue.withDirectives((vue.openBlock(), vue.createElementBlock("div", vue.mergeProps({
            key: 0,
            class: `${_ctx.prefixCls}-container`,
            style: { zIndex: _ctx.zIndex }
          }, _ctx.$attrs), [
            vue.createVNode(vue.Transition, {
              name: _ctx.maskAnimationName,
              appear: ""
            }, {
              default: vue.withCtx(() => [
                _ctx.mask ? vue.withDirectives((vue.openBlock(), vue.createElementBlock("div", {
                  key: 0,
                  ref: "maskRef",
                  class: vue.normalizeClass(`${_ctx.prefixCls}-mask`),
                  style: vue.normalizeStyle(_ctx.maskStyle)
                }, null, 6)), [
                  [vue.vShow, _ctx.computedVisible]
                ]) : vue.createCommentVNode("v-if", true)
              ]),
              _: 1
            }, 8, ["name"]),
            vue.createElementVNode("div", {
              ref: "wrapperRef",
              class: vue.normalizeClass(_ctx.wrapperCls),
              onClick: _cache[2] || (_cache[2] = vue.withModifiers((...args) => _ctx.handleMaskClick && _ctx.handleMaskClick(...args), ["self"])),
              onMousedown: _cache[3] || (_cache[3] = vue.withModifiers((...args) => _ctx.handleMaskMouseDown && _ctx.handleMaskMouseDown(...args), ["self"]))
            }, [
              vue.createVNode(vue.Transition, {
                name: _ctx.modalAnimationName,
                appear: "",
                onAfterEnter: _ctx.handleOpen,
                onAfterLeave: _ctx.handleClose
              }, {
                default: vue.withCtx(() => [
                  vue.withDirectives(vue.createElementVNode("div", {
                    ref: "modalRef",
                    class: vue.normalizeClass(_ctx.modalCls),
                    style: vue.normalizeStyle(_ctx.mergedModalStyle)
                  }, [
                    _ctx.$slots.title || _ctx.title || _ctx.closable ? (vue.openBlock(), vue.createElementBlock("div", {
                      key: 0,
                      class: vue.normalizeClass(`${_ctx.prefixCls}-header`),
                      onMousedown: _cache[1] || (_cache[1] = (...args) => _ctx.handleMoveDown && _ctx.handleMoveDown(...args))
                    }, [
                      _ctx.$slots.title || _ctx.title ? (vue.openBlock(), vue.createElementBlock("div", {
                        key: 0,
                        class: vue.normalizeClass([
                          `${_ctx.prefixCls}-title`,
                          `${_ctx.prefixCls}-title-align-${_ctx.titleAlign}`
                        ])
                      }, [
                        _ctx.messageType ? (vue.openBlock(), vue.createElementBlock("div", {
                          key: 0,
                          class: vue.normalizeClass(`${_ctx.prefixCls}-title-icon`)
                        }, [
                          _ctx.messageType === "info" ? (vue.openBlock(), vue.createBlock(_component_icon_info_circle_fill, { key: 0 })) : vue.createCommentVNode("v-if", true),
                          _ctx.messageType === "success" ? (vue.openBlock(), vue.createBlock(_component_icon_check_circle_fill, { key: 1 })) : vue.createCommentVNode("v-if", true),
                          _ctx.messageType === "warning" ? (vue.openBlock(), vue.createBlock(_component_icon_exclamation_circle_fill, { key: 2 })) : vue.createCommentVNode("v-if", true),
                          _ctx.messageType === "error" ? (vue.openBlock(), vue.createBlock(_component_icon_close_circle_fill, { key: 3 })) : vue.createCommentVNode("v-if", true)
                        ], 2)) : vue.createCommentVNode("v-if", true),
                        vue.renderSlot(_ctx.$slots, "title", {}, () => [
                          vue.createTextVNode(vue.toDisplayString(_ctx.title), 1)
                        ])
                      ], 2)) : vue.createCommentVNode("v-if", true),
                      !_ctx.simple && _ctx.closable ? (vue.openBlock(), vue.createElementBlock("div", {
                        key: 1,
                        tabindex: "-1",
                        role: "button",
                        "aria-label": "Close",
                        class: vue.normalizeClass(`${_ctx.prefixCls}-close-btn`),
                        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleCancel && _ctx.handleCancel(...args))
                      }, [
                        vue.createVNode(_component_icon_hover, null, {
                          default: vue.withCtx(() => [
                            vue.createVNode(_component_icon_close)
                          ]),
                          _: 1
                        })
                      ], 2)) : vue.createCommentVNode("v-if", true)
                    ], 34)) : vue.createCommentVNode("v-if", true),
                    vue.createElementVNode("div", {
                      class: vue.normalizeClass([`${_ctx.prefixCls}-body`, _ctx.bodyClass]),
                      style: vue.normalizeStyle(_ctx.bodyStyle)
                    }, [
                      vue.renderSlot(_ctx.$slots, "default")
                    ], 6),
                    _ctx.footer ? (vue.openBlock(), vue.createElementBlock("div", {
                      key: 1,
                      class: vue.normalizeClass(`${_ctx.prefixCls}-footer`)
                    }, [
                      vue.renderSlot(_ctx.$slots, "footer", {}, () => [
                        !_ctx.hideCancel ? (vue.openBlock(), vue.createBlock(_component_arco_button, vue.mergeProps({ key: 0 }, _ctx.cancelButtonProps, { onClick: _ctx.handleCancel }), {
                          default: vue.withCtx(() => [
                            vue.createTextVNode(vue.toDisplayString(_ctx.cancelDisplayText), 1)
                          ]),
                          _: 1
                        }, 16, ["onClick"])) : vue.createCommentVNode("v-if", true),
                        vue.createVNode(_component_arco_button, vue.mergeProps({ type: "primary" }, _ctx.okButtonProps, {
                          loading: _ctx.mergedOkLoading,
                          onClick: _ctx.handleOk
                        }), {
                          default: vue.withCtx(() => [
                            vue.createTextVNode(vue.toDisplayString(_ctx.okDisplayText), 1)
                          ]),
                          _: 1
                        }, 16, ["loading", "onClick"])
                      ])
                    ], 2)) : vue.createCommentVNode("v-if", true)
                  ], 6), [
                    [vue.vShow, _ctx.computedVisible]
                  ])
                ]),
                _: 3
              }, 8, ["name", "onAfterEnter", "onAfterLeave"])
            ], 34)
          ], 16)), [
            [vue.vShow, _ctx.computedVisible || _ctx.mounted]
          ]) : vue.createCommentVNode("v-if", true)
        ], 8, ["to", "disabled"]))
      ]),
      _: 3
    });
  }
  var _Modal = /* @__PURE__ */ _export_sfc(_sfc_main$Z, [["render", _sfc_render$Y]]);
  const open = (config, appContext) => {
    let container2 = getOverlay("modal");
    const handleOk = () => {
      if (vm.component) {
        vm.component.props.visible = false;
      }
      if (isFunction$1(config.onOk)) {
        config.onOk();
      }
    };
    const handleCancel = () => {
      if (vm.component) {
        vm.component.props.visible = false;
      }
      if (isFunction$1(config.onCancel)) {
        config.onCancel();
      }
    };
    const handleClose = async () => {
      await vue.nextTick();
      if (container2) {
        vue.render(null, container2);
        document.body.removeChild(container2);
      }
      container2 = null;
      if (isFunction$1(config.onClose)) {
        config.onClose();
      }
    };
    const handleReturnClose = () => {
      if (vm.component) {
        vm.component.props.visible = false;
      }
    };
    const handleUpdateConfig = (config2) => {
      if (vm.component) {
        Object.entries(config2).forEach(([key, value]) => {
          vm.component.props[key] = value;
        });
      }
    };
    const defaultConfig = {
      visible: true,
      renderToBody: false,
      unmountOnClose: true,
      onOk: handleOk,
      onCancel: handleCancel,
      onClose: handleClose
    };
    const vm = vue.createVNode(_Modal, __spreadValues(__spreadValues(__spreadValues({}, defaultConfig), omit(config, ["content", "title", "footer", "visible", "unmountOnClose", "onOk", "onCancel", "onClose"])), {
      footer: typeof config.footer === "boolean" ? config.footer : void 0
    }), {
      default: getSlotFunction(config.content),
      title: getSlotFunction(config.title),
      footer: typeof config.footer !== "boolean" ? getSlotFunction(config.footer) : void 0
    });
    if (appContext != null ? appContext : Modal._context) {
      vm.appContext = appContext != null ? appContext : Modal._context;
    }
    vue.render(vm, container2);
    document.body.appendChild(container2);
    return {
      close: handleReturnClose,
      update: handleUpdateConfig
    };
  };
  const modal = __spreadValues({
    open,
    confirm: (config, appContext) => {
      const _config = __spreadValues({
        simple: true,
        messageType: "warning"
      }, config);
      return open(_config, appContext);
    }
  }, MESSAGE_TYPES.reduce((pre, value) => {
    pre[value] = (config, appContext) => {
      const _config = __spreadValues({
        simple: true,
        hideCancel: true,
        messageType: value
      }, config);
      return open(_config, appContext);
    };
    return pre;
  }, {}));
  const Modal = Object.assign(_Modal, __spreadProps(__spreadValues({}, modal), {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Modal.name, _Modal);
      const modalWithContext = {};
      for (const key of Object.keys(modal)) {
        modalWithContext[key] = (config, appContext = app._context) => modal[key](config, appContext);
      }
      app.config.globalProperties.$modal = modalWithContext;
    },
    _context: null
  }));
  const _sfc_main$Y = vue.defineComponent({
    name: "Notification",
    components: {
      AIconHover: IconHover,
      IconInfoCircleFill,
      IconCheckCircleFill,
      IconExclamationCircleFill,
      IconCloseCircleFill,
      IconClose
    },
    props: {
      type: {
        type: String,
        default: "info"
      },
      showIcon: {
        type: Boolean,
        default: true
      },
      closable: {
        type: Boolean,
        default: false
      },
      duration: {
        type: Number,
        default: 3e3
      },
      resetOnUpdate: {
        type: Boolean,
        default: false
      }
    },
    emits: ["close"],
    setup(props, context) {
      const prefixCls = getPrefixCls("notification");
      let timer = 0;
      const handleClose = () => {
        context.emit("close");
      };
      vue.onMounted(() => {
        if (props.duration > 0) {
          timer = window.setTimeout(handleClose, props.duration);
        }
      });
      vue.onUpdated(() => {
        if (props.resetOnUpdate) {
          if (timer) {
            window.clearTimeout(timer);
            timer = 0;
          }
          if (props.duration > 0) {
            timer = window.setTimeout(handleClose, props.duration);
          }
        }
      });
      vue.onUnmounted(() => {
        if (timer) {
          window.clearTimeout(timer);
        }
      });
      return {
        prefixCls,
        handleClose
      };
    }
  });
  function _sfc_render$X(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_icon_info_circle_fill = vue.resolveComponent("icon-info-circle-fill");
    const _component_icon_check_circle_fill = vue.resolveComponent("icon-check-circle-fill");
    const _component_icon_exclamation_circle_fill = vue.resolveComponent("icon-exclamation-circle-fill");
    const _component_icon_close_circle_fill = vue.resolveComponent("icon-close-circle-fill");
    const _component_icon_close = vue.resolveComponent("icon-close");
    const _component_a_icon_hover = vue.resolveComponent("a-icon-hover");
    return vue.openBlock(), vue.createElementBlock("li", {
      role: "alert",
      class: vue.normalizeClass([
        _ctx.prefixCls,
        `${_ctx.prefixCls}-${_ctx.type}`,
        { [`${_ctx.prefixCls}-closable`]: _ctx.closable }
      ])
    }, [
      _ctx.showIcon ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: vue.normalizeClass(`${_ctx.prefixCls}-left`)
      }, [
        vue.createElementVNode("div", {
          class: vue.normalizeClass(`${_ctx.prefixCls}-icon`)
        }, [
          vue.renderSlot(_ctx.$slots, "icon", {}, () => [
            _ctx.type === "info" ? (vue.openBlock(), vue.createBlock(_component_icon_info_circle_fill, { key: 0 })) : _ctx.type === "success" ? (vue.openBlock(), vue.createBlock(_component_icon_check_circle_fill, { key: 1 })) : _ctx.type === "warning" ? (vue.openBlock(), vue.createBlock(_component_icon_exclamation_circle_fill, { key: 2 })) : _ctx.type === "error" ? (vue.openBlock(), vue.createBlock(_component_icon_close_circle_fill, { key: 3 })) : vue.createCommentVNode("v-if", true)
          ])
        ], 2)
      ], 2)) : vue.createCommentVNode("v-if", true),
      vue.createElementVNode("div", {
        class: vue.normalizeClass(`${_ctx.prefixCls}-right`)
      }, [
        _ctx.$slots.default ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 0,
          class: vue.normalizeClass(`${_ctx.prefixCls}-title`)
        }, [
          vue.renderSlot(_ctx.$slots, "default")
        ], 2)) : vue.createCommentVNode("v-if", true),
        _ctx.$slots.content ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 1,
          class: vue.normalizeClass(`${_ctx.prefixCls}-content`)
        }, [
          vue.renderSlot(_ctx.$slots, "content")
        ], 2)) : vue.createCommentVNode("v-if", true),
        _ctx.$slots.footer ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 2,
          class: vue.normalizeClass(`${_ctx.prefixCls}-footer`)
        }, [
          vue.renderSlot(_ctx.$slots, "footer")
        ], 2)) : vue.createCommentVNode("v-if", true)
      ], 2),
      _ctx.closable ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 1,
        class: vue.normalizeClass(`${_ctx.prefixCls}-close-btn`),
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClose && _ctx.handleClose(...args))
      }, [
        vue.renderSlot(_ctx.$slots, "closeIconElement", {}, () => [
          vue.createVNode(_component_a_icon_hover, null, {
            default: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "closeIcon", {}, () => [
                vue.createVNode(_component_icon_close)
              ])
            ]),
            _: 3
          })
        ])
      ], 2)) : vue.createCommentVNode("v-if", true)
    ], 2);
  }
  var Notification$1 = /* @__PURE__ */ _export_sfc(_sfc_main$Y, [["render", _sfc_render$X]]);
  const NOTIFICATION_POSITION = [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ];
  function _isSlot$7(s) {
    return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !vue.isVNode(s);
  }
  var NotificationList = vue.defineComponent({
    name: "NotificationList",
    props: {
      notifications: {
        type: Array,
        default: () => []
      },
      position: {
        type: String,
        default: "topRight",
        validator: (value) => {
          return NOTIFICATION_POSITION.includes(value);
        }
      }
    },
    emits: ["close", "afterClose"],
    setup(props, context) {
      const prefixCls = getPrefixCls("notification-list");
      const kebabPosition = toKebabCase(props.position);
      const {
        zIndex
      } = usePopupManager("message", {
        runOnMounted: true
      });
      const isRight = props.position.includes("Right");
      return () => {
        let _slot;
        return vue.createVNode(vue.TransitionGroup, {
          "class": [prefixCls, `${prefixCls}-${kebabPosition}`],
          "style": {
            zIndex: zIndex.value
          },
          "name": `slide-${isRight ? "right" : "left"}-notification`,
          "onAfterLeave": () => context.emit("afterClose"),
          "tag": "ul"
        }, _isSlot$7(_slot = props.notifications.map((item) => {
          const slots = {
            default: getSlotFunction(item.title),
            content: getSlotFunction(item.content),
            icon: getSlotFunction(item.icon),
            footer: getSlotFunction(item.footer),
            closeIcon: getSlotFunction(item.closeIcon),
            closeIconElement: getSlotFunction(item.closeIconElement)
          };
          return vue.createVNode(Notification$1, {
            "key": item.id,
            "type": item.type,
            "style": item.style,
            "class": item.class,
            "duration": item.duration,
            "closable": item.closable,
            "showIcon": item.showIcon,
            "resetOnUpdate": item.resetOnUpdate,
            "onClose": () => context.emit("close", item.id)
          }, slots);
        })) ? _slot : {
          default: () => [_slot]
        });
      };
    }
  });
  class NotificationManger {
    constructor(config, appContext) {
      this.notificationCount = 0;
      this.add = (config2) => {
        var _a;
        this.notificationCount++;
        const id = (_a = config2.id) != null ? _a : `__arco_notification_${this.notificationCount}`;
        if (this.notificationIds.has(id)) {
          return this.update(id, config2);
        }
        const notification2 = vue.reactive(__spreadValues({ id }, config2));
        this.notifications.value.push(notification2);
        this.notificationIds.add(id);
        return {
          close: () => this.remove(id)
        };
      };
      this.update = (id, config2) => {
        for (let i = 0; i < this.notifications.value.length; i++) {
          if (this.notifications.value[i].id === id) {
            const resetOnUpdate = !isUndefined(config2.duration);
            Object.assign(this.notifications.value[i], __spreadProps(__spreadValues({}, config2), {
              id,
              resetOnUpdate
            }));
            break;
          }
        }
        return {
          close: () => this.remove(id)
        };
      };
      this.remove = (id) => {
        for (let i = 0; i < this.notifications.value.length; i++) {
          const item = this.notifications.value[i];
          if (item.id === id) {
            if (isFunction$1(item.onClose)) {
              item.onClose(id);
            }
            this.notifications.value.splice(i, 1);
            this.notificationIds.delete(id);
            break;
          }
        }
      };
      this.clear = () => {
        this.notifications.value.splice(0);
      };
      this.destroy = () => {
        if (this.notifications.value.length === 0 && this.container) {
          vue.render(null, this.container);
          document.body.removeChild(this.container);
          this.container = null;
          notificationInstance[this.position] = void 0;
        }
      };
      const { position = "topRight" } = config;
      this.container = getOverlay("notification");
      this.notificationIds = new Set();
      this.notifications = vue.ref([]);
      this.position = position;
      const vm = vue.createVNode(NotificationList, {
        notifications: this.notifications.value,
        position,
        onClose: this.remove,
        onAfterClose: this.destroy
      });
      if (appContext != null ? appContext : Notification._context) {
        vm.appContext = appContext != null ? appContext : Notification._context;
      }
      vue.render(vm, this.container);
      document.body.appendChild(this.container);
    }
  }
  const notificationInstance = {};
  const notification = MESSAGE_TYPES.reduce((pre, value) => {
    pre[value] = (config, appContext) => {
      if (isString$1(config)) {
        config = { content: config };
      }
      const _config = __spreadValues({ type: value }, config);
      const { position = "topRight" } = _config;
      if (!notificationInstance[position]) {
        notificationInstance[position] = new NotificationManger(_config, appContext);
      }
      return notificationInstance[position].add(_config);
    };
    return pre;
  }, {});
  notification.remove = (id) => {
    if (id) {
      Object.values(notificationInstance).forEach((item) => item == null ? void 0 : item.remove(id));
    }
  };
  notification.clear = (position) => {
    var _a;
    if (position) {
      (_a = notificationInstance[position]) == null ? void 0 : _a.clear();
    } else {
      Object.values(notificationInstance).forEach((item) => item == null ? void 0 : item.clear());
    }
  };
  const Notification = __spreadProps(__spreadValues({}, notification), {
    install: (app) => {
      const _notification = {
        clear: notification.clear
      };
      for (const key of MESSAGE_TYPES) {
        _notification[key] = (config, appContext = app._context) => notification[key](config, appContext);
      }
      app.config.globalProperties.$notification = _notification;
    },
    _context: null
  });
  const _sfc_main$X = vue.defineComponent({
    name: "PageHeader",
    components: { AIconHover: IconHover, IconLeft },
    props: {
      title: String,
      subtitle: String,
      showBack: {
        type: Boolean,
        default: true
      }
    },
    emits: [
      "back"
    ],
    setup(props, { emit, slots }) {
      const prefixCls = getPrefixCls("page-header");
      const handleBack = (e2) => {
        emit("back", e2);
      };
      const cls = vue.computed(() => [
        prefixCls,
        {
          [`${prefixCls}-with-breadcrumb`]: Boolean(slots.breadcrumb),
          [`${prefixCls}-with-content`]: Boolean(slots.default)
        }
      ]);
      return {
        prefixCls,
        cls,
        handleBack
      };
    }
  });
  function _sfc_render$W(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_icon_left = vue.resolveComponent("icon-left");
    const _component_a_icon_hover = vue.resolveComponent("a-icon-hover");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.cls)
    }, [
      vue.createElementVNode("div", {
        class: vue.normalizeClass(`${_ctx.prefixCls}-wrapper`)
      }, [
        _ctx.$slots.breadcrumb ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 0,
          class: vue.normalizeClass(`${_ctx.prefixCls}-breadcrumb`)
        }, [
          vue.renderSlot(_ctx.$slots, "breadcrumb")
        ], 2)) : vue.createCommentVNode("v-if", true),
        vue.createElementVNode("div", {
          class: vue.normalizeClass(`${_ctx.prefixCls}-header`)
        }, [
          vue.createElementVNode("span", {
            class: vue.normalizeClass(`${_ctx.prefixCls}-main`)
          }, [
            _ctx.showBack ? (vue.openBlock(), vue.createBlock(_component_a_icon_hover, {
              key: 0,
              class: vue.normalizeClass(`${_ctx.prefixCls}-back-btn`),
              prefix: _ctx.prefixCls,
              onClick: _ctx.handleBack
            }, {
              default: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "back-icon", {}, () => [
                  vue.createVNode(_component_icon_left)
                ])
              ]),
              _: 3
            }, 8, ["class", "prefix", "onClick"])) : vue.createCommentVNode("v-if", true),
            vue.createElementVNode("span", {
              class: vue.normalizeClass(`${_ctx.prefixCls}-title`)
            }, [
              vue.renderSlot(_ctx.$slots, "title", {}, () => [
                vue.createTextVNode(vue.toDisplayString(_ctx.title), 1)
              ])
            ], 2),
            _ctx.$slots.subtitle || _ctx.subtitle ? (vue.openBlock(), vue.createElementBlock("span", {
              key: 1,
              class: vue.normalizeClass(`${_ctx.prefixCls}-divider`)
            }, null, 2)) : vue.createCommentVNode("v-if", true),
            _ctx.$slots.subtitle || _ctx.subtitle ? (vue.openBlock(), vue.createElementBlock("span", {
              key: 2,
              class: vue.normalizeClass(`${_ctx.prefixCls}-subtitle`)
            }, [
              vue.renderSlot(_ctx.$slots, "subtitle", {}, () => [
                vue.createTextVNode(vue.toDisplayString(_ctx.subtitle), 1)
              ])
            ], 2)) : vue.createCommentVNode("v-if", true)
          ], 2),
          _ctx.$slots.extra ? (vue.openBlock(), vue.createElementBlock("span", {
            key: 0,
            class: vue.normalizeClass(`${_ctx.prefixCls}-extra`)
          }, [
            vue.renderSlot(_ctx.$slots, "extra")
          ], 2)) : vue.createCommentVNode("v-if", true)
        ], 2)
      ], 2),
      _ctx.$slots.default ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: vue.normalizeClass(`${_ctx.prefixCls}-content`)
      }, [
        vue.renderSlot(_ctx.$slots, "default")
      ], 2)) : vue.createCommentVNode("v-if", true)
    ], 2);
  }
  var _PageHeader = /* @__PURE__ */ _export_sfc(_sfc_main$X, [["render", _sfc_render$W]]);
  const PageHeader = Object.assign(_PageHeader, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _PageHeader.name, _PageHeader);
    }
  });
  const _sfc_main$W = vue.defineComponent({
    name: "Popconfirm",
    components: {
      ArcoButton: Button,
      Trigger,
      IconInfoCircleFill,
      IconCheckCircleFill,
      IconExclamationCircleFill,
      IconCloseCircleFill
    },
    props: {
      content: String,
      position: {
        type: String,
        default: "top"
      },
      popupVisible: {
        type: Boolean,
        default: void 0
      },
      defaultPopupVisible: {
        type: Boolean,
        default: false
      },
      type: {
        type: String,
        default: "info"
      },
      okText: String,
      cancelText: String,
      okLoading: {
        type: Boolean,
        default: false
      },
      okButtonProps: {
        type: Object
      },
      cancelButtonProps: {
        type: Object
      },
      contentClass: {
        type: [String, Array, Object]
      },
      contentStyle: {
        type: Object
      },
      arrowClass: {
        type: [String, Array, Object]
      },
      arrowStyle: {
        type: Object
      },
      popupContainer: {
        type: [String, Object]
      },
      onBeforeOk: {
        type: Function
      },
      onBeforeCancel: {
        type: Function
      }
    },
    emits: {
      "update:popupVisible": (visible) => true,
      "popupVisibleChange": (visible) => true,
      "ok": () => true,
      "cancel": () => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("popconfirm");
      const { t: t2 } = useI18n();
      const _popupVisible = vue.ref(props.defaultPopupVisible);
      const computedPopupVisible = vue.computed(() => {
        var _a;
        return (_a = props.popupVisible) != null ? _a : _popupVisible.value;
      });
      const _okLoading = vue.ref(false);
      const mergedOkLoading = vue.computed(() => props.okLoading || _okLoading.value);
      let promiseNumber = 0;
      const close = () => {
        promiseNumber++;
        if (_okLoading.value) {
          _okLoading.value = false;
        }
        _popupVisible.value = false;
        emit("update:popupVisible", false);
        emit("popupVisibleChange", false);
      };
      const handlePopupVisibleChange = (visible) => {
        if (!visible) {
          close();
        } else {
          _popupVisible.value = visible;
          emit("update:popupVisible", visible);
          emit("popupVisibleChange", visible);
        }
      };
      const handleOk = async () => {
        const currentPromiseNumber = promiseNumber;
        const closed = await new Promise(async (resolve) => {
          var _a;
          if (isFunction$1(props.onBeforeOk)) {
            let result = props.onBeforeOk((closed2 = true) => resolve(closed2));
            if (isPromise(result) || !isBoolean$1(result)) {
              _okLoading.value = true;
            }
            if (isPromise(result)) {
              try {
                result = (_a = await result) != null ? _a : true;
              } catch (error) {
                result = false;
              }
            }
            if (isBoolean$1(result)) {
              resolve(result);
            }
          } else {
            resolve(true);
          }
        });
        if (currentPromiseNumber === promiseNumber) {
          if (closed) {
            emit("ok");
            close();
          } else if (_okLoading.value) {
            _okLoading.value = false;
          }
        }
      };
      const handleCancel = () => {
        var _a;
        let result = true;
        if (isFunction$1(props.onBeforeCancel)) {
          result = (_a = props.onBeforeCancel()) != null ? _a : false;
        }
        if (result) {
          emit("cancel");
          close();
        }
      };
      const contentCls = vue.computed(() => [
        `${prefixCls}-popup-content`,
        props.contentClass
      ]);
      const arrowCls = vue.computed(() => [
        `${prefixCls}-popup-arrow`,
        props.arrowClass
      ]);
      return {
        prefixCls,
        contentCls,
        arrowCls,
        computedPopupVisible,
        mergedOkLoading,
        handlePopupVisibleChange,
        handleOk,
        handleCancel,
        t: t2
      };
    }
  });
  function _sfc_render$V(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_icon_info_circle_fill = vue.resolveComponent("icon-info-circle-fill");
    const _component_icon_check_circle_fill = vue.resolveComponent("icon-check-circle-fill");
    const _component_icon_exclamation_circle_fill = vue.resolveComponent("icon-exclamation-circle-fill");
    const _component_icon_close_circle_fill = vue.resolveComponent("icon-close-circle-fill");
    const _component_arco_button = vue.resolveComponent("arco-button");
    const _component_trigger = vue.resolveComponent("trigger");
    return vue.openBlock(), vue.createBlock(_component_trigger, {
      class: vue.normalizeClass(_ctx.prefixCls),
      trigger: "click",
      position: _ctx.position,
      "show-arrow": "",
      "popup-visible": _ctx.computedPopupVisible,
      "popup-offset": 10,
      "popup-container": _ctx.popupContainer,
      "content-class": _ctx.contentCls,
      "content-style": _ctx.contentStyle,
      "arrow-class": _ctx.arrowCls,
      "arrow-style": _ctx.arrowStyle,
      "animation-name": "zoom-in-fade-out",
      "auto-fit-transform-origin": "",
      onPopupVisibleChange: _ctx.handlePopupVisibleChange
    }, {
      content: vue.withCtx(() => [
        vue.createElementVNode("div", {
          class: vue.normalizeClass(`${_ctx.prefixCls}-body`)
        }, [
          vue.createElementVNode("span", {
            class: vue.normalizeClass(`${_ctx.prefixCls}-icon`)
          }, [
            vue.renderSlot(_ctx.$slots, "icon", {}, () => [
              _ctx.type === "info" ? (vue.openBlock(), vue.createBlock(_component_icon_info_circle_fill, { key: 0 })) : _ctx.type === "success" ? (vue.openBlock(), vue.createBlock(_component_icon_check_circle_fill, { key: 1 })) : _ctx.type === "warning" ? (vue.openBlock(), vue.createBlock(_component_icon_exclamation_circle_fill, { key: 2 })) : _ctx.type === "error" ? (vue.openBlock(), vue.createBlock(_component_icon_close_circle_fill, { key: 3 })) : vue.createCommentVNode("v-if", true)
            ])
          ], 2),
          vue.createElementVNode("span", {
            class: vue.normalizeClass(`${_ctx.prefixCls}-content`)
          }, [
            vue.renderSlot(_ctx.$slots, "content", {}, () => [
              vue.createTextVNode(vue.toDisplayString(_ctx.content), 1)
            ])
          ], 2)
        ], 2),
        vue.createElementVNode("div", {
          class: vue.normalizeClass(`${_ctx.prefixCls}-footer`)
        }, [
          vue.createVNode(_component_arco_button, vue.mergeProps({ size: "mini" }, _ctx.cancelButtonProps, { onClick: _ctx.handleCancel }), {
            default: vue.withCtx(() => [
              vue.createTextVNode(vue.toDisplayString(_ctx.cancelText || _ctx.t("popconfirm.cancelText")), 1)
            ]),
            _: 1
          }, 16, ["onClick"]),
          vue.createVNode(_component_arco_button, vue.mergeProps({
            type: "primary",
            size: "mini"
          }, _ctx.okButtonProps, {
            loading: _ctx.mergedOkLoading,
            onClick: _ctx.handleOk
          }), {
            default: vue.withCtx(() => [
              vue.createTextVNode(vue.toDisplayString(_ctx.okText || _ctx.t("popconfirm.okText")), 1)
            ]),
            _: 1
          }, 16, ["loading", "onClick"])
        ], 2)
      ]),
      default: vue.withCtx(() => [
        vue.renderSlot(_ctx.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "position", "popup-visible", "popup-container", "content-class", "content-style", "arrow-class", "arrow-style", "onPopupVisibleChange"]);
  }
  var _Popconfirm = /* @__PURE__ */ _export_sfc(_sfc_main$W, [["render", _sfc_render$V]]);
  const Popconfirm = Object.assign(_Popconfirm, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Popconfirm.name, _Popconfirm);
    }
  });
  const DEFAULT_STROKE_WIDTH$1 = {
    small: 3,
    medium: 4,
    large: 8
  };
  const getBackground = (color) => {
    if (!color) {
      return void 0;
    }
    if (isObject$1(color)) {
      const val = Object.keys(color).map((key) => `${color[key]} ${key}`).join(",");
      return {
        backgroundImage: `linear-gradient(to right, ${val})`
      };
    }
    return {
      backgroundColor: color
    };
  };
  const _sfc_main$V = vue.defineComponent({
    name: "ProgressLine",
    components: {
      IconExclamationCircleFill
    },
    props: {
      percent: {
        type: Number,
        default: 0
      },
      animation: {
        type: Boolean,
        default: false
      },
      size: {
        type: String,
        default: "medium"
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      width: {
        type: [Number, String],
        default: "100%"
      },
      color: {
        type: [String, Object],
        default: void 0
      },
      trackColor: String,
      formatText: {
        type: Function,
        default: void 0
      },
      status: {
        type: String
      },
      showText: Boolean
    },
    setup(props) {
      const prefixCls = getPrefixCls("progress-line");
      const strokeWidth = vue.computed(() => {
        if (props.strokeWidth !== 4) {
          return props.strokeWidth;
        }
        return DEFAULT_STROKE_WIDTH$1[props.size];
      });
      const text = vue.computed(() => `${index.times(props.percent, 100)}%`);
      const style = vue.computed(() => ({
        width: props.width,
        height: `${strokeWidth.value}px`,
        backgroundColor: props.trackColor
      }));
      const barStyle = vue.computed(() => __spreadValues({
        width: `${props.percent * 100}%`
      }, getBackground(props.color)));
      return {
        prefixCls,
        style,
        barStyle,
        text
      };
    }
  });
  const _hoisted_1$r = ["aria-valuenow"];
  function _sfc_render$U(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_icon_exclamation_circle_fill = vue.resolveComponent("icon-exclamation-circle-fill");
    return vue.openBlock(), vue.createElementBlock("div", {
      role: "progressbar",
      "aria-valuemin": "0",
      "aria-valuemax": "100",
      "aria-valuenow": _ctx.percent,
      class: vue.normalizeClass(`${_ctx.prefixCls}-wrapper`)
    }, [
      vue.createElementVNode("div", {
        class: vue.normalizeClass(_ctx.prefixCls),
        style: vue.normalizeStyle(_ctx.style)
      }, [
        vue.createElementVNode("div", {
          class: vue.normalizeClass(`${_ctx.prefixCls}-bar-buffer`)
        }, null, 2),
        vue.createElementVNode("div", {
          class: vue.normalizeClass([`${_ctx.prefixCls}-bar`]),
          style: vue.normalizeStyle(_ctx.barStyle)
        }, null, 6)
      ], 6),
      _ctx.showText ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: vue.normalizeClass(`${_ctx.prefixCls}-text`)
      }, [
        vue.renderSlot(_ctx.$slots, "text", { percent: _ctx.percent }, () => [
          vue.createTextVNode(vue.toDisplayString(_ctx.text) + " ", 1),
          _ctx.status === "danger" ? (vue.openBlock(), vue.createBlock(_component_icon_exclamation_circle_fill, { key: 0 })) : vue.createCommentVNode("v-if", true)
        ])
      ], 2)) : vue.createCommentVNode("v-if", true)
    ], 10, _hoisted_1$r);
  }
  var ProgressLine = /* @__PURE__ */ _export_sfc(_sfc_main$V, [["render", _sfc_render$U]]);
  const _sfc_main$U = vue.defineComponent({
    name: "IconExclamation",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-exclamation`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$q = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$m = /* @__PURE__ */ vue.createElementVNode("path", { d: "M23 9h2v21h-2z" }, null, -1);
  const _hoisted_3$l = /* @__PURE__ */ vue.createElementVNode("path", {
    fill: "currentColor",
    stroke: "none",
    d: "M23 9h2v21h-2z"
  }, null, -1);
  const _hoisted_4$6 = /* @__PURE__ */ vue.createElementVNode("path", { d: "M23 37h2v2h-2z" }, null, -1);
  const _hoisted_5$3 = /* @__PURE__ */ vue.createElementVNode("path", {
    fill: "currentColor",
    stroke: "none",
    d: "M23 37h2v2h-2z"
  }, null, -1);
  const _hoisted_6$2 = [
    _hoisted_2$m,
    _hoisted_3$l,
    _hoisted_4$6,
    _hoisted_5$3
  ];
  function _sfc_render$T(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_6$2, 14, _hoisted_1$q);
  }
  var _IconExclamation = /* @__PURE__ */ _export_sfc(_sfc_main$U, [["render", _sfc_render$T]]);
  const IconExclamation = Object.assign(_IconExclamation, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconExclamation.name, _IconExclamation);
    }
  });
  const _sfc_main$T = vue.defineComponent({
    name: "IconCheck",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-check`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$p = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$l = /* @__PURE__ */ vue.createElementVNode("path", { d: "M41.678 11.05 19.05 33.678 6.322 20.95" }, null, -1);
  const _hoisted_3$k = [
    _hoisted_2$l
  ];
  function _sfc_render$S(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$k, 14, _hoisted_1$p);
  }
  var _IconCheck = /* @__PURE__ */ _export_sfc(_sfc_main$T, [["render", _sfc_render$S]]);
  const IconCheck = Object.assign(_IconCheck, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconCheck.name, _IconCheck);
    }
  });
  let __ARCO_PROGRESS_SEED = 0;
  const DEFAULT_WIDTH = {
    mini: 16,
    small: 48,
    medium: 64,
    large: 80
  };
  const DEFAULT_STROKE_WIDTH = {
    mini: 4,
    small: 3,
    medium: 4,
    large: 4
  };
  const _sfc_main$S = vue.defineComponent({
    name: "ProgressCircle",
    components: {
      IconExclamation,
      IconCheck
    },
    props: {
      percent: {
        type: Number,
        default: 0
      },
      type: {
        type: String
      },
      size: {
        type: String,
        default: "medium"
      },
      strokeWidth: {
        type: Number
      },
      width: {
        type: Number,
        default: void 0
      },
      color: {
        type: [String, Object],
        default: void 0
      },
      trackColor: String,
      status: {
        type: String,
        default: void 0
      },
      showText: {
        type: Boolean,
        default: true
      },
      pathStrokeWidth: {
        type: Number
      }
    },
    setup(props) {
      const prefixCls = getPrefixCls("progress-circle");
      const isLinearGradient = isObject$1(props.color);
      const mergedWidth = vue.computed(() => {
        var _a;
        return (_a = props.width) != null ? _a : DEFAULT_WIDTH[props.size];
      });
      const mergedStrokeWidth = vue.computed(() => {
        var _a;
        return (_a = props.strokeWidth) != null ? _a : props.size === "mini" ? mergedWidth.value / 2 : DEFAULT_STROKE_WIDTH[props.size];
      });
      const mergedPathStrokeWidth = vue.computed(() => {
        var _a;
        return (_a = props.pathStrokeWidth) != null ? _a : props.size === "mini" ? mergedStrokeWidth.value : Math.max(2, mergedStrokeWidth.value - 2);
      });
      const radius = vue.computed(() => (mergedWidth.value - mergedStrokeWidth.value) / 2);
      const perimeter = vue.computed(() => Math.PI * 2 * radius.value);
      const center = vue.computed(() => mergedWidth.value / 2);
      const linearGradientId = vue.computed(() => {
        __ARCO_PROGRESS_SEED += 1;
        return `${prefixCls}-linear-gradient-${__ARCO_PROGRESS_SEED}`;
      });
      const text = vue.computed(() => `${index.times(props.percent, 100)}%`);
      return {
        prefixCls,
        isLinearGradient,
        radius,
        text,
        perimeter,
        center,
        mergedWidth,
        mergedStrokeWidth,
        mergedPathStrokeWidth,
        linearGradientId
      };
    }
  });
  const _hoisted_1$o = ["aria-valuenow"];
  const _hoisted_2$k = ["viewBox"];
  const _hoisted_3$j = { key: 0 };
  const _hoisted_4$5 = ["id"];
  const _hoisted_5$2 = ["offset", "stop-color"];
  const _hoisted_6$1 = ["cx", "cy", "r", "stroke-width"];
  const _hoisted_7 = ["cx", "cy", "r", "stroke-width"];
  function _sfc_render$R(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_icon_check = vue.resolveComponent("icon-check");
    const _component_icon_exclamation = vue.resolveComponent("icon-exclamation");
    return vue.openBlock(), vue.createElementBlock("div", {
      role: "progressbar",
      "aria-valuemin": "0",
      "aria-valuemax": "100",
      "aria-valuenow": _ctx.percent,
      class: vue.normalizeClass(`${_ctx.prefixCls}-wrapper`),
      style: vue.normalizeStyle({ width: `${_ctx.mergedWidth}px`, height: `${_ctx.mergedWidth}px` })
    }, [
      _ctx.type === "circle" && _ctx.size === "mini" && _ctx.status === "success" ? (vue.openBlock(), vue.createBlock(_component_icon_check, {
        key: 0,
        style: vue.normalizeStyle({ fontSize: _ctx.mergedWidth - 2, color: _ctx.color })
      }, null, 8, ["style"])) : (vue.openBlock(), vue.createElementBlock("svg", {
        key: 1,
        viewBox: `0 0 ${_ctx.mergedWidth} ${_ctx.mergedWidth}`,
        class: vue.normalizeClass(`${_ctx.prefixCls}-svg`)
      }, [
        _ctx.isLinearGradient ? (vue.openBlock(), vue.createElementBlock("defs", _hoisted_3$j, [
          vue.createElementVNode("linearGradient", {
            id: _ctx.linearGradientId,
            x1: "0",
            y1: "1",
            x2: "0",
            y2: "0"
          }, [
            (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(Object.keys(_ctx.color), (key) => {
              return vue.openBlock(), vue.createElementBlock("stop", {
                key,
                offset: key,
                "stop-color": _ctx.color[key]
              }, null, 8, _hoisted_5$2);
            }), 128))
          ], 8, _hoisted_4$5)
        ])) : vue.createCommentVNode("v-if", true),
        vue.createElementVNode("circle", {
          class: vue.normalizeClass(`${_ctx.prefixCls}-bg`),
          fill: "none",
          cx: _ctx.center,
          cy: _ctx.center,
          r: _ctx.radius,
          "stroke-width": _ctx.mergedPathStrokeWidth,
          style: vue.normalizeStyle({
            stroke: _ctx.trackColor
          })
        }, null, 14, _hoisted_6$1),
        vue.createElementVNode("circle", {
          class: vue.normalizeClass(`${_ctx.prefixCls}-bar`),
          fill: "none",
          cx: _ctx.center,
          cy: _ctx.center,
          r: _ctx.radius,
          "stroke-width": _ctx.mergedStrokeWidth,
          style: vue.normalizeStyle({
            stroke: _ctx.isLinearGradient ? `url(#${_ctx.linearGradientId})` : _ctx.color,
            strokeDasharray: _ctx.perimeter,
            strokeDashoffset: (_ctx.percent >= 1 ? 0 : 1 - _ctx.percent) * _ctx.perimeter
          })
        }, null, 14, _hoisted_7)
      ], 10, _hoisted_2$k)),
      _ctx.showText && _ctx.size !== "mini" ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 2,
        class: vue.normalizeClass(`${_ctx.prefixCls}-text`)
      }, [
        vue.renderSlot(_ctx.$slots, "text", { percent: _ctx.percent }, () => [
          _ctx.status === "danger" ? (vue.openBlock(), vue.createBlock(_component_icon_exclamation, { key: 0 })) : _ctx.status === "success" ? (vue.openBlock(), vue.createBlock(_component_icon_check, { key: 1 })) : (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 2 }, [
            vue.createTextVNode(vue.toDisplayString(_ctx.text), 1)
          ], 2112))
        ])
      ], 2)) : vue.createCommentVNode("v-if", true)
    ], 14, _hoisted_1$o);
  }
  var ProgressCircle = /* @__PURE__ */ _export_sfc(_sfc_main$S, [["render", _sfc_render$R]]);
  const _sfc_main$R = vue.defineComponent({
    name: "ProgressSteps",
    components: {
      IconExclamationCircleFill
    },
    props: {
      steps: {
        type: Number,
        default: 0
      },
      percent: {
        type: Number,
        default: 0
      },
      size: {
        type: String
      },
      color: {
        type: [String, Object],
        default: void 0
      },
      trackColor: String,
      strokeWidth: {
        type: Number
      },
      status: {
        type: String,
        default: void 0
      },
      showText: {
        type: Boolean,
        default: true
      }
    },
    setup(props) {
      const prefixCls = getPrefixCls("progress-steps");
      const mergedStrokeWidth = vue.computed(() => {
        var _a;
        return ((_a = props.strokeWidth) != null ? _a : props.size === "small") ? 8 : 4;
      });
      const stepList = vue.computed(() => [...Array(props.steps)].map((_, index2) => {
        return props.percent > 0 && props.percent > 1 / props.steps * index2;
      }));
      const text = vue.computed(() => `${index.times(props.percent, 100)}%`);
      return {
        prefixCls,
        stepList,
        mergedStrokeWidth,
        text
      };
    }
  });
  const _hoisted_1$n = ["aria-valuenow"];
  function _sfc_render$Q(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_icon_exclamation_circle_fill = vue.resolveComponent("icon-exclamation-circle-fill");
    return vue.openBlock(), vue.createElementBlock("div", {
      role: "progressbar",
      "aria-valuemin": "0",
      "aria-valuemax": "100",
      "aria-valuenow": _ctx.percent,
      class: vue.normalizeClass(`${_ctx.prefixCls}-wrapper`)
    }, [
      vue.createElementVNode("div", {
        class: vue.normalizeClass(_ctx.prefixCls),
        style: vue.normalizeStyle({ height: `${_ctx.mergedStrokeWidth}px` })
      }, [
        (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.stepList, (active, index2) => {
          return vue.openBlock(), vue.createElementBlock("div", {
            key: index2,
            class: vue.normalizeClass([
              `${_ctx.prefixCls}-item`,
              {
                [`${_ctx.prefixCls}-item-active`]: active
              }
            ]),
            style: vue.normalizeStyle({
              backgroundColor: active ? _ctx.color : _ctx.trackColor
            })
          }, null, 6);
        }), 128))
      ], 6),
      _ctx.showText ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: vue.normalizeClass(`${_ctx.prefixCls}-text`)
      }, [
        vue.renderSlot(_ctx.$slots, "text", { percent: _ctx.percent }, () => [
          vue.createTextVNode(vue.toDisplayString(_ctx.text) + " ", 1),
          _ctx.status === "danger" ? (vue.openBlock(), vue.createBlock(_component_icon_exclamation_circle_fill, { key: 0 })) : vue.createCommentVNode("v-if", true)
        ])
      ], 2)) : vue.createCommentVNode("v-if", true)
    ], 10, _hoisted_1$n);
  }
  var ProgressSteps = /* @__PURE__ */ _export_sfc(_sfc_main$R, [["render", _sfc_render$Q]]);
  const _sfc_main$Q = vue.defineComponent({
    name: "Progress",
    components: {
      ProgressLine,
      ProgressCircle,
      ProgressSteps
    },
    props: {
      type: {
        type: String,
        default: "line"
      },
      size: {
        type: String
      },
      percent: {
        type: Number,
        default: 0
      },
      steps: {
        type: Number,
        default: 0
      },
      animation: {
        type: Boolean,
        default: false
      },
      strokeWidth: {
        type: Number
      },
      width: {
        type: [Number, String]
      },
      color: {
        type: [String, Object]
      },
      trackColor: String,
      bufferColor: {
        type: [String, Object]
      },
      showText: {
        type: Boolean,
        default: true
      },
      status: {
        type: String
      }
    },
    setup(props) {
      const prefixCls = getPrefixCls("progress");
      const { size } = vue.toRefs(props);
      const type = vue.computed(() => props.steps > 0 ? "steps" : props.type);
      const computedStatus = vue.computed(() => {
        return props.status || (props.percent >= 1 ? "success" : "normal");
      });
      const { mergedSize } = useSize$1(size);
      const cls = vue.computed(() => [
        prefixCls,
        `${prefixCls}-type-${type.value}`,
        `${prefixCls}-size-${mergedSize.value}`,
        `${prefixCls}-status-${computedStatus.value}`
      ]);
      return {
        cls,
        computedStatus,
        mergedSize
      };
    }
  });
  function _sfc_render$P(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_progress_steps = vue.resolveComponent("progress-steps");
    const _component_progress_line = vue.resolveComponent("progress-line");
    const _component_progress_circle = vue.resolveComponent("progress-circle");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.cls)
    }, [
      _ctx.steps > 0 ? (vue.openBlock(), vue.createBlock(_component_progress_steps, {
        key: 0,
        "stroke-width": _ctx.strokeWidth,
        percent: _ctx.percent,
        color: _ctx.color,
        "track-color": _ctx.trackColor,
        width: _ctx.width,
        steps: _ctx.steps,
        size: _ctx.mergedSize,
        "show-text": _ctx.showText
      }, vue.createSlots({ _: 2 }, [
        _ctx.$slots.text ? {
          name: "text",
          fn: vue.withCtx((scope) => [
            vue.renderSlot(_ctx.$slots, "text", vue.normalizeProps(vue.guardReactiveProps(scope)))
          ])
        } : void 0
      ]), 1032, ["stroke-width", "percent", "color", "track-color", "width", "steps", "size", "show-text"])) : _ctx.type === "line" && _ctx.mergedSize !== "mini" ? (vue.openBlock(), vue.createBlock(_component_progress_line, {
        key: 1,
        "stroke-width": _ctx.strokeWidth,
        animation: _ctx.animation,
        percent: _ctx.percent,
        color: _ctx.color,
        "track-color": _ctx.trackColor,
        size: _ctx.mergedSize,
        "buffer-color": _ctx.bufferColor,
        width: _ctx.width,
        "show-text": _ctx.showText,
        status: _ctx.computedStatus
      }, vue.createSlots({ _: 2 }, [
        _ctx.$slots.text ? {
          name: "text",
          fn: vue.withCtx((scope) => [
            vue.renderSlot(_ctx.$slots, "text", vue.normalizeProps(vue.guardReactiveProps(scope)))
          ])
        } : void 0
      ]), 1032, ["stroke-width", "animation", "percent", "color", "track-color", "size", "buffer-color", "width", "show-text", "status"])) : (vue.openBlock(), vue.createBlock(_component_progress_circle, {
        key: 2,
        type: _ctx.type,
        "stroke-width": _ctx.type === "line" ? _ctx.strokeWidth || 4 : _ctx.strokeWidth,
        "path-stroke-width": _ctx.type === "line" ? _ctx.strokeWidth || 4 : _ctx.strokeWidth,
        width: _ctx.width,
        percent: _ctx.percent,
        color: _ctx.color,
        "track-color": _ctx.trackColor,
        size: _ctx.mergedSize,
        "show-text": _ctx.showText,
        status: _ctx.computedStatus
      }, vue.createSlots({ _: 2 }, [
        _ctx.$slots.text ? {
          name: "text",
          fn: vue.withCtx((scope) => [
            vue.renderSlot(_ctx.$slots, "text", vue.normalizeProps(vue.guardReactiveProps(scope)))
          ])
        } : void 0
      ]), 1032, ["type", "stroke-width", "path-stroke-width", "width", "percent", "color", "track-color", "size", "show-text", "status"]))
    ], 2);
  }
  var _Progress = /* @__PURE__ */ _export_sfc(_sfc_main$Q, [["render", _sfc_render$P]]);
  const Progress = Object.assign(_Progress, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Progress.name, _Progress);
    }
  });
  const _sfc_main$P = vue.defineComponent({
    name: "IconStarFill",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-star-fill`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$m = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$j = /* @__PURE__ */ vue.createElementVNode("path", {
    d: "M22.683 5.415c.568-1.043 2.065-1.043 2.634 0l5.507 10.098a1.5 1.5 0 0 0 1.04.756l11.306 2.117c1.168.219 1.63 1.642.814 2.505l-7.902 8.359a1.5 1.5 0 0 0-.397 1.223l1.48 11.407c.153 1.177-1.058 2.057-2.131 1.548l-10.391-4.933a1.5 1.5 0 0 0-1.287 0l-10.39 4.933c-1.073.51-2.284-.37-2.131-1.548l1.48-11.407a1.5 1.5 0 0 0-.398-1.223L4.015 20.89c-.816-.863-.353-2.286.814-2.505l11.306-2.117a1.5 1.5 0 0 0 1.04-.756l5.508-10.098Z",
    fill: "currentColor",
    stroke: "none"
  }, null, -1);
  const _hoisted_3$i = [
    _hoisted_2$j
  ];
  function _sfc_render$O(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$i, 14, _hoisted_1$m);
  }
  var _IconStarFill = /* @__PURE__ */ _export_sfc(_sfc_main$P, [["render", _sfc_render$O]]);
  const IconStarFill = Object.assign(_IconStarFill, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconStarFill.name, _IconStarFill);
    }
  });
  const _sfc_main$O = vue.defineComponent({
    name: "IconFaceMehFill",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-face-meh-fill`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$l = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$i = /* @__PURE__ */ vue.createElementVNode("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm7.321-26.873a2.625 2.625 0 1 1 0 5.25 2.625 2.625 0 0 1 0-5.25Zm-14.646 0a2.625 2.625 0 1 1 0 5.25 2.625 2.625 0 0 1 0-5.25ZM15.999 30a2 2 0 0 1 2-2h12a2 2 0 1 1 0 4H18a2 2 0 0 1-2-2Z",
    fill: "currentColor",
    stroke: "none"
  }, null, -1);
  const _hoisted_3$h = [
    _hoisted_2$i
  ];
  function _sfc_render$N(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$h, 14, _hoisted_1$l);
  }
  var _IconFaceMehFill = /* @__PURE__ */ _export_sfc(_sfc_main$O, [["render", _sfc_render$N]]);
  const IconFaceMehFill = Object.assign(_IconFaceMehFill, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconFaceMehFill.name, _IconFaceMehFill);
    }
  });
  const _sfc_main$N = vue.defineComponent({
    name: "IconFaceSmileFill",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-face-smile-fill`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$k = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$h = /* @__PURE__ */ vue.createElementVNode("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm7.321-26.873a2.625 2.625 0 1 1 0 5.25 2.625 2.625 0 0 1 0-5.25Zm-14.646 0a2.625 2.625 0 1 1 0 5.25 2.625 2.625 0 0 1 0-5.25Zm-.355 9.953a1.91 1.91 0 0 1 2.694.177 6.66 6.66 0 0 0 5.026 2.279c1.918 0 3.7-.81 4.961-2.206a1.91 1.91 0 0 1 2.834 2.558 10.476 10.476 0 0 1-7.795 3.466 10.477 10.477 0 0 1-7.897-3.58 1.91 1.91 0 0 1 .177-2.694Z",
    fill: "currentColor",
    stroke: "none"
  }, null, -1);
  const _hoisted_3$g = [
    _hoisted_2$h
  ];
  function _sfc_render$M(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$g, 14, _hoisted_1$k);
  }
  var _IconFaceSmileFill = /* @__PURE__ */ _export_sfc(_sfc_main$N, [["render", _sfc_render$M]]);
  const IconFaceSmileFill = Object.assign(_IconFaceSmileFill, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconFaceSmileFill.name, _IconFaceSmileFill);
    }
  });
  const _sfc_main$M = vue.defineComponent({
    name: "IconFaceFrownFill",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-face-frown-fill`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$j = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$g = /* @__PURE__ */ vue.createElementVNode("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm7.322-26.873a2.625 2.625 0 1 1 0 5.25 2.625 2.625 0 0 1 0-5.25Zm-14.646 0a2.625 2.625 0 1 1 0 5.25 2.625 2.625 0 0 1 0-5.25ZM31.68 32.88a1.91 1.91 0 0 1-2.694-.176 6.66 6.66 0 0 0-5.026-2.28c-1.918 0-3.701.81-4.962 2.207a1.91 1.91 0 0 1-2.834-2.559 10.476 10.476 0 0 1 7.796-3.465c3.063 0 5.916 1.321 7.896 3.58a1.909 1.909 0 0 1-.176 2.693Z",
    fill: "currentColor",
    stroke: "none"
  }, null, -1);
  const _hoisted_3$f = [
    _hoisted_2$g
  ];
  function _sfc_render$L(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$f, 14, _hoisted_1$j);
  }
  var _IconFaceFrownFill = /* @__PURE__ */ _export_sfc(_sfc_main$M, [["render", _sfc_render$L]]);
  const IconFaceFrownFill = Object.assign(_IconFaceFrownFill, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconFaceFrownFill.name, _IconFaceFrownFill);
    }
  });
  var _Rate = vue.defineComponent({
    name: "Rate",
    props: {
      count: {
        type: Number,
        default: 5
      },
      modelValue: {
        type: Number,
        default: void 0
      },
      defaultValue: {
        type: Number,
        default: 0
      },
      allowHalf: {
        type: Boolean,
        default: false
      },
      allowClear: {
        type: Boolean,
        default: false
      },
      grading: {
        type: Boolean,
        default: false
      },
      readonly: {
        type: Boolean,
        default: false
      },
      disabled: {
        type: Boolean,
        default: false
      },
      color: {
        type: [String, Object]
      }
    },
    emits: {
      "update:modelValue": (value) => true,
      "change": (value) => true,
      "hoverChange": (value) => true
    },
    setup(props, {
      emit,
      slots
    }) {
      const {
        modelValue
      } = vue.toRefs(props);
      const prefixCls = getPrefixCls("rate");
      const {
        mergedDisabled: _mergedDisabled,
        eventHandlers
      } = useFormItem({
        disabled: vue.toRef(props, "disabled")
      });
      const _value = vue.ref(props.defaultValue);
      const animation = vue.ref(false);
      vue.watch(modelValue, (value) => {
        if (isUndefined(value) || isNull(value)) {
          _value.value = 0;
        }
      });
      const hoverIndex = vue.ref(0);
      const computedValue = vue.computed(() => {
        var _a;
        return (_a = props.modelValue) != null ? _a : _value.value;
      });
      const displayIndex = vue.computed(() => {
        const fixedValue = props.allowHalf ? index.times(index.round(index.divide(computedValue.value, 0.5), 0), 0.5) : Math.round(computedValue.value);
        return hoverIndex.value || fixedValue;
      });
      const mergedDisabled = vue.computed(() => _mergedDisabled.value || props.readonly);
      const indexArray = vue.computed(() => [...Array(props.grading ? 5 : props.count)]);
      const customColor = vue.computed(() => {
        var _a;
        if (isString$1(props.color)) {
          return indexArray.value.map(() => props.color);
        }
        if (isObject$1(props.color)) {
          const sortedKeys = Object.keys(props.color).map((key) => Number(key)).sort((a, b) => b - a);
          let threshold = (_a = sortedKeys.pop()) != null ? _a : indexArray.value.length;
          return indexArray.value.map((_, index2) => {
            var _a2;
            if (index2 + 1 > threshold) {
              threshold = (_a2 = sortedKeys.pop()) != null ? _a2 : threshold;
            }
            return props.color[String(threshold)];
          });
        }
        return void 0;
      });
      const resetHoverIndex = () => {
        if (hoverIndex.value) {
          hoverIndex.value = 0;
          emit("hoverChange", 0);
        }
      };
      const handleMouseEnter = (index2, isHalf) => {
        const newHoverIndex = isHalf && props.allowHalf ? index2 + 0.5 : index2 + 1;
        if (newHoverIndex !== hoverIndex.value) {
          hoverIndex.value = newHoverIndex;
          emit("hoverChange", newHoverIndex);
        }
      };
      const handleClick = (index2, isHalf) => {
        var _a, _b, _c, _d;
        const newValue = isHalf && props.allowHalf ? index2 + 0.5 : index2 + 1;
        animation.value = true;
        if (newValue !== computedValue.value) {
          _value.value = newValue;
          emit("update:modelValue", newValue);
          emit("change", newValue);
          (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a);
        } else if (props.allowClear) {
          _value.value = 0;
          emit("update:modelValue", 0);
          emit("change", 0);
          (_d = (_c = eventHandlers.value) == null ? void 0 : _c.onChange) == null ? void 0 : _d.call(_c);
        }
      };
      const handleAnimationEnd = (index2) => {
        if (animation.value && index2 + 1 >= computedValue.value - 1) {
          animation.value = false;
        }
      };
      const renderGradingCharacter = (index2, displayIndex2) => {
        if (index2 > displayIndex2) {
          return vue.createVNode(IconFaceMehFill, null, null);
        }
        if (displayIndex2 <= 2) {
          return vue.createVNode(IconFaceFrownFill, null, null);
        }
        if (displayIndex2 <= 3) {
          return vue.createVNode(IconFaceMehFill, null, null);
        }
        return vue.createVNode(IconFaceSmileFill, null, null);
      };
      const getAriaProps = (index2, isHalf = false) => {
        return {
          "role": "radio",
          "aria-checked": index2 + (isHalf ? 0.5 : 1) <= computedValue.value,
          "aria-setsize": indexArray.value.length,
          "aria-posinset": index2 + (isHalf ? 0.5 : 1)
        };
      };
      const renderCharacter = (index2) => {
        var _a, _b;
        const displayCharacter = props.grading ? renderGradingCharacter(index2, displayIndex.value) : (_b = (_a = slots.character) == null ? void 0 : _a.call(slots, {
          index: index2
        })) != null ? _b : vue.createVNode(IconStarFill, null, null);
        const leftProps = mergedDisabled.value ? {} : {
          onMouseenter: () => handleMouseEnter(index2, true),
          onClick: () => handleClick(index2, true)
        };
        const rightProps = mergedDisabled.value ? {} : {
          onMouseenter: () => handleMouseEnter(index2, false),
          onClick: () => handleClick(index2, false)
        };
        const style = animation.value ? {
          animationDelay: `${50 * index2}ms`
        } : void 0;
        const parseDisplayIndex = Math.ceil(displayIndex.value) - 1;
        const leftStyle = customColor.value && props.allowHalf && index2 + 0.5 === displayIndex.value ? {
          color: customColor.value[parseDisplayIndex]
        } : void 0;
        const rightStyle = customColor.value && index2 + 1 <= displayIndex.value ? {
          color: customColor.value[parseDisplayIndex]
        } : void 0;
        const cls2 = [`${prefixCls}-character`, {
          [`${prefixCls}-character-half`]: props.allowHalf && index2 + 0.5 === displayIndex.value,
          [`${prefixCls}-character-full`]: index2 + 1 <= displayIndex.value,
          [`${prefixCls}-character-scale`]: animation.value && index2 + 1 < computedValue.value
        }];
        return vue.createVNode("div", vue.mergeProps({
          "class": cls2,
          "style": style
        }, !props.allowHalf ? getAriaProps(index2) : void 0, {
          "onAnimationend": () => handleAnimationEnd(index2)
        }), [vue.createVNode("div", vue.mergeProps({
          "class": `${prefixCls}-character-left`,
          "style": leftStyle
        }, leftProps, props.allowHalf ? getAriaProps(index2, true) : void 0), [displayCharacter]), vue.createVNode("div", vue.mergeProps({
          "class": `${prefixCls}-character-right`,
          "style": rightStyle
        }, rightProps, props.allowHalf ? getAriaProps(index2) : void 0), [displayCharacter])]);
      };
      const cls = vue.computed(() => [prefixCls, {
        [`${prefixCls}-readonly`]: props.readonly,
        [`${prefixCls}-disabled`]: _mergedDisabled.value
      }]);
      return () => vue.createVNode("div", {
        "class": cls.value,
        "onMouseleave": resetHoverIndex
      }, [indexArray.value.map((_, index2) => renderCharacter(index2))]);
    }
  });
  const Rate = Object.assign(_Rate, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Rate.name, _Rate);
    }
  });
  const _sfc_main$L = vue.defineComponent({
    name: "IconInfo",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-info`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$i = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$f = /* @__PURE__ */ vue.createElementVNode("path", { d: "M25 39h-2V18h2z" }, null, -1);
  const _hoisted_3$e = /* @__PURE__ */ vue.createElementVNode("path", {
    fill: "currentColor",
    stroke: "none",
    d: "M25 39h-2V18h2z"
  }, null, -1);
  const _hoisted_4$4 = /* @__PURE__ */ vue.createElementVNode("path", { d: "M25 11h-2V9h2z" }, null, -1);
  const _hoisted_5$1 = /* @__PURE__ */ vue.createElementVNode("path", {
    fill: "currentColor",
    stroke: "none",
    d: "M25 11h-2V9h2z"
  }, null, -1);
  const _hoisted_6 = [
    _hoisted_2$f,
    _hoisted_3$e,
    _hoisted_4$4,
    _hoisted_5$1
  ];
  function _sfc_render$K(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_6, 14, _hoisted_1$i);
  }
  var _IconInfo = /* @__PURE__ */ _export_sfc(_sfc_main$L, [["render", _sfc_render$K]]);
  const IconInfo = Object.assign(_IconInfo, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconInfo.name, _IconInfo);
    }
  });
  var ResultForbidden = vue.defineComponent({
    name: "ResultForbidden",
    render() {
      return vue.createVNode("svg", {
        "viewBox": "0 0 213 213",
        "height": "100%",
        "width": "100%",
        "style": {
          fillRule: "evenodd",
          clipRule: "evenodd",
          strokeLinejoin: "round",
          strokeMiterlimit: 2
        }
      }, [vue.createVNode("g", {
        "transform": "matrix(1,0,0,1,-871.485,-445.62)"
      }, [vue.createVNode("g", null, [vue.createVNode("g", {
        "transform": "matrix(1,0,0,1,-75.2684,-87.3801)"
      }, [vue.createVNode("circle", {
        "cx": "1053.23",
        "cy": "639.477",
        "r": "106.477",
        "style": {
          fill: "rgb(235, 238, 246)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(1,0,0,1,246.523,295.575)"
      }, [vue.createVNode("g", {
        "transform": "matrix(0.316667,0,0,0.316667,277.545,71.0298)"
      }, [vue.createVNode("g", {
        "transform": "matrix(0.989011,-0.571006,1.14201,0.659341,-335.171,81.4498)"
      }, [vue.createVNode("rect", {
        "x": "495.52",
        "y": "1057.87",
        "width": "105.078",
        "height": "91",
        "style": {
          fill: "rgb(253, 243, 228)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.164835,-0.0951676,1.14201,0.659341,116.224,-179.163)"
      }, [vue.createVNode("rect", {
        "x": "495.52",
        "y": "1057.87",
        "width": "105.078",
        "height": "91",
        "style": {
          fill: "rgb(202, 174, 136)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.978261,-0.564799,1.26804e-16,1.30435,-337.046,42.0327)"
      }, [vue.createVNode("rect", {
        "x": "1844.06",
        "y": "1192.54",
        "width": "106.232",
        "height": "92",
        "style": {
          fill: "rgb(196, 173, 142)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.267591,-0.154493,3.46856e-17,0.356787,992.686,475.823)"
      }, [vue.createVNode("rect", {
        "x": "1844.06",
        "y": "1192.54",
        "width": "106.232",
        "height": "92",
        "style": {
          fill: "rgb(102, 102, 102)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(1.28257,-0.740494,1.23317e-16,1.7101,1501.14,624.071)"
      }, [vue.createVNode("g", {
        "transform": "matrix(1,0,0,1,-6,-6)"
      }, [vue.createVNode("path", {
        "d": "M2.25,10.5C2.25,10.5 1.5,10.5 1.5,9.75C1.5,9 2.25,6.75 6,6.75C9.75,6.75 10.5,9 10.5,9.75C10.5,10.5 9.75,10.5 9.75,10.5L2.25,10.5ZM6,6C7.234,6 8.25,4.984 8.25,3.75C8.25,2.516 7.234,1.5 6,1.5C4.766,1.5 3.75,2.516 3.75,3.75C3.75,4.984 4.766,6 6,6Z",
        "style": {
          fill: "white"
        }
      }, null)])]), vue.createVNode("g", {
        "transform": "matrix(0.725806,0.419045,1.75755e-17,1.01444,155.314,212.138)"
      }, [vue.createVNode("rect", {
        "x": "1663.92",
        "y": "-407.511",
        "width": "143.183",
        "height": "118.292",
        "style": {
          fill: "rgb(240, 218, 183)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(1.58977,-0.917857,1.15976e-16,2.2425,-1270.46,-614.379)"
      }, [vue.createVNode("rect", {
        "x": "1748.87",
        "y": "1226.67",
        "width": "10.895",
        "height": "13.378",
        "style": {
          fill: "rgb(132, 97, 0)"
        }
      }, null)])]), vue.createVNode("g", {
        "transform": "matrix(0.182997,0.105653,-0.494902,0.285732,814.161,66.3087)"
      }, [vue.createVNode("rect", {
        "x": "657.012",
        "y": "404.643",
        "width": "198.586",
        "height": "145.08",
        "style": {
          fillOpacity: 0.1
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.316667,0,0,0.316667,237.301,94.2647)"
      }, [vue.createVNode("g", {
        "transform": "matrix(0.989011,-0.571006,1.14201,0.659341,-335.171,81.4498)"
      }, [vue.createVNode("rect", {
        "x": "495.52",
        "y": "1057.87",
        "width": "105.078",
        "height": "91",
        "style": {
          fill: "rgb(253, 243, 228)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.164835,-0.0951676,1.14201,0.659341,116.224,-179.163)"
      }, [vue.createVNode("rect", {
        "x": "495.52",
        "y": "1057.87",
        "width": "105.078",
        "height": "91",
        "style": {
          fill: "rgb(202, 174, 136)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.978261,-0.564799,1.26804e-16,1.30435,-337.046,42.0327)"
      }, [vue.createVNode("rect", {
        "x": "1844.06",
        "y": "1192.54",
        "width": "106.232",
        "height": "92",
        "style": {
          fill: "rgb(196, 173, 142)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.267591,-0.154493,3.46856e-17,0.356787,992.686,475.823)"
      }, [vue.createVNode("rect", {
        "x": "1844.06",
        "y": "1192.54",
        "width": "106.232",
        "height": "92",
        "style": {
          fill: "rgb(102, 102, 102)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(1.28257,-0.740494,1.23317e-16,1.7101,1501.14,624.071)"
      }, [vue.createVNode("g", {
        "transform": "matrix(1,0,0,1,-6,-6)"
      }, [vue.createVNode("path", {
        "d": "M2.25,10.5C2.25,10.5 1.5,10.5 1.5,9.75C1.5,9 2.25,6.75 6,6.75C9.75,6.75 10.5,9 10.5,9.75C10.5,10.5 9.75,10.5 9.75,10.5L2.25,10.5ZM6,6C7.234,6 8.25,4.984 8.25,3.75C8.25,2.516 7.234,1.5 6,1.5C4.766,1.5 3.75,2.516 3.75,3.75C3.75,4.984 4.766,6 6,6Z",
        "style": {
          fill: "white"
        }
      }, null)])]), vue.createVNode("g", {
        "transform": "matrix(0.725806,0.419045,1.75755e-17,1.01444,155.314,212.138)"
      }, [vue.createVNode("rect", {
        "x": "1663.92",
        "y": "-407.511",
        "width": "143.183",
        "height": "118.292",
        "style": {
          fill: "rgb(240, 218, 183)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(1.58977,-0.917857,1.15976e-16,2.2425,-1270.46,-614.379)"
      }, [vue.createVNode("rect", {
        "x": "1748.87",
        "y": "1226.67",
        "width": "10.895",
        "height": "13.378",
        "style": {
          fill: "rgb(132, 97, 0)"
        }
      }, null)])]), vue.createVNode("g", {
        "transform": "matrix(0.474953,0,0,0.474953,538.938,8.95289)"
      }, [vue.createVNode("g", {
        "transform": "matrix(0.180615,0.104278,-0.973879,0.562269,790.347,286.159)"
      }, [vue.createVNode("rect", {
        "x": "657.012",
        "y": "404.643",
        "width": "198.586",
        "height": "145.08",
        "style": {
          fillOpacity: 0.1
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.473356,0,0,0.473356,294.481,129.741)"
      }, [vue.createVNode("g", null, [vue.createVNode("g", {
        "transform": "matrix(0.1761,-0.101671,1.73518e-16,1.22207,442.564,7.31508)"
      }, [vue.createVNode("rect", {
        "x": "202.62",
        "y": "575.419",
        "width": "124.002",
        "height": "259.402",
        "style": {
          fill: "rgb(235, 235, 235)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.0922781,0.0532768,2.03964e-16,2.20569,405.236,-248.842)"
      }, [vue.createVNode("rect", {
        "x": "657.012",
        "y": "404.643",
        "width": "198.586",
        "height": "145.08",
        "style": {
          fill: "rgb(34, 34, 34)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.147541,-0.0851831,1.52371e-16,1.23446,454.294,-3.8127)"
      }, [vue.createVNode("rect", {
        "x": "202.62",
        "y": "575.419",
        "width": "124.002",
        "height": "259.402",
        "style": {
          fill: "rgb(51, 51, 51)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.0921286,0.0531905,-0.126106,0.0728076,474.688,603.724)"
      }, [vue.createVNode("rect", {
        "x": "657.012",
        "y": "404.643",
        "width": "198.586",
        "height": "145.08",
        "style": {
          fill: "rgb(102, 102, 102)"
        }
      }, null)])])]), vue.createVNode("g", {
        "transform": "matrix(0.473356,0,0,0.473356,192.621,188.549)"
      }, [vue.createVNode("g", null, [vue.createVNode("g", {
        "transform": "matrix(0.1761,-0.101671,1.73518e-16,1.22207,442.564,7.31508)"
      }, [vue.createVNode("rect", {
        "x": "202.62",
        "y": "575.419",
        "width": "124.002",
        "height": "259.402",
        "style": {
          fill: "rgb(235, 235, 235)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.0922781,0.0532768,2.03964e-16,2.20569,405.236,-248.842)"
      }, [vue.createVNode("rect", {
        "x": "657.012",
        "y": "404.643",
        "width": "198.586",
        "height": "145.08",
        "style": {
          fill: "rgb(34, 34, 34)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.147541,-0.0851831,1.52371e-16,1.23446,454.294,-3.8127)"
      }, [vue.createVNode("rect", {
        "x": "202.62",
        "y": "575.419",
        "width": "124.002",
        "height": "259.402",
        "style": {
          fill: "rgb(51, 51, 51)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.0921286,0.0531905,-0.126106,0.0728076,474.688,603.724)"
      }, [vue.createVNode("rect", {
        "x": "657.012",
        "y": "404.643",
        "width": "198.586",
        "height": "145.08",
        "style": {
          fill: "rgb(102, 102, 102)"
        }
      }, null)])])]), vue.createVNode("g", {
        "transform": "matrix(0.668111,0,0,0.668111,-123.979,-49.2109)"
      }, [vue.createVNode("g", {
        "transform": "matrix(0.0349225,0.0201625,1.81598e-17,0.220789,974.758,729.412)"
      }, [vue.createVNode("rect", {
        "x": "657.012",
        "y": "404.643",
        "width": "198.586",
        "height": "145.08",
        "style": {
          fill: "rgb(235, 235, 235)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(1.1164,-0.644557,0,0.220789,42.5091,1294.14)"
      }, [vue.createVNode("rect", {
        "x": "657.012",
        "y": "404.643",
        "width": "198.586",
        "height": "145.08",
        "style": {
          fill: "rgb(235, 235, 235)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.0349225,0.0201625,-1.52814,0.882275,1593.11,461.746)"
      }, [vue.createVNode("rect", {
        "x": "657.012",
        "y": "404.643",
        "width": "198.586",
        "height": "145.08",
        "style": {
          fill: "rgb(102, 102, 102)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(1.1164,-0.644557,0,0.220789,49.4442,1298.14)"
      }, [vue.createVNode("rect", {
        "x": "657.012",
        "y": "404.643",
        "width": "198.586",
        "height": "145.08",
        "style": {
          fill: "rgb(51, 51, 51)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.0349225,0.0201625,1.81598e-17,0.220789,753.056,857.412)"
      }, [vue.createVNode("rect", {
        "x": "657.012",
        "y": "404.643",
        "width": "198.586",
        "height": "145.08",
        "style": {
          fill: "rgb(34, 34, 34)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.142968,-0.0825428,-0.207261,0.478709,898.874,529.479)"
      }, [vue.createVNode("rect", {
        "x": "831",
        "y": "1023.79",
        "width": "89.214",
        "height": "89.214",
        "style": {
          fill: "rgb(255, 125, 0)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.142968,-0.0825428,-0.207261,0.478709,930.12,511.44)"
      }, [vue.createVNode("rect", {
        "x": "831",
        "y": "1023.79",
        "width": "89.214",
        "height": "89.214",
        "style": {
          fill: "rgb(255, 125, 0)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.142968,-0.0825428,-0.207261,0.478709,961.365,493.4)"
      }, [vue.createVNode("rect", {
        "x": "831",
        "y": "1023.79",
        "width": "89.214",
        "height": "89.214",
        "style": {
          fill: "rgb(248, 248, 248)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.142968,-0.0825428,-0.207261,0.478709,992.61,475.361)"
      }, [vue.createVNode("rect", {
        "x": "831",
        "y": "1023.79",
        "width": "89.214",
        "height": "89.214",
        "style": {
          fill: "rgb(248, 248, 248)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.142968,-0.0825428,-0.207261,0.478709,1023.86,457.321)"
      }, [vue.createVNode("rect", {
        "x": "831",
        "y": "1023.79",
        "width": "89.214",
        "height": "89.214",
        "style": {
          fill: "rgb(248, 248, 248)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.142968,-0.0825428,-0.207261,0.478709,1056.25,438.617)"
      }, [vue.createVNode("rect", {
        "x": "831",
        "y": "1023.79",
        "width": "89.214",
        "height": "89.214",
        "style": {
          fill: "rgb(255, 125, 0)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.142968,-0.0825428,-0.207261,0.478709,1085.74,421.589)"
      }, [vue.createVNode("rect", {
        "x": "831",
        "y": "1023.79",
        "width": "89.214",
        "height": "89.214",
        "style": {
          fill: "rgb(255, 125, 0)"
        }
      }, null)])]), vue.createVNode("g", {
        "transform": "matrix(0.668111,0,0,0.668111,-123.979,-91.97)"
      }, [vue.createVNode("g", {
        "transform": "matrix(0.0349225,0.0201625,1.81598e-17,0.220789,974.758,729.412)"
      }, [vue.createVNode("rect", {
        "x": "657.012",
        "y": "404.643",
        "width": "198.586",
        "height": "145.08",
        "style": {
          fill: "rgb(235, 235, 235)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(1.1164,-0.644557,0,0.220789,42.5091,1294.14)"
      }, [vue.createVNode("rect", {
        "x": "657.012",
        "y": "404.643",
        "width": "198.586",
        "height": "145.08",
        "style": {
          fill: "rgb(235, 235, 235)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.0349225,0.0201625,-1.52814,0.882275,1593.11,461.746)"
      }, [vue.createVNode("rect", {
        "x": "657.012",
        "y": "404.643",
        "width": "198.586",
        "height": "145.08",
        "style": {
          fill: "rgb(102, 102, 102)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(1.1164,-0.644557,0,0.220789,49.4442,1298.14)"
      }, [vue.createVNode("rect", {
        "x": "657.012",
        "y": "404.643",
        "width": "198.586",
        "height": "145.08",
        "style": {
          fill: "rgb(51, 51, 51)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.0349225,0.0201625,1.81598e-17,0.220789,753.056,857.412)"
      }, [vue.createVNode("rect", {
        "x": "657.012",
        "y": "404.643",
        "width": "198.586",
        "height": "145.08",
        "style": {
          fill: "rgb(34, 34, 34)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.142968,-0.0825428,-0.207261,0.478709,898.874,529.479)"
      }, [vue.createVNode("rect", {
        "x": "831",
        "y": "1023.79",
        "width": "89.214",
        "height": "89.214",
        "style": {
          fill: "rgb(255, 125, 0)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.142968,-0.0825428,-0.207261,0.478709,930.12,511.44)"
      }, [vue.createVNode("rect", {
        "x": "831",
        "y": "1023.79",
        "width": "89.214",
        "height": "89.214",
        "style": {
          fill: "rgb(255, 125, 0)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.142968,-0.0825428,-0.207261,0.478709,961.365,493.4)"
      }, [vue.createVNode("rect", {
        "x": "831",
        "y": "1023.79",
        "width": "89.214",
        "height": "89.214",
        "style": {
          fill: "rgb(248, 248, 248)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.142968,-0.0825428,-0.207261,0.478709,992.61,475.361)"
      }, [vue.createVNode("rect", {
        "x": "831",
        "y": "1023.79",
        "width": "89.214",
        "height": "89.214",
        "style": {
          fill: "rgb(248, 248, 248)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.142968,-0.0825428,-0.207261,0.478709,1023.86,457.321)"
      }, [vue.createVNode("rect", {
        "x": "831",
        "y": "1023.79",
        "width": "89.214",
        "height": "89.214",
        "style": {
          fill: "rgb(248, 248, 248)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.142968,-0.0825428,-0.207261,0.478709,1056.25,438.617)"
      }, [vue.createVNode("rect", {
        "x": "831",
        "y": "1023.79",
        "width": "89.214",
        "height": "89.214",
        "style": {
          fill: "rgb(255, 125, 0)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.142968,-0.0825428,-0.207261,0.478709,1085.74,421.589)"
      }, [vue.createVNode("rect", {
        "x": "831",
        "y": "1023.79",
        "width": "89.214",
        "height": "89.214",
        "style": {
          fill: "rgb(255, 125, 0)"
        }
      }, null)])]), vue.createVNode("g", {
        "transform": "matrix(0.701585,5.16096e-35,-5.16096e-35,0.701585,-546.219,-21.3487)"
      }, [vue.createVNode("g", {
        "transform": "matrix(0.558202,-0.322278,0,0.882275,1033.27,615.815)"
      }, [vue.createVNode("path", {
        "d": "M855.598,410.446C855.598,407.244 852.515,404.643 848.718,404.643L663.891,404.643C660.094,404.643 657.012,407.244 657.012,410.446L657.012,543.92C657.012,547.123 660.094,549.723 663.891,549.723L848.718,549.723C852.515,549.723 855.598,547.123 855.598,543.92L855.598,410.446Z",
        "style": {
          fill: "white"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.558202,-0.322278,0,0.882275,1035.25,616.977)"
      }, [vue.createVNode("path", {
        "d": "M855.598,410.446C855.598,407.244 852.515,404.643 848.718,404.643L663.891,404.643C660.094,404.643 657.012,407.244 657.012,410.446L657.012,543.92C657.012,547.123 660.094,549.723 663.891,549.723L848.718,549.723C852.515,549.723 855.598,547.123 855.598,543.92L855.598,410.446Z",
        "style": {
          fill: "white"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(1,0,0,1,418.673,507.243)"
      }, [vue.createVNode("path", {
        "d": "M1088.34,192.063C1089.79,191.209 1090.78,191.821 1090.78,191.821L1092.71,192.944C1092.71,192.944 1092.29,192.721 1091.7,192.763C1090.99,192.813 1090.34,193.215 1090.34,193.215C1090.34,193.215 1088.85,192.362 1088.34,192.063Z",
        "style": {
          fill: "rgb(248, 248, 248)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(1,0,0,1,235.984,-39.1315)"
      }, [vue.createVNode("path", {
        "d": "M1164.02,805.247C1164.05,802.517 1165.64,799.379 1167.67,798.118L1169.67,799.272C1167.58,800.648 1166.09,803.702 1166.02,806.402L1164.02,805.247Z",
        "style": {
          fill: "url(#_Linear1)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.396683,0,0,0.396683,1000.22,516.921)"
      }, [vue.createVNode("path", {
        "d": "M1011.2,933.14C1009.31,932.075 1008.05,929.696 1007.83,926.324L1012.87,929.235C1012.87,929.235 1012.96,930.191 1013.04,930.698C1013.16,931.427 1013.42,932.344 1013.62,932.845C1013.79,933.255 1014.59,935.155 1016.22,936.046C1015.83,935.781 1011.19,933.139 1011.19,933.139L1011.2,933.14Z",
        "style": {
          fill: "rgb(238, 238, 238)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.253614,-0.146424,4.87691e-17,0.338152,1209.98,830.02)"
      }, [vue.createVNode("circle", {
        "cx": "975.681",
        "cy": "316.681",
        "r": "113.681",
        "style": {
          fill: "rgb(245, 63, 63)"
        }
      }, null), vue.createVNode("g", {
        "transform": "matrix(1.08844,0,0,0.61677,-99.9184,125.436)"
      }, [vue.createVNode("path", {
        "d": "M1062,297.556C1062,296.697 1061.61,296 1061.12,296L915.882,296C915.395,296 915,296.697 915,297.556L915,333.356C915,334.215 915.395,334.912 915.882,334.912L1061.12,334.912C1061.61,334.912 1062,334.215 1062,333.356L1062,297.556Z",
        "style": {
          fill: "white"
        }
      }, null)])]), vue.createVNode("g", {
        "transform": "matrix(5.57947,-3.22131,0.306277,0.176829,-6260.71,4938.32)"
      }, [vue.createVNode("rect", {
        "x": "1335.54",
        "y": "694.688",
        "width": "18.525",
        "height": "6.511",
        "style": {
          fill: "rgb(248, 248, 248)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.10726,0.0619268,-1.83335e-14,18.1609,1256.76,-11932.8)"
      }, [vue.createVNode("rect", {
        "x": "1335.54",
        "y": "694.688",
        "width": "18.525",
        "height": "6.511",
        "style": {
          fill: "rgb(238, 238, 238)"
        }
      }, null)])])]), vue.createVNode("g", {
        "transform": "matrix(0.316667,0,0,0.316667,269.139,37.8829)"
      }, [vue.createVNode("g", {
        "transform": "matrix(0.989011,-0.571006,1.14201,0.659341,-335.171,81.4498)"
      }, [vue.createVNode("rect", {
        "x": "495.52",
        "y": "1057.87",
        "width": "105.078",
        "height": "91",
        "style": {
          fill: "rgb(253, 243, 228)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.164835,-0.0951676,1.14201,0.659341,116.224,-179.163)"
      }, [vue.createVNode("rect", {
        "x": "495.52",
        "y": "1057.87",
        "width": "105.078",
        "height": "91",
        "style": {
          fill: "rgb(202, 174, 136)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.978261,-0.564799,1.26804e-16,1.30435,-337.046,42.0327)"
      }, [vue.createVNode("rect", {
        "x": "1844.06",
        "y": "1192.54",
        "width": "106.232",
        "height": "92",
        "style": {
          fill: "rgb(196, 173, 142)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.267591,-0.154493,3.46856e-17,0.356787,992.686,475.823)"
      }, [vue.createVNode("rect", {
        "x": "1844.06",
        "y": "1192.54",
        "width": "106.232",
        "height": "92",
        "style": {
          fill: "rgb(102, 102, 102)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(1.28257,-0.740494,1.23317e-16,1.7101,1501.14,624.071)"
      }, [vue.createVNode("g", {
        "transform": "matrix(1,0,0,1,-6,-6)"
      }, [vue.createVNode("path", {
        "d": "M2.25,10.5C2.25,10.5 1.5,10.5 1.5,9.75C1.5,9 2.25,6.75 6,6.75C9.75,6.75 10.5,9 10.5,9.75C10.5,10.5 9.75,10.5 9.75,10.5L2.25,10.5ZM6,6C7.234,6 8.25,4.984 8.25,3.75C8.25,2.516 7.234,1.5 6,1.5C4.766,1.5 3.75,2.516 3.75,3.75C3.75,4.984 4.766,6 6,6Z",
        "style": {
          fill: "white"
        }
      }, null)])]), vue.createVNode("g", {
        "transform": "matrix(0.725806,0.419045,1.75755e-17,1.01444,155.314,212.138)"
      }, [vue.createVNode("rect", {
        "x": "1663.92",
        "y": "-407.511",
        "width": "143.183",
        "height": "118.292",
        "style": {
          fill: "rgb(240, 218, 183)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(1.58977,-0.917857,1.15976e-16,2.2425,-1270.46,-614.379)"
      }, [vue.createVNode("rect", {
        "x": "1748.87",
        "y": "1226.67",
        "width": "10.895",
        "height": "13.378",
        "style": {
          fill: "rgb(132, 97, 0)"
        }
      }, null)])])])])]), vue.createVNode("defs", null, [vue.createVNode("linearGradient", {
        "id": "_Linear1",
        "x1": "0",
        "y1": "0",
        "x2": "1",
        "y2": "0",
        "gradientUnits": "userSpaceOnUse",
        "gradientTransform": "matrix(-2.64571,4.04098,-4.04098,-2.64571,1167.67,799.269)"
      }, [vue.createVNode("stop", {
        "offset": "0",
        "style": {
          stopColor: "rgb(248, 248, 248)",
          stopOpacity: 1
        }
      }, null), vue.createVNode("stop", {
        "offset": "1",
        "style": {
          stopColor: "rgb(248, 248, 248)",
          stopOpacity: 1
        }
      }, null)])])]);
    }
  });
  var ResultNotFound = vue.defineComponent({
    name: "ResultNotFound",
    render() {
      return vue.createVNode("svg", {
        "width": "100%",
        "height": "100%",
        "viewBox": "0 0 213 213",
        "style": {
          fillRule: "evenodd",
          clipRule: "evenodd",
          strokeLinejoin: "round",
          strokeMiterlimit: 2
        }
      }, [vue.createVNode("g", {
        "transform": "matrix(1,0,0,1,-1241.95,-445.62)"
      }, [vue.createVNode("g", null, [vue.createVNode("g", {
        "transform": "matrix(1,0,0,1,295.2,-87.3801)"
      }, [vue.createVNode("circle", {
        "cx": "1053.23",
        "cy": "639.477",
        "r": "106.477",
        "style": {
          fill: "rgb(235, 238, 246)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.38223,0,0,0.38223,1126.12,238.549)"
      }, [vue.createVNode("g", {
        "transform": "matrix(0.566536,0.327089,-1.28774,0.74348,763.4,317.171)"
      }, [vue.createVNode("rect", {
        "x": "657.012",
        "y": "404.643",
        "width": "198.586",
        "height": "145.08",
        "style": {
          fillOpacity: 0.1
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.29595,0.170867,-0.91077,0.525833,873.797,588.624)"
      }, [vue.createVNode("rect", {
        "x": "657.012",
        "y": "404.643",
        "width": "198.586",
        "height": "145.08",
        "style": {
          fillOpacity: 0.1
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(1,0,0,1,275,-15)"
      }, [vue.createVNode("path", {
        "d": "M262.077,959.012L276.923,959.012L273.388,1004.01C273.388,1004.59 273.009,1005.16 272.25,1005.6C270.732,1006.48 268.268,1006.48 266.75,1005.6C265.991,1005.16 265.612,1004.59 265.612,1004.01L262.077,959.012Z",
        "style": {
          fill: "rgb(196, 173, 142)"
        }
      }, null), vue.createVNode("g", {
        "transform": "matrix(0.866025,-0.5,1,0.57735,0,-45)"
      }, [vue.createVNode("ellipse", {
        "cx": "-848.416",
        "cy": "1004.25",
        "rx": "6.062",
        "ry": "5.25",
        "style": {
          fill: "rgb(255, 125, 0)"
        }
      }, null)])]), vue.createVNode("g", {
        "transform": "matrix(1,0,0,1,183.952,-67.5665)"
      }, [vue.createVNode("path", {
        "d": "M262.077,959.012L276.923,959.012L273.388,1004.01C273.388,1004.59 273.009,1005.16 272.25,1005.6C270.732,1006.48 268.268,1006.48 266.75,1005.6C265.991,1005.16 265.612,1004.59 265.612,1004.01L262.077,959.012Z",
        "style": {
          fill: "rgb(196, 173, 142)"
        }
      }, null), vue.createVNode("g", {
        "transform": "matrix(0.866025,-0.5,1,0.57735,0,-45)"
      }, [vue.createVNode("ellipse", {
        "cx": "-848.416",
        "cy": "1004.25",
        "rx": "6.062",
        "ry": "5.25",
        "style": {
          fill: "rgb(255, 125, 0)"
        }
      }, null)])]), vue.createVNode("g", {
        "transform": "matrix(1,0,0,1,414,-95.2517)"
      }, [vue.createVNode("path", {
        "d": "M262.077,959.012L276.923,959.012L273.388,1004.01C273.388,1004.59 273.009,1005.16 272.25,1005.6C270.732,1006.48 268.268,1006.48 266.75,1005.6C265.991,1005.16 265.612,1004.59 265.612,1004.01L262.077,959.012Z",
        "style": {
          fill: "rgb(196, 173, 142)"
        }
      }, null), vue.createVNode("g", {
        "transform": "matrix(0.866025,-0.5,1,0.57735,0,-45)"
      }, [vue.createVNode("ellipse", {
        "cx": "-848.416",
        "cy": "1004.25",
        "rx": "6.062",
        "ry": "5.25",
        "style": {
          fill: "rgb(255, 125, 0)"
        }
      }, null)])]), vue.createVNode("g", {
        "transform": "matrix(1,0,0,1,322.952,-147.818)"
      }, [vue.createVNode("path", {
        "d": "M262.077,959.012L276.923,959.012L273.388,1004.01C273.388,1004.59 273.009,1005.16 272.25,1005.6C270.732,1006.48 268.268,1006.48 266.75,1005.6C265.991,1005.16 265.612,1004.59 265.612,1004.01L262.077,959.012Z",
        "style": {
          fill: "rgb(196, 173, 142)"
        }
      }, null), vue.createVNode("g", {
        "transform": "matrix(0.866025,-0.5,1,0.57735,0,-45)"
      }, [vue.createVNode("ellipse", {
        "cx": "-848.416",
        "cy": "1004.25",
        "rx": "6.062",
        "ry": "5.25",
        "style": {
          fill: "rgb(255, 125, 0)"
        }
      }, null)])]), vue.createVNode("g", null, [vue.createVNode("g", {
        "transform": "matrix(1.42334,-0.821763,1.11271,0.642426,-1439.64,459.621)"
      }, [vue.createVNode("rect", {
        "x": "495.52",
        "y": "1057.87",
        "width": "105.078",
        "height": "91",
        "style": {
          fill: "rgb(253, 243, 228)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(1.40786,-0.812831,6.60237e-16,1.99081,-2052.17,-84.7286)"
      }, [vue.createVNode("rect", {
        "x": "1844.06",
        "y": "1192.54",
        "width": "106.232",
        "height": "92",
        "style": {
          fill: "rgb(196, 173, 142)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(1.26159,-0.728382,5.91642e-16,1.78397,-1774.67,11.2303)"
      }, [vue.createVNode("path", {
        "d": "M1950.29,1194.38C1950.29,1193.37 1949.41,1192.54 1948.34,1192.54L1846.01,1192.54C1844.93,1192.54 1844.06,1193.37 1844.06,1194.38L1844.06,1282.7C1844.06,1283.72 1844.93,1284.54 1846.01,1284.54L1948.34,1284.54C1949.41,1284.54 1950.29,1283.72 1950.29,1282.7L1950.29,1194.38Z",
        "style": {
          fill: "rgb(132, 97, 51)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(1.2198,-0.704254,5.72043e-16,1.72488,-1697.6,37.2103)"
      }, [vue.createVNode("path", {
        "d": "M1950.29,1194.38C1950.29,1193.37 1949.41,1192.54 1948.34,1192.54L1846.01,1192.54C1844.93,1192.54 1844.06,1193.37 1844.06,1194.38L1844.06,1282.7C1844.06,1283.72 1844.93,1284.54 1846.01,1284.54L1948.34,1284.54C1949.41,1284.54 1950.29,1283.72 1950.29,1282.7L1950.29,1194.38Z",
        "style": {
          fill: "rgb(196, 173, 142)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.707187,0.408295,9.06119e-17,1.54833,-733.949,683.612)"
      }, [vue.createVNode("rect", {
        "x": "1663.92",
        "y": "-407.511",
        "width": "143.183",
        "height": "118.292",
        "style": {
          fill: "rgb(240, 218, 183)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(1.64553,-0.950049,1.17482,0.678285,-1632.45,473.879)"
      }, [vue.createVNode("rect", {
        "x": "495.52",
        "y": "1057.87",
        "width": "105.078",
        "height": "91",
        "style": {
          fill: "rgb(253, 243, 228)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.74666,0.431085,2.3583e-17,0.135259,-816.63,57.1397)"
      }, [vue.createVNode("rect", {
        "x": "1663.92",
        "y": "-407.511",
        "width": "143.183",
        "height": "118.292",
        "style": {
          fill: "rgb(240, 218, 183)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(1.64553,-0.950049,1.17482,0.678285,-1632.45,473.879)"
      }, [vue.createVNode("rect", {
        "x": "495.52",
        "y": "1057.87",
        "width": "105.078",
        "height": "91",
        "style": {
          fill: "rgb(253, 243, 228)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.750082,0,0,0.750082,163.491,354.191)"
      }, [vue.createVNode("g", {
        "transform": "matrix(1.75943,-1.01581,1.75879e-16,0.632893,-2721.54,1876.43)"
      }, [vue.createVNode("rect", {
        "x": "1844.06",
        "y": "1192.54",
        "width": "106.232",
        "height": "92",
        "style": {
          fill: "rgb(196, 173, 142)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.290956,-0.167984,2.90849e-17,0.104661,69.4195,919.311)"
      }, [vue.createVNode("path", {
        "d": "M1950.29,1238.54C1950.29,1213.15 1944.73,1192.54 1937.88,1192.54L1856.47,1192.54C1849.62,1192.54 1844.06,1213.15 1844.06,1238.54C1844.06,1263.93 1849.62,1284.54 1856.47,1284.54L1937.88,1284.54C1944.73,1284.54 1950.29,1263.93 1950.29,1238.54Z",
        "style": {
          fill: "rgb(132, 97, 51)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.262716,-0.151679,8.27418e-18,0.0364999,121.496,970.53)"
      }, [vue.createVNode("path", {
        "d": "M1950.29,1238.54C1950.29,1213.15 1948.14,1192.54 1945.5,1192.54L1848.85,1192.54C1846.2,1192.54 1844.06,1213.15 1844.06,1238.54C1844.06,1263.93 1846.2,1284.54 1848.85,1284.54L1945.5,1284.54C1948.14,1284.54 1950.29,1263.93 1950.29,1238.54Z",
        "style": {
          fill: "rgb(246, 220, 185)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(1.77877,-1.02697,0.0581765,0.0335882,-425.293,1228.27)"
      }, [vue.createVNode("rect", {
        "x": "495.52",
        "y": "1057.87",
        "width": "105.078",
        "height": "91",
        "style": {
          fill: "rgb(240, 218, 183)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.0369741,0.021347,4.72735e-17,0.492225,456.143,919.985)"
      }, [vue.createVNode("rect", {
        "x": "1663.92",
        "y": "-407.511",
        "width": "143.183",
        "height": "118.292",
        "style": {
          fill: "rgb(240, 218, 183)"
        }
      }, null)])]), vue.createVNode("g", {
        "transform": "matrix(0.750082,0,0,0.750082,163.491,309.191)"
      }, [vue.createVNode("g", {
        "transform": "matrix(1.75943,-1.01581,1.75879e-16,0.632893,-2721.54,1876.43)"
      }, [vue.createVNode("rect", {
        "x": "1844.06",
        "y": "1192.54",
        "width": "106.232",
        "height": "92",
        "style": {
          fill: "rgb(196, 173, 142)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.290956,-0.167984,2.90849e-17,0.104661,69.4195,919.311)"
      }, [vue.createVNode("path", {
        "d": "M1950.29,1238.54C1950.29,1213.15 1944.73,1192.54 1937.88,1192.54L1856.47,1192.54C1849.62,1192.54 1844.06,1213.15 1844.06,1238.54C1844.06,1263.93 1849.62,1284.54 1856.47,1284.54L1937.88,1284.54C1944.73,1284.54 1950.29,1263.93 1950.29,1238.54Z",
        "style": {
          fill: "rgb(132, 97, 51)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.262716,-0.151679,8.27418e-18,0.0364999,121.496,970.53)"
      }, [vue.createVNode("path", {
        "d": "M1950.29,1238.54C1950.29,1213.15 1948.14,1192.54 1945.5,1192.54L1848.85,1192.54C1846.2,1192.54 1844.06,1213.15 1844.06,1238.54C1844.06,1263.93 1846.2,1284.54 1848.85,1284.54L1945.5,1284.54C1948.14,1284.54 1950.29,1263.93 1950.29,1238.54Z",
        "style": {
          fill: "rgb(246, 220, 185)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(1.77877,-1.02697,0.0581765,0.0335882,-425.293,1228.27)"
      }, [vue.createVNode("rect", {
        "x": "495.52",
        "y": "1057.87",
        "width": "105.078",
        "height": "91",
        "style": {
          fill: "rgb(240, 218, 183)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.0369741,0.021347,4.72735e-17,0.492225,456.143,919.985)"
      }, [vue.createVNode("rect", {
        "x": "1663.92",
        "y": "-407.511",
        "width": "143.183",
        "height": "118.292",
        "style": {
          fill: "rgb(240, 218, 183)"
        }
      }, null)])]), vue.createVNode("g", {
        "transform": "matrix(0.750082,0,0,0.750082,163.491,263.931)"
      }, [vue.createVNode("g", {
        "transform": "matrix(1.75943,-1.01581,1.75879e-16,0.632893,-2721.54,1876.43)"
      }, [vue.createVNode("rect", {
        "x": "1844.06",
        "y": "1192.54",
        "width": "106.232",
        "height": "92",
        "style": {
          fill: "rgb(196, 173, 142)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.290956,-0.167984,2.90849e-17,0.104661,69.4195,919.311)"
      }, [vue.createVNode("path", {
        "d": "M1950.29,1238.54C1950.29,1213.15 1944.73,1192.54 1937.88,1192.54L1856.47,1192.54C1849.62,1192.54 1844.06,1213.15 1844.06,1238.54C1844.06,1263.93 1849.62,1284.54 1856.47,1284.54L1937.88,1284.54C1944.73,1284.54 1950.29,1263.93 1950.29,1238.54Z",
        "style": {
          fill: "rgb(132, 97, 51)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.262716,-0.151679,8.27418e-18,0.0364999,121.496,970.53)"
      }, [vue.createVNode("path", {
        "d": "M1950.29,1238.54C1950.29,1213.15 1948.14,1192.54 1945.5,1192.54L1848.85,1192.54C1846.2,1192.54 1844.06,1213.15 1844.06,1238.54C1844.06,1263.93 1846.2,1284.54 1848.85,1284.54L1945.5,1284.54C1948.14,1284.54 1950.29,1263.93 1950.29,1238.54Z",
        "style": {
          fill: "rgb(246, 220, 185)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(1.77877,-1.02697,0.0581765,0.0335882,-425.293,1228.27)"
      }, [vue.createVNode("rect", {
        "x": "495.52",
        "y": "1057.87",
        "width": "105.078",
        "height": "91",
        "style": {
          fill: "rgb(240, 218, 183)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.0369741,0.021347,4.72735e-17,0.492225,456.143,919.985)"
      }, [vue.createVNode("rect", {
        "x": "1663.92",
        "y": "-407.511",
        "width": "143.183",
        "height": "118.292",
        "style": {
          fill: "rgb(240, 218, 183)"
        }
      }, null)])]), vue.createVNode("path", {
        "d": "M555.753,832.474L555.753,921.408L630.693,878.141L630.693,789.207L555.753,832.474Z",
        "style": {
          fillOpacity: 0.1
        }
      }, null), vue.createVNode("g", {
        "transform": "matrix(0.750082,0,0,0.750082,236.431,272.852)"
      }, [vue.createVNode("g", {
        "transform": "matrix(1.64553,-0.950049,1.14552,0.661368,-1606.78,467.933)"
      }, [vue.createVNode("rect", {
        "x": "495.52",
        "y": "1057.87",
        "width": "105.078",
        "height": "91",
        "style": {
          fill: "rgb(253, 243, 228)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(1.54477,-0.891873,1.05847,0.611108,-1456.84,490.734)"
      }, [vue.createVNode("rect", {
        "x": "495.52",
        "y": "1057.87",
        "width": "105.078",
        "height": "91",
        "style": {
          fill: "rgb(132, 97, 51)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(1.27607,-0.736739,0.751435,0.433841,-970.952,617.519)"
      }, [vue.createVNode("rect", {
        "x": "495.52",
        "y": "1057.87",
        "width": "105.078",
        "height": "91",
        "style": {
          fill: "rgb(240, 218, 183)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(1.62765,-0.939723,1.42156e-16,0.5,-2476.81,1893.62)"
      }, [vue.createVNode("rect", {
        "x": "1844.06",
        "y": "1192.54",
        "width": "106.232",
        "height": "92",
        "style": {
          fill: "rgb(196, 173, 142)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(1.62765,-0.939723,1.42156e-16,0.5,-2476.81,1893.62)"
      }, [vue.createVNode("rect", {
        "x": "1844.06",
        "y": "1192.54",
        "width": "106.232",
        "height": "92",
        "style": {
          fill: "rgb(196, 173, 142)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.728038,0.420333,3.52595e-17,0.377589,-790.978,151.274)"
      }, [vue.createVNode("rect", {
        "x": "1663.92",
        "y": "-407.511",
        "width": "143.183",
        "height": "118.292",
        "style": {
          fill: "rgb(240, 218, 183)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(1.75943,-1.01581,1.75879e-16,0.632893,-2726.83,1873.38)"
      }, [vue.createVNode("rect", {
        "x": "1844.06",
        "y": "1192.54",
        "width": "106.232",
        "height": "92",
        "style": {
          fill: "rgb(196, 173, 142)"
        }
      }, null)]), vue.createVNode("g", null, [vue.createVNode("g", {
        "transform": "matrix(1.75943,-1.01581,1.75879e-16,0.632893,-2721.54,1876.43)"
      }, [vue.createVNode("rect", {
        "x": "1844.06",
        "y": "1192.54",
        "width": "106.232",
        "height": "92",
        "style": {
          fill: "rgb(196, 173, 142)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.290956,-0.167984,2.90849e-17,0.104661,69.4195,919.311)"
      }, [vue.createVNode("path", {
        "d": "M1950.29,1238.54C1950.29,1213.15 1944.73,1192.54 1937.88,1192.54L1856.47,1192.54C1849.62,1192.54 1844.06,1213.15 1844.06,1238.54C1844.06,1263.93 1849.62,1284.54 1856.47,1284.54L1937.88,1284.54C1944.73,1284.54 1950.29,1263.93 1950.29,1238.54Z",
        "style": {
          fill: "rgb(132, 97, 51)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.262716,-0.151679,8.27418e-18,0.0364999,121.496,970.53)"
      }, [vue.createVNode("path", {
        "d": "M1950.29,1238.54C1950.29,1213.15 1948.14,1192.54 1945.5,1192.54L1848.85,1192.54C1846.2,1192.54 1844.06,1213.15 1844.06,1238.54C1844.06,1263.93 1846.2,1284.54 1848.85,1284.54L1945.5,1284.54C1948.14,1284.54 1950.29,1263.93 1950.29,1238.54Z",
        "style": {
          fill: "rgb(246, 220, 185)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(1.77877,-1.02697,0.0581765,0.0335882,-425.293,1228.27)"
      }, [vue.createVNode("rect", {
        "x": "495.52",
        "y": "1057.87",
        "width": "105.078",
        "height": "91",
        "style": {
          fill: "rgb(240, 218, 183)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.0369741,0.021347,4.72735e-17,0.492225,456.143,919.985)"
      }, [vue.createVNode("rect", {
        "x": "1663.92",
        "y": "-407.511",
        "width": "143.183",
        "height": "118.292",
        "style": {
          fill: "rgb(240, 218, 183)"
        }
      }, null)])])]), vue.createVNode("g", {
        "transform": "matrix(1.62765,-0.939723,4.80984e-17,0.173913,-2468.81,2307.87)"
      }, [vue.createVNode("rect", {
        "x": "1844.06",
        "y": "1192.54",
        "width": "106.232",
        "height": "92",
        "style": {
          fill: "rgb(196, 173, 142)"
        }
      }, null)])]), vue.createVNode("g", null, [vue.createVNode("g", {
        "transform": "matrix(0.479077,0.276595,-0.564376,0.325843,598.357,-129.986)"
      }, [vue.createVNode("path", {
        "d": "M1776.14,1326C1776.14,1321.19 1772.15,1317.28 1767.24,1317.28L1684.37,1317.28C1679.46,1317.28 1675.47,1321.19 1675.47,1326L1675.47,1395.75C1675.47,1400.56 1679.46,1404.46 1684.37,1404.46L1767.24,1404.46C1772.15,1404.46 1776.14,1400.56 1776.14,1395.75L1776.14,1326Z",
        "style": {
          fill: "white"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(2.61622,0,0,2.61622,-2305.73,162.161)"
      }, [vue.createVNode("g", {
        "transform": "matrix(1.09915,-0.634597,1.26919,0.73277,-299.167,-62.4615)"
      }, [vue.createVNode("ellipse", {
        "cx": "412.719",
        "cy": "770.575",
        "rx": "6.303",
        "ry": "5.459",
        "style": {
          fill: "rgb(255, 125, 0)"
        }
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.238212,-0.137532,0.178659,0.103149,875.064,207.93)"
      }, [vue.createVNode("text", {
        "x": "413.474px",
        "y": "892.067px",
        "style": {
          fontFamily: "NunitoSans-Bold, Nunito Sans",
          fontWeight: 700,
          fontSize: 41.569,
          fill: "white"
        }
      }, [vue.createTextVNode("?")])])])])])])])]);
    }
  });
  var ResultServerError = vue.defineComponent({
    name: "ResultServerError",
    render() {
      return vue.createVNode("svg", {
        "width": "100%",
        "height": "100%",
        "viewBox": "0 0 213 213",
        "style": "fill-rule: evenodd; clip-rule: evenodd; stroke-linejoin: round; stroke-miterlimit: 2;"
      }, [vue.createVNode("g", {
        "transform": "matrix(1,0,0,1,-483.054,-445.448)"
      }, [vue.createVNode("g", null, [vue.createVNode("g", {
        "transform": "matrix(1,0,0,1,-463.699,-87.5516)"
      }, [vue.createVNode("circle", {
        "cx": "1053.23",
        "cy": "639.477",
        "r": "106.477",
        "style": "fill: rgb(235, 238, 246);"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.384532,-0.222009,0.444019,0.256354,-0.569781,260.021)"
      }, [vue.createVNode("path", {
        "d": "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z",
        "style": "fill-opacity: 0.1;"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.384532,-0.222009,0.444019,0.256354,-0.569781,218.845)"
      }, [vue.createVNode("path", {
        "d": "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z",
        "style": "fill: rgb(64, 128, 255);"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.361496,-0.20871,0.41742,0.240997,34.7805,238.807)"
      }, [vue.createVNode("path", {
        "d": "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z",
        "style": "fill: rgb(0, 85, 255);"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.341853,-0.197369,0.394738,0.227902,64.9247,257.804)"
      }, [vue.createVNode("path", {
        "d": "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z",
        "style": "fill: rgb(29, 105, 255);"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.428916,0,0,0.428916,19.0588,329.956)"
      }, [vue.createVNode("clipPath", {
        "id": "_clip1"
      }, [vue.createVNode("path", {
        "d": "M1461.07,528.445C1461.07,530.876 1459.6,533.196 1456.6,534.928L1342.04,601.072C1335.41,604.896 1323.83,604.415 1316.18,600L1205.33,536C1201.14,533.585 1199,530.489 1199,527.555L1199,559.555C1199,562.489 1201.14,565.585 1205.33,568L1316.18,632C1323.83,636.415 1335.41,636.896 1342.04,633.072L1456.6,566.928C1459.6,565.196 1461.07,562.876 1461.07,560.445L1461.07,528.445Z"
      }, null)]), vue.createVNode("g", {
        "clip-path": "url(#_clip1)"
      }, [vue.createVNode("g", {
        "transform": "matrix(2.33146,-0,-0,2.33146,1081.79,269.266)"
      }, [vue.createVNode("use", {
        "href": "#_Image2",
        "x": "50.54",
        "y": "112.301",
        "width": "112.406px",
        "height": "46.365px",
        "transform": "matrix(0.99474,0,0,0.98649,0,0)"
      }, null)])])]), vue.createVNode("g", {
        "transform": "matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,265.448)"
      }, [vue.createVNode("path", {
        "d": "M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z",
        "style": "fill: white;"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,268.45)"
      }, [vue.createVNode("path", {
        "d": "M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z",
        "style": "fill: white;"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,271.452)"
      }, [vue.createVNode("path", {
        "d": "M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z",
        "style": "fill: white;"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.360289,-0.208013,-4.39887e-18,0.576941,37.5847,124.262)"
      }, [vue.createVNode("rect", {
        "x": "1621.2",
        "y": "1370.57",
        "width": "57.735",
        "height": "5.947",
        "style": "fill: rgb(106, 161, 255);"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,307.505,420.796)"
      }, [vue.createVNode("ellipse", {
        "cx": "1566.31",
        "cy": "1372.3",
        "rx": "4",
        "ry": "3.464",
        "style": "fill: rgb(64, 128, 255);"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,310.507,419.062)"
      }, [vue.createVNode("ellipse", {
        "cx": "1566.31",
        "cy": "1372.3",
        "rx": "4",
        "ry": "3.464",
        "style": "fill: rgb(64, 128, 255);"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,313.509,417.329)"
      }, [vue.createVNode("ellipse", {
        "cx": "1566.31",
        "cy": "1372.3",
        "rx": "4",
        "ry": "3.464",
        "style": "fill: white;"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,316.512,415.595)"
      }, [vue.createVNode("ellipse", {
        "cx": "1566.31",
        "cy": "1372.3",
        "rx": "4",
        "ry": "3.464",
        "style": "fill: rgb(64, 128, 255);"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,319.514,413.862)"
      }, [vue.createVNode("ellipse", {
        "cx": "1566.31",
        "cy": "1372.3",
        "rx": "4",
        "ry": "3.464",
        "style": "fill: rgb(64, 128, 255);"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.384532,-0.222009,0.444019,0.256354,-0.569781,196.542)"
      }, [vue.createVNode("clipPath", {
        "id": "_clip3"
      }, [vue.createVNode("path", {
        "d": "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z"
      }, null)]), vue.createVNode("g", {
        "clip-path": "url(#_clip3)"
      }, [vue.createVNode("g", {
        "transform": "matrix(1.30028,1.12608,-2.25216,1.95042,68.2716,1030.07)"
      }, [vue.createVNode("use", {
        "href": "#_Image4",
        "x": "50.54",
        "y": "56.312",
        "width": "112.406px",
        "height": "64.897px",
        "transform": "matrix(0.99474,0,0,0.998422,0,0)"
      }, null)])])]), vue.createVNode("g", {
        "transform": "matrix(0.361496,-0.20871,0.41742,0.240997,34.7805,216.764)"
      }, [vue.createVNode("path", {
        "d": "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z",
        "style": "fill: rgb(0, 85, 255);"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.341853,-0.197369,0.394738,0.227902,64.9247,235.762)"
      }, [vue.createVNode("path", {
        "d": "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z",
        "style": "fill: rgb(29, 105, 255);"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.428916,0,0,0.428916,19.0588,307.652)"
      }, [vue.createVNode("clipPath", {
        "id": "_clip5"
      }, [vue.createVNode("path", {
        "d": "M1461.07,528.445C1461.07,530.876 1459.6,533.196 1456.6,534.928L1342.04,601.072C1335.41,604.896 1323.83,604.415 1316.18,600L1205.33,536C1201.14,533.585 1199,530.489 1199,527.555L1199,559.555C1199,562.489 1201.14,565.585 1205.33,568L1316.18,632C1323.83,636.415 1335.41,636.896 1342.04,633.072L1456.6,566.928C1459.6,565.196 1461.07,562.876 1461.07,560.445L1461.07,528.445Z"
      }, null)]), vue.createVNode("g", {
        "clip-path": "url(#_clip5)"
      }, [vue.createVNode("g", {
        "transform": "matrix(2.33146,-0,-0,2.33146,1081.79,321.266)"
      }, [vue.createVNode("use", {
        "href": "#_Image2",
        "x": "50.54",
        "y": "89.692",
        "width": "112.406px",
        "height": "46.365px",
        "transform": "matrix(0.99474,0,0,0.98649,0,0)"
      }, null)])])]), vue.createVNode("g", {
        "transform": "matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,243.144)"
      }, [vue.createVNode("path", {
        "d": "M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z",
        "style": "fill: white;"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,246.146)"
      }, [vue.createVNode("path", {
        "d": "M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z",
        "style": "fill: white;"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,249.149)"
      }, [vue.createVNode("path", {
        "d": "M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z",
        "style": "fill: white;"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.360289,-0.208013,-4.39887e-18,0.576941,37.5847,101.958)"
      }, [vue.createVNode("rect", {
        "x": "1621.2",
        "y": "1370.57",
        "width": "57.735",
        "height": "5.947",
        "style": "fill: rgb(106, 161, 255);"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,307.505,398.492)"
      }, [vue.createVNode("ellipse", {
        "cx": "1566.31",
        "cy": "1372.3",
        "rx": "4",
        "ry": "3.464",
        "style": "fill: rgb(64, 128, 255);"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,310.507,396.759)"
      }, [vue.createVNode("ellipse", {
        "cx": "1566.31",
        "cy": "1372.3",
        "rx": "4",
        "ry": "3.464",
        "style": "fill: white;"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,313.509,395.025)"
      }, [vue.createVNode("ellipse", {
        "cx": "1566.31",
        "cy": "1372.3",
        "rx": "4",
        "ry": "3.464",
        "style": "fill: rgb(64, 128, 255);"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,316.512,393.292)"
      }, [vue.createVNode("ellipse", {
        "cx": "1566.31",
        "cy": "1372.3",
        "rx": "4",
        "ry": "3.464",
        "style": "fill: rgb(64, 128, 255);"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,319.514,391.558)"
      }, [vue.createVNode("ellipse", {
        "cx": "1566.31",
        "cy": "1372.3",
        "rx": "4",
        "ry": "3.464",
        "style": "fill: rgb(64, 128, 255);"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.384532,-0.222009,0.444019,0.256354,-0.569781,171.832)"
      }, [vue.createVNode("clipPath", {
        "id": "_clip6"
      }, [vue.createVNode("path", {
        "d": "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z"
      }, null)]), vue.createVNode("g", {
        "clip-path": "url(#_clip6)"
      }, [vue.createVNode("g", {
        "transform": "matrix(1.30028,1.12608,-2.25216,1.95042,12.6215,1078.27)"
      }, [vue.createVNode("use", {
        "href": "#_Image7",
        "x": "50.54",
        "y": "31.563",
        "width": "112.406px",
        "height": "64.897px",
        "transform": "matrix(0.99474,0,0,0.998422,0,0)"
      }, null)])])]), vue.createVNode("g", {
        "transform": "matrix(0.361496,-0.20871,0.41742,0.240997,34.7805,192.055)"
      }, [vue.createVNode("path", {
        "d": "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z",
        "style": "fill: rgb(0, 85, 255);"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.341853,-0.197369,0.394738,0.227902,64.9247,211.052)"
      }, [vue.createVNode("path", {
        "d": "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z",
        "style": "fill: rgb(29, 105, 255);"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.428916,0,0,0.428916,19.0588,282.943)"
      }, [vue.createVNode("clipPath", {
        "id": "_clip8"
      }, [vue.createVNode("path", {
        "d": "M1461.07,528.445C1461.07,530.876 1459.6,533.196 1456.6,534.928L1342.04,601.072C1335.41,604.896 1323.83,604.415 1316.18,600L1205.33,536C1201.14,533.585 1199,530.489 1199,527.555L1199,559.555C1199,562.489 1201.14,565.585 1205.33,568L1316.18,632C1323.83,636.415 1335.41,636.896 1342.04,633.072L1456.6,566.928C1459.6,565.196 1461.07,562.876 1461.07,560.445L1461.07,528.445Z"
      }, null)]), vue.createVNode("g", {
        "clip-path": "url(#_clip8)"
      }, [vue.createVNode("g", {
        "transform": "matrix(2.33146,-0,-0,2.33146,1081.79,378.876)"
      }, [vue.createVNode("use", {
        "href": "#_Image2",
        "x": "50.54",
        "y": "64.644",
        "width": "112.406px",
        "height": "46.365px",
        "transform": "matrix(0.99474,0,0,0.98649,0,0)"
      }, null)])])]), vue.createVNode("g", {
        "transform": "matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,218.434)"
      }, [vue.createVNode("path", {
        "d": "M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z",
        "style": "fill: white;"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,221.437)"
      }, [vue.createVNode("path", {
        "d": "M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z",
        "style": "fill: white;"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,224.439)"
      }, [vue.createVNode("path", {
        "d": "M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z",
        "style": "fill: white;"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.360289,-0.208013,-4.39887e-18,0.576941,37.5847,77.2484)"
      }, [vue.createVNode("rect", {
        "x": "1621.2",
        "y": "1370.57",
        "width": "57.735",
        "height": "5.947",
        "style": "fill: rgb(106, 161, 255);"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,307.505,373.782)"
      }, [vue.createVNode("ellipse", {
        "cx": "1566.31",
        "cy": "1372.3",
        "rx": "4",
        "ry": "3.464",
        "style": "fill: white;"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,310.507,372.049)"
      }, [vue.createVNode("ellipse", {
        "cx": "1566.31",
        "cy": "1372.3",
        "rx": "4",
        "ry": "3.464",
        "style": "fill: rgb(64, 128, 255);"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,313.509,370.316)"
      }, [vue.createVNode("ellipse", {
        "cx": "1566.31",
        "cy": "1372.3",
        "rx": "4",
        "ry": "3.464",
        "style": "fill: rgb(64, 128, 255);"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,316.512,368.582)"
      }, [vue.createVNode("ellipse", {
        "cx": "1566.31",
        "cy": "1372.3",
        "rx": "4",
        "ry": "3.464",
        "style": "fill: rgb(64, 128, 255);"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,319.514,366.849)"
      }, [vue.createVNode("ellipse", {
        "cx": "1566.31",
        "cy": "1372.3",
        "rx": "4",
        "ry": "3.464",
        "style": "fill: rgb(64, 128, 255);"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.365442,-0.210988,0.421976,0.243628,28.7259,185.45)"
      }, [vue.createVNode("clipPath", {
        "id": "_clip9"
      }, [vue.createVNode("path", {
        "d": "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z"
      }, null)]), vue.createVNode("g", {
        "clip-path": "url(#_clip9)"
      }, [vue.createVNode("g", {
        "transform": "matrix(1.36821,1.1849,-2.36981,2.05231,5.46929,1071.93)"
      }, [vue.createVNode("use", {
        "href": "#_Image10",
        "x": "53.151",
        "y": "30.14",
        "width": "106.825px",
        "height": "61.676px",
        "transform": "matrix(0.998367,0,0,0.994768,0,0)"
      }, null)])])]), vue.createVNode("g", {
        "transform": "matrix(0.365442,-0.210988,0.421976,0.243628,28.7259,183.729)"
      }, [vue.createVNode("path", {
        "d": "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z",
        "style": 'fill: url("#_Linear11");'
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.407622,0,0,0.407622,47.38,278)"
      }, [vue.createVNode("clipPath", {
        "id": "_clip12"
      }, [vue.createVNode("path", {
        "d": "M1461.07,554.317C1461.07,556.747 1459.6,559.067 1456.6,560.8L1342.04,626.943C1335.41,630.767 1323.83,630.287 1316.18,625.871L1205.33,561.871C1201.14,559.456 1199,556.361 1199,553.426L1199,559.555C1199,562.489 1201.14,565.585 1205.33,568L1316.18,632C1323.83,636.415 1335.41,636.896 1342.04,633.072L1456.6,566.928C1459.6,565.196 1461.07,562.876 1461.07,560.445L1461.07,554.317Z"
      }, null)]), vue.createVNode("g", {
        "clip-path": "url(#_clip12)"
      }, [vue.createVNode("g", {
        "transform": "matrix(2.45325,-0,-0,2.45325,1068.82,410.793)"
      }, [vue.createVNode("use", {
        "href": "#_Image13",
        "x": "53.151",
        "y": "58.978",
        "width": "106.825px",
        "height": "33.517px",
        "transform": "matrix(0.998367,0,0,0.985808,0,0)"
      }, null)])])]), vue.createVNode("g", {
        "transform": "matrix(0.371452,-0.214458,2.38096e-17,0.495269,-19.3677,248.256)"
      }, [vue.createVNode("clipPath", {
        "id": "_clip14"
      }, [vue.createVNode("path", {
        "d": "M1776.14,1326C1776.14,1321.19 1772.23,1317.28 1767.42,1317.28L1684.19,1317.28C1679.38,1317.28 1675.47,1321.19 1675.47,1326L1675.47,1395.75C1675.47,1400.56 1679.38,1404.46 1684.19,1404.46L1767.42,1404.46C1772.23,1404.46 1776.14,1400.56 1776.14,1395.75L1776.14,1326Z"
      }, null)]), vue.createVNode("g", {
        "clip-path": "url(#_clip14)"
      }, [vue.createVNode("g", {
        "transform": "matrix(2.69214,1.16573,-1.29422e-16,2.0191,1352.59,983.841)"
      }, [vue.createVNode("use", {
        "href": "#_Image15",
        "x": "121.882",
        "y": "76.034",
        "width": "37.393px",
        "height": "61.803px",
        "transform": "matrix(0.984021,0,0,0.996825,0,0)"
      }, null)])])]), vue.createVNode("g", {
        "transform": "matrix(0.371452,-0.214458,2.38096e-17,0.495269,-15.0786,249.972)"
      }, [vue.createVNode("path", {
        "d": "M1776.14,1326C1776.14,1321.19 1772.23,1317.28 1767.42,1317.28L1684.19,1317.28C1679.38,1317.28 1675.47,1321.19 1675.47,1326L1675.47,1395.75C1675.47,1400.56 1679.38,1404.46 1684.19,1404.46L1767.42,1404.46C1772.23,1404.46 1776.14,1400.56 1776.14,1395.75L1776.14,1326Z",
        "style": "fill: white; stop-opacity: 0.9;"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.220199,-0.127132,1.41145e-17,0.293599,339.708,327.53)"
      }, [vue.createVNode("path", {
        "d": "M1306.5,1286.73C1307.09,1285.72 1308.6,1285.48 1310.36,1286.12C1312.13,1286.76 1313.84,1288.16 1314.73,1289.7C1326.44,1309.98 1355.4,1360.15 1363.73,1374.57C1364.33,1375.61 1364.49,1376.61 1364.18,1377.35C1363.87,1378.09 1363.11,1378.5 1362.07,1378.5C1346.41,1378.5 1288.17,1378.5 1264.07,1378.5C1262.42,1378.5 1260.37,1377.48 1258.9,1375.94C1257.44,1374.41 1256.88,1372.67 1257.5,1371.6C1268.1,1353.25 1296.8,1303.53 1306.5,1286.73Z"
      }, null)]), vue.createVNode("g", {
        "transform": "matrix(0.254264,-0.1468,1.22235e-17,0.254264,329.57,364.144)"
      }, [vue.createVNode("text", {
        "x": "1170.88px",
        "y": "1451.42px",
        "style": 'font-family: NunitoSans-Bold, "Nunito Sans"; font-weight: 700; font-size: 41.569px; fill: white; fill-opacity: 0.9;'
      }, [vue.createTextVNode("!")])])])]), vue.createVNode("defs", null, [vue.createVNode("image", {
        "id": "_Image2",
        "width": "113px",
        "height": "47px",
        "href": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHEAAAAvCAYAAADU+iVXAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABVUlEQVR4nO2aQRKCMAxFxUN4O+9/DNw4CoiTliZN8vPfQlm00ykvP3aQ5fFc11sjy/L+/nx8r3ffm7Fn845jz+aJa23XOJvfs9Zh7NBawv3YrSGtdbj+x10egkFzpRrNt+SSxMgbqkiZJCJDiQDoSmSfdYFJ3JD18GMmcXhDTHUzNZIIXhA1JIJDib0MptqiKbhKzHqQiAaT6IlSFVIiAJQIACUGpLfLhpfIw49Ml8T2v4/JTPySyIJQI3w7JTIYEp2fong3FXWJ3huqCEYSNUlYhZRoyaSCoEQAKHESlqF0kZj9NBgNJhEASgSAEgNx9WfCTmLxpygzYRIBmCORsTIlXxJZED/kk0h+KC1x9E2FKG86qEkMsh8/HG9A6SSGYqAIKDEinUIpUSDDYXiqxAw3JCNMIgDXJTIWYdBJIvukK2ynARit4XASUZ6izCScRFWKCH0BfLM84oTw1Z8AAAAASUVORK5CYII="
      }, null), vue.createVNode("image", {
        "id": "_Image4",
        "width": "113px",
        "height": "65px",
        "href": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHEAAABBCAYAAADmBEt9AAAACXBIWXMAAA7EAAAOxAGVKw4bAAASeElEQVR4nN2d6ZbcNpKFL5cs9UN1W5bntWxr6XmsWTzLQ7mSJDA/gh/iApWyLalUy+AcnypVJkEAsd24EaQn/T8Yb9+XKknrOuk4pOM4tCyLpkkqpWpZJu170TzPKqVoWWZJUq3Sbx+m6VkX/wjjVW/gH7/sdZ5nTacc5lkqJT6rtWqaJtVaVUrRNE26XGbd3+9alkW1Vi3LrFKq/uvj/KrP4dUu/t3HWkupmuepWVspIcjrddc8z1qWWcdRTusLwc3z3Cz1OA5dLouOo+o4Dv3vv15e5Xm8ukX//eetTtOkdV20bWFVkrQsk+ZZOo74Xq3SNMVPqXextYal1lq1rrNqlfb90LrGXP/5/nW52Fez2B8/1FpPiSxLLLsUaV2lfZdKiZiHkHCtuFWPj/73cvpfLDQseNJxvB43++IX+cOvR5WkZQkBbdsh4uCySNtWWkxEuLVKx1HOuLecFjdp3/NnWiYKUbSuAXiOIwR8HIf+55/riz+jF73Anz7VWkq4RSkEI+m0Fun+ftflsra/r+usfY/fATVY3DzP2ratCe3Nm7UhWawv3KzO69PtllJetDBf5MJ++hRHWWu4QCkOm1h4HH2agJuVpHme2ufHUXS5zLpeQ1B8Ns9zu2ZdU3gAJdwxFh3zxjUv0cW+qAX9+KFWhMV/Urg6kCUWcxzpRvlsmno3ehwBVhDKcWRMZQ6uQ4D7HsgI1MrcDIT/koT5IhaC28T17fuudV0bWAmhTJ0QpN56ti1cq4MXSR1wiWv6+ChJ12ukGpJaunG5rJpnad9rm+NyWVRKgqiXQhQ8+yI87pEicDQIRApAg3US60gvPPYhbBceqYTH17DEo8VLSVqWTFGmKdKOZVm0LDKlqIaEQ+GeO798tpu/fV/qPE+nCwwLiwNVi1FhCaUJIFxbury7uxAiwrled0k6Dz6F78J2FgcBk2qs66J9T/QrpRt2MoH7RX6ZXuO/Py3Pcp5PftMffj0qdBeHF4AlXJwU4ETSGavUMSsAD1AlqYDHvut1P61y6QRPMg/g2bbSudnJvCNCgmsFQKEE8Z2p+1x6Hi72SW/47mPk6/u+txwNa4vfpw4hYi3Lok7AHBiHCfjArTr6ZE4Sfr+W+aVAqQgVpUCJJBQq1kas7FFxAqTLZdK//fx0wnySG/3LP2sl1uEKU4uX9r1Siu7uliYwhHwctR0y1zmz4gwO80gp3OM4dHe3NqIAy3R36kjX4yvVj31P4OR0HYJluPVOk/Qfv35/YX7XG/z4IVSVQ8d11lp1ucydsNxlLsukbQth4zLnWQ8sA85zWZYm7LCiiFEp7J6O477rOul6TU5VUpdHjgJmL4QDKiGxzmSP3OqJ8d+Tj/0uE//w61EBI57jSWldUk+hxWc9OR1Wk+4WYWNNaD2jlNKsxdMOEnZJ7dC3bTcFmZpQSimNzXHl81ok7tndvAOlW8KXvl9u+eiTAlyoIozuB4DhrAt/w6qkdL3kb1Jymli0xzSH/Vi153QcLqmJX0t6c70erTqyrusfKhPEggOjmGvqANAIxNZ10r//8rhW+WiTkTI4iCDuOGAZ+U8osXWddH+/twMn5iEIeFEswasRkroir49l4cDVhM/Bcshc44LwCkcKZD6tfW75JHN6jRJlQnld+NzzOB4vJfnmSd59rHWMTwEkFh3HeDBxDVaIwB1JjlxofhZCj0pG7bQ9508rIH+bJq6JU/eaYsybaczd3dJVRXCZpajVLhEMua2j5VueIeZxAqNXnlrrNwvzqy/+6VP1s+6Sdnpd/LAYxJ1lWbTv+2mpc8ekeOz5XJINkPEknbSABN/dIfFrniddr9uZm65tPudsGS4gLyqzX9ZTSgIq9iipoWfQKyGm1qyDxn2+DcV+1YU/faqVxbEZL8Iy3AURV0Z2Bgjv8aPW2iyJgbDcejk4YiCQnwEH6gpGuuHxknV5GAApe+rhjBIM0Zs362dJAwTM2uNzNWAnPQRtX1Py+qILEJ4kXS6Tfv89ER6D2ITLjEPpSWjiCL8DXvhezrO0eIhuJILNQ6IqUUqS2lJAfikQKWi01tq5enJBXKQn/SiK57LO3XrvDvdxZgfSAC+xbXvjat3K2a+fyZe42L/0RfI94sO+H11S7ptzwDFCbQcKHuTTitVZhR+g/x13u+/HGaPWJtBucwZOGNQXmddjl9cYr9fjjIlzQ6EolO9vjIHM4Yo65o6+L1CuK76j2b+SlvzhF959rBWEySY9r/IWBxeapJsxgs9gP9y6cHlj99q+9zwow8tRzIFr4l4jqHJkPOaAzOFzOnjy3z3ZZw73HJwRQM/PZZzLz5bwdH+/6e7ucirDnxeiP/shqPN63U1rMo5J6nI/YgiaD9IbUahX19mwI1dHp+6SRvDgBzIWbaHvIu7VB4dIHCwly09es8TF46JZH6AJl4i18H2KyMuS83tbpSvXuk4nKs70ybGBnwWe4XPx8sEf//7zVtd17YAKNJgjPrSNSjqCy5bBjBmx+FyUC5IxghyPM1w75nMIxF0v6yVmjqzQmJT7YaKYYdUJtCQ1ZaKjwNMPZ4ig+dwlxv6mdi2CJm0ZvYafnYcg1jNWSto/3r4v9ZZms/HRlTjKQ0ggMQcCXhPctiwZObr0+7iC8D0npEHCgBuGu0f+/ebN2oTh1ZFQjhAUwvBiMMriB+kpTwi1z1P9++wF0OSAB4HggpkDz+WKFF6uV2z3fljm5IgTM0ZjRqQ2ukKPDSzO3aa7orHhyGONI8FsR8wD8Prfus5dh/donX4PDjYtZ+q8ixecHUl6l/jIf8LYcOC33Dnu2lOQEEAqsKPymPchNnDBj/2yDnwmmnK9h2WEzLhWhifcnvDimm5B5xH0eFwZEah/lw2wMdryuX6sMKTVBnrl87E7oFZ1uagDHPZIDuzC2/eoF+57368z5pPUTDGMUaHhjdnPSNXhacbvO4BrBoNWQEthUQ7NXSNCcHHQYSnxtzjgZFxG7eU+6S5n0856WmJfaOXacKHTef/ZWJ4ERB4BYv0xN4IJ96fu4CC5Y/299W7b3pRx33cdx9GUwKszpFnpVQL8ZQpTT4XILvTLJWuRtVZdLuvpcY4GchAg3wnsQdf7fLJiZ7nucoleTvpViEfRbLurlKJ9P0R9zjcQ2l5PTcxDpIgaLjc/QFvRqlLKqWW90gSY6asBbNoJ5/QYcd3lMneQnYNIIAQhjkLoTAVK21+eQWrF5bI2yO9rZB8BpNxT8GwITExt3kuKpmcPJft+nCEj8QHnOU2TLpelU7JQdhR60gzHSWCPw4kvRNse6Cpb58NNhN/3+MXNp4lmpfk8uIxzjiyzWiCt63JuPONcBPjpVCSaoJhrOQ+otPgUrj3dZ+ynnGWp0lkTQMsbo6KaklYFmYBFuXsOoKS2/rT+uSl74Ae8SQhynjPnDYusZwpVTmFmTJXCC4T7zHXFd0u754zv9aQ6hJDawE1i0nrGtNHNzp3Gx3dDMwJKT6ebqJ2WpSstLb5SPkLYcbhrs66Ma7W7p1sdG5+mqeV2d3f5eFsp0UcKp5nxWuf9lnbYXjCutbbQwz7dK3C4t/7tqBdwlLhj7lgkUheUi/RlXRMLtNDkQuDQ2EwejE6Txh0Gyrpe9xYj0MrrdWtaFDeSKcbcDrBPvp2P7BXBlQPrgtlY16nrYNu2ox22K1Ek7rV5m5hD5uZAxulmM16lN7hcLlpXd9mJavEarBe37fGbGOasUn/mx2mpkPJHM6DoWCgNaHEPSZoxSQIrpr8sKcTQjocVgiAFKPMEyPnb3y7NbXiciU7qkTlJITT/PmM5STaQNzn4Oo6qbStdyoOg2XgSErWzOD+MzHOnM/bXbn2wOl4uC1DUK7S7PI/5/MTL8W/iIvdGwblH/7SXt3hSgMjcc/7twzQFsKhnHOu7zxws3mIWvM/kONRATghy7jbM4XBAaDNaz+/ExQQ2vav0DjMs7+5ubRZfStWbN+tpFRmTwhVu56GGJUfYANpHQTs9TD1jYW3MET2trCNqolCEEXe3bX8Q23wsy3KS9tNZ2chqTICsuB8MkbNEefY6UfCUjA09oeR+TjPBRDhMJj/yZHesQLjvHvnDyHcOcz+525HKg3DgQBB23BNSvafFXPHCivdWe/T0BCKBkEDO5wfrMZ690k7iBLfv2+/Nnih3ZZqVzV6eQ2ca1VOfyAVlpYPuAXf6w69HRTDOSUJ1OUODK4VJyUCftUQqERRnnTz3p47CctON4Ipo9/BnIjzPQ3mc2+WQ6d9hH5DiHJz37XDIsf5UNhTTFQY35uuE4QqFedgoxVhX6f4+FS7z2KPjSsdaLGSF9Afc6Tho+B0tKm6Q7A6jTzN6rXRqzVGVL9gZDRTBm4wkDe0cbm09COO7zsZwyM6lIhj3QOMenT1yxiisI1MtUD50JHO612B/sz04RGbg/UCu3G6lnytJfVaIDIhxKUtPvmkHFH6QuLVbLfmOEhGCF0bd/2MJY/u+Wyqbj8/yIFAsn+9WYXp0b27NiQbVXR/INSx726L+xx5w3azLH/Rx78Y8biBO03nnwB/VFP9UiFI+N4/b+1wNzA8AV0Tux8K8y8sJdCeV4T1HlwPmwn07F+oCxI17DB3LQAyvdXa51/A01Gjld3fe/9P3lUaumUqO1/E+G+ZBuM6fEo+lv9Zw/JeEyHj7vtSE6KW5tlhYDwhwB+5SvGDsKYs3XAVK7J+7cMDi7i0P0d9Tk4/Lcf3Y+uCIGqGS81FZGEEE8SnnDJxwf7+1RN2TeI+3faGgXzfM0RiyvqRb/IuEyPAne/0gvGbn8XAM0qNFjMjSEaWDFag7Ns3fYo5wYR5fODzosh6mZ58se0iXP3VKABd8qyls7FCgQoM38aIwrvXubhXPjYT1hiAvl+WrWhe/SoiMdx9r3ba9FYcdsPATq0MLSV04SEeCoE93yxyAIzxHjMsy6XpNAQaAWdr3cYNYqb/ACEXyZzWSe+1flcKAfPBWjFt9SCPwGoGUdyIg/K99Q8c3CVFK4DPmiuNz8xRzqbGND7k4MMFyvJHJEWBel+4JZcLaoarI/WLusWUkrdJDgIMdVybAjyNp0iLQqgvM+2K5npqkM1ff+qDNNwuRwZNQkiO51OQR+IyFUM+r+mfk+2Ymb5kYXVm3MQMitxDo+HQVa/Jiredmjh79+35fqvUoknce4GkgSEopj/as/6MJkfH2faluhYAF75qT+ke66TDzxByXOLpD4qbnpWPq4vkWvUDjsxOOHhGw9w8FNTbdtGLefeO4AKtjnW6hxHvW+tiPhD+6EBkgWafi0NxMqLMxV1JzO/nSvRDMSGUx3NW5sBwZ8293Y2Mvq6PbsbKQCHlurNDIEI05rOefTliU8n3eTPXdhCipPXQDqPEOs/FgsB7i3mGMgLfCe46aaDIZfY9rntLwaJv0UHnGFAIheC+QP3rnDE78VKsNEoOdTqz1+76Q4bsKkfHjh3z8jYP2eIF78u4zb8N482bV/X0++CllY7ET0t7z6k1bWA6oOL4TPz2mpkt/yBG7O7/VsXeLbXqqF/w9iRAZvCk4qyL9YUk9HUZMcsAwHhYgyHNCrMU5Tql3dQjM06Jb77FhjZ97xM4JArzIND3tO1OfVIgM3tntVsWIikc0JXkJa3y2A+33vM+tydkbKd359Rrm+rlccryPs0kjIxPr7b2HpCd/KdGzCFGKlCRLTA9fTuSVhs/1nYIo/ZAdaY6v9fL6IDVLYh41O3JcrIoOB2I3aQgx1K99ited3BrPJkSGv0k/QU1SXaBIJwPGOOYpRyLTqfs+sdObgD1l8WqL1yoldUwQXgHhS8//xsVnFyLjxw+13mJn/O1Okk5O9eGrouuNup2/+MgRqZeaHAzxXQTtL2tAOUh7njru/dG40QHyPOO3D9ME6EGAPUUWLvH337cmJBJorwyEi0xrTlaIZuVDNCtfr4fot6EXKB9Xyw6+7FxLxXopApRekCX6ePexVtzc+MZhSc1KnEgAzUpZb/SHVp3IdvLZLXPsOhgrM4/Bc36P8eIW5IP/9wWW5+S354hSz6z4+25IJ2BzmCuuiZ+AFn9x4EiKv5QX1N4aL3ZhPqDwvN/H63vENqe6kgbrCXAHObcq+k504w1eovX5eNGL8/GPX4KJBpXi4oh/lLrGd7tRdIUsx7L89SjEv/EFuS9deIxXsUgf8LF9p3a+o3TsO3UOk1eQSLQY5iulqXpIz58yfOl4VYv14awPeZ0XpEnE+Y7Hwuw4ry33k16f8BivctE+/H8/5IBkfLmfv2Wf3NIF/ZKBy5+NV7twH2OVRPJH1fp3vsG0IMTnevn6Y47/AxX1K5XSf237AAAAAElFTkSuQmCC"
      }, null), vue.createVNode("image", {
        "id": "_Image7",
        "width": "113px",
        "height": "65px",
        "href": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHEAAABBCAYAAADmBEt9AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAMrklEQVR4nOVdW2LbNhAcUD5Xkl4scXqxpr0XiX7AQwwGu7Rj2RLV7o8lknjtc3YBygX/Afr2XOu2bQCAZVkAALVWlFJQClAr9mvLUrBt7R4A/Hp++fDA9NAL+PpjqwBQSkF9kVQkOBIFx2vLUlDr4wvyYSf/7blJghanglFLc9q2DZfLgnXddqvl9X/+vDwkPx5u0l9/bFWtTf+q8Hidwt22DaWUXYCtj3H5bPNolvkwk2Xc05hHcjep1yk8Fy4tksSmfH5ZCv768RjCPP0k3W3ysxKFtSwLaq0vAGYZXC2vtefHmKn9Lkv7TKt+BKs89QT/+FnrtnVECYwghuRukfcpOL1N4fgzrZ/umgHsbvfsVnnKiX35vlYFHUpMJQAMwMQtqpSCdV3x9HTBujbXSUUAZmVQa876A84ZL081oS/f1+qAQwGLusx+vz/rSNUtbk5FZvccpSuOdmut+PvnchrenWIidJvAKJRIaPpZY6B+Z/6nAlBrisjjp4KezKWfRZB3n8QfP2tlKuBWAHS0SMZqOFSAwu+R1QA9sVdhupA5riNapUjY946Xdxv823OtHnfIFGp+lv+pZSiaZH/e1gVIlmseCXRBk1SBFO26i6fA7xUvbz4oS2UABoaua699ZjFK25CJ/NzajukBgMmNerzUNuyD1Rw2U6XR/ihAzhu4D/C56YDM+QAMDMqScrUiYMzjiDjVmjT2aTLvlhtZLeOvI9RufWWyRCUt9906Xt5kIFpf5uaUKarlR0jUy2p+X2Nh62+2bi3faaxz1JoBInf1nr/WWm9Sj/3UAb7+2KrHo6hC4gJ0kAOMwMSf0RwwSgu8isNrDpSU1KIVBY9zX+Rz9xAaP3n/My3zUzrWOqdbhLpGPqMuFMhjkGu8pxZRKuE5H0ljYFaC0z60b8ZNutllAbatC1PdcxurPftZgvzwTnWDFuhJdSlzHFOozudGsHBsxeMYc5xiHxm6jdyx11mVojHVkt2zaJ/6+aOF+WGdffm+7hu0zrB9sCC2ULiRNUUF6fa5l9H0GjCX4nRsF9BRPsj2kVC8fyofx88KC5/lYq/uhPt7zni6FFoetZaCjQU2okPgWBBqtXrfXbczmP2qmz7a5oqAVwR6Mkv1Zz3eXpuWvLux7jBwog7bIyKTNaboEjQ+7ZMUl+RQnvdVYTKE6S48AiD6LOepwMmVTfs6Qsw+P1/XNVb5roaa7wFjzIqAgloHidaoRyUiVOruz9MOIE4ZpoVapcfben9ODpAyC9M+dc1UWmCuDGnb9wjztxqo65wXNqcNUVDXeBmdc4kWqsKLQBL78zIcx6U71aMZfa6xW86uOeKOarU6R3fZ6n2y3Bj4vcrPmx789lyrx7QsH9OFXC4F6xqnGBHo0aqJCihzpa+hV33OEWpk/ZGFkJWeh0YVI953ZSU+UIGyzeVSQDDvHgF4m2UePsAiNRmoNUXX9NcOIDkTyJhs0R782/PxZzLAtZ3XNYXxeKhMzRivfbW1XlKX/1oakn3XsVyxXtslSW+q61QNjayv1oqnp+VlMnGVxRnnwEKFQAaocFQx9BkHPWSIV1OyfUUfb2KQeRnPL13wJHWrkedyZY3auSfKrHK6mIEW7YyTd2txbVbw0vuL9/1GxvXPtG510W3xs6X4wtXyiJo9Trml6jo1vqqCaHvOVcd1AWdgz/FFBu6cTx4v9y9R3BsZO2uPCkM1Xl1vhvwi16j967PKKP0cxTMFFC4k9umxl8r2lvlmTPa4TXIBet+RG414wvbqrVhcL9xZ10Hcuo6OO0QD8/MoiNnqdIKZ4pB8AY4ql4VKNQ0zzU3XGrlgjdk6F80ds3VxHd6vto3G8fyTc4x2ftimlLYRXfx9Bg/+RxoRAYMIYUX3IxfdJz6fOHPGt+8Yis9jSjDHnAzRcj56cDg686NziEALKQNdLhQKg89oKVHvR25+2BPVCXECOvkuVGWyl7fmZF7jUCljfNB2nem8P277aIzhuG0BdJ0ag0bm6PEKlQX7dNR6uSwTCGLb7gEU0I0xMFJQzoHt13Xb16BEdE8Z1NpPOyiPW1/kbVOUJy6+MaUMGuaW1jvE3hlJNYptIhfZJ6CId0aL/XhEmdqy7yjuRrlnmz+ZU3amKVCJ5sO+lZlRESFCvbyuSuHgiXzkGN3tLnt7kuIN9zBPFIpqfktkL4NAI4TlVRXVDk6ScYBMIXEBbMt9RUd8ruVdaGXoT4Wsa1ENZ36nCkjk7IwZ4/Wcv+l1pVHZ66R4kZtuAtKxxudU4I7qSylYdHK8p9pNBvRFjh3rgtpkutvRwTtYKnJPraYrQ3OF82I5R3V1zlB3b02Rln1MjtUtYi4ucA0zSi7Wd//chD4K0EOClyL7sx2YqWA7Nhnz4a7kbdyFDSh9jxMx7MYuMHdZFAQnNrYru4A4MQBD+SqD8XroieMrc3Ujms9qfFXLJwP6urcpduv8KVi9766xucMYuLkSjC61DoqrMX/Mr0fF7Ir24k5ZBxy1I/bxbn1uGRHkBub9ui60Lnx+VjfJ/hXWKyR3N6fITZmpcZ9/+wszfc9ThcM41ePQnMwreFJBUYk0DXIBdtc5sGxYp7r+plTtu26PLb+eS9Fis1pes6hZc2gFZEhHq8s+GLWTWtMtaazAaL9kJEmhvgZ7R6M9PleJf8uLhVe48ilq1O+cqwqBHqqHmrIrjzJdleNy6crl6+acPZy4B+S6xnl2DzEAOH7gyywKWrzyoaiwI7h8OyY6/qBWM2rtnJvRerLjGGOs7Qm0H0T2Z9RiIytRiqzHrU7bRWiXbfnXT+dpH17A8KOd6g32io1PmoVvAFjX1VxbXAgYAUpvq2hQ6WhfLXc5M9DxcSOXFjGabfW6CjUqcGTz8XU3IY3u1wERkKc4vn72rWN6IXxWvRfSQngWrFWjfTG+aPZ2lFtFWsrJ6zjqLbQUxTFG1DimGmq97hK1LRALVj2HMz1atyuok3o8XU+0qZ5tFKdCJOm7EzqZyGqUGdGiIgaxjbpMzS3VYltfnEd3tRq7FOFqnOHzylivZWZzzcKB3su8hc5TQ4saQOQu3WCOdvpfFSLQD0VlKCsThPrvvtjxJRqPmd6nMydihraL4mAkkGynnVbrrjD6q3OLGD8x+6AvnyObv+W1uTcJkcSd/sjslZFR3Iqq+srQ6Liiotr2fY4vc/yMT75pm+hsaCk9pXDhZ3E5U+bIUx3FPi+8v2U3X+m3hEji9pW6uKOJRxpHxmg88A1gXfDR+ZouiDnuaLw8iu0TY4LrPjb78L5UOTxsRHxQPr3nDOq7hEjyHwaKDjpFsTJzJZGL3Cdaeo7Fw1fRM1FKQWUBxkIC73Hu0Y8zeExrfcRbVUcuNVN4Heu9h4ivEiLQUawDhkAOALRgsEzxTZ9xrScz94kbkFGA47sb6g5Lab+q0Sw9Pi7ZxxjzP68kqTVyHvxOPmTHULgPClz/YurVQiTpu/fDAAkQcMa6Fkcbq15XVQFGxwd53wGIx0udBxAXFzxdorJkz+kcVMBt7e3vR73r/2FCJPm7GRkgIJGpwJhAq9D8tJ3qicdHLbpHqNaF6CAt3hQe88kIWPn61KXrXwAf/uLphwuR5O/mAzEIUe1u17XwO8Y1t1rdQPb+dQwlzw0jhJmVHCNAlYGkTMCf8U7/pwkRGH+XDRhztAhgROhTBaUC8SqNWjzHygBTlgY4ZejV+1aX6aiT1x7uTWGn6PW3iMmkjBEeWzLk6y7TyWObu9YobrZ2CEt3fN7jfa23+TWNmwiRpL9dE0HwaOdbGeIC6e44P2LpVSG3IHePfiSQlBUAVNDX5nvvpZsKkURhZpYF5AXpKN3gcx6TFDkeKU0Elvg3eukGiBWOz9/6t2zuIkRgfFknQoJRhUaL4wo6nDKAEVWAvBzom9aRq492VIDrXhS9hu4mRJL+LKaDE1IE+9vz84azu9hIgBHAigCOWqgKj6+j8dr/9rfdnHzLi+Qul9eAectHD3rpfbf43maOi442gX5kg5vcFOZZfmUx/mXYO5AyRC3MXWP0mbLUE3BKUWrCds1ix+OPHLe3WXC5XNL53ptOMxElLaz7ybUsufadBY9/fu4mugZgf7vZx6SQz/hvF043ISX/Mdsoz9QYmCX8fMYL0hEqzXLWM1me02knpuRbXsC8tdM+x7vmWmrrQh/P7mgMVGU4A3B5jU49OaXX/i8Gy3N+iizKEbPKkVvsma1P6SEmqeRVH2U8CwGa/wHjXqG++KPWrHniGePeET3UZJX05VhgLouR/H526uxWdc7PoIectBJ/a8B3872yoxvHwHxu51EFCPwHhAjMv/gBzNUYIP5duEeJe0f0L+D749HrhKeLAAAAAElFTkSuQmCC"
      }, null), vue.createVNode("image", {
        "id": "_Image10",
        "width": "107px",
        "height": "62px",
        "href": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGsAAAA+CAYAAAAs/OVIAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAgAElEQVR4nN2dWa8saXaWn5jnzMjMPZ5T1V3tsrGR+TNIvjAgC+y2uw22bIONzB/gBgkEAowZJbiBCyR+CzdIIHDX0Gfvs4fMjHmO+LhYEbGrrabdQw2nCKl0ztlDROQ3rPWu933XVxpf0+vn/0CpplEAeJ7G83MBQByHmCaczzVx7GEYMI7QtjAMA/f/1tK+yvf+Wa6v5Yt/4+8olWU5YRgCYJoawyATZxgargtVBZoGZVlhWRamaeJ5Gl0HRVFx/I/B1+6zf61e+Ju/o1TXDTw/P3N7e4NhQN8rbFujaUY0TSMMdU6nhjh2GUfoezBN+a/rIM9LLi8DHh8LNpuQj/+l9rUZg6/Fi17+eq00TaNpGjabDZ6noesyEY4jk2BZUBQKTdPQNIgiyHMYx4lpmnh+fiaKIq6vAz799MxmsyEMDboOlOJrMWnv9Au++s6gLMvgeDxzc7Pj+Tnn4iICIElqLMvCMAxcV2MYoOtGdF0HoOs6NhuH47HAMAw8z0PXIQyhruHx8cwHH+zo+2Wi4aN/8W5P2Dv7cq+/OyrL0jFNAQhl2RIEDtMEwzDRNA2GYWCaJrZtcDwm7PcxVdXQdR37/Ya2HTFNg7bt6LqOi4uQpoEggGGQnFYUA45jzvcdiWOD//GP3s1Je+de6uf/QKkkqXFdlzDUyLKR/d7g+bmfJ0Yjy+T7fd8DEAQ2AIYhIbGqGkzTpCxLttstcSwTrhSk6YjrGuS5THZZllxcxOg6uK6EzjiWifzv//DdmrR35mVuf6tXlmUyTYqqqthuAwxDBm0YBCBoGjw9CURXSrHbRUyT/P4wTLiujq5DWY4YhsHbt2/58MMbHh4KXr8OOZ8nlFJM04TnWVRVh67r6LqO7+u8fZsQxzGGAUVREwTeO5XL3okX+cU/VCpNe7quw3VdbNtgmmQnBAGkqYSq5+czV1e7dVeM40gQuOuEdV2P61r0vXzBsnSaRnZkVVVomkbXdWiaxmazwTDk44+jQinFOI64rkXXCbLUdZ0ggKendwPqf6Uv8Oo7gxrHkf3eJk0FHBiGhmVJ2Hp6EmBR1xPavMCTJMGyLDRNIwgC6rpmHEeUUmy3EXXdst87VBV4HhTFhOPo1PVAFJn0Pei63B9kxyoFeS45sW1Hmqbh/fcD2lZ28+Njxe2tT5Iovv+n+lc2Zl/Jg3e/lisAwzC4ufFmiK0wTY2qahnHEd/3sSxBba7rMk0Tr14FVJUMcF0LPO86uWffy78fH1s8z1mfVVWyC+PYommgrjtc10bXwbbh+bnC932qqsLzPDRNI0kSwjDEtk0sS+6tafJf3yt8X+N//ZMvPzx+qQ/8xt9RCgR1WZZBVTW4rouuQ123dF3H9XXE+dxydeXQdTIxaTphWfoKApJEQMfpNLLdSsh8fq4YxxHLstjvXepaQmieK6JIo65hGGRBLGiwaWQyHcdhGAa2W4tpetl1SVLiui5ZlrHb7VBKYRgamw0cjyN3/8b8UsdP/7IedPG3KrXdwjQp2ralLGvC0GW3g+0WqqqawxlomsbxOFCWE30vNVPT9HSdoq5hszE4HgeCwJjBwIRpmrx+HXFx4ZIkHY4jfGDXdYyj1FKGIbTU+TzO7MbIxYVLHGsMw0Cej+i6TFLfw/vvB2y3Bo7jEEl5R5YVvH3bSH77lUe1/Rup+rLG8AtfGX/p7yk1jpAkFWHoM00CsR1HcsfjY0UQ+KRpNoceHcOQHVUUijjWqCqYJil6o8jANOGTTxLeey+maaDrJrquw/Nc2rbDcWyKouT6OkDTIMvkPkmi2Gw0jsduDXv7vUNZQlEUbLchj49HXr8+rCVA27YEQYBpmozjOIdUeHrqmaYJy7IA2G71L7w++8Ju/kt/pFTfQ12P9H2PruvEsY1SMlF3dxWvXvlkGWw28uGVUvi+jWHA8SiDl+cVjiM5KAyNleuzrIVOGpkmgeS2bWOazPBdBvPyUn738VFyl6ZpuK5J3yssS8P3hfRdCuhpUniexjRBUXQz+2GsTMeSv2ybmd3vsW2ZsGGQ+PlFhcfPPQxef7tVv/zHStU1pGlNFBlEkQtInkjTjrKE/d7n/r7G8+D+vp4LXpthgKoaiaKQYVDouo6maWy3BgB13VPXik8+OdO2LUmSsNtZTJNwgAtpOwwDYejQNHA6DTPMt+j7nr5XpGmK5wlQUUrAjiwkYebbVhFFNk3ToJSE7+MxZxwnum7g/v5MVUEUWXRdTxDAdmuQ5znv/231hYTGz3WyXn93VI5j07ZwOiV4nkdZKrKsZr+3CUPwfZtxhDzvKYqC47HB9z0MQxJ/FMlAx7Hcs65r+r7n8bECIAyteSJCuk6K2rKUwfZ9naIYaBrwfY++l/DbdR1RFOA4cH3tsdlInfX01OD7EpYNQ547DLKDhmGgaRS+73M+SyE+DAOapnE4mDNDUtP3cHtr0XWQJAPvvy9F9eavJ+qD3/18J+1z2a7X324VgOMI7XM6nQHQdZ3NZoNlCYL63vdSXr3aUlUSMmzboGl6qqpis9lgmhpJkq/E636vkabQdVIUN00/k7fQNBJa27YlDP0VtpumCcjAWpZFGOqkac9mYzEMzEVuz25nUZbQNO2aj2zbRinZdZeX8VqTLXVf0wwYhuxw09RwHAmhris5tW0VYaiRJBLSlVJ4nkPTdDz8e+dnHuuf6Qa7X8vV9XWIZcFHHyVzYbrFdfWVfTif1YzIRnY7n7aVAQCJ/a4Lb9/mRFFEXdd4nkdVCejoup793sKy4HhU6LrIH6dTwqtXMVk24Lom4whFUc7PD9E0Zgguz7ZtG8PQqKqGvu85HCK6DsqyxDRNHMdZ0eMCfJoG+n7g6srk6UlykYANH5CclSQ1tm0TBAZv30qxHscBXSclwgI3TFNy3c/K6v/Uv3z567WKY3fl4ZqmIQhc6rrjcLDpe3h4SLm93a4F7MIqZJmiLEssS0Ka7/szoRry9JQTx4KTpwnqull3y7ID0jTl9es9b9+m2LaNZVl0XUcY+tR1y/W1gIqylHukqYSxzSZkHBXDMNC27TyJBpZlcDolXF7GaJrsEAmJA77vEYbyzn3fs9lImJ8m+bfr2uu7Sn6THRVFPmEoIGgYhIGxLA3DgP/9T3+6SfuJc1b0187qm7+j1OWly/lcs9sJlHYchywrVz2p72G/3zIM8nt5Ln+ezwNxrKGUwjRN4jjgcNB4770Qz4M4juYBG5gmNSNEk67r6Pue3c7A9/05pAXYto1tm/PPQRg6HI8jeS7vUNcdnucRxyF9/8L5tW3LdmvTdR2GARcXMVXVUxQdti1j+eqVx/Pzcf3sSikeHzMA0jRlu7Vpmo7n5xOmCRcXLlHkYZomeV5xOo0YhnCURVHg+/JOr74zqJvf7H7ifPZjz/B7vz0ppdScrF2Uku3dNPIhNE2jqiouLnzGUVZaWUrN07YdFxf2al4ZRzgeG4Zh4OYm5OGhJAwDxlF4vDR9get5nrPbCdooipKLi4Dz+QWGT9PEdmtTlhNBoK9C4kIPCZID3xdC+HAwub+v5h1lEQQ6SdLOSHSYw6KEsK57uUfbdrNtwMJx5BllKWHQ9405Cgzouo5t63TdRBjKwjVNuL8v8TyPpmnWksVxZPw++ZMfb6f9hTvrw99X6hf+rlJZlqFpGp7nkqYVVdXx9JSTpikguSeKfE6nBtuWiYoim74fmKaJuoaHh448Z4buAufrGrbbYKaREspSapv9XuqbwyGmKEpME3zfp2nkd7MsI45Ntlt7DrM6x2PFOC6c4Uhd9+i6TPLjY8luZ/LxxwkAlmWRpum8++p5UGWH6jo8PCSM40RZ1ozjRBjKLpSwquj7kcPBmxeMLEDPM2fKC8JQ5/4+pSwVaarYbAKqShbhQoVlWU/X9T821P+Rk/X6u6MaR6mPvvWtLbouRSSI4HdzExGGIaapMY4yQI7j8OmnCZqmEUWsVX8Uwc2NvSZw4flcum6kbUf6njnW27RtS9+/cHSO49A0I0GgMU2KcYT9fr8O0jAMdB3Ytk3XQZoKEnVdi6YZub2VcFmWsNvFXF0Jcbvb7ajrnutr2bmbjYZl6bQt3N7GGIbOxYXH4aBTliK1TJP8XF3XGIY8p+tk8ppmxLYtzueGuoY43hIEkqvO52z+2W7O5xVKKW5vLTQNfu73lFpQ9f/r+qHbz/qr9+rDD28YBkE8mqZxdeVyd1dwcRFi27K6hmHAcSzOZwESDw9iD3McDaUkPrvuwihIQnYcG8+TuibLFK6rkeeyC7tOVNokEUjteQ6nk8j1SskOCYIAXRdEeDjEKyNSVeJyenqS+s5xnJmyknDrui5RZFJVijzP2W43lGU112cOeV6x3/v0vYTMtoXHxwTf99ls7DXcPzw88OrVDUVRYds24zhS1zWHQzwvnhc5x/MEUCyFN8i96/olvC6k8v19MpcvOn3/w0niH/hC+KsntdvtZugrDPM4KrZbjTyXAZYQJ1SNhBjxN3zwQcgwvEB1WTUuZSmUU1EU7HbbFY3VdU0cb6iqBt93KQqB63kuyO2zxpcoivB9g2GQiX96+qym5dP3gmIOB5OyhCQRm5llQV1PxLHO42OzcodRZK8KdJIUKKUIw5BhGFZRU9O0dZJlMQitFcfCzJ9O9fw9bd79gnYXrWwcX+ist28rdjt//nvLdisLqSwlFwpQkXquqiRvRpF8/7NKtQbwwe8q5TiQpsJzaZo8XOCo1AwgyEoEQgPL0lY+7XxOuLqKSdMa3xcXkePA8VgzTRPX18G6A85ncRgdjx2bjXCFCwgYBlkMS6gcR7i/zzFNk7Zt8TyP16+FQioKIV89z8OyjHWVlqXcbwm/4ziuueLy0uajj8SGJpKIQ12rVb8KQ4u2lR0kphsHTRP+b7+3yHN5pmVZc8h2sW1517Zd0GdDXYvzStd1HMdhuzXWiWzbkTA0SFPR1dq2xzAM0jTl1asdZTlhmjrjqKjrGsdx1l2m/ZV/oFSWsdq08lyI1ft7QTq6rs+eBYHowj4M+L6JbcPp1BEENlUlrECWTUSRzt1dShxvGQZRgPu+ZxxHwtADpPa5vAxnmkaK4jiGLBPpQrg84Qo9j3kXy4TI7pYdGwQGeS6DWZby/U8/TbBtmzj2ybKGsizZ7/fzhLtkmTwvyzJev96QptOsWcV0nZhwltJCPBpwPqdcX285nSo2G5++V+tOdBydthXH1cWFT1lKydE0DTc3AooELcoY6LrOMAwcDj739xJql5C6eBkXt1YQyOe2bdAXo6Ss4oq6btcJCQKDYRjYbAzGcVFoayzLpK7HWSey6Hvh7N68STEMna4Tri7LcnRdRylFENhEkYemycDHcbjunu02IgzhdJrWWmgphA1DVm2ajmgavHmT8NFHKboutU6evyT+/V5W99VVjO/7KAW+73I4HCjLcg1pcRyhlMJxnBnF6ViWhW0LMXt5abHbCdAR24Di8nJLnvdcXvqcz1I0TtOEbctkmqbObuevoXu71TkcfO7uCqZJFGZRqxtcVxaSbcN778WM40iWZRiGweOj3PvqKp69IRIeTRP0slQUxTCHPmf2IahVCGya5geS7n7vMU0KxzE4nxsBJJaEy/1+S98PZFm91jGyKwUxDQNkWUWeN2voEGGx43zu15eWUKtTlt2cv8A0DYZhJIoibm+3WBYcDvsZTWmczx2nk8T2cZQoIQ0JPZoGFxfhCsuXLOB5Ds/PFedzRRAEPD1l1LWi70VLMwyDIBB4Lova4ulJgIXjaBwODsMgu2ah0IZBFnRdy9d3u5CybHFdjdOp5fXreJVXJMf3OI6DrutEkcyBUswLRyPLJpSSn9Vlpk08T1ZKkkiCD8OQtpU/01TY5b6XxBqGGk0zcHUl3ogXWM3skHWpqgrXdbm8NGYxUQrNqyufw8FlGCR+L+Kd48ifu91uDpkTrmtTVR1ZVmNZsNsJrVUUE3kOux3c3QmYsSwLz5OFs4Tn8znFdS2mSdgNIWtllSdJQt+PRJE/85Adt7cbgkCjKCRP931P2/Zst3A+J2ga3Nz4aJpGWfZzflQURTtrW6IMbLfbWcHuOR4z4tjh8VGose9//8zpVJGm/ZyrRYv7xjdC7u8lH55OCXUNd3fZLP0IwNEOf7NUC+sgtY7krDRlVVOXLg2ZWBddXxjnabV3Lbxd3/c0TUMcx0SRwfEoqElW3UCWZWw2G+LY4nwWVsC2rRni9mRZNsvoIUEgFb5hvDAiS/ja7eDP/uzFmqaU4vra4/m5m8OnQd/3DMMw+wJ9np6eME0TTdP45jdjigKyTJiFKNLpe1nBS+gRH7wiy7LZpxjT98PMZBjc3yfz38MZlhtomoyLMBmSb9++fSF8FyI7z8Woo2lSpvR9z8VFyPlcz5KRLOZpmnAcWYjaYlNumn71zJ1OJ25uLgHW9plFUZWXkUnbbGQwxxEeH4/s93tsW3ZQmopJMgjg7dty5vVi6loMKotnT9fh+VlI1CU0+v4LU11VkqzP5zOO43A4hOS5wF0pxGVAl8vztJmz9DidxEL25k1BEAT4vsbxWBFF/uqL3++1Wf4QdTkIRErx/UUsbZmmadbHBmzbZBgkVzXNsOZWXWeWbsY53ztUVTfbDTxc18B1hRsVf6KzSi+uK97EIPDRdXn2w0M1q+sueT4DE8PQGQaF686zp2lcXFzQNBLrP/nkiK7LRNV1MwuELuM4znWCmgFDPPsbsjlceLRtP/Nr2oy+cm5uXA4Hjb4fqev2MywFc64oSJKONFWzu0m6R0zTxHVdDEPYk9Oppm3VHIYbDEPD8zSSRMwsAqV7qkpCeRRpFMU452XZBV3XkSSyQNpWEQQWx2NOlhXzTh7nWs6b84hJ28rAdd1EURQ4juSoMISuU+vC6bppLTeapqHrFEky4jgmwzBg26xCZ9PA7a1ocraQ+Fxe+nPBrdjvLbZbV+imzUabfd6KoijQdY3NxqIoGl6/PpDn1Sp9C3qCKDJ4fj6jaRrPz+lniladp6eMqoI4lrpFaKBOaoa7isfHgSgy2G4lmb56FVOWzDkkpKoqTFOjrru5PnN49WqLpmmzaRMuLz0cR4jc3c7j6em4vuP1tWha2+2WPJe6pyjAsowZaUqxfH3tEMfw+Jiy2Whz2PJo23ZGlwKSzueUNE1xXbBtsQbYtr7SW+M48sknCXGsURTFHLrElp1l2Spquq4xRzB3DrkTRTFwPCYkiXCIadpxPIr14fY2mEsIyX9rdfxLf6RUUYjOdHkZkiQtUeTMiGrAssw11CxajoQRk/N5XF9sAQy7nb+WBOKulXadZcX7vkWaVtzc+PNASjhI08U2JtJ/HFsoBff36YzCHJqmYZomwjCc2fF+VYa3W5MkEfV5yVXDMHBxIS7d+fVoGoH+oiZL7ghDef5CChyPJZtNQBiymkvzfFhFUssyOZ3OxHFMWZa8ehXy8CAOYc/z8H2Dh4eE29uYtoWm6fA8e65XpUYUEfOFohJ0LX+vKvn5PBf79g/QTe/99qQ8TyPP+1WgE1len7sw1JwIhR5ZFFnPg48/lmTfdWrt/kiShIuLA1mWc3sbUVXC6d3cxNS18ILCM76Ic54nAzkMwp6/fSsTKsWyTHKSlPK+7wWzfCE5482bZGYWIjYbE8OA+/uCOA5n4CBq89L8YNs2fd/jeR5ZlnF1teV0KmeNzJpRsZhKNxuDspR8soAe8XgkXFzEFIV0W3adjIfY7xr2e5eqkp/b72NcVxbMxx9L4f76tc+bNxXTNHE4hLMFrub62qMsf1Bd/qFE7vW3W3VxYfPxx0LNyPaVVhmxNBe4rsswDFxfuzw8CL8nu47ZFqZxPhc4joPrWivddDxWbLc+VSXU1uKB2O8NkkTNZpiXnxeXVMnNTUCWiXVZdkU2W6xNsixnv49WC/WnnyazsBnSNOJxf3jIuLraoGmQJC23tw53d/Le0/RS4I6jLELDWDzwNZuNmG+macIw9BURGoZBXQuYEZpKJsX3fS4v7bWrsusk5IHoc9/85pb7e6lFw9CmbcX+JjRagW3bP9Sz8SNFL/dXHtXFxcUqyi3EbpIk3N7ueHrKORwimuZlGxuGwPrvfe8tH3xwQ1VJK87iim0aOJ/Pcy2i43mQJB2WZeE4Ur9EkbUW0GHoE8fw/Cwf1vd1hmGRRl6oLN+3aZqBvu8JAo9xlETvuhpFIQtjATFSZE6z1yOY/YUG9/fC9KephOyFXpP7QFGM+L6B5wlhLbltWkGI9IcpLi+liBZ7tlBISdICzKDE4fY2pCggzwt0Xef2VqLHjxIif6Se1fzXK+37f6prCyEq6rA228BEjxKI3X8GlS3o5oY8l0Q8lyFzp2GBaZr0fc/5nJDnQrhO08T5XHJxYVHXiq6bCAIfzxOzzOEgWlBRDKRpObMZxsyE27guM1vt0TQdbdtSVRVVNVKW5QyH09nvLjWk7/trC1CaCqMxjmr2lKjZONNiGHB3dyYM5et3dxVBoLHdujiOQxx7zAgeXdf45JNqNd90XUdVKaLImZVpcfem6UTX9VxdhbP/Uf2FivGPLevf/lavxnEkihzqesRxDLpOGOKlvgBmuf1Fspa6TAq9um6wLIu2bbm99TmdFh5Q53xOef16uxLBDw/CpARBgKaJ1CCrmzVESn0npGwQQJL0lGXJbhdTltXqbNrv/dVSIMy/7Ib9XuPTTyWnWZaE8PNZdvMwCPQW86m1cppZJnJHUfT0fc9+768O3cfHdmbahWfsOmZILwtFhFoBFVnWcnHhkKYTb/618WPNw0/ssvm531OqqiRUSfErjMF2a/P0VHB9HfL8XHN15VFVUFXtHJqCub5Y6jl4eCjm5jkhYpcicRzVGtocB56f61lM1ElTETiXGL+gvsUDcn29o20FvLx9K/1dWSbhCiCOPaZJNDEhdh1cV6Np1ErcfvjhjtNJ7h2GPlXVEIYuWVZxOPgUxThbD2TXAytRvKgLi3NqYdilTpTnOI5GXf/kXSg/tRXt6jcatds5ZNlAGJorKmuaht3OpW2XLvh+RjpCej495VxeRiRJQxRJu8/xWLDbhZzPBVEkMdOy4HyWMytAEr4UlQZl2a4OJSmUDYpCWArD0EnTjJubzbxYRNJYitRhGNjtIvJcdjvIbhP/vRhy7u7On+EoRzzPJQzh6amZuU/xMmZZtxpbF5/7QjjbtsEwCHBoW1G5bdvm+tr6qXuVf2aX6F/++0rJJEnyrSoRJIXYlGTq+xZdJ6v9fK7mVWYTRfDmjfzMxYXFRx+d125GOadCm3WrmosLj/NZtLOuU7MPQpiCpTkhihzKsl9lGYA4Nueww9pDLMYWKcLD0FgprbaVRSCuX52yrFYuse97osinqgRJns/LCTYiNEoXypY0TWeUKnLI5aXH83OzaoOf/quf3uj5udinf/mPpWPk6Unif5IUvP9+SJqKRLEgSduWvJAkFXHs0zQCl/v+Bbm1LatAB5Kg5XvCNhgGPD2p2e+3AB9h3S3LWOX052epa8TTCHd3+SxDBKv7Vu4riK8opEl8IV2X0LrbidD58HAmiiK6ruPmxl89KEFgzfodlKUYXZUS/tTz3PUZn0en5OfamvLeb09KQp5BnktCXpqzP2tpLsuSzSbkdEpm352P677UJGUpk1nXUowuRPLiUxgGGYAsm6jrmv0+4HgsOBzEzHN/L+1Ci1IQRUIoPz8LUfvmzRO6rnN9fZhbTyXnSDuQuy6WIDBWqJ9lEqIti1VvWkJ9WU6cz2cuLw+AfEbZ6Qb/8x9/fj1bX0gf0TJpfd8Thu6aH3xfEJthGGuN9fwsSXwcpZAWL4bi+fmZ/X6PruszMdtyOATkeT9bzPrZhLOjLKVoXgjZaRKJ4nQ68fr1AcuSfKfrOufzmffe2895pCaKPBwH8nyakZzk0JubkDwXXUuUXmHcXfflqIdPPz3yC79w4O5OdpGgYvHfT9Pnf8TQF9ZMd/UbjdpuRQZ4eKhm+O3N/cPdipSyLOP997eMI5zP3bqq+75fm+kuLvx1hy6QuG1lwNp2YrvV5w5IxX4vH0kpePtWlOzt1uXhQSxqfd/zjW9IiO77ic1G5/m54fLS5XTqubiw1ibyYZAdE8/9R8LMmPT9uDq0ttvt6nHf7Xy67sd32P6k1xfepvr6u6NaTCdNs8j0+io3RJGF6wqt1PfM9ZI0iKdpznYrTQrL15cmiO3W5XgsaNuWq6vDLOP0q74kjXVyFBC85MHbW4ePP5b7iggou35RbTVNI4417u7KuRbzSVOZvLIUoFOWi7G0WwXEsvziz8r40rrNlxNklILj8cirV4f1WATTlB2T5xO+r5PnPYeDWL/O5wTDMNhsIoZhXLs0tltr3lmsNdrzsyjbck9Rt4W81Wcm5AWJ1nWL4zgrk7H0MS8uX8mfPZ5n0bbjeqCKlCbe7NUQ0+oXtZP+/PWln+Xw4e8rlSQyQHVdz40A1mxFlhDXdf0s95ukqdRlZSmtPldX+zUkLpY1zxPTpijHclLNe+8Fs2AquXMxhcqgO6sBaJFFhkHAzCITXV+Hs/dBmPoFVb55I7LK0qZ0+k/hlzaGX8mhJT//B0qlabNyi0tH4vEo0FfafWRGgsBeqaCyHFe/uFILdA6wLI00FWu1uGuFSLVtGVzf9/E8a0Wjcp6FPnNzFlUFed4xTRP7vYvrwsODyDHLwsiyksMhIE2lFnv77+z/vw8t+fNX+Ksntd/vVmtY2/azVGHjujLgi4zuOA6bjRTJYfiieS1HNeS5eBjKUsBM0zR861s7zmcpxstSjKnzQWozky8F/HYr/vqlt3ix4rVtSxQFNE1HGNqUZf+VTNJyfWmHlvywq/gve+2TP9E0yQ8DRVGsO0aI4A7ft9ak//QkHpCPPz7PTW/Mztd+1paa+SxcjziOOZ/FmZTn3Xw24dLoPc4yy4jvC7sh8jucTvIOeZ6vB0q6rs3/+Wea9lVOFLwjp6It1y/+oTzw8moAAAHYSURBVFJl+cJOLBrZZmOQ52IWTVOxQ4vxJVhdUkqJoadtWyzL4nDw1zZWOWjEnk+gfhH6kkSOrNM0+V3fd9fifQE9bQvf++df/jlNP+x6J17is9f1t1slsNtc/eJRFK2+jEWUXPyMy0Eii31rYfhBmtsk1y07zqTr5J6CEB36fmS3M+beXykZyrKmbVvy/7x7p8bnnXqZz17f/B2lmqabpXRhuhf6yLZt8jxns9ng+8I6LKzC6TSujLznuSuh7Hketm3MLMo4d+2LMzjPO4ZhmPWp7Tt7Vu47+VKfvV59Z1B1Xa/Iz/etGVio9biE5aihpVuy7wWG17XkvcPB5u4un21rW5qmY7ezubtL567MkGmSXPlV56Ufdb2zL/bZ6+Y3O+W6FmXZrAJfFFkUxbDmryhyZxVYWAyhgnyaZlxNKLe3Huezms0uL4eN/CRN2F/l9c6/4GevX/ojpapKitMX1gPyXDjA5WyLxUMoNmWXzcbg8bFkuw3WBkA5zvXLPzPwZ7m+Ni/62Wv5/5Asx4W7rs3pJK2rV1fB3GB9nifKo22Fxlr8hVXV8vgf3K/dZ//avfBnr8tfr9UC1a+u/PXM9udnYc+zbPH+vfx/Sx4eHuj/2+3X8nP/X8+jjAy2QdiEAAAAAElFTkSuQmCC"
      }, null), vue.createVNode("linearGradient", {
        "id": "_Linear11",
        "x1": "0",
        "y1": "0",
        "x2": "1",
        "y2": "0",
        "gradientUnits": "userSpaceOnUse",
        "gradientTransform": "matrix(-118.47,-106.79,210.785,-180.125,69.2121,1372.7)"
      }, [vue.createVNode("stop", {
        "offset": "0",
        "style": "stop-color: rgb(64, 128, 255); stop-opacity: 1;"
      }, null), vue.createVNode("stop", {
        "offset": "1",
        "style": "stop-color: rgb(64, 128, 255); stop-opacity: 1;"
      }, null)]), vue.createVNode("image", {
        "id": "_Image13",
        "width": "107px",
        "height": "34px",
        "href": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGsAAAAiCAYAAABY6CeoAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABFElEQVRoge2aQRKDMAhFmx6it/P+x7Ab64xOmaAG8vnwFnWhiOGFOG3TPsu6vpS0djpuH61zXoz5F3s6r4rRxipiftddeUbp3t18QozEu3/JfdSzgCy5VWpTWcVYSlaPqcvDEUpZQPUdCqUsSAbMoJIViJIVCBNZrO+MHtbjrs4KRMkKBJUs9uXXTxZ7JR2g6ix27sly6BIxReIOHdpZWevoNe68y2DAmTVXFmDBAB9pJ29nBYRCln5jgkVyv1QUsrIAJyvtvg1F7iGykF/KlniPG66zKDCyWLI2IqwOJSsQz2URbqZEpTorEDCypn6xnciVYT+SlbS+08Zt01lJfv7xBmYZLPpgy6p/pA9gyxIArKMLXxexLNiBCThLAAAAAElFTkSuQmCC"
      }, null), vue.createVNode("image", {
        "id": "_Image15",
        "width": "38px",
        "height": "62px",
        "href": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACYAAAA+CAYAAABHuGlYAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAGaElEQVRogcVZSWLjOAwsblIu+oD+/zZ/YC4di8sc7IKLsJzJdCdpXGxLXIACUADpgL8oIYR9jKG/wd/hL+m080uMEb33pwHpR9UBkFLaU7ptW0rBGAOKGgAsy/KjiO3Aw105Z4wx0FpDSgmtNVPqer0if7c2Oee91oqUEsYY5rZaK5ZlQYwRx3HY+J+IsSmOQghPqKhwTO8dIYRvU8yU0kzzEmPEGGNSiGO/Ovh3ABtwQ4UI5ZxRSjEFKBprYwyUUtB7v6H3hQqhlGIb1loRY0RKCcdxIKWE3rshUkqZYsvLHykWQthjjJZZGtwqpRS01ia3MaZCCKi1cj2MMZBS+n1XhhB2brKuK2qtj/hIyeJHkVEypft678g5I+c8uf53FNsBbLoJF6RwU800kirjinM18HXcpxULIewANi5KyDWT1nWd3KquXZbF5tGVmq2qXO/9UzG2f/SSyK3rivf395e1T5/TmBAClmXB+/u7AnBD+7NK5fwoEiE822OM7d7lnBFjtIwlmkSMga97hBBelqRdraTf1SIvnsm1/gEwVBgCfMfPpwQ6UWgj0XGQxgrfeUWJFIO7tYacs20WYzRDPbqkDcZs790U25dl2ai9xoKK+V+oQFEhspzvWZ4kC2DKTK6tCRBjjDtd4RVZlgVvb2/T4lqMj+Ow9yRaRU/Xi/E5nIkUjWLMpZSQxhibn8C6dhyHlRZa6Ru73jtKKbYgDeBmWor8PN2LLmf8JdyLrsKrlV7hp+XeRa01G+/jjaj4hGE49N6ngm/vVakQgqU1N9c2uPc+pTdLjyqpn7qOFz6PMU48RjBsVcaHr/hqPZVZ13XKMn3v+U4zmiWKhur6mpm994diDDwN2BDCxD80wD9TZWqttimfE1lPQYyndV2n32OMW4xp6jI7vGi80CqSr48PRZGGkttSShO/sV9b19XHcjSkmEWKmP5mcKsiipaXs/hjCFCUO1ncASDFGLdXmxJBjRFFk4VbfxNVpRi6h/F2tgfBoRdiaw3LshifeCGPsW3hQsCj/lER5T1SCN3nWd76rhehk0IIGxVQC7iAh3xZlmksUVQC1eMaS5gqRve/OoXXWm/Br0jwANFas3aFStFNuomlt7iZ2aeErUox8Espxp9U1GomgJ0WTec6l23+HcvIWWPIHoytkM7lfYWi7ue21hBZ/9TiUsqUPWcMT746U6rWOvVnOvdVJaAYjeScNwYorSeFeDL0LO838W5WQ/S7ZZ4klc/4eL1eLViZsrVW8z39f9a2eKR8u8Mg93NpZGsNx3FMBxTzEoDt7KCqCcFNtTNVK1+dK1trljxKEWyVfDfLLM05I7Fz1c191tVarbPwLlXOMjecKKWbMtEo/s6s945IjWutBq1apxbpUR94JAkX00Kv8aSuZDZynWVZTCltNs2VHikN/DP+okvOEsCHA68BPFLa3XoujZqFKlqctRx5BfQsSI7iHACWeeoySmvt6eDDsmaIeSF18PbPu5ZjtCroe7+mP01pS+T3tZM4G7uzWGCvpNZpdhExZqx2ptpRKPX47oJoszMG7j2/xoIqx8DU1oYLcxwTxbfkPl5jjFN4MAP53p8nIsmV15G+9yICXIyKcNHjOKY5KjqXY6kc6yzXbK0ZkjFGhFLKzoH2UG75xIIP6xzT3X8HHg3B2TGOzabe+/PiblOfn8UEn3MToqnI6R0GjfOJoOXNcx7r552CLmmMsem1NjdX7uGiSqa6IUWPa2eZzoOtntBVeu8XAP8AuF1D5ZytmKoVFH/0OpNX79St/lMo5uLnJdzvUzXwpk5SiFTpwlv9qnfXYm8F+jHPEPJiaUR21gzTf8fUytba1E2Qw/TcSdECzaS6U8sTShPS/MKOk27T9FXxqKirSBetNby9veHXr182XrL0Q4UokVdInnO0vj1Zc+ciJUV2HloVXON4+axSAJDJ2F4Bn+p6tD9rhbkGkZee//JR0rySlHPelLfOWhUqqH966gFFKYRz7p+fRuhJsRDCaWtNJf1JiJvqkf6E4y6999Ns+6xkbVtIE2enZ0XKX4VzPP5HDP2XGI8B81W5lhTlOZYiV3YuY4w/QshLVJeR/TVOBA0TF49fhpJKptXaT/mSoZlLRa/X67coRAkAdt+OnP2ZLvKtClEy8Bz4L5T6EYUoU2utqGm9+2mlAMz/vunfxHda+HGFKP8C6wW6ett+DK8AAAAASUVORK5CYII="
      }, null)])]);
    }
  });
  const RESULT_STATUS = [
    "info",
    "success",
    "warning",
    "error",
    "403",
    "404",
    "500",
    null
  ];
  const _sfc_main$K = vue.defineComponent({
    name: "Result",
    components: {
      IconInfo,
      IconCheck,
      IconExclamation,
      IconClose,
      ResultForbidden,
      ResultNotFound,
      ResultServerError
    },
    props: {
      status: {
        type: String,
        default: "info",
        validator: (value) => {
          return RESULT_STATUS.includes(value);
        }
      },
      title: String,
      subtitle: String
    },
    setup() {
      const prefixCls = getPrefixCls("result");
      return {
        prefixCls
      };
    }
  });
  function _sfc_render$J(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_icon_info = vue.resolveComponent("icon-info");
    const _component_icon_check = vue.resolveComponent("icon-check");
    const _component_icon_exclamation = vue.resolveComponent("icon-exclamation");
    const _component_icon_close = vue.resolveComponent("icon-close");
    const _component_result_forbidden = vue.resolveComponent("result-forbidden");
    const _component_result_not_found = vue.resolveComponent("result-not-found");
    const _component_result_server_error = vue.resolveComponent("result-server-error");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.prefixCls)
    }, [
      vue.createElementVNode("div", {
        class: vue.normalizeClass([
          `${_ctx.prefixCls}-icon`,
          {
            [`${_ctx.prefixCls}-icon-${_ctx.status}`]: _ctx.status,
            [`${_ctx.prefixCls}-icon-custom`]: _ctx.status === null
          }
        ])
      }, [
        vue.createElementVNode("div", {
          class: vue.normalizeClass(`${_ctx.prefixCls}-icon-tip`)
        }, [
          vue.renderSlot(_ctx.$slots, "icon", {}, () => [
            _ctx.status === "info" ? (vue.openBlock(), vue.createBlock(_component_icon_info, { key: 0 })) : _ctx.status === "success" ? (vue.openBlock(), vue.createBlock(_component_icon_check, { key: 1 })) : _ctx.status === "warning" ? (vue.openBlock(), vue.createBlock(_component_icon_exclamation, { key: 2 })) : _ctx.status === "error" ? (vue.openBlock(), vue.createBlock(_component_icon_close, { key: 3 })) : _ctx.status === "403" ? (vue.openBlock(), vue.createBlock(_component_result_forbidden, { key: 4 })) : _ctx.status === "404" ? (vue.openBlock(), vue.createBlock(_component_result_not_found, { key: 5 })) : _ctx.status === "500" ? (vue.openBlock(), vue.createBlock(_component_result_server_error, { key: 6 })) : vue.createCommentVNode("v-if", true)
          ])
        ], 2)
      ], 2),
      _ctx.title || _ctx.$slots.title ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: vue.normalizeClass(`${_ctx.prefixCls}-title`)
      }, [
        vue.renderSlot(_ctx.$slots, "title", {}, () => [
          vue.createTextVNode(vue.toDisplayString(_ctx.title), 1)
        ])
      ], 2)) : vue.createCommentVNode("v-if", true),
      _ctx.subtitle || _ctx.$slots.subtitle ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 1,
        class: vue.normalizeClass(`${_ctx.prefixCls}-subtitle`)
      }, [
        vue.renderSlot(_ctx.$slots, "subtitle", {}, () => [
          vue.createTextVNode(vue.toDisplayString(_ctx.subtitle), 1)
        ])
      ], 2)) : vue.createCommentVNode("v-if", true),
      _ctx.$slots.extra ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 2,
        class: vue.normalizeClass(`${_ctx.prefixCls}-extra`)
      }, [
        vue.renderSlot(_ctx.$slots, "extra")
      ], 2)) : vue.createCommentVNode("v-if", true),
      _ctx.$slots.default ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 3,
        class: vue.normalizeClass(`${_ctx.prefixCls}-content`)
      }, [
        vue.renderSlot(_ctx.$slots, "default")
      ], 2)) : vue.createCommentVNode("v-if", true)
    ], 2);
  }
  var _Result = /* @__PURE__ */ _export_sfc(_sfc_main$K, [["render", _sfc_render$J]]);
  const Result = Object.assign(_Result, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Result.name, _Result);
    }
  });
  const _sfc_main$J = vue.defineComponent({
    name: "Skeleton",
    props: {
      loading: {
        type: Boolean,
        default: true
      },
      animation: {
        type: Boolean,
        default: false
      }
    },
    setup(props) {
      const prefixCls = getPrefixCls("skeleton");
      const cls = vue.computed(() => [
        prefixCls,
        {
          [`${prefixCls}-animation`]: props.animation
        }
      ]);
      return {
        prefixCls,
        cls
      };
    }
  });
  function _sfc_render$I(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.cls)
    }, [
      _ctx.loading ? vue.renderSlot(_ctx.$slots, "default", { key: 0 }) : vue.renderSlot(_ctx.$slots, "content", { key: 1 })
    ], 2);
  }
  var _Skeleton = /* @__PURE__ */ _export_sfc(_sfc_main$J, [["render", _sfc_render$I]]);
  const _sfc_main$I = vue.defineComponent({
    name: "SkeletonLine",
    props: {
      rows: {
        type: Number,
        default: 1
      },
      widths: {
        type: Array,
        default: () => []
      },
      lineHeight: {
        type: Number,
        default: 20
      },
      lineSpacing: {
        type: Number,
        default: 15
      }
    },
    setup(props) {
      const prefixCls = getPrefixCls("skeleton-line");
      const lines = [];
      for (let i = 0; i < props.rows; i++) {
        const style = {};
        if (isNumber$1(props.widths[i])) {
          style.width = `${props.widths[i]}px`;
        } else if (isString$1(props.widths[i])) {
          style.width = String(props.widths[i]);
        }
        style.height = `${props.lineHeight}px`;
        if (i > 0) {
          style.marginTop = `${props.lineSpacing}px`;
        }
        lines.push(style);
      }
      return {
        prefixCls,
        lines
      };
    }
  });
  function _sfc_render$H(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.lines, (style, index2) => {
      return vue.openBlock(), vue.createElementBlock("ul", {
        key: index2,
        class: vue.normalizeClass(_ctx.prefixCls)
      }, [
        vue.createElementVNode("li", {
          class: vue.normalizeClass(`${_ctx.prefixCls}-row`),
          style: vue.normalizeStyle(style)
        }, null, 6)
      ], 2);
    }), 128);
  }
  var SkeletonLine = /* @__PURE__ */ _export_sfc(_sfc_main$I, [["render", _sfc_render$H]]);
  const _sfc_main$H = vue.defineComponent({
    name: "SkeletonShape",
    props: {
      shape: {
        type: String,
        default: "square"
      },
      size: {
        type: String,
        default: "medium"
      }
    },
    setup(props) {
      const prefixCls = getPrefixCls("skeleton-shape");
      const cls = vue.computed(() => [
        prefixCls,
        `${prefixCls}-${props.shape}`,
        `${prefixCls}-${props.size}`
      ]);
      return {
        prefixCls,
        cls
      };
    }
  });
  function _sfc_render$G(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.cls)
    }, null, 2);
  }
  var SkeletonShape = /* @__PURE__ */ _export_sfc(_sfc_main$H, [["render", _sfc_render$G]]);
  const Skeleton = Object.assign(_Skeleton, {
    Line: SkeletonLine,
    Shape: SkeletonShape,
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Skeleton.name, _Skeleton);
      app.component(componentPrefix + SkeletonLine.name, SkeletonLine);
      app.component(componentPrefix + SkeletonShape.name, SkeletonShape);
    }
  });
  const _sfc_main$G = vue.defineComponent({
    name: "SliderButton",
    components: {
      Tooltip
    },
    inheritAttrs: false,
    props: {
      direction: {
        type: String,
        default: "horizontal"
      },
      disabled: {
        type: Boolean,
        default: false
      },
      min: {
        type: Number,
        required: true
      },
      max: {
        type: Number,
        required: true
      },
      formatTooltip: {
        type: Function
      },
      value: [String, Number],
      tooltipPosition: {
        type: String
      },
      showTooltip: {
        type: Boolean,
        default: true
      }
    },
    emits: ["movestart", "moving", "moveend"],
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("slider-btn");
      const isDragging = vue.ref(false);
      const handleMouseDown = (e2) => {
        if (props.disabled) {
          return;
        }
        e2.preventDefault();
        isDragging.value = true;
        on(window, "mousemove", handleMouseMove);
        on(window, "mouseup", handleMouseUp);
        on(window, "contextmenu", handleMouseUp);
        emit("movestart");
      };
      const handleMouseMove = (e2) => {
        emit("moving", e2.clientX, e2.clientY);
      };
      const handleMouseUp = () => {
        isDragging.value = false;
        off(window, "mousemove", handleMouseMove);
        off(window, "mouseup", handleMouseUp);
        emit("moveend");
      };
      const cls = vue.computed(() => [prefixCls]);
      const mergedTooltipPosition = vue.computed(() => {
        var _a;
        return ((_a = props.tooltipPosition) != null ? _a : props.direction === "vertical") ? "right" : "top";
      });
      const tooltipContent = vue.computed(() => {
        var _a, _b;
        return (_b = (_a = props.formatTooltip) == null ? void 0 : _a.call(props, props.value)) != null ? _b : `${props.value}`;
      });
      const popupVisible = vue.computed(() => props.showTooltip ? isDragging.value ? true : void 0 : false);
      return {
        prefixCls,
        cls,
        tooltipContent,
        mergedTooltipPosition,
        popupVisible,
        handleMouseDown
      };
    }
  });
  const _hoisted_1$h = ["aria-disabled", "aria-valuemax", "aria-valuemin", "aria-valuenow", "aria-valuetext"];
  function _sfc_render$F(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_tooltip = vue.resolveComponent("tooltip");
    return vue.openBlock(), vue.createBlock(_component_tooltip, {
      "popup-visible": _ctx.popupVisible,
      position: _ctx.mergedTooltipPosition,
      content: _ctx.tooltipContent
    }, {
      default: vue.withCtx(() => [
        vue.createElementVNode("div", vue.mergeProps(_ctx.$attrs, {
          tabindex: "0",
          role: "slider",
          "aria-disabled": _ctx.disabled,
          "aria-valuemax": _ctx.max,
          "aria-valuemin": _ctx.min,
          "aria-valuenow": _ctx.value,
          "aria-valuetext": _ctx.tooltipContent,
          class: _ctx.cls,
          onMousedown: _cache[0] || (_cache[0] = (...args) => _ctx.handleMouseDown && _ctx.handleMouseDown(...args)),
          onClick: _cache[1] || (_cache[1] = vue.withModifiers(() => {
          }, ["stop"]))
        }), null, 16, _hoisted_1$h)
      ]),
      _: 1
    }, 8, ["popup-visible", "position", "content"]);
  }
  var SliderButton = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["render", _sfc_render$F]]);
  const getOffsetPercent = (value, [min, max]) => {
    const percent = Math.max((value - min) / (max - min), 0);
    return `${index.round(percent * 100, 2)}%`;
  };
  const getPositionStyle = (offset, direction) => {
    return direction === "vertical" ? { bottom: offset } : { left: offset };
  };
  const _sfc_main$F = vue.defineComponent({
    name: "SliderDots",
    props: {
      data: {
        type: Array,
        required: true
      },
      min: {
        type: Number,
        required: true
      },
      max: {
        type: Number,
        required: true
      },
      direction: {
        type: String,
        default: "horizontal"
      }
    },
    setup(props) {
      const prefixCls = getPrefixCls("slider");
      const getStyle2 = (value) => getPositionStyle(getOffsetPercent(value, [props.min, props.max]), props.direction);
      return {
        prefixCls,
        getStyle: getStyle2
      };
    }
  });
  function _sfc_render$E(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(`${_ctx.prefixCls}-dots`)
    }, [
      (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.data, (item, index2) => {
        return vue.openBlock(), vue.createElementBlock("div", {
          key: index2,
          class: vue.normalizeClass(`${_ctx.prefixCls}-dot-wrapper`),
          style: vue.normalizeStyle(_ctx.getStyle(item.key))
        }, [
          vue.createElementVNode("div", {
            class: vue.normalizeClass([
              `${_ctx.prefixCls}-dot`,
              { [`${_ctx.prefixCls}-dot-active`]: item.isActive }
            ])
          }, null, 2)
        ], 6);
      }), 128))
    ], 2);
  }
  var SliderDots = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["render", _sfc_render$E]]);
  const _sfc_main$E = vue.defineComponent({
    name: "SliderMarks",
    props: {
      data: {
        type: Array,
        required: true
      },
      min: {
        type: Number,
        required: true
      },
      max: {
        type: Number,
        required: true
      },
      direction: {
        type: String,
        default: "horizontal"
      }
    },
    setup(props) {
      const prefixCls = getPrefixCls("slider");
      const getStyle2 = (value) => getPositionStyle(getOffsetPercent(value, [props.min, props.max]), props.direction);
      return {
        prefixCls,
        getStyle: getStyle2
      };
    }
  });
  function _sfc_render$D(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(`${_ctx.prefixCls}-marks`)
    }, [
      (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.data, (item, index2) => {
        return vue.openBlock(), vue.createElementBlock("div", {
          key: index2,
          "aria-hidden": "true",
          class: vue.normalizeClass(`${_ctx.prefixCls}-mark`),
          style: vue.normalizeStyle(_ctx.getStyle(item.key))
        }, vue.toDisplayString(item.content), 7);
      }), 128))
    ], 2);
  }
  var SliderMarks = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["render", _sfc_render$D]]);
  const _sfc_main$D = vue.defineComponent({
    name: "SliderTicks",
    props: {
      value: {
        type: Array,
        required: true
      },
      step: {
        type: Number,
        required: true
      },
      min: {
        type: Number,
        required: true
      },
      max: {
        type: Number,
        required: true
      },
      direction: {
        type: String,
        default: "horizontal"
      }
    },
    setup(props) {
      const prefixCls = getPrefixCls("slider");
      const steps = vue.computed(() => {
        const steps2 = [];
        const stepsLength = Math.floor((props.max - props.min) / props.step);
        for (let i = 0; i <= stepsLength; i++) {
          const stepVal = index.plus(i * props.step, props.min);
          if (stepVal <= props.min || stepVal >= props.max)
            continue;
          steps2.push({
            key: stepVal,
            isActive: stepVal >= props.value[0] && stepVal <= props.value[1]
          });
        }
        return steps2;
      });
      const getStyle2 = (value) => getPositionStyle(getOffsetPercent(value, [props.min, props.max]), props.direction);
      return {
        prefixCls,
        steps,
        getStyle: getStyle2
      };
    }
  });
  function _sfc_render$C(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(`${_ctx.prefixCls}-ticks`)
    }, [
      (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.steps, (item, index2) => {
        return vue.openBlock(), vue.createElementBlock("div", {
          key: index2,
          class: vue.normalizeClass([
            `${_ctx.prefixCls}-tick`,
            { [`${_ctx.prefixCls}-tick-active`]: item.isActive }
          ]),
          style: vue.normalizeStyle(_ctx.getStyle(item.key))
        }, null, 6);
      }), 128))
    ], 2);
  }
  var SliderTicks = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["render", _sfc_render$C]]);
  const _sfc_main$C = vue.defineComponent({
    name: "SliderInput",
    components: {
      InputNumber
    },
    props: {
      modelValue: {
        type: Array,
        required: true
      },
      min: {
        type: Number
      },
      max: {
        type: Number
      },
      step: {
        type: Number
      },
      disabled: {
        type: Boolean
      },
      range: {
        type: Boolean
      }
    },
    emits: ["startChange", "endChange"],
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("slider");
      return {
        prefixCls
      };
    }
  });
  function _sfc_render$B(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_input_number = vue.resolveComponent("input-number");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(`${_ctx.prefixCls}-input`)
    }, [
      _ctx.range ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
        vue.createVNode(_component_input_number, {
          min: _ctx.min,
          max: _ctx.max,
          step: _ctx.step,
          disabled: _ctx.disabled,
          "model-value": _ctx.modelValue[0],
          "hide-button": "",
          onChange: _cache[0] || (_cache[0] = (value) => _ctx.$emit("startChange", value))
        }, null, 8, ["min", "max", "step", "disabled", "model-value"]),
        vue.createElementVNode("div", {
          class: vue.normalizeClass(`${_ctx.prefixCls}-input-hyphens`)
        }, null, 2)
      ], 64)) : vue.createCommentVNode("v-if", true),
      vue.createVNode(_component_input_number, {
        min: _ctx.min,
        max: _ctx.max,
        step: _ctx.step,
        disabled: _ctx.disabled,
        "model-value": _ctx.modelValue[1],
        "hide-button": "",
        onChange: _cache[1] || (_cache[1] = (value) => _ctx.$emit("endChange", value))
      }, null, 8, ["min", "max", "step", "disabled", "model-value"])
    ], 2);
  }
  var SliderInput = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["render", _sfc_render$B]]);
  const _sfc_main$B = vue.defineComponent({
    name: "Slider",
    components: {
      SliderButton,
      SliderDots,
      SliderMarks,
      SliderTicks,
      SliderInput
    },
    props: {
      modelValue: {
        type: [Number, Array],
        default: void 0
      },
      defaultValue: {
        type: [Number, Array],
        default: 0
      },
      step: {
        type: Number,
        default: 1
      },
      min: {
        type: Number,
        default: 0
      },
      marks: {
        type: Object
      },
      max: {
        type: Number,
        default: 100
      },
      direction: {
        type: String,
        default: "horizontal"
      },
      disabled: {
        type: Boolean,
        default: false
      },
      showTicks: {
        type: Boolean,
        default: false
      },
      showInput: {
        type: Boolean,
        default: false
      },
      range: {
        type: Boolean,
        default: false
      },
      formatTooltip: {
        type: Function
      },
      showTooltip: {
        type: Boolean,
        default: true
      }
    },
    emits: {
      "update:modelValue": (value) => true,
      "change": (value) => true
    },
    setup(props, { emit }) {
      const { modelValue } = vue.toRefs(props);
      const prefixCls = getPrefixCls("slider");
      const { mergedDisabled, eventHandlers } = useFormItem({
        disabled: vue.toRef(props, "disabled")
      });
      const trackRef = vue.ref(null);
      const trackRect = vue.ref();
      const defaultValue = props.modelValue ? props.modelValue : props.defaultValue;
      const startValue = vue.ref(isArray$1(defaultValue) ? defaultValue[0] : 0);
      const endValue = vue.ref(isArray$1(defaultValue) ? defaultValue[1] : defaultValue);
      vue.watch(modelValue, (value) => {
        var _a, _b, _c, _d, _e;
        if (isArray$1(value)) {
          startValue.value = (_b = (_a = value[0]) != null ? _a : props.min) != null ? _b : 0;
          endValue.value = (_d = (_c = value[1]) != null ? _c : props.min) != null ? _d : 0;
        } else {
          endValue.value = (_e = value != null ? value : props.min) != null ? _e : 0;
        }
      });
      const handleChange = () => {
        var _a, _b;
        if (props.range) {
          emit("update:modelValue", [startValue.value, endValue.value]);
          emit("change", [startValue.value, endValue.value]);
        } else {
          emit("update:modelValue", endValue.value);
          emit("change", endValue.value);
        }
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a);
      };
      const handleStartChange = (value) => {
        value = value != null ? value : props.min;
        startValue.value = value;
        handleChange();
      };
      const handleEndChange = (value) => {
        value = value != null ? value : props.min;
        endValue.value = value;
        handleChange();
      };
      const computedValue = vue.computed(() => {
        var _a, _b, _c;
        if (props.range) {
          if (isArray$1(props.modelValue)) {
            return props.modelValue;
          }
          return [startValue.value, (_a = props.modelValue) != null ? _a : endValue.value];
        }
        if (isUndefined(props.modelValue)) {
          return [startValue.value, endValue.value];
        }
        if (isArray$1(props.modelValue)) {
          return [(_b = props.min) != null ? _b : 0, props.modelValue[1]];
        }
        return [(_c = props.min) != null ? _c : 0, props.modelValue];
      });
      const markList = vue.computed(() => Object.keys(props.marks || {}).map((index2) => {
        var _a;
        const key = Number(index2);
        return {
          key,
          content: (_a = props.marks) == null ? void 0 : _a[key],
          isActive: key >= computedValue.value[0] && key <= computedValue.value[1]
        };
      }));
      const getBtnStyle = (value) => getPositionStyle(getOffsetPercent(value, [props.min, props.max]), props.direction);
      const isDragging = vue.ref(false);
      const handleMoveStart = () => {
        isDragging.value = true;
        if (trackRef.value) {
          trackRect.value = trackRef.value.getBoundingClientRect();
        }
      };
      function getValueByCoords(x, y) {
        if (!trackRect.value) {
          return 0;
        }
        const { left, top, width, height } = trackRect.value;
        const trackLength = props.direction === "horizontal" ? width : height;
        const stepLength = trackLength * props.step / (props.max - props.min);
        let diff = props.direction === "horizontal" ? x - left : top + height - y;
        if (diff < 0)
          diff = 0;
        if (diff > trackLength)
          diff = trackLength;
        const steps = Math.round(diff / stepLength);
        return index.plus(props.min, index.times(steps, props.step));
      }
      const handleEndMoving = (x, y) => {
        endValue.value = getValueByCoords(x, y);
        handleChange();
      };
      const handleClick = (e2) => {
        if (mergedDisabled.value) {
          return;
        }
        const { clientX, clientY } = e2;
        if (trackRef.value) {
          trackRect.value = trackRef.value.getBoundingClientRect();
        }
        endValue.value = getValueByCoords(clientX, clientY);
        handleChange();
      };
      function getBarStyle([start, end]) {
        if (start > end) {
          [start, end] = [end, start];
        }
        return props.direction === "vertical" ? {
          bottom: getOffsetPercent(start, [props.min, props.max]),
          top: getOffsetPercent(props.max + props.min - end, [
            props.min,
            props.max
          ])
        } : {
          left: getOffsetPercent(start, [props.min, props.max]),
          right: getOffsetPercent(props.max + props.min - end, [
            props.min,
            props.max
          ])
        };
      }
      const handleStartMoving = (x, y) => {
        startValue.value = getValueByCoords(x, y);
        handleChange();
      };
      const handleMoveEnd = () => {
        isDragging.value = false;
      };
      const cls = vue.computed(() => [
        prefixCls,
        {
          [`${prefixCls}-vertical`]: props.direction === "vertical",
          [`${prefixCls}-with-marks`]: Boolean(props.marks)
        }
      ]);
      const trackCls = vue.computed(() => [
        `${prefixCls}-track`,
        {
          [`${prefixCls}-track-disabled`]: mergedDisabled.value,
          [`${prefixCls}-track-vertical`]: props.direction === "vertical"
        }
      ]);
      return {
        prefixCls,
        cls,
        trackCls,
        trackRef,
        computedValue,
        mergedDisabled,
        markList,
        getBtnStyle,
        getBarStyle,
        handleClick,
        handleMoveStart,
        handleEndMoving,
        handleMoveEnd,
        handleStartMoving,
        handleStartChange,
        handleEndChange
      };
    }
  });
  function _sfc_render$A(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_slider_ticks = vue.resolveComponent("slider-ticks");
    const _component_slider_dots = vue.resolveComponent("slider-dots");
    const _component_slider_marks = vue.resolveComponent("slider-marks");
    const _component_slider_button = vue.resolveComponent("slider-button");
    const _component_slider_input = vue.resolveComponent("slider-input");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.cls)
    }, [
      vue.createElementVNode("div", {
        ref: "trackRef",
        class: vue.normalizeClass(_ctx.trackCls),
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
      }, [
        vue.createElementVNode("div", {
          class: vue.normalizeClass(`${_ctx.prefixCls}-bar`),
          style: vue.normalizeStyle(_ctx.getBarStyle(_ctx.computedValue))
        }, null, 6),
        _ctx.showTicks ? (vue.openBlock(), vue.createBlock(_component_slider_ticks, {
          key: 0,
          value: _ctx.computedValue,
          step: _ctx.step,
          min: _ctx.min,
          max: _ctx.max,
          direction: _ctx.direction
        }, null, 8, ["value", "step", "min", "max", "direction"])) : vue.createCommentVNode("v-if", true),
        _ctx.marks ? (vue.openBlock(), vue.createBlock(_component_slider_dots, {
          key: 1,
          data: _ctx.markList,
          min: _ctx.min,
          max: _ctx.max,
          direction: _ctx.direction
        }, null, 8, ["data", "min", "max", "direction"])) : vue.createCommentVNode("v-if", true),
        _ctx.marks ? (vue.openBlock(), vue.createBlock(_component_slider_marks, {
          key: 2,
          data: _ctx.markList,
          min: _ctx.min,
          max: _ctx.max,
          direction: _ctx.direction
        }, null, 8, ["data", "min", "max", "direction"])) : vue.createCommentVNode("v-if", true),
        _ctx.range ? (vue.openBlock(), vue.createBlock(_component_slider_button, {
          key: 3,
          style: vue.normalizeStyle(_ctx.getBtnStyle(_ctx.computedValue[0])),
          value: _ctx.computedValue[0],
          direction: _ctx.direction,
          disabled: _ctx.mergedDisabled,
          min: _ctx.min,
          max: _ctx.max,
          "format-tooltip": _ctx.formatTooltip,
          "show-tooltip": _ctx.showTooltip,
          onMovestart: _ctx.handleMoveStart,
          onMoving: _ctx.handleStartMoving,
          onMoveend: _ctx.handleMoveEnd
        }, null, 8, ["style", "value", "direction", "disabled", "min", "max", "format-tooltip", "show-tooltip", "onMovestart", "onMoving", "onMoveend"])) : vue.createCommentVNode("v-if", true),
        vue.createVNode(_component_slider_button, {
          style: vue.normalizeStyle(_ctx.getBtnStyle(_ctx.computedValue[1])),
          value: _ctx.computedValue[1],
          direction: _ctx.direction,
          disabled: _ctx.mergedDisabled,
          min: _ctx.min,
          max: _ctx.max,
          "format-tooltip": _ctx.formatTooltip,
          "show-tooltip": _ctx.showTooltip,
          onMovestart: _ctx.handleMoveStart,
          onMoving: _ctx.handleEndMoving,
          onMoveend: _ctx.handleMoveEnd
        }, null, 8, ["style", "value", "direction", "disabled", "min", "max", "format-tooltip", "show-tooltip", "onMovestart", "onMoving", "onMoveend"])
      ], 2),
      _ctx.showInput ? (vue.openBlock(), vue.createBlock(_component_slider_input, {
        key: 0,
        "model-value": _ctx.computedValue,
        min: _ctx.min,
        max: _ctx.max,
        step: _ctx.step,
        range: _ctx.range,
        disabled: _ctx.disabled,
        onStartChange: _ctx.handleStartChange,
        onEndChange: _ctx.handleEndChange
      }, null, 8, ["model-value", "min", "max", "step", "range", "disabled", "onStartChange", "onEndChange"])) : vue.createCommentVNode("v-if", true)
    ], 2);
  }
  var _Slider = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["render", _sfc_render$A]]);
  const Slider = Object.assign(_Slider, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Slider.name, _Slider);
    }
  });
  var _Space = vue.defineComponent({
    name: "Space",
    props: {
      align: {
        type: String
      },
      direction: {
        type: String,
        default: "horizontal"
      },
      size: {
        type: [Number, String, Array],
        default: "small"
      },
      wrap: {
        type: Boolean
      },
      fill: {
        type: Boolean
      }
    },
    setup(props, {
      slots
    }) {
      const prefixCls = getPrefixCls("space");
      const mergedAlign = vue.computed(() => {
        var _a;
        return (_a = props.align) != null ? _a : props.direction === "horizontal" ? "center" : "";
      });
      const cls = vue.computed(() => [prefixCls, {
        [`${prefixCls}-${props.direction}`]: props.direction,
        [`${prefixCls}-align-${mergedAlign.value}`]: mergedAlign.value,
        [`${prefixCls}-wrap`]: props.wrap,
        [`${prefixCls}-fill`]: props.fill
      }]);
      function getMargin(size) {
        if (isNumber$1(size)) {
          return size;
        }
        switch (size) {
          case "mini":
            return 4;
          case "small":
            return 8;
          case "medium":
            return 16;
          case "large":
            return 24;
          default:
            return 8;
        }
      }
      const getMarginStyle = (isLast) => {
        const style = {};
        const marginRight = `${getMargin(isArray$1(props.size) ? props.size[0] : props.size)}px`;
        const marginBottom = `${getMargin(isArray$1(props.size) ? props.size[1] : props.size)}px`;
        if (isLast) {
          return props.wrap ? {
            marginBottom
          } : {};
        }
        if (props.direction === "horizontal") {
          style.marginRight = marginRight;
        }
        if (props.direction === "vertical" || props.wrap) {
          style.marginBottom = marginBottom;
        }
        return style;
      };
      return () => {
        var _a;
        const children = getAllElements((_a = slots.default) == null ? void 0 : _a.call(slots), true).filter((item) => item.type !== vue.Comment);
        return vue.createVNode("div", {
          "class": cls.value
        }, [children.map((child, index2) => {
          var _a2, _b;
          const shouldRenderSplit = slots.split && index2 > 0;
          return vue.createVNode(vue.Fragment, {
            "key": (_a2 = child.key) != null ? _a2 : `item-${index2}`
          }, [shouldRenderSplit && vue.createVNode("div", {
            "class": `${prefixCls}-item-split`,
            "style": getMarginStyle(false)
          }, [(_b = slots.split) == null ? void 0 : _b.call(slots)]), vue.createVNode("div", {
            "class": `${prefixCls}-item`,
            "style": getMarginStyle(index2 === children.length - 1)
          }, [child])]);
        })]);
      };
    }
  });
  const Space = Object.assign(_Space, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Space.name, _Space);
    }
  });
  function getSizeConfig(size) {
    const numberSize = isString$1(size) ? parseFloat(size) : size;
    let unit = "";
    if (isNumber$1(size) || String(numberSize) === size) {
      unit = numberSize > 1 ? "px" : "%";
    } else {
      unit = "px";
    }
    return {
      size: numberSize,
      unit,
      isPx: unit === "px"
    };
  }
  function getPxSize({
    size,
    defaultSize,
    containerSize
  }) {
    const config = getSizeConfig(size != null ? size : defaultSize);
    if (config.isPx) {
      return config.size;
    }
    return config.size * containerSize;
  }
  function px2percent(numerator, denominator) {
    return parseFloat(numerator) / parseFloat(denominator);
  }
  const _sfc_main$A = vue.defineComponent({
    name: "Split",
    components: {
      ResizeTrigger
    },
    props: {
      component: {
        type: String,
        default: "div"
      },
      direction: {
        type: String,
        default: "horizontal"
      },
      size: {
        type: [Number, String],
        default: void 0
      },
      defaultSize: {
        type: [Number, String],
        default: 0.5
      },
      min: {
        type: [Number, String]
      },
      max: {
        type: [Number, String]
      },
      disabled: {
        type: Boolean,
        default: false
      }
    },
    emits: {
      "moveStart": (ev) => true,
      "moving": (ev) => true,
      "moveEnd": (ev) => true,
      "update:size": (size) => true
    },
    setup(props, { emit }) {
      const { direction, size: propSize, defaultSize, min, max } = vue.toRefs(props);
      const triggerSize = vue.ref(0);
      const wrapperRef = vue.ref();
      const prefixCls = getPrefixCls("split");
      const [size, setSize] = useMergeState(defaultSize.value, vue.reactive({
        value: propSize
      }));
      const sizeConfig = vue.computed(() => getSizeConfig(size.value));
      const isHorizontal2 = vue.computed(() => direction.value === "horizontal");
      const classNames = vue.computed(() => [
        prefixCls,
        {
          [`${prefixCls}-horizontal`]: isHorizontal2.value,
          [`${prefixCls}-vertical`]: !isHorizontal2.value
        }
      ]);
      const firstPaneStyles = vue.computed(() => {
        const { size: numberSize, unit, isPx } = sizeConfig.value;
        const baseVal = isPx ? numberSize : numberSize * 100;
        return {
          flex: `0 0 calc(${baseVal}${unit} - ${triggerSize.value / 2}px)`
        };
      });
      const record = {
        startPageX: 0,
        startPageY: 0,
        startContainerSize: 0,
        startSize: 0
      };
      async function getContainerSize() {
        const getSize = () => {
          var _a, _b;
          return isHorizontal2.value ? (_a = wrapperRef.value) == null ? void 0 : _a.clientWidth : ((_b = wrapperRef.value) == null ? void 0 : _b.clientHeight) || 0;
        };
        if (!wrapperRef.value || getSize()) {
          await vue.nextTick();
        }
        return getSize();
      }
      function updateSize(newPxSize, containerSize) {
        if (!containerSize) {
          return;
        }
        const newSize = sizeConfig.value.isPx ? `${newPxSize}px` : px2percent(newPxSize, containerSize);
        if (size.value === newSize)
          return;
        setSize(newSize);
        emit("update:size", newSize);
      }
      function getLegalPxSize(size2, containerSize) {
        const pxSize = getPxSize({
          size: size2,
          containerSize
        });
        const minPxSize = getPxSize({
          size: min.value,
          defaultSize: "0px",
          containerSize
        });
        const maxPxSize = getPxSize({
          size: max.value,
          defaultSize: `${containerSize}px`,
          containerSize
        });
        let legalPxSize = pxSize;
        legalPxSize = Math.max(legalPxSize, minPxSize);
        legalPxSize = Math.min(legalPxSize, maxPxSize);
        return legalPxSize;
      }
      function getNewPxSize({
        startContainerSize,
        startSize,
        startPosition,
        endPosition
      }) {
        const startPxSize = getPxSize({
          size: startSize,
          containerSize: startContainerSize
        });
        return getLegalPxSize(`${startPxSize + (endPosition - startPosition)}px`, startContainerSize);
      }
      function onMoving(e2) {
        emit("moving", e2);
        const newPxSize = isHorizontal2.value ? getNewPxSize({
          startContainerSize: record.startContainerSize,
          startSize: record.startSize,
          startPosition: record.startPageX,
          endPosition: e2.pageX
        }) : getNewPxSize({
          startContainerSize: record.startContainerSize,
          startSize: record.startSize,
          startPosition: record.startPageY,
          endPosition: e2.pageY
        });
        updateSize(newPxSize, record.startContainerSize);
      }
      function onMovingEnd(e2) {
        off(window, "mousemove", onMoving);
        off(window, "mouseup", onMovingEnd);
        off(window, "contextmenu", onMovingEnd);
        document.body.style.cursor = "default";
        emit("moveEnd", e2);
      }
      async function onMoveStart(e2) {
        emit("moveStart", e2);
        record.startPageX = e2.pageX;
        record.startPageY = e2.pageY;
        record.startContainerSize = await getContainerSize();
        record.startSize = size.value;
        on(window, "mousemove", onMoving);
        on(window, "mouseup", onMovingEnd);
        on(window, "contextmenu", onMovingEnd);
        document.body.style.cursor = isHorizontal2.value ? "col-resize" : "row-resize";
      }
      function onTriggerResize(entry) {
        const { width, height } = entry.contentRect;
        triggerSize.value = isHorizontal2.value ? width : height;
      }
      vue.onMounted(async () => {
        const containerSize = await getContainerSize();
        const fixedPxSize = getLegalPxSize(size.value, containerSize);
        updateSize(fixedPxSize, containerSize);
      });
      return {
        prefixCls,
        classNames,
        isHorizontal: isHorizontal2,
        wrapperRef,
        onMoveStart,
        onTriggerResize,
        firstPaneStyles
      };
    }
  });
  function _sfc_render$z(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_ResizeTrigger = vue.resolveComponent("ResizeTrigger");
    return vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.component), {
      ref: "wrapperRef",
      class: vue.normalizeClass(_ctx.classNames)
    }, {
      default: vue.withCtx(() => [
        vue.createElementVNode("div", {
          class: vue.normalizeClass([`${_ctx.prefixCls}-pane`, `${_ctx.prefixCls}-pane-first`]),
          style: vue.normalizeStyle(_ctx.firstPaneStyles)
        }, [
          vue.renderSlot(_ctx.$slots, "first")
        ], 6),
        !_ctx.disabled ? (vue.openBlock(), vue.createBlock(_component_ResizeTrigger, {
          key: 0,
          "prefix-cls": `${_ctx.prefixCls}-trigger`,
          direction: _ctx.isHorizontal ? "vertical" : "horizontal",
          onMousedown: _ctx.onMoveStart,
          onResize: _ctx.onTriggerResize
        }, {
          default: vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "resize-trigger")
          ]),
          icon: vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "resize-trigger-icon")
          ]),
          _: 3
        }, 8, ["prefix-cls", "direction", "onMousedown", "onResize"])) : vue.createCommentVNode("v-if", true),
        vue.createElementVNode("div", {
          class: vue.normalizeClass([`${_ctx.prefixCls}-pane`, `${_ctx.prefixCls}-pane-second`])
        }, [
          vue.renderSlot(_ctx.$slots, "second")
        ], 2)
      ]),
      _: 3
    }, 8, ["class"]);
  }
  var _Split = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["render", _sfc_render$z]]);
  const Split = Object.assign(_Split, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Split.name, _Split);
    }
  });
  const _sfc_main$z = vue.defineComponent({
    name: "Statistic",
    props: {
      title: String,
      value: {
        type: [Number, Object]
      },
      format: {
        type: String,
        default: "HH:mm:ss"
      },
      extra: String,
      start: {
        type: Boolean,
        default: true
      },
      precision: {
        type: Number,
        default: 0
      },
      separator: String,
      showGroupSeparator: {
        type: Boolean,
        default: false
      },
      animation: {
        type: Boolean,
        default: false
      },
      animationDuration: {
        type: Number,
        default: 2e3
      },
      valueFrom: {
        type: Number,
        default: void 0
      },
      placeholder: {
        type: String
      },
      valueStyle: {
        type: Object
      }
    },
    setup(props) {
      var _a;
      const prefixCls = getPrefixCls("statistic");
      const numberValue = vue.computed(() => {
        if (isNumber$1(props.value)) {
          return props.value;
        }
        return 0;
      });
      const innerValue = vue.ref((_a = props.valueFrom) != null ? _a : props.value);
      const tween = vue.ref(null);
      const { value } = vue.toRefs(props);
      const showPlaceholder = vue.computed(() => isUndefined(props.value));
      const animation = (from = ((_b) => (_b = props.valueFrom) != null ? _b : 0)(), to = numberValue.value) => {
        var _a2;
        if (from !== to) {
          tween.value = new Tween({
            from: {
              value: from
            },
            to: {
              value: to
            },
            duration: props.animationDuration,
            easing: "quartOut",
            onUpdate: (keys) => {
              innerValue.value = keys.value;
            },
            onFinish: () => {
              innerValue.value = to;
            }
          });
          (_a2 = tween.value) == null ? void 0 : _a2.start();
        }
      };
      const formatValue = vue.computed(() => {
        let _value = innerValue.value;
        if (isNumber$1(_value)) {
          if (isNumber$1(props.precision)) {
            _value = index.round(_value, props.precision).toFixed(props.precision);
          }
          const splitValue = String(_value).split(".");
          const integer = props.showGroupSeparator ? Number(splitValue[0]).toLocaleString("en-US") : splitValue[0];
          const decimal = splitValue[1];
          return {
            isNumber: true,
            integer,
            decimal
          };
        }
        if (props.format) {
          _value = dayjs$1(_value).format(props.format);
        }
        return {
          isNumber: false,
          value: _value
        };
      });
      vue.onMounted(() => {
        if (props.animation && props.start) {
          animation();
        }
      });
      vue.watch(() => props.start, (value2) => {
        if (value2 && props.animation && !tween.value) {
          animation();
        }
      });
      vue.watch(value, (value2) => {
        var _a2;
        if (tween.value) {
          (_a2 = tween.value) == null ? void 0 : _a2.stop();
          tween.value = null;
        }
        innerValue.value = value2;
        if (props.animation && props.start) {
          animation();
        }
      });
      return {
        prefixCls,
        showPlaceholder,
        formatValue
      };
    }
  });
  const _hoisted_1$g = { key: 0 };
  function _sfc_render$y(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.prefixCls)
    }, [
      _ctx.title || _ctx.$slots.title ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: vue.normalizeClass(`${_ctx.prefixCls}-title`)
      }, [
        vue.renderSlot(_ctx.$slots, "title", {}, () => [
          vue.createTextVNode(vue.toDisplayString(_ctx.title), 1)
        ])
      ], 2)) : vue.createCommentVNode("v-if", true),
      vue.createElementVNode("div", {
        class: vue.normalizeClass(`${_ctx.prefixCls}-content`)
      }, [
        vue.createElementVNode("div", {
          class: vue.normalizeClass(`${_ctx.prefixCls}-value`),
          style: vue.normalizeStyle(_ctx.valueStyle)
        }, [
          _ctx.showPlaceholder ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_1$g, vue.toDisplayString(_ctx.placeholder), 1)) : (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 1 }, [
            _ctx.$slots.prefix ? (vue.openBlock(), vue.createElementBlock("span", {
              key: 0,
              class: vue.normalizeClass(`${_ctx.prefixCls}-prefix`)
            }, [
              vue.renderSlot(_ctx.$slots, "prefix")
            ], 2)) : vue.createCommentVNode("v-if", true),
            _ctx.formatValue.isNumber ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 1 }, [
              vue.createElementVNode("span", {
                class: vue.normalizeClass(`${_ctx.prefixCls}-value-integer`)
              }, vue.toDisplayString(_ctx.formatValue.integer), 3),
              _ctx.formatValue.decimal ? (vue.openBlock(), vue.createElementBlock("span", {
                key: 0,
                class: vue.normalizeClass(`${_ctx.prefixCls}-value-decimal`)
              }, " ." + vue.toDisplayString(_ctx.formatValue.decimal), 3)) : vue.createCommentVNode("v-if", true)
            ], 64)) : (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 2 }, [
              vue.createTextVNode(vue.toDisplayString(_ctx.formatValue.value), 1)
            ], 2112)),
            _ctx.$slots.suffix ? (vue.openBlock(), vue.createElementBlock("span", {
              key: 3,
              class: vue.normalizeClass(`${_ctx.prefixCls}-suffix`)
            }, [
              vue.renderSlot(_ctx.$slots, "suffix")
            ], 2)) : vue.createCommentVNode("v-if", true)
          ], 64))
        ], 6),
        _ctx.extra || _ctx.$slots.extra ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 0,
          class: vue.normalizeClass(`${_ctx.prefixCls}-extra`)
        }, [
          vue.renderSlot(_ctx.$slots, "extra", {}, () => [
            vue.createTextVNode(vue.toDisplayString(_ctx.extra), 1)
          ])
        ], 2)) : vue.createCommentVNode("v-if", true)
      ], 2)
    ], 2);
  }
  var _Statistic = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["render", _sfc_render$y]]);
  const units = [
    ["Y", 1e3 * 60 * 60 * 24 * 365],
    ["M", 1e3 * 60 * 60 * 24 * 30],
    ["D", 1e3 * 60 * 60 * 24],
    ["H", 1e3 * 60 * 60],
    ["m", 1e3 * 60],
    ["s", 1e3],
    ["S", 1]
  ];
  function getDateString(millisecond, format) {
    let leftMillisecond = millisecond;
    return units.reduce((current, [name, unit]) => {
      if (current.indexOf(name) !== -1) {
        const value = Math.floor(leftMillisecond / unit);
        leftMillisecond -= value * unit;
        return current.replace(new RegExp(`${name}+`, "g"), (match) => {
          const len = match.length;
          return String(value).padStart(len, "0");
        });
      }
      return current;
    }, format);
  }
  const _sfc_main$y = vue.defineComponent({
    name: "Countdown",
    props: {
      title: String,
      value: {
        type: Number,
        default: () => Date.now() + 3e5
      },
      now: {
        type: Number,
        default: () => Date.now()
      },
      format: {
        type: String,
        default: "HH:mm:ss"
      },
      start: {
        type: Boolean,
        default: true
      },
      valueStyle: {
        type: Object
      }
    },
    emits: {
      finish: () => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("statistic");
      const { start, value, now, format } = vue.toRefs(props);
      const displayValue = vue.ref(getDateString(Math.max(dayjs$1(props.value).diff(dayjs$1(props.now), "millisecond"), 0), props.format));
      vue.watch([value, now, format], () => {
        const _value = getDateString(Math.max(dayjs$1(props.value).diff(dayjs$1(props.now), "millisecond"), 0), props.format);
        if (_value !== displayValue.value) {
          displayValue.value = _value;
        }
      });
      const timer = vue.ref(0);
      const stopTimer = () => {
        if (timer.value) {
          window.clearInterval(timer.value);
          timer.value = 0;
        }
      };
      const startTimer = () => {
        if (dayjs$1(props.value).valueOf() < Date.now()) {
          return;
        }
        timer.value = window.setInterval(() => {
          const _value = dayjs$1(props.value).diff(dayjs$1(), "millisecond");
          if (_value <= 0) {
            stopTimer();
            emit("finish");
          }
          displayValue.value = getDateString(Math.max(_value, 0), props.format);
        }, 1e3 / 30);
      };
      vue.onMounted(() => {
        if (props.start) {
          startTimer();
        }
      });
      vue.onBeforeUnmount(() => {
        stopTimer();
      });
      vue.watch(start, (value2) => {
        if (value2 && !timer.value) {
          startTimer();
        }
      });
      return {
        prefixCls,
        displayValue
      };
    }
  });
  function _sfc_render$x(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass([`${_ctx.prefixCls}`, `${_ctx.prefixCls}-countdown`])
    }, [
      _ctx.title || _ctx.$slots.title ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: vue.normalizeClass(`${_ctx.prefixCls}-title`)
      }, [
        vue.renderSlot(_ctx.$slots, "title", {}, () => [
          vue.createTextVNode(vue.toDisplayString(_ctx.title), 1)
        ])
      ], 2)) : vue.createCommentVNode("v-if", true),
      vue.createElementVNode("div", {
        class: vue.normalizeClass(`${_ctx.prefixCls}-content`)
      }, [
        vue.createElementVNode("div", {
          class: vue.normalizeClass(`${_ctx.prefixCls}-value`),
          style: vue.normalizeStyle(_ctx.valueStyle)
        }, vue.toDisplayString(_ctx.displayValue), 7)
      ], 2)
    ], 2);
  }
  var Countdown = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["render", _sfc_render$x]]);
  const Statistic = Object.assign(_Statistic, {
    Countdown,
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Statistic.name, _Statistic);
      app.component(componentPrefix + Countdown.name, Countdown);
    }
  });
  const stepsInjectionKey = Symbol("ArcoSteps");
  const _sfc_main$x = vue.defineComponent({
    name: "Steps",
    props: {
      type: {
        type: String,
        default: "default"
      },
      direction: {
        type: String,
        default: "horizontal"
      },
      labelPlacement: {
        type: String,
        default: "horizontal"
      },
      current: {
        type: Number,
        default: void 0
      },
      defaultCurrent: {
        type: Number,
        default: 1
      },
      status: {
        type: String,
        default: "process"
      },
      lineLess: {
        type: Boolean,
        default: false
      },
      small: {
        type: Boolean,
        default: false
      },
      changeable: {
        type: Boolean,
        default: false
      }
    },
    emits: {
      "update:current": (step) => true,
      "change": (step, ev) => true
    },
    setup(props, { emit, slots }) {
      const { type, lineLess } = vue.toRefs(props);
      const prefixCls = getPrefixCls("steps");
      const _current = vue.ref(props.defaultCurrent);
      const computedCurrent = vue.computed(() => {
        var _a;
        return (_a = props.current) != null ? _a : _current.value;
      });
      const direction = vue.computed(() => ["navigation", "arrow"].includes(props.type) ? "horizontal" : props.direction);
      const labelPlacement = vue.computed(() => {
        if (props.type === "dot") {
          return direction.value === "vertical" ? "horizontal" : "vertical";
        }
        if (props.type === "navigation") {
          return "horizontal";
        }
        return props.labelPlacement;
      });
      const getStatus = (step) => {
        if (step < computedCurrent.value) {
          return "finish";
        }
        if (step > computedCurrent.value) {
          return "wait";
        }
        return props.status;
      };
      const handleClick = (step, e2) => {
        if (props.changeable) {
          _current.value = step;
          emit("update:current", step);
          emit("change", step, e2);
        }
      };
      const stepMap = vue.reactive(new Map());
      const errorSteps = vue.computed(() => Array.from(stepMap.values()).filter((item) => item.status === "error").map((item) => item.step));
      const addItem = (step, data) => {
        stepMap.set(step, data);
      };
      const removeItem = (step) => {
        stepMap.delete(step);
      };
      const cls = vue.computed(() => [
        prefixCls,
        `${prefixCls}-${direction.value}`,
        `${prefixCls}-label-${labelPlacement.value}`,
        `${prefixCls}-mode-${type.value}`,
        {
          [`${prefixCls}-changeable`]: props.changeable,
          [`${prefixCls}-size-small`]: props.small && props.type !== "dot",
          [`${prefixCls}-line-less`]: lineLess.value
        }
      ]);
      vue.provide(stepsInjectionKey, vue.reactive({
        type,
        direction,
        labelPlacement,
        lineLess,
        current: computedCurrent,
        errorSteps,
        getStatus,
        addItem,
        removeItem,
        onClick: handleClick,
        parentCls: prefixCls
      }));
      return {
        cls
      };
    }
  });
  function _sfc_render$w(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.cls)
    }, [
      vue.renderSlot(_ctx.$slots, "default")
    ], 2);
  }
  var _Steps = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["render", _sfc_render$w]]);
  const _sfc_main$w = vue.defineComponent({
    name: "Step",
    components: {
      IconCheck,
      IconClose
    },
    props: {
      title: String,
      description: String,
      status: {
        type: String
      },
      disabled: {
        type: Boolean,
        default: false
      }
    },
    setup(props) {
      const prefixCls = getPrefixCls("steps-item");
      const instance = vue.getCurrentInstance();
      const iconCls = getPrefixCls("steps-icon");
      const stepsCtx = vue.inject(stepsInjectionKey, void 0);
      const type = vue.computed(() => {
        var _a;
        return (_a = stepsCtx == null ? void 0 : stepsCtx.type) != null ? _a : "default";
      });
      const itemRef = vue.ref();
      const { computedIndex } = useIndex({
        itemRef,
        selector: `.${prefixCls}`,
        parentClassName: stepsCtx == null ? void 0 : stepsCtx.parentCls
      });
      const stepNumber = vue.computed(() => computedIndex.value + 1);
      const computedStatus = vue.computed(() => {
        var _a, _b;
        return (_b = (_a = props.status) != null ? _a : stepsCtx == null ? void 0 : stepsCtx.getStatus(stepNumber.value)) != null ? _b : "process";
      });
      const nextStepError = vue.computed(() => {
        var _a;
        return (_a = stepsCtx == null ? void 0 : stepsCtx.errorSteps.includes(stepNumber.value + 1)) != null ? _a : false;
      });
      if (instance) {
        stepsCtx == null ? void 0 : stepsCtx.addItem(instance.uid, vue.reactive({
          step: stepNumber,
          status: computedStatus
        }));
      }
      vue.onBeforeUnmount(() => {
        if (instance) {
          stepsCtx == null ? void 0 : stepsCtx.removeItem(instance.uid);
        }
      });
      const showTail = vue.computed(() => !(stepsCtx == null ? void 0 : stepsCtx.lineLess) && ((stepsCtx == null ? void 0 : stepsCtx.labelPlacement) === "vertical" || (stepsCtx == null ? void 0 : stepsCtx.direction) === "vertical"));
      const handleClick = (ev) => {
        if (!props.disabled) {
          stepsCtx == null ? void 0 : stepsCtx.onClick(stepNumber.value, ev);
        }
      };
      const cls = vue.computed(() => [
        prefixCls,
        `${prefixCls}-${computedStatus.value}`,
        {
          [`${prefixCls}-active`]: stepNumber.value === (stepsCtx == null ? void 0 : stepsCtx.current),
          [`${prefixCls}-next-error`]: nextStepError.value,
          [`${prefixCls}-disabled`]: props.disabled
        }
      ]);
      return {
        prefixCls,
        iconCls,
        cls,
        itemRef,
        showTail,
        stepNumber,
        computedStatus,
        type,
        handleClick
      };
    }
  });
  function _sfc_render$v(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_icon_check = vue.resolveComponent("icon-check");
    const _component_icon_close = vue.resolveComponent("icon-close");
    return vue.openBlock(), vue.createElementBlock("div", {
      ref: "itemRef",
      class: vue.normalizeClass(_ctx.cls),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    }, [
      _ctx.showTail ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: vue.normalizeClass(`${_ctx.prefixCls}-tail`)
      }, null, 2)) : vue.createCommentVNode("v-if", true),
      _ctx.type !== "arrow" ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 1,
        class: vue.normalizeClass(`${_ctx.prefixCls}-node`)
      }, [
        vue.renderSlot(_ctx.$slots, "node", {
          step: _ctx.stepNumber,
          status: _ctx.computedStatus
        }, () => [
          _ctx.type !== "dot" ? (vue.openBlock(), vue.createElementBlock("div", {
            key: 0,
            class: vue.normalizeClass(_ctx.iconCls)
          }, [
            vue.renderSlot(_ctx.$slots, "icon", {
              step: _ctx.stepNumber,
              status: _ctx.computedStatus
            }, () => [
              _ctx.computedStatus === "finish" ? (vue.openBlock(), vue.createBlock(_component_icon_check, { key: 0 })) : _ctx.computedStatus === "error" ? (vue.openBlock(), vue.createBlock(_component_icon_close, { key: 1 })) : (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 2 }, [
                vue.createTextVNode(vue.toDisplayString(_ctx.stepNumber), 1)
              ], 2112))
            ])
          ], 2)) : vue.createCommentVNode("v-if", true)
        ])
      ], 2)) : vue.createCommentVNode("v-if", true),
      vue.createElementVNode("div", {
        class: vue.normalizeClass(`${_ctx.prefixCls}-content`)
      }, [
        vue.createElementVNode("div", {
          class: vue.normalizeClass(`${_ctx.prefixCls}-title`)
        }, [
          vue.renderSlot(_ctx.$slots, "default", {}, () => [
            vue.createTextVNode(vue.toDisplayString(_ctx.title), 1)
          ])
        ], 2),
        _ctx.description || _ctx.$slots.description ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 0,
          class: vue.normalizeClass(`${_ctx.prefixCls}-description`)
        }, [
          vue.renderSlot(_ctx.$slots, "description", {}, () => [
            vue.createTextVNode(vue.toDisplayString(_ctx.description), 1)
          ])
        ], 2)) : vue.createCommentVNode("v-if", true)
      ], 2)
    ], 2);
  }
  var Step = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["render", _sfc_render$v]]);
  const Steps = Object.assign(_Steps, {
    Step,
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Steps.name, _Steps);
      app.component(componentPrefix + Step.name, Step);
    }
  });
  const _sfc_main$v = vue.defineComponent({
    name: "Switch",
    components: {
      IconLoading
    },
    props: {
      modelValue: {
        type: [String, Number, Boolean],
        default: void 0
      },
      defaultChecked: {
        type: Boolean,
        default: false
      },
      disabled: {
        type: Boolean,
        default: false
      },
      loading: {
        type: Boolean,
        default: false
      },
      type: {
        type: String,
        default: "circle"
      },
      size: {
        type: String
      },
      checkedValue: {
        type: [String, Number, Boolean],
        default: true
      },
      uncheckedValue: {
        type: [String, Number, Boolean],
        default: false
      },
      checkedColor: {
        type: String
      },
      uncheckedColor: {
        type: String
      },
      beforeChange: {
        type: Function
      },
      checkedText: {
        type: String
      },
      uncheckedText: {
        type: String
      }
    },
    emits: {
      "update:modelValue": (value) => true,
      "change": (value, ev) => true,
      "focus": (ev) => true,
      "blur": (ev) => true
    },
    setup(props, { emit }) {
      const { disabled, size } = vue.toRefs(props);
      const prefixCls = getPrefixCls("switch");
      const { mergedSize: configSize } = useSize$1(size);
      const { mergedDisabled, mergedSize, eventHandlers } = useFormItem({
        disabled,
        size: configSize
      });
      const _checked = vue.ref(props.defaultChecked ? props.checkedValue : props.uncheckedValue);
      const computedCheck = vue.computed(() => {
        var _a;
        return ((_a = props.modelValue) != null ? _a : _checked.value) === props.checkedValue;
      });
      const _loading = vue.ref(props.loading);
      const computedLoading = vue.computed(() => _loading.value || props.loading);
      const handleChange = (checked, ev) => {
        var _a, _b;
        _checked.value = checked ? props.checkedValue : props.uncheckedValue;
        emit("update:modelValue", _checked.value);
        emit("change", _checked.value, ev);
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a, ev);
      };
      const handleClick = async (ev) => {
        if (computedLoading.value || mergedDisabled.value) {
          return;
        }
        const checked = !computedCheck.value;
        const checkedValue = checked ? props.checkedValue : props.uncheckedValue;
        const shouldChange = props.beforeChange;
        if (isFunction$1(shouldChange)) {
          _loading.value = true;
          try {
            const result = await shouldChange(checkedValue);
            if (result != null ? result : true) {
              handleChange(checked, ev);
            }
          } finally {
            _loading.value = false;
          }
        } else {
          handleChange(checked, ev);
        }
      };
      const handleFocus = (ev) => {
        var _a, _b;
        emit("focus", ev);
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onFocus) == null ? void 0 : _b.call(_a, ev);
      };
      const handleBlur = (ev) => {
        var _a, _b;
        emit("blur", ev);
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onBlur) == null ? void 0 : _b.call(_a, ev);
      };
      const cls = vue.computed(() => [
        prefixCls,
        `${prefixCls}-type-${props.type}`,
        {
          [`${prefixCls}-small`]: mergedSize.value === "small" || mergedSize.value === "mini",
          [`${prefixCls}-checked`]: computedCheck.value,
          [`${prefixCls}-disabled`]: mergedDisabled.value,
          [`${prefixCls}-loading`]: computedLoading.value,
          [`${prefixCls}-custom-color`]: props.type === "line" && (props.checkedColor || props.uncheckedColor)
        }
      ]);
      const buttonStyle = vue.computed(() => {
        if (computedCheck.value && props.checkedColor) {
          return props.type === "line" ? { "--custom-color": props.checkedColor } : { backgroundColor: props.checkedColor };
        }
        if (!computedCheck.value && props.uncheckedColor) {
          return props.type === "line" ? { "--custom-color": props.uncheckedColor } : { backgroundColor: props.uncheckedColor };
        }
        return void 0;
      });
      return {
        prefixCls,
        cls,
        mergedDisabled,
        buttonStyle,
        computedCheck,
        computedLoading,
        handleClick,
        handleFocus,
        handleBlur
      };
    }
  });
  const _hoisted_1$f = ["aria-checked", "disabled"];
  function _sfc_render$u(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_icon_loading = vue.resolveComponent("icon-loading");
    return vue.openBlock(), vue.createElementBlock("button", {
      type: "button",
      role: "switch",
      "aria-checked": _ctx.computedCheck,
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.buttonStyle),
      disabled: _ctx.mergedDisabled,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args)),
      onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
      onBlur: _cache[2] || (_cache[2] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args))
    }, [
      vue.createElementVNode("span", {
        class: vue.normalizeClass(`${_ctx.prefixCls}-handle`)
      }, [
        vue.createElementVNode("span", {
          class: vue.normalizeClass(`${_ctx.prefixCls}-handle-icon`)
        }, [
          _ctx.computedLoading ? (vue.openBlock(), vue.createBlock(_component_icon_loading, { key: 0 })) : (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 1 }, [
            _ctx.computedCheck ? vue.renderSlot(_ctx.$slots, "checked-icon", { key: 0 }) : vue.renderSlot(_ctx.$slots, "unchecked-icon", { key: 1 })
          ], 2112))
        ], 2)
      ], 2),
      vue.createCommentVNode("  prettier-ignore  "),
      _ctx.type !== "line" && _ctx.size !== "small" && (_ctx.$slots.checked || _ctx.checkedText || _ctx.$slots.unchecked || _ctx.uncheckedText) ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
        vue.createElementVNode("span", {
          class: vue.normalizeClass(`${_ctx.prefixCls}-text-holder`)
        }, [
          _ctx.computedCheck ? vue.renderSlot(_ctx.$slots, "checked", { key: 0 }, () => [
            vue.createTextVNode(vue.toDisplayString(_ctx.checkedText), 1)
          ]) : vue.renderSlot(_ctx.$slots, "unchecked", { key: 1 }, () => [
            vue.createTextVNode(vue.toDisplayString(_ctx.uncheckedText), 1)
          ])
        ], 2),
        vue.createElementVNode("span", {
          class: vue.normalizeClass(`${_ctx.prefixCls}-text`)
        }, [
          _ctx.computedCheck ? vue.renderSlot(_ctx.$slots, "checked", { key: 0 }, () => [
            vue.createTextVNode(vue.toDisplayString(_ctx.checkedText), 1)
          ]) : vue.renderSlot(_ctx.$slots, "unchecked", { key: 1 }, () => [
            vue.createTextVNode(vue.toDisplayString(_ctx.uncheckedText), 1)
          ])
        ], 2)
      ], 64)) : vue.createCommentVNode("v-if", true)
    ], 46, _hoisted_1$f);
  }
  var _Switch = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["render", _sfc_render$u]]);
  const Switch = Object.assign(_Switch, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Switch.name, _Switch);
    }
  });
  const getDataColumnsNumber = (columns) => {
    let count = 0;
    const travelColumns = (columns2) => {
      if (isArray$1(columns2) && columns2.length > 0) {
        for (const item of columns2) {
          if (!item.children) {
            count += 1;
          } else {
            travelColumns(item.children);
          }
        }
      }
    };
    travelColumns(columns);
    return count;
  };
  const getTotalHeaderRows = (columns) => {
    let count = 0;
    if (isArray$1(columns) && columns.length > 0) {
      count = 1;
      for (const item of columns) {
        if (item.children) {
          const depth = getTotalHeaderRows(item.children);
          if (depth > 0) {
            count = Math.max(count, depth + 1);
          }
        }
      }
    }
    return count;
  };
  const setParentFixed = (column, fixed) => {
    let { parent } = column;
    while (parent) {
      if (parent.fixed === fixed) {
        if (fixed === "left") {
          parent.isLastLeftFixed = true;
        } else {
          parent.isFirstRightFixed = true;
        }
      }
      parent = parent.parent;
    }
  };
  const getGroupColumns = (columns, columnMap, columnWidth) => {
    const totalHeaderRows = getTotalHeaderRows(columns);
    columnMap.clear();
    const dataColumns = [];
    const groupColumns = [...Array(totalHeaderRows)].map(() => []);
    let lastLeftFixedIndex;
    let firstRightFixedIndex;
    const travelColumns = (columns2, {
      level = 0,
      parent,
      fixed
    } = {}) => {
      var _a;
      for (const item of columns2) {
        const cell = __spreadProps(__spreadValues({}, item), { parent });
        if (isArray$1(cell.children)) {
          const colSpan = getDataColumnsNumber(cell.children);
          if (colSpan > 1) {
            cell.colSpan = colSpan;
          }
          groupColumns[level].push(cell);
          travelColumns(cell.children, {
            level: level + 1,
            parent: cell,
            fixed: cell.fixed
          });
        } else {
          const rowSpan = totalHeaderRows - level;
          if (rowSpan > 1) {
            cell.rowSpan = rowSpan;
          }
          if (fixed || cell.fixed) {
            cell.fixed = (_a = cell.fixed) != null ? _a : fixed;
            if (cell.fixed === "left") {
              lastLeftFixedIndex = dataColumns.length;
            } else if (isUndefined(firstRightFixedIndex)) {
              firstRightFixedIndex = dataColumns.length;
            }
          }
          if (isUndefined(cell.dataIndex) || isNull(cell.dataIndex)) {
            cell.dataIndex = `__arco_data_index_${dataColumns.length}`;
          }
          if (columnWidth[cell.dataIndex]) {
            cell._resizeWidth = columnWidth[cell.dataIndex];
          }
          columnMap.set(cell.dataIndex, cell);
          dataColumns.push(cell);
          groupColumns[level].push(cell);
        }
      }
    };
    travelColumns(columns);
    if (!isUndefined(lastLeftFixedIndex)) {
      dataColumns[lastLeftFixedIndex].isLastLeftFixed = true;
      setParentFixed(dataColumns[lastLeftFixedIndex], "left");
    }
    if (!isUndefined(firstRightFixedIndex)) {
      dataColumns[firstRightFixedIndex].isFirstRightFixed = true;
      setParentFixed(dataColumns[firstRightFixedIndex], "right");
    }
    return { dataColumns, groupColumns };
  };
  const getOperationColumnIndex = (operations, name) => {
    for (let i = 0; i < operations.length; i++) {
      if (operations[i].name === name) {
        return i;
      }
    }
    return -1;
  };
  const getOperationFixedNumber = (column, operations) => {
    var _a;
    const index2 = getOperationColumnIndex(operations, column.name);
    if (index2 <= 0) {
      return 0;
    }
    let count = 0;
    const _operations = operations.slice(0, index2);
    for (const item of _operations) {
      count += (_a = item.width) != null ? _a : 0;
    }
    return count;
  };
  const getFirstDataColumn = (column) => {
    if (column.children && column.children.length > 0)
      return getFirstDataColumn(column.children[0]);
    return column;
  };
  const getLastDataColumn = (column) => {
    if (column.children && column.children.length > 0)
      return getFirstDataColumn(column.children[column.children.length - 1]);
    return column;
  };
  const getFixedNumber = (column, {
    dataColumns,
    operations
  }) => {
    var _a, _b, _c;
    let count = 0;
    if (column.fixed === "left") {
      for (const item of operations) {
        count += (_a = item.width) != null ? _a : 40;
      }
      const first = getFirstDataColumn(column);
      for (const item of dataColumns) {
        if (first.dataIndex === item.dataIndex) {
          break;
        }
        count += (_c = (_b = item._resizeWidth) != null ? _b : item.width) != null ? _c : 0;
      }
      return count;
    }
    const last = getLastDataColumn(column);
    for (let i = dataColumns.length - 1; i > 0; i--) {
      const item = dataColumns[i];
      if (last.dataIndex === item.dataIndex) {
        break;
      }
      if (item.fixed === "right") {
        count += item.width;
      }
    }
    return count;
  };
  const getOperationFixedCls = (prefixCls, column) => {
    if (column.fixed) {
      return [
        `${prefixCls}-col-fixed-left`,
        {
          [`${prefixCls}-col-fixed-left-last`]: column.isLastLeftFixed
        }
      ];
    }
    return [];
  };
  const getFixedCls = (prefixCls, column) => {
    if (column.fixed === "left") {
      return [
        `${prefixCls}-col-fixed-left`,
        {
          [`${prefixCls}-col-fixed-left-last`]: column.isLastLeftFixed
        }
      ];
    }
    if (column.fixed === "right") {
      return [
        `${prefixCls}-col-fixed-right`,
        {
          [`${prefixCls}-col-fixed-right-first`]: column.isFirstRightFixed
        }
      ];
    }
    return [];
  };
  const getStyle = (column, {
    dataColumns,
    operations
  }) => {
    if (column.fixed) {
      const offset = `${getFixedNumber(column, { dataColumns, operations })}px`;
      if (column.fixed === "left") {
        return {
          left: offset
        };
      }
      return {
        right: offset
      };
    }
    return {};
  };
  const getOperationStyle = (column, operations) => {
    if (column.fixed) {
      return {
        left: `${getOperationFixedNumber(column, operations)}px`
      };
    }
    return {};
  };
  function mapArrayWithChildren(arr) {
    return arr.map((item) => {
      const newItem = __spreadValues({}, item);
      if (newItem.children) {
        newItem.children = mapArrayWithChildren(newItem.children);
      }
      return newItem;
    });
  }
  function mapRawTableData(arr) {
    return arr.map((item) => {
      const rawItem = item.raw;
      if (item.children && rawItem.children) {
        rawItem.children = mapRawTableData(item.children);
      }
      return item.raw;
    });
  }
  const getLeafKeys = (record) => {
    const keys = [];
    if (record.children) {
      for (const item of record.children) {
        if (item.isLeaf) {
          keys.push(item.key);
        } else {
          keys.push(...getLeafKeys(item));
        }
      }
    }
    return keys;
  };
  const getSelectionStatus = (selectedRowKeys, leafKeys) => {
    let checked = false;
    let indeterminate = false;
    const selectedLeafKeys = leafKeys.filter((key) => selectedRowKeys.includes(key));
    if (selectedLeafKeys.length > 0) {
      if (selectedLeafKeys.length >= leafKeys.length) {
        checked = true;
      } else {
        indeterminate = true;
      }
    }
    return {
      checked,
      indeterminate
    };
  };
  const union = (target2, source, difference = false) => {
    return difference ? target2.filter((item) => !source.includes(item)) : Array.from(new Set(target2.concat(source)));
  };
  const getReverse = (array) => {
    const result = [];
    for (let i = 0; i < array.length; i++) {
      result[i] = array[array.length - 1 - i];
    }
    return result;
  };
  const useRowSelection = ({
    selectedKeys,
    defaultSelectedKeys,
    rowSelection,
    currentAllRowKeys,
    currentAllEnabledRowKeys,
    emit
  }) => {
    var _a, _b, _c;
    const isRadio = vue.computed(() => {
      var _a2;
      return ((_a2 = rowSelection.value) == null ? void 0 : _a2.type) === "radio";
    });
    const _selectedRowKeys = vue.ref((_c = (_b = defaultSelectedKeys.value) != null ? _b : (_a = rowSelection.value) == null ? void 0 : _a.defaultSelectedRowKeys) != null ? _c : []);
    const selectedRowKeys = vue.computed(() => {
      var _a2, _b2, _c2;
      return (_c2 = (_b2 = selectedKeys.value) != null ? _b2 : (_a2 = rowSelection.value) == null ? void 0 : _a2.selectedRowKeys) != null ? _c2 : _selectedRowKeys.value;
    });
    const currentSelectedRowKeys = vue.computed(() => selectedRowKeys.value.filter((key) => currentAllRowKeys.value.includes(key)));
    const handleSelectAll = (checked) => {
      const newKeys = union(selectedRowKeys.value, currentAllEnabledRowKeys.value, !checked);
      _selectedRowKeys.value = newKeys;
      emit("selectAll", checked);
      emit("selectionChange", newKeys);
      emit("update:selectedKeys", newKeys);
    };
    const handleSelect = (checked, record) => {
      const selectedAllRowKeys = isRadio.value ? [record.key] : union(selectedRowKeys.value, [record.key], !checked);
      _selectedRowKeys.value = selectedAllRowKeys;
      emit("select", selectedAllRowKeys, record.key, record.raw);
      emit("selectionChange", selectedAllRowKeys);
      emit("update:selectedKeys", selectedAllRowKeys);
    };
    const handleSelectAllLeafs = (record, checked) => {
      const newKeys = union(selectedRowKeys.value, getLeafKeys(record), !checked);
      _selectedRowKeys.value = newKeys;
      emit("select", newKeys, record.key, record.raw);
      emit("selectionChange", newKeys);
      emit("update:selectedKeys", newKeys);
    };
    const select = (rowKey, checked = true) => {
      const _rowKeys = [].concat(rowKey);
      const newSelectedRowKeys = isRadio.value ? _rowKeys : union(selectedRowKeys.value, _rowKeys, !checked);
      _selectedRowKeys.value = newSelectedRowKeys;
      emit("selectionChange", newSelectedRowKeys);
      emit("update:selectedKeys", newSelectedRowKeys);
    };
    const selectAll = (checked = true) => {
      const newKeys = union(selectedRowKeys.value, currentAllEnabledRowKeys.value, !checked);
      _selectedRowKeys.value = newKeys;
      emit("selectionChange", newKeys);
      emit("update:selectedKeys", newKeys);
    };
    const clearSelected = () => {
      _selectedRowKeys.value = [];
      emit("selectionChange", []);
      emit("update:selectedKeys", []);
    };
    return {
      isRadio,
      selectedRowKeys,
      currentSelectedRowKeys,
      handleSelectAll,
      handleSelect,
      handleSelectAllLeafs,
      select,
      selectAll,
      clearSelected
    };
  };
  const useExpand = ({
    expandedKeys,
    defaultExpandedKeys,
    defaultExpandAllRows,
    expandable,
    allRowKeys,
    emit
  }) => {
    const getDefaultExpandedRowKeys = () => {
      var _a, _b;
      if (defaultExpandedKeys.value) {
        return defaultExpandedKeys.value;
      }
      if ((_a = expandable.value) == null ? void 0 : _a.defaultExpandedRowKeys) {
        return expandable.value.defaultExpandedRowKeys;
      }
      if (defaultExpandAllRows.value || ((_b = expandable.value) == null ? void 0 : _b.defaultExpandAllRows)) {
        return [...allRowKeys.value];
      }
      return [];
    };
    const _expandedRowKeys = vue.ref(getDefaultExpandedRowKeys());
    const expandedRowKeys = vue.computed(() => {
      var _a, _b, _c;
      return (_c = (_b = expandedKeys.value) != null ? _b : (_a = expandable.value) == null ? void 0 : _a.expandedRowKeys) != null ? _c : _expandedRowKeys.value;
    });
    const handleExpand = (rowKey, record) => {
      const isExpanded = expandedRowKeys.value.includes(rowKey);
      const newExpandedRowKeys = isExpanded ? expandedRowKeys.value.filter((key) => rowKey !== key) : expandedRowKeys.value.concat(rowKey);
      _expandedRowKeys.value = newExpandedRowKeys;
      emit("expand", rowKey, record);
      emit("expandedChange", newExpandedRowKeys);
      emit("update:expandedKeys", newExpandedRowKeys);
    };
    const expand = (rowKey, expanded = true) => {
      const _rowKeys = [].concat(rowKey);
      const newExpandedRowKeys = expanded ? expandedRowKeys.value.concat(_rowKeys) : expandedRowKeys.value.filter((key) => !_rowKeys.includes(key));
      _expandedRowKeys.value = newExpandedRowKeys;
      emit("expandedChange", newExpandedRowKeys);
      emit("update:expandedKeys", newExpandedRowKeys);
    };
    const expandAll = (expanded = true) => {
      const newExpandedRowKeys = expanded ? [...allRowKeys.value] : [];
      _expandedRowKeys.value = newExpandedRowKeys;
      emit("expandedChange", newExpandedRowKeys);
      emit("update:expandedKeys", newExpandedRowKeys);
    };
    return {
      expandedRowKeys,
      handleExpand,
      expand,
      expandAll
    };
  };
  const usePagination = (props, emit) => {
    var _a, _b;
    const _page = vue.ref(isObject$1(props.pagination) ? (_a = props.pagination.defaultCurrent) != null ? _a : 1 : 1);
    const _pageSize = vue.ref(isObject$1(props.pagination) ? (_b = props.pagination.defaultPageSize) != null ? _b : 10 : 10);
    const pageSize = vue.computed(() => {
      var _a2;
      return isObject$1(props.pagination) ? (_a2 = props.pagination.pageSize) != null ? _a2 : _pageSize.value : _pageSize.value;
    });
    const page = vue.computed(() => {
      var _a2;
      return isObject$1(props.pagination) ? (_a2 = props.pagination.current) != null ? _a2 : _page.value : _page.value;
    });
    const handlePageChange = (page2) => {
      _page.value = page2;
      emit("pageChange", page2);
    };
    const handlePageSizeChange = (pageSize2) => {
      _pageSize.value = pageSize2;
      emit("pageSizeChange", pageSize2);
    };
    return {
      page,
      pageSize,
      handlePageChange,
      handlePageSizeChange
    };
  };
  const _sfc_main$u = vue.defineComponent({
    name: "ColGroup",
    props: {
      dataColumns: {
        type: Array,
        required: true
      },
      operations: {
        type: Array,
        required: true
      },
      columnWidth: {
        type: Object
      }
    },
    setup() {
      const fixedWidth = (width) => {
        if (width) {
          return {
            width: `${width}px`,
            minWidth: `${width}px`,
            maxWidth: `${width}px`
          };
        }
        return void 0;
      };
      return {
        fixedWidth
      };
    }
  });
  function _sfc_render$t(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("colgroup", null, [
      (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.operations, (item) => {
        return vue.openBlock(), vue.createElementBlock("col", {
          key: `arco-col-${item.name}`,
          class: vue.normalizeClass(`arco-table-${item.name}-col`),
          style: vue.normalizeStyle(_ctx.fixedWidth(item.width))
        }, null, 6);
      }), 128)),
      (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.dataColumns, (item) => {
        return vue.openBlock(), vue.createElementBlock("col", {
          key: `arco-col-${item.dataIndex}`,
          style: vue.normalizeStyle(_ctx.fixedWidth(_ctx.columnWidth && item.dataIndex && _ctx.columnWidth[item.dataIndex] || item.width))
        }, null, 4);
      }), 128))
    ]);
  }
  var ColGroup = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["render", _sfc_render$t]]);
  var Thead = vue.defineComponent({
    name: "Thead",
    setup(_, {
      slots
    }) {
      return () => {
        var _a, _b;
        return vue.createVNode((_b = (_a = slots.thead) == null ? void 0 : _a.call(slots)[0]) != null ? _b : "thead", null, {
          default: slots.default
        });
      };
    }
  });
  var Tbody = vue.defineComponent({
    name: "Tbody",
    setup(_, {
      slots
    }) {
      return () => {
        var _a, _b;
        return vue.createVNode((_b = (_a = slots.tbody) == null ? void 0 : _a.call(slots)[0]) != null ? _b : "tbody", null, {
          default: slots.default
        });
      };
    }
  });
  var Tr = vue.defineComponent({
    name: "Tr",
    props: {
      expand: {
        type: Boolean
      },
      empty: {
        type: Boolean
      },
      checked: {
        type: Boolean
      },
      rowIndex: Number,
      record: {
        type: Object,
        default: () => ({})
      }
    },
    setup(props, {
      slots
    }) {
      const prefixCls = getPrefixCls("table");
      const cls = vue.computed(() => [`${prefixCls}-tr`, {
        [`${prefixCls}-tr-expand`]: props.expand,
        [`${prefixCls}-tr-empty`]: props.empty,
        [`${prefixCls}-tr-checked`]: props.checked
      }]);
      return () => {
        var _a, _b, _c;
        return vue.createVNode((_c = (_b = slots.tr) == null ? void 0 : _b.call(slots, {
          rowIndex: props.rowIndex,
          record: (_a = props.record) == null ? void 0 : _a.raw
        })[0]) != null ? _c : "tr", {
          class: cls.value
        }, {
          default: slots.default
        });
      };
    }
  });
  const _sfc_main$t = vue.defineComponent({
    name: "IconCaretDown",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-caret-down`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$e = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$e = /* @__PURE__ */ vue.createElementVNode("path", {
    d: "M24.938 34.829a1.2 1.2 0 0 1-1.875 0L9.56 17.949c-.628-.785-.069-1.949.937-1.949h27.007c1.006 0 1.565 1.164.937 1.95L24.937 34.829Z",
    fill: "currentColor",
    stroke: "none"
  }, null, -1);
  const _hoisted_3$d = [
    _hoisted_2$e
  ];
  function _sfc_render$s(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$d, 14, _hoisted_1$e);
  }
  var _IconCaretDown = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["render", _sfc_render$s]]);
  const IconCaretDown = Object.assign(_IconCaretDown, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconCaretDown.name, _IconCaretDown);
    }
  });
  const _sfc_main$s = vue.defineComponent({
    name: "IconCaretUp",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-caret-up`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$d = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$d = /* @__PURE__ */ vue.createElementVNode("path", {
    d: "M23.063 13.171a1.2 1.2 0 0 1 1.875 0l13.503 16.88c.628.785.069 1.949-.937 1.949H10.497c-1.006 0-1.565-1.164-.937-1.95l13.503-16.879Z",
    fill: "currentColor",
    stroke: "none"
  }, null, -1);
  const _hoisted_3$c = [
    _hoisted_2$d
  ];
  function _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$c, 14, _hoisted_1$d);
  }
  var _IconCaretUp = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["render", _sfc_render$r]]);
  const IconCaretUp = Object.assign(_IconCaretUp, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconCaretUp.name, _IconCaretUp);
    }
  });
  const _sfc_main$r = vue.defineComponent({
    name: "IconFilter",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-filter`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$c = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$c = /* @__PURE__ */ vue.createElementVNode("path", { d: "M30 42V22.549a1 1 0 0 1 .463-.844l10.074-6.41A1 1 0 0 0 41 14.45V8a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v6.451a1 1 0 0 0 .463.844l10.074 6.41a1 1 0 0 1 .463.844V37" }, null, -1);
  const _hoisted_3$b = [
    _hoisted_2$c
  ];
  function _sfc_render$q(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$b, 14, _hoisted_1$c);
  }
  var _IconFilter = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["render", _sfc_render$q]]);
  const IconFilter = Object.assign(_IconFilter, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconFilter.name, _IconFilter);
    }
  });
  const useColumnSorter = ({
    column,
    tableCtx
  }) => {
    const sortOrder = vue.computed(() => {
      var _a;
      if (column.value.dataIndex && column.value.dataIndex === ((_a = tableCtx.sorter) == null ? void 0 : _a.field)) {
        return tableCtx.sorter.direction;
      }
      return void 0;
    });
    const sortDirections = vue.computed(() => {
      var _a, _b, _c;
      return (_c = (_b = (_a = column.value) == null ? void 0 : _a.sortable) == null ? void 0 : _b.sortDirections) != null ? _c : [];
    });
    const hasSorter = vue.computed(() => sortDirections.value.length > 0);
    const hasAscendBtn = vue.computed(() => sortDirections.value.includes("ascend"));
    const hasDescendBtn = vue.computed(() => sortDirections.value.includes("descend"));
    const nextSortOrder = vue.computed(() => {
      var _a, _b;
      if (!sortOrder.value) {
        return (_a = sortDirections.value[0]) != null ? _a : "";
      }
      if (sortOrder.value === sortDirections.value[0]) {
        return (_b = sortDirections.value[1]) != null ? _b : "";
      }
      return "";
    });
    const handleClickSorter = (ev) => {
      var _a;
      if (column.value.dataIndex) {
        (_a = tableCtx.onSorterChange) == null ? void 0 : _a.call(tableCtx, column.value.dataIndex, nextSortOrder.value, ev);
      }
    };
    return {
      sortOrder,
      hasSorter,
      hasAscendBtn,
      hasDescendBtn,
      nextSortOrder,
      handleClickSorter
    };
  };
  const useColumnFilter = ({
    column,
    tableCtx
  }) => {
    const filterValue = vue.computed(() => {
      var _a;
      if (column.value.dataIndex && ((_a = tableCtx.filters) == null ? void 0 : _a[column.value.dataIndex])) {
        return tableCtx.filters[column.value.dataIndex];
      }
      return [];
    });
    const filterPopupVisible = vue.ref(false);
    const isFilterActive = vue.computed(() => filterValue.value.length > 0);
    const isMultipleFilter = vue.computed(() => {
      var _a;
      return Boolean((_a = column.value.filterable) == null ? void 0 : _a.multiple);
    });
    const columnFilterValue = vue.ref(filterValue.value);
    vue.watch(filterValue, (value) => {
      if (isArray$1(value) && String(value) !== String(columnFilterValue.value)) {
        columnFilterValue.value = value;
      }
    });
    const handleFilterPopupVisibleChange = (value) => {
      filterPopupVisible.value = value;
    };
    const setFilterValue = (filterValue2) => {
      columnFilterValue.value = filterValue2;
    };
    const handleCheckboxFilterChange = (values) => {
      setFilterValue(values);
    };
    const handleRadioFilterChange = (value) => {
      setFilterValue([value]);
    };
    const handleFilterConfirm = (ev) => {
      var _a;
      if (column.value.dataIndex) {
        (_a = tableCtx.onFilterChange) == null ? void 0 : _a.call(tableCtx, column.value.dataIndex, columnFilterValue.value, ev);
      }
      handleFilterPopupVisibleChange(false);
    };
    const handleFilterReset = (ev) => {
      var _a;
      setFilterValue([]);
      if (column.value.dataIndex) {
        (_a = tableCtx.onFilterChange) == null ? void 0 : _a.call(tableCtx, column.value.dataIndex, columnFilterValue.value, ev);
      }
      handleFilterPopupVisibleChange(false);
    };
    return {
      filterPopupVisible,
      isFilterActive,
      isMultipleFilter,
      columnFilterValue,
      handleFilterPopupVisibleChange,
      setFilterValue,
      handleCheckboxFilterChange,
      handleRadioFilterChange,
      handleFilterConfirm,
      handleFilterReset
    };
  };
  const tableInjectionKey = Symbol("ArcoTable");
  const tableColumnInjectionKey = Symbol("ArcoTableColumn");
  function _isSlot$6(s) {
    return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !vue.isVNode(s);
  }
  var AutoTooltip = vue.defineComponent({
    name: "AutoTooltip",
    inheritAttrs: false,
    props: {
      tooltipProps: {
        type: Object
      }
    },
    setup(props, {
      attrs,
      slots
    }) {
      const prefix = getPrefixCls("auto-tooltip");
      const containerRef = vue.ref();
      const contentRef = vue.ref();
      const text = vue.ref("");
      const showTooltip = vue.ref(false);
      const calTooltip = () => {
        if (containerRef.value && contentRef.value) {
          const _show = contentRef.value.offsetWidth > containerRef.value.offsetWidth;
          if (_show !== showTooltip.value) {
            showTooltip.value = _show;
          }
        }
      };
      const getText = () => {
        var _a;
        if (((_a = contentRef.value) == null ? void 0 : _a.textContent) && contentRef.value.textContent !== text.value) {
          text.value = contentRef.value.textContent;
        }
      };
      const onResize = () => {
        getText();
        calTooltip();
      };
      vue.onMounted(() => {
        getText();
        calTooltip();
      });
      vue.onUpdated(() => {
        getText();
        calTooltip();
      });
      const renderContent = () => {
        return vue.createVNode("span", vue.mergeProps({
          "ref": containerRef,
          "class": prefix
        }, attrs), [vue.createVNode(ResizeObserver, {
          "onResize": onResize
        }, {
          default: () => {
            var _a;
            return [vue.createVNode("span", {
              "ref": contentRef,
              "class": `${prefix}-content`
            }, [(_a = slots.default) == null ? void 0 : _a.call(slots)])];
          }
        })]);
      };
      return () => {
        let _slot2;
        if (showTooltip.value) {
          let _slot;
          return vue.createVNode(Tooltip, vue.mergeProps({
            "content": text.value,
            "onResize": onResize
          }, props.tooltipProps), _isSlot$6(_slot = renderContent()) ? _slot : {
            default: () => [_slot]
          });
        }
        return vue.createVNode(ResizeObserver, {
          "onResize": onResize
        }, _isSlot$6(_slot2 = renderContent()) ? _slot2 : {
          default: () => [_slot2]
        });
      };
    }
  });
  function _isSlot$5(s) {
    return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !vue.isVNode(s);
  }
  var Th = vue.defineComponent({
    name: "Th",
    props: {
      column: {
        type: Object,
        default: () => ({})
      },
      operations: {
        type: Array,
        default: () => []
      },
      dataColumns: {
        type: Array,
        default: () => []
      },
      resizable: Boolean
    },
    setup(props, {
      slots
    }) {
      const {
        column
      } = vue.toRefs(props);
      const prefixCls = getPrefixCls("table");
      const {
        t: t2
      } = useI18n();
      const tableCtx = vue.inject(tableInjectionKey, {});
      const resizing = vue.computed(() => {
        var _a;
        return ((_a = props.column) == null ? void 0 : _a.dataIndex) && tableCtx.resizingColumn === props.column.dataIndex;
      });
      const tooltipProps = vue.computed(() => {
        var _a;
        if (isObject$1((_a = props.column) == null ? void 0 : _a.tooltip)) {
          return props.column.tooltip;
        }
        return void 0;
      });
      const filterIconAlignLeft = vue.computed(() => {
        var _a;
        if (((_a = props.column) == null ? void 0 : _a.filterable) && isBoolean$1(props.column.filterable.alignLeft)) {
          return props.column.filterable.alignLeft;
        }
        return tableCtx.filterIconAlignLeft;
      });
      const {
        sortOrder,
        hasSorter,
        hasAscendBtn,
        hasDescendBtn,
        nextSortOrder,
        handleClickSorter
      } = useColumnSorter({
        column,
        tableCtx
      });
      const {
        filterPopupVisible,
        isFilterActive,
        isMultipleFilter,
        columnFilterValue,
        handleFilterPopupVisibleChange,
        setFilterValue,
        handleCheckboxFilterChange,
        handleRadioFilterChange,
        handleFilterConfirm,
        handleFilterReset
      } = useColumnFilter({
        column,
        tableCtx
      });
      const renderFilterContent = () => {
        var _a, _b, _c, _d, _e;
        let _slot, _slot2;
        const {
          filterable
        } = props.column;
        if ((_a = props.column.slots) == null ? void 0 : _a["filter-content"]) {
          return (_b = props.column.slots) == null ? void 0 : _b["filter-content"]({
            filterValue: columnFilterValue.value,
            setFilterValue,
            handleFilterConfirm,
            handleFilterReset
          });
        }
        if (filterable == null ? void 0 : filterable.slotName) {
          return (_d = (_c = tableCtx == null ? void 0 : tableCtx.slots) == null ? void 0 : _c[filterable == null ? void 0 : filterable.slotName]) == null ? void 0 : _d.call(_c, {
            filterValue: columnFilterValue.value,
            setFilterValue,
            handleFilterConfirm,
            handleFilterReset
          });
        }
        if (filterable == null ? void 0 : filterable.renderContent) {
          return filterable.renderContent({
            filterValue: columnFilterValue.value,
            setFilterValue,
            handleFilterConfirm,
            handleFilterReset
          });
        }
        return vue.createVNode("div", {
          "class": `${prefixCls}-filters-content`
        }, [vue.createVNode("ul", {
          "class": `${prefixCls}-filters-list`
        }, [(_e = filterable == null ? void 0 : filterable.filters) == null ? void 0 : _e.map((item, index2) => {
          var _a2;
          return vue.createVNode("li", {
            "class": `${prefixCls}-filters-item`,
            "key": index2
          }, [isMultipleFilter.value ? vue.createVNode(Checkbox, {
            "value": item.value,
            "modelValue": columnFilterValue.value,
            "uninjectGroupContext": true,
            "onChange": handleCheckboxFilterChange
          }, {
            default: () => [item.text]
          }) : vue.createVNode(Radio, {
            "value": item.value,
            "modelValue": (_a2 = columnFilterValue.value[0]) != null ? _a2 : "",
            "uninjectGroupContext": true,
            "onChange": handleRadioFilterChange
          }, {
            default: () => [item.text]
          })]);
        })]), vue.createVNode("div", {
          "class": `${prefixCls}-filters-bottom`
        }, [vue.createVNode(Button, {
          "size": "mini",
          "onClick": handleFilterReset
        }, _isSlot$5(_slot = t2("table.resetText")) ? _slot : {
          default: () => [_slot]
        }), vue.createVNode(Button, {
          "type": "primary",
          "size": "mini",
          "onClick": handleFilterConfirm
        }, _isSlot$5(_slot2 = t2("table.okText")) ? _slot2 : {
          default: () => [_slot2]
        })])]);
      };
      const renderFilter = () => {
        const {
          filterable
        } = props.column;
        if (!filterable) {
          return null;
        }
        return vue.createVNode(Trigger, vue.mergeProps({
          "popupVisible": filterPopupVisible.value,
          "trigger": "click",
          "autoFitPosition": true,
          "popupOffset": filterIconAlignLeft.value ? 4 : 0,
          "onPopupVisibleChange": handleFilterPopupVisibleChange
        }, filterable.triggerProps), {
          default: () => [vue.createVNode(IconHover, {
            "class": [`${prefixCls}-filters`, {
              [`${prefixCls}-filters-active`]: isFilterActive.value,
              [`${prefixCls}-filters-open`]: filterPopupVisible.value,
              [`${prefixCls}-filters-align-left`]: filterIconAlignLeft.value
            }],
            "disabled": !filterIconAlignLeft.value,
            "onClick": (ev) => ev.stopPropagation()
          }, {
            default: () => {
              var _a, _b, _c, _d, _e;
              return [(_e = (_d = (_b = (_a = props.column.slots) == null ? void 0 : _a["filter-icon"]) == null ? void 0 : _b.call(_a)) != null ? _d : (_c = filterable.icon) == null ? void 0 : _c.call(filterable)) != null ? _e : vue.createVNode(IconFilter, null, null)];
            }
          })],
          content: renderFilterContent
        });
      };
      const cellCls = vue.computed(() => {
        var _a, _b;
        const cls2 = [`${prefixCls}-cell`, `${prefixCls}-cell-align-${(_b = (_a = props.column) == null ? void 0 : _a.align) != null ? _b : props.column.children ? "center" : "left"}`];
        if (hasSorter.value) {
          cls2.push(`${prefixCls}-cell-with-sorter`, {
            [`${prefixCls}-cell-next-ascend`]: nextSortOrder.value === "ascend",
            [`${prefixCls}-cell-next-descend`]: nextSortOrder.value === "descend"
          });
        }
        if (filterIconAlignLeft.value) {
          cls2.push(`${prefixCls}-cell-with-filter`);
        }
        return cls2;
      });
      const renderTitle = () => {
        var _a, _b, _c, _d, _e, _f;
        if (slots.default) {
          return slots.default();
        }
        if (((_a = props.column) == null ? void 0 : _a.titleSlotName) && ((_b = tableCtx.slots) == null ? void 0 : _b[props.column.titleSlotName])) {
          return (_d = (_c = tableCtx.slots)[props.column.titleSlotName]) == null ? void 0 : _d.call(_c, {
            column: props.column
          });
        }
        if ((_f = (_e = props.column) == null ? void 0 : _e.slots) == null ? void 0 : _f.title) {
          return props.column.slots.title();
        }
        if (isFunction$1(props.column.title)) {
          return props.column.title();
        }
        return props.column.title;
      };
      const renderCell = () => {
        var _a, _b, _c;
        let _slot3;
        return vue.createVNode("span", {
          "class": cellCls.value,
          "onClick": hasSorter.value ? handleClickSorter : void 0
        }, [((_a = props.column) == null ? void 0 : _a.ellipsis) && ((_b = props.column) == null ? void 0 : _b.tooltip) ? vue.createVNode(AutoTooltip, {
          "class": `${prefixCls}-th-title`,
          "tooltipProps": tooltipProps.value
        }, _isSlot$5(_slot3 = renderTitle()) ? _slot3 : {
          default: () => [_slot3]
        }) : vue.createVNode("span", {
          "class": [`${prefixCls}-th-title`, {
            [`${prefixCls}-text-ellipsis`]: (_c = props.column) == null ? void 0 : _c.ellipsis
          }]
        }, [renderTitle()]), hasSorter.value && vue.createVNode("span", {
          "class": `${prefixCls}-sorter`
        }, [hasAscendBtn.value && vue.createVNode("div", {
          "class": [`${prefixCls}-sorter-icon`, {
            [`${prefixCls}-sorter-icon-active`]: sortOrder.value === "ascend"
          }]
        }, [vue.createVNode(IconCaretUp, null, null)]), hasDescendBtn.value && vue.createVNode("div", {
          "class": [`${prefixCls}-sorter-icon`, {
            [`${prefixCls}-sorter-icon-active`]: sortOrder.value === "descend"
          }]
        }, [vue.createVNode(IconCaretDown, null, null)])]), filterIconAlignLeft.value && renderFilter()]);
      };
      const style = vue.computed(() => {
        var _a, _b;
        return __spreadValues(__spreadValues(__spreadValues({}, getStyle(props.column, {
          dataColumns: props.dataColumns,
          operations: props.operations
        })), (_a = props.column) == null ? void 0 : _a.cellStyle), (_b = props.column) == null ? void 0 : _b.headerCellStyle);
      });
      const cls = vue.computed(() => {
        var _a, _b;
        return [`${prefixCls}-th`, {
          [`${prefixCls}-col-sorted`]: Boolean(sortOrder.value),
          [`${prefixCls}-th-resizing`]: resizing.value
        }, ...getFixedCls(prefixCls, props.column), (_a = props.column) == null ? void 0 : _a.cellClass, (_b = props.column) == null ? void 0 : _b.headerCellClass];
      });
      const handleMouseDown = (ev) => {
        var _a, _b, _c;
        if ((_a = props.column) == null ? void 0 : _a.dataIndex) {
          (_c = tableCtx.onThMouseDown) == null ? void 0 : _c.call(tableCtx, (_b = props.column) == null ? void 0 : _b.dataIndex, ev);
        }
      };
      return () => {
        var _a, _b, _c, _d;
        const colSpan = (_a = props.column.colSpan) != null ? _a : 1;
        const rowSpan = (_b = props.column.rowSpan) != null ? _b : 1;
        return vue.createVNode((_d = (_c = slots.th) == null ? void 0 : _c.call(slots, {
          column: props.column
        })[0]) != null ? _d : "th", {
          class: cls.value,
          style: style.value,
          colspan: colSpan > 1 ? colSpan : void 0,
          rowspan: rowSpan > 1 ? rowSpan : void 0
        }, {
          default: () => [renderCell(), !filterIconAlignLeft.value && renderFilter(), props.resizable && vue.createVNode("span", {
            "class": `${prefixCls}-column-handle`,
            "onMousedown": handleMouseDown
          }, null)]
        });
      };
    }
  });
  function _isSlot$4(s) {
    return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !vue.isVNode(s);
  }
  var Td = vue.defineComponent({
    name: "Td",
    props: {
      rowIndex: Number,
      record: {
        type: Object,
        default: () => ({})
      },
      column: {
        type: Object,
        default: () => ({})
      },
      type: {
        type: String,
        default: "normal"
      },
      operations: {
        type: Array,
        default: () => []
      },
      dataColumns: {
        type: Array,
        default: () => []
      },
      colSpan: {
        type: Number,
        default: 1
      },
      rowSpan: {
        type: Number,
        default: 1
      },
      isFixedExpand: {
        type: Boolean,
        default: false
      },
      containerWidth: {
        type: Number
      },
      showExpandBtn: {
        type: Boolean,
        default: false
      },
      indentSize: {
        type: Number,
        default: 0
      },
      renderExpandBtn: {
        type: Function
      },
      summary: {
        type: Boolean,
        default: false
      }
    },
    setup(props, {
      slots
    }) {
      const prefixCls = getPrefixCls("table");
      const tooltipProps = vue.computed(() => {
        var _a;
        if (isObject$1((_a = props.column) == null ? void 0 : _a.tooltip)) {
          return props.column.tooltip;
        }
        return void 0;
      });
      const isSorted = vue.computed(() => {
        var _a, _b;
        return ((_a = props.column) == null ? void 0 : _a.dataIndex) && ((_b = tableCtx.sorter) == null ? void 0 : _b.field) === props.column.dataIndex;
      });
      const resizing = vue.computed(() => {
        var _a;
        return ((_a = props.column) == null ? void 0 : _a.dataIndex) && tableCtx.resizingColumn === props.column.dataIndex;
      });
      const getCustomClass = () => {
        var _a, _b, _c, _d, _e, _f;
        if (props.summary) {
          return isFunction$1((_a = props.column) == null ? void 0 : _a.summaryCellClass) ? props.column.summaryCellClass((_b = props.record) == null ? void 0 : _b.raw) : (_c = props.column) == null ? void 0 : _c.summaryCellClass;
        }
        return isFunction$1((_d = props.column) == null ? void 0 : _d.bodyCellClass) ? props.column.bodyCellClass((_e = props.record) == null ? void 0 : _e.raw) : (_f = props.column) == null ? void 0 : _f.bodyCellClass;
      };
      const cls = vue.computed(() => {
        var _a;
        return [`${prefixCls}-td`, {
          [`${prefixCls}-col-sorted`]: isSorted.value,
          [`${prefixCls}-td-resizing`]: resizing.value
        }, ...getFixedCls(prefixCls, props.column), (_a = props.column) == null ? void 0 : _a.cellClass, getCustomClass()];
      });
      const getCustomStyle = () => {
        var _a, _b, _c, _d, _e, _f;
        if (props.summary) {
          return isFunction$1((_a = props.column) == null ? void 0 : _a.summaryCellStyle) ? props.column.summaryCellStyle((_b = props.record) == null ? void 0 : _b.raw) : (_c = props.column) == null ? void 0 : _c.summaryCellStyle;
        }
        return isFunction$1((_d = props.column) == null ? void 0 : _d.bodyCellStyle) ? props.column.bodyCellStyle((_e = props.record) == null ? void 0 : _e.raw) : (_f = props.column) == null ? void 0 : _f.bodyCellStyle;
      };
      const style = vue.computed(() => {
        var _a;
        const style2 = getStyle(props.column, {
          dataColumns: props.dataColumns,
          operations: props.operations
        });
        const customStyle = getCustomStyle();
        return __spreadValues(__spreadValues(__spreadValues({}, style2), (_a = props.column) == null ? void 0 : _a.cellStyle), customStyle);
      });
      const cellStyle = vue.computed(() => {
        if (props.isFixedExpand && props.containerWidth) {
          return {
            width: `${props.containerWidth}px`
          };
        }
        return void 0;
      });
      const tableCtx = vue.inject(tableInjectionKey, {});
      const renderContent = () => {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (slots.default) {
          return slots.default();
        }
        const data = {
          record: (_a = props.record) == null ? void 0 : _a.raw,
          column: props.column,
          rowIndex: (_b = props.rowIndex) != null ? _b : -1
        };
        if (slots.cell) {
          return slots.cell(data);
        }
        if ((_c = props.column.slots) == null ? void 0 : _c.cell) {
          return props.column.slots.cell(data);
        }
        if (props.column.render) {
          return props.column.render(data);
        }
        if (props.column.slotName && ((_d = tableCtx.slots) == null ? void 0 : _d[props.column.slotName])) {
          return (_f = (_e = tableCtx.slots)[props.column.slotName]) == null ? void 0 : _f.call(_e, data);
        }
        return String((_h = getValueByPath((_g = props.record) == null ? void 0 : _g.raw, props.column.dataIndex)) != null ? _h : "");
      };
      const isLoading = vue.ref(false);
      const handleClick = (ev) => {
        var _a, _b;
        if (isFunction$1(tableCtx.loadMore) && !((_a = props.record) == null ? void 0 : _a.isLeaf) && !((_b = props.record) == null ? void 0 : _b.children)) {
          isLoading.value = true;
          new Promise((resolve) => {
            var _a2;
            (_a2 = tableCtx.loadMore) == null ? void 0 : _a2.call(tableCtx, props.record.raw, resolve);
          }).then((children) => {
            var _a2;
            (_a2 = tableCtx.addLazyLoadData) == null ? void 0 : _a2.call(tableCtx, children, props.record);
            isLoading.value = false;
          });
        }
        ev.stopPropagation();
      };
      const renderCell = () => {
        var _a, _b, _c, _d, _e, _f;
        let _slot;
        return vue.createVNode("span", {
          "class": [`${prefixCls}-cell`, `${prefixCls}-cell-align-${(_b = (_a = props.column) == null ? void 0 : _a.align) != null ? _b : "left"}`, {
            [`${prefixCls}-cell-fixed-expand`]: props.isFixedExpand,
            [`${prefixCls}-cell-expand-icon`]: props.showExpandBtn
          }],
          "style": cellStyle.value
        }, [props.indentSize > 0 && vue.createVNode("span", {
          "style": {
            paddingLeft: `${props.indentSize}px`
          }
        }, null), props.showExpandBtn && vue.createVNode("span", {
          "class": `${prefixCls}-cell-inline-icon`,
          "onClick": handleClick
        }, [isLoading.value ? vue.createVNode(IconLoading, null, null) : (_c = props.renderExpandBtn) == null ? void 0 : _c.call(props, props.record, false)]), ((_d = props.column) == null ? void 0 : _d.ellipsis) && ((_e = props.column) == null ? void 0 : _e.tooltip) ? vue.createVNode(AutoTooltip, {
          "class": `${prefixCls}-td-content`,
          "tooltipProps": tooltipProps.value
        }, _isSlot$4(_slot = renderContent()) ? _slot : {
          default: () => [_slot]
        }) : vue.createVNode("span", {
          "class": [`${prefixCls}-td-content`, {
            [`${prefixCls}-text-ellipsis`]: (_f = props.column) == null ? void 0 : _f.ellipsis
          }]
        }, [renderContent()])]);
      };
      return () => {
        var _a, _b, _c, _d;
        return vue.createVNode((_d = (_c = slots.td) == null ? void 0 : _c.call(slots, {
          record: (_a = props.record) == null ? void 0 : _a.raw,
          column: props.column,
          rowIndex: (_b = props.rowIndex) != null ? _b : -1
        })[0]) != null ? _d : "td", {
          class: cls.value,
          style: style.value,
          rowspan: props.rowSpan > 1 ? props.rowSpan : void 0,
          colspan: props.colSpan > 1 ? props.colSpan : void 0
        }, {
          default: () => [renderCell()]
        });
      };
    }
  });
  var OperationTh = vue.defineComponent({
    name: "OperationTh",
    props: {
      operationColumn: {
        type: Object,
        required: true
      },
      operations: {
        type: Array,
        required: true
      },
      rowSpan: {
        type: Number,
        default: 1
      },
      selectAll: {
        type: Boolean,
        default: false
      }
    },
    setup(props) {
      const prefixCls = getPrefixCls("table");
      const tableCtx = vue.inject(tableInjectionKey, {});
      const checkboxStatus = vue.computed(() => {
        var _a, _b, _c, _d;
        let checked = false;
        let indeterminate = false;
        const currentSelectedEnabledRowKeys = (_b = (_a = tableCtx.currentSelectedRowKeys) == null ? void 0 : _a.filter((key) => {
          var _a2, _b2;
          return (_b2 = (_a2 = tableCtx.currentAllEnabledRowKeys) == null ? void 0 : _a2.includes(key)) != null ? _b2 : true;
        })) != null ? _b : [];
        const selectedNumber = currentSelectedEnabledRowKeys.length;
        const totalEnabledNumber = (_d = (_c = tableCtx.currentAllEnabledRowKeys) == null ? void 0 : _c.length) != null ? _d : 0;
        if (selectedNumber > 0) {
          if (selectedNumber >= totalEnabledNumber) {
            checked = true;
          } else {
            indeterminate = true;
          }
        }
        return {
          checked,
          indeterminate
        };
      });
      const renderContent = () => {
        if (props.selectAll) {
          return vue.createVNode(Checkbox, {
            "modelValue": checkboxStatus.value.checked,
            "indeterminate": checkboxStatus.value.indeterminate,
            "uninjectGroupContext": true,
            "onChange": (checked) => {
              var _a;
              (_a = tableCtx.onSelectAll) == null ? void 0 : _a.call(tableCtx, checked);
            }
          }, {
            default: isFunction$1(props.operationColumn.title) ? props.operationColumn.title() : props.operationColumn.title
          });
        }
        if (props.operationColumn.title) {
          return isFunction$1(props.operationColumn.title) ? props.operationColumn.title() : props.operationColumn.title;
        }
        return null;
      };
      const style = vue.computed(() => getOperationStyle(props.operationColumn, props.operations));
      const cls = vue.computed(() => [`${prefixCls}-th`, `${prefixCls}-operation`, {
        [`${prefixCls}-checkbox`]: props.selectAll
      }, ...getOperationFixedCls(prefixCls, props.operationColumn)]);
      return () => vue.createVNode("th", {
        "class": cls.value,
        "style": style.value,
        "rowspan": props.rowSpan > 1 ? props.rowSpan : void 0
      }, [vue.createVNode("span", {
        "class": `${prefixCls}-cell`
      }, [renderContent()])]);
    }
  });
  var OperationTd = vue.defineComponent({
    name: "OperationTd",
    components: {
      Checkbox,
      Radio,
      IconPlus,
      IconMinus
    },
    props: {
      operationColumn: {
        type: Object,
        required: true
      },
      operations: {
        type: Array,
        required: true
      },
      record: {
        type: Object,
        required: true
      },
      hasExpand: {
        type: Boolean,
        default: false
      },
      selectedRowKeys: {
        type: Array
      },
      renderExpandBtn: {
        type: Function
      },
      colSpan: {
        type: Number,
        default: 1
      },
      rowSpan: {
        type: Number,
        default: 1
      },
      summary: {
        type: Boolean,
        default: false
      }
    },
    emits: ["select"],
    setup(props, {
      emit,
      slots
    }) {
      const prefixCls = getPrefixCls("table");
      const tableCtx = vue.inject(tableInjectionKey, {});
      const style = vue.computed(() => getOperationStyle(props.operationColumn, props.operations));
      const cls = vue.computed(() => [`${prefixCls}-td`, `${prefixCls}-operation`, {
        [`${prefixCls}-checkbox`]: props.operationColumn.name === "selection-checkbox",
        [`${prefixCls}-radio`]: props.operationColumn.name === "selection-radio",
        [`${prefixCls}-expand`]: props.operationColumn.name === "expand",
        [`${prefixCls}-drag-handle`]: props.operationColumn.name === "drag-handle"
      }, ...getOperationFixedCls(prefixCls, props.operationColumn)]);
      const leafKeys = vue.computed(() => getLeafKeys(props.record));
      const selectionStatus = vue.computed(() => {
        var _a;
        return getSelectionStatus((_a = tableCtx.currentSelectedRowKeys) != null ? _a : [], leafKeys.value);
      });
      const renderContent = () => {
        var _a, _b, _c, _d, _e, _f;
        if (props.summary) {
          return null;
        }
        if (props.operationColumn.render) {
          return props.operationColumn.render(props.record.raw);
        }
        if (props.operationColumn.name === "selection-checkbox") {
          const value = props.record.key;
          if (!tableCtx.checkStrictly && !props.record.isLeaf) {
            return vue.createVNode(Checkbox, {
              "modelValue": selectionStatus.value.checked,
              "indeterminate": selectionStatus.value.indeterminate,
              "disabled": Boolean(props.record.disabled),
              "uninjectGroupContext": true,
              "onChange": (checked) => {
                var _a2;
                return (_a2 = tableCtx.onSelectAllLeafs) == null ? void 0 : _a2.call(tableCtx, props.record, checked);
              },
              "onClick": (ev) => ev.stopPropagation()
            }, null);
          }
          return vue.createVNode(Checkbox, {
            "modelValue": (_b = (_a = props.selectedRowKeys) == null ? void 0 : _a.includes(value)) != null ? _b : false,
            "disabled": Boolean(props.record.disabled),
            "uninjectGroupContext": true,
            "onChange": (checked) => {
              var _a2;
              return (_a2 = tableCtx.onSelect) == null ? void 0 : _a2.call(tableCtx, checked, props.record);
            },
            "onClick": (ev) => ev.stopPropagation()
          }, null);
        }
        if (props.operationColumn.name === "selection-radio") {
          const value = props.record.key;
          return vue.createVNode(Radio, {
            "modelValue": (_d = (_c = props.selectedRowKeys) == null ? void 0 : _c.includes(value)) != null ? _d : false,
            "disabled": Boolean(props.record.disabled),
            "uninjectGroupContext": true,
            "onChange": (checked) => {
              var _a2;
              return (_a2 = tableCtx.onSelect) == null ? void 0 : _a2.call(tableCtx, checked, props.record);
            },
            "onClick": (ev) => ev.stopPropagation()
          }, null);
        }
        if (props.operationColumn.name === "expand") {
          if (props.hasExpand && props.renderExpandBtn) {
            return props.renderExpandBtn(props.record);
          }
          return null;
        }
        if (props.operationColumn.name === "drag-handle") {
          return (_f = (_e = slots["drag-handle-icon"]) == null ? void 0 : _e.call(slots)) != null ? _f : vue.createVNode(IconDragDotVertical, null, null);
        }
        return null;
      };
      return () => vue.createVNode("td", {
        "class": cls.value,
        "style": style.value,
        "rowspan": props.rowSpan > 1 ? props.rowSpan : void 0,
        "colspan": props.colSpan > 1 ? props.colSpan : void 0
      }, [vue.createVNode("span", {
        "class": `${prefixCls}-cell`
      }, [renderContent()])]);
    }
  });
  const useDrag = (draggable) => {
    const dragType = vue.computed(() => {
      if (draggable.value) {
        if (draggable.value.type === "handle") {
          return "handle";
        }
        return "row";
      }
      return void 0;
    });
    const dragState = vue.reactive({
      dragging: false,
      sourceKey: "",
      sourcePath: [],
      targetPath: [],
      data: {}
    });
    const clearDragState = () => {
      dragState.dragging = false;
      dragState.sourceKey = "";
      dragState.sourcePath = [];
      dragState.targetPath = [];
      dragState.data = {};
    };
    const handleDragStart = (ev, sourceKey, sourcePath, data) => {
      if (ev.dataTransfer) {
        ev.dataTransfer.effectAllowed = "move";
        if (ev.target && ev.target.tagName === "TD") {
          const { parentElement } = ev.target;
          if (parentElement && parentElement.tagName === "TR") {
            ev.dataTransfer.setDragImage(parentElement, 0, 0);
          }
        }
      }
      dragState.dragging = true;
      dragState.sourceKey = sourceKey;
      dragState.sourcePath = sourcePath;
      dragState.targetPath = [...sourcePath];
      dragState.data = data;
    };
    const handleDragEnter = (ev, targetPath) => {
      if (ev.dataTransfer) {
        ev.dataTransfer.dropEffect = "move";
      }
      if (dragState.targetPath.toString() !== targetPath.toString()) {
        dragState.targetPath = targetPath;
      }
      ev.preventDefault();
    };
    const handleDragLeave = (ev) => {
    };
    const handleDragover = (ev) => {
      if (ev.dataTransfer) {
        ev.dataTransfer.dropEffect = "move";
      }
      ev.preventDefault();
    };
    const handleDragEnd = (ev) => {
      var _a;
      if (((_a = ev.dataTransfer) == null ? void 0 : _a.dropEffect) === "none") {
        clearDragState();
      }
    };
    const handleDrop = (ev) => {
      clearDragState();
      ev.preventDefault();
    };
    return {
      dragType,
      dragState,
      handleDragStart,
      handleDragEnter,
      handleDragLeave,
      handleDragover,
      handleDragEnd,
      handleDrop
    };
  };
  const useColumnResize = (thRefs, emit) => {
    const resizingColumn = vue.ref("");
    const columnWidth = vue.reactive({});
    const handleThMouseDown = (dataIndex, ev) => {
      ev.preventDefault();
      resizingColumn.value = dataIndex;
      on(window, "mousemove", handleThMouseMoving);
      on(window, "mouseup", handleThMouseUp);
      on(window, "contextmenu", handleThMouseUp);
    };
    const handleThMouseUp = () => {
      resizingColumn.value = "";
      off(window, "mousemove", handleThMouseMoving);
      off(window, "mouseup", handleThMouseUp);
      off(window, "contextmenu", handleThMouseUp);
    };
    const handleThMouseMoving = (ev) => {
      const element = thRefs.value[resizingColumn.value];
      if (element) {
        const { clientX } = ev;
        const { x } = element.getBoundingClientRect();
        let width = Math.ceil(clientX - x);
        if (width < 40) {
          width = 40;
        }
        columnWidth[resizingColumn.value] = width;
        emit("columnResize", resizingColumn.value, width);
      }
    };
    return {
      resizingColumn,
      columnWidth,
      handleThMouseDown,
      handleThMouseUp
    };
  };
  const useFilter = ({
    columns,
    onFilterChange
  }) => {
    const _filters = vue.ref(getDefaultFilters(columns.value));
    vue.watch(columns, (columns2) => {
      const newFilters = getDefaultFilters(columns2);
      if (!isEqual$1(newFilters, _filters.value)) {
        _filters.value = newFilters;
      }
    });
    const computedFilters = vue.computed(() => {
      var _a, _b;
      const filters = {};
      for (const item of columns.value) {
        if (item.dataIndex) {
          const value = (_b = (_a = item.filterable) == null ? void 0 : _a.filteredValue) != null ? _b : _filters.value[item.dataIndex];
          if (value) {
            filters[item.dataIndex] = value;
          }
        }
      }
      return filters;
    });
    const resetFilters = (dataIndex) => {
      var _a;
      const _dataIndex = dataIndex ? [].concat(dataIndex) : [];
      const filters = {};
      for (const item of columns.value) {
        if (item.dataIndex && item.filterable) {
          if (_dataIndex.length === 0 || _dataIndex.includes(item.dataIndex)) {
            const filteredValue = (_a = item.filterable.defaultFilteredValue) != null ? _a : [];
            filters[item.dataIndex] = filteredValue;
            onFilterChange(item.dataIndex, filteredValue);
          }
        }
      }
      _filters.value = filters;
    };
    const clearFilters = (dataIndex) => {
      const _dataIndex = dataIndex ? [].concat(dataIndex) : [];
      const filters = {};
      for (const item of columns.value) {
        if (item.dataIndex && item.filterable) {
          if (_dataIndex.length === 0 || _dataIndex.includes(item.dataIndex)) {
            const filteredValue = [];
            filters[item.dataIndex] = filteredValue;
            onFilterChange(item.dataIndex, filteredValue);
          }
        }
      }
      _filters.value = filters;
    };
    return {
      _filters,
      computedFilters,
      resetFilters,
      clearFilters
    };
  };
  const getDefaultFilters = (columns) => {
    var _a;
    const filters = {};
    for (const item of columns) {
      if (item.dataIndex && ((_a = item.filterable) == null ? void 0 : _a.defaultFilteredValue)) {
        filters[item.dataIndex] = item.filterable.defaultFilteredValue;
      }
    }
    return filters;
  };
  const useSorter = ({
    columns,
    onSorterChange
  }) => {
    const _sorter = vue.ref(getDefaultSorter(columns.value));
    vue.watch(columns, (columns2) => {
      const newSorter = getDefaultSorter(columns2);
      if (!isEqual$1(newSorter, _sorter.value)) {
        _sorter.value = newSorter;
      }
    });
    const computedSorter = vue.computed(() => {
      var _a;
      for (const item of columns.value) {
        if (item.dataIndex && item.sortable) {
          const direction = isString$1(item.sortable.sortOrder) ? item.sortable.sortOrder : ((_a = _sorter.value) == null ? void 0 : _a.field) === item.dataIndex ? _sorter.value.direction : "";
          if (direction) {
            return {
              field: item.dataIndex,
              direction
            };
          }
        }
      }
      return void 0;
    });
    const resetSorters = () => {
      var _a;
      let sorter;
      for (const item of columns.value) {
        if (item.dataIndex && item.sortable) {
          if (!sorter && item.sortable.defaultSortOrder) {
            sorter = {
              field: item.dataIndex,
              direction: item.sortable.defaultSortOrder
            };
          }
          onSorterChange(item.dataIndex, (_a = item.sortable.defaultSortOrder) != null ? _a : "");
        }
      }
      _sorter.value = sorter;
    };
    const clearSorters = () => {
      for (const item of columns.value) {
        if (item.dataIndex && item.sortable) {
          onSorterChange(item.dataIndex, "");
        }
      }
    };
    return {
      _sorter,
      computedSorter,
      resetSorters,
      clearSorters
    };
  };
  const getDefaultSorter = (columns) => {
    var _a;
    for (const item of columns) {
      if (item.dataIndex && ((_a = item.sortable) == null ? void 0 : _a.defaultSortOrder)) {
        return {
          field: item.dataIndex,
          direction: item.sortable.defaultSortOrder
        };
      }
    }
    return void 0;
  };
  const useSpan = ({
    spanMethod,
    data,
    columns
  }) => {
    const flattenTableSpan = (tableData, span) => {
      tableData == null ? void 0 : tableData.forEach((record, rowIndex) => {
        var _a;
        if (record.hasSubtree && ((_a = record.children) == null ? void 0 : _a.length)) {
          flattenTableSpan(record.children || [], span);
        }
        columns.value.forEach((column, columnIndex) => {
          var _a2, _b;
          const { rowspan = 1, colspan = 1 } = (_b = (_a2 = spanMethod.value) == null ? void 0 : _a2.call(spanMethod, {
            record: record.raw,
            column,
            rowIndex,
            columnIndex
          })) != null ? _b : {};
          if (rowspan > 1 || colspan > 1) {
            span[`${rowIndex}-${columnIndex}-${record.key}`] = [rowspan, colspan];
            Array.from({ length: rowspan }).forEach((_, r2) => {
              const key = tableData == null ? void 0 : tableData[rowIndex + r2].key;
              Array.from({ length: colspan }).forEach((_2, c) => {
                if (`${rowIndex}-${columnIndex}-${record.key}` !== `${rowIndex + r2}-${columnIndex + c}-${key}`) {
                  spanzero.value[`${rowIndex + r2}-${columnIndex + c}-${key}`] = [
                    0,
                    0
                  ];
                }
              });
            });
          }
        });
      });
    };
    let spanzero = vue.ref({});
    const tableSpan = vue.computed(() => {
      const span = {};
      spanzero.value = {};
      if (spanMethod.value) {
        flattenTableSpan(data.value, span);
      }
      return span;
    });
    const removedCells = vue.computed(() => {
      const data2 = [];
      for (const indexKey of Object.keys(spanzero.value)) {
        data2.push(indexKey);
      }
      return data2;
    });
    return {
      tableSpan,
      removedCells
    };
  };
  function _isSlot$3(s) {
    return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !vue.isVNode(s);
  }
  const DEFAULT_BORDERED = {
    wrapper: true,
    cell: false,
    headerCell: false,
    bodyCell: false
  };
  var _Table = vue.defineComponent({
    name: "Table",
    props: {
      columns: {
        type: Array,
        default: () => []
      },
      data: {
        type: Array,
        default: () => []
      },
      bordered: {
        type: [Boolean, Object],
        default: true
      },
      hoverable: {
        type: Boolean,
        default: true
      },
      stripe: {
        type: Boolean,
        default: false
      },
      size: {
        type: String,
        default: () => {
          var _a, _b;
          return (_b = (_a = vue.inject(configProviderInjectionKey, void 0)) == null ? void 0 : _a.size) != null ? _b : "large";
        }
      },
      tableLayoutFixed: {
        type: Boolean,
        default: false
      },
      loading: {
        type: [Boolean, Object],
        default: false
      },
      rowSelection: {
        type: Object
      },
      expandable: {
        type: Object
      },
      scroll: {
        type: Object
      },
      pagination: {
        type: [Boolean, Object],
        default: true
      },
      pagePosition: {
        type: String,
        default: "br"
      },
      indentSize: {
        type: Number,
        default: 16
      },
      rowKey: {
        type: String,
        default: "key"
      },
      showHeader: {
        type: Boolean,
        default: true
      },
      virtualListProps: {
        type: Object
      },
      spanMethod: {
        type: Function
      },
      spanAll: {
        type: Boolean,
        default: false
      },
      components: {
        type: Object
      },
      loadMore: {
        type: Function
      },
      filterIconAlignLeft: {
        type: Boolean,
        default: false
      },
      hideExpandButtonOnEmpty: {
        type: Boolean,
        default: false
      },
      rowClass: {
        type: [String, Array, Object, Function]
      },
      draggable: {
        type: Object
      },
      rowNumber: {
        type: [Boolean, Object]
      },
      columnResizable: {
        type: Boolean
      },
      summary: {
        type: [Boolean, Function]
      },
      summaryText: {
        type: String,
        default: "Summary"
      },
      summarySpanMethod: {
        type: Function
      },
      selectedKeys: {
        type: Array
      },
      defaultSelectedKeys: {
        type: Array
      },
      expandedKeys: {
        type: Array
      },
      defaultExpandedKeys: {
        type: Array
      },
      defaultExpandAllRows: {
        type: Boolean,
        default: false
      },
      stickyHeader: {
        type: [Boolean, Number],
        default: false
      },
      scrollbar: {
        type: [Object, Boolean],
        default: true
      }
    },
    emits: {
      "update:selectedKeys": (rowKeys) => true,
      "update:expandedKeys": (rowKeys) => true,
      "expand": (rowKey, record) => true,
      "expandedChange": (rowKeys) => true,
      "select": (rowKeys, rowKey, record) => true,
      "selectAll": (checked) => true,
      "selectionChange": (rowKeys) => true,
      "sorterChange": (dataIndex, direction) => true,
      "filterChange": (dataIndex, filteredValues) => true,
      "pageChange": (page) => true,
      "pageSizeChange": (pageSize) => true,
      "change": (data, extra, currentData) => true,
      "cellMouseEnter": (record, column, ev) => true,
      "cellMouseLeave": (record, column, ev) => true,
      "cellClick": (record, column, ev) => true,
      "rowClick": (record, ev) => true,
      "headerClick": (column, ev) => true,
      "columnResize": (dataIndex, width) => true,
      "rowDblclick": (record, ev) => true,
      "cellDblclick": (record, column, ev) => true,
      "rowContextmenu": (record, ev) => true,
      "cellContextmenu": (record, column, ev) => true
    },
    setup(props, {
      emit,
      slots
    }) {
      const {
        columns,
        rowKey,
        rowSelection,
        expandable,
        loadMore,
        filterIconAlignLeft,
        selectedKeys,
        defaultSelectedKeys,
        expandedKeys,
        defaultExpandedKeys,
        defaultExpandAllRows,
        spanMethod,
        draggable,
        summarySpanMethod,
        scrollbar
      } = vue.toRefs(props);
      const prefixCls = getPrefixCls("table");
      const configCtx = vue.inject(configProviderInjectionKey, void 0);
      const bordered = vue.computed(() => {
        if (isObject$1(props.bordered)) {
          return __spreadValues(__spreadValues({}, DEFAULT_BORDERED), props.bordered);
        }
        return __spreadProps(__spreadValues({}, DEFAULT_BORDERED), {
          wrapper: props.bordered
        });
      });
      const {
        children,
        components: components2
      } = useChildrenComponents("TableColumn");
      const checkStrictly = vue.computed(() => {
        var _a, _b;
        return (_b = (_a = rowSelection.value) == null ? void 0 : _a.checkStrictly) != null ? _b : true;
      });
      const {
        displayScrollbar,
        scrollbarProps
      } = useScrollbar(scrollbar);
      const isScroll2 = vue.computed(() => {
        var _a, _b, _c, _d;
        const x = Boolean(((_a = props.scroll) == null ? void 0 : _a.x) || ((_b = props.scroll) == null ? void 0 : _b.minWidth));
        const y = Boolean(((_c = props.scroll) == null ? void 0 : _c.y) || ((_d = props.scroll) == null ? void 0 : _d.maxHeight));
        return {
          x,
          y
        };
      });
      const summaryRef = vue.ref();
      const thRefs = vue.ref({});
      const {
        componentRef: contentComRef,
        elementRef: contentRef
      } = useComponentRef("containerRef");
      const {
        componentRef: tbodyComRef,
        elementRef: tbodyRef
      } = useComponentRef("containerRef");
      const {
        componentRef: virtualComRef,
        elementRef: virtualRef
      } = useComponentRef("viewportRef");
      const {
        componentRef: theadComRef,
        elementRef: theadRef
      } = useComponentRef("containerRef");
      const containerElement = vue.computed(() => {
        if (splitTable.value) {
          if (isVirtualList.value) {
            return virtualRef.value;
          }
          return tbodyRef.value;
        }
        return contentRef.value;
      });
      const splitTable = vue.computed(() => isScroll2.value.y || props.stickyHeader || isVirtualList.value || isScroll2.value.x && flattenData.value.length === 0);
      const slotColumnMap = vue.reactive(new Map());
      const slotColumns = vue.ref();
      vue.watch([components2, slotColumnMap], ([components3, slotColumnMap2]) => {
        if (components3.length > 0) {
          const columns2 = [];
          components3.forEach((id) => {
            const column = slotColumnMap2.get(id);
            if (column)
              columns2.push(column);
          });
          slotColumns.value = columns2;
        } else {
          slotColumns.value = void 0;
        }
      });
      const dataColumnMap = new Map();
      const dataColumns = vue.ref([]);
      const groupColumns = vue.ref([]);
      const {
        resizingColumn,
        columnWidth,
        handleThMouseDown
      } = useColumnResize(thRefs, emit);
      vue.watch([columns, slotColumns, columnWidth], ([columns2, slotColumns2]) => {
        var _a;
        const result = getGroupColumns((_a = slotColumns2 != null ? slotColumns2 : columns2) != null ? _a : [], dataColumnMap, columnWidth);
        dataColumns.value = result.dataColumns;
        groupColumns.value = result.groupColumns;
      }, {
        immediate: true,
        deep: true
      });
      const isPaginationTop = vue.computed(() => ["tl", "top", "tr"].includes(props.pagePosition));
      const hasLeftFixedColumn = vue.ref(false);
      const hasRightFixedColumn = vue.ref(false);
      const hasLeftFixedDataColumns = vue.ref(false);
      vue.watchEffect(() => {
        var _a, _b, _c;
        let _hasLeftFixedColumn = false;
        let _hasRightFixedColumn = false;
        let _hasLeftFixedDataColumns = false;
        if (((_a = props.rowSelection) == null ? void 0 : _a.fixed) || ((_b = props.expandable) == null ? void 0 : _b.fixed) || ((_c = props.draggable) == null ? void 0 : _c.fixed)) {
          _hasLeftFixedColumn = true;
        }
        for (const column of dataColumns.value) {
          if (column.fixed === "left") {
            _hasLeftFixedColumn = true;
            _hasLeftFixedDataColumns = true;
          } else if (column.fixed === "right") {
            _hasRightFixedColumn = true;
          }
        }
        if (_hasLeftFixedColumn !== hasLeftFixedColumn.value) {
          hasLeftFixedColumn.value = _hasLeftFixedColumn;
        }
        if (_hasRightFixedColumn !== hasRightFixedColumn.value) {
          hasRightFixedColumn.value = _hasRightFixedColumn;
        }
        if (_hasLeftFixedDataColumns !== hasLeftFixedDataColumns.value) {
          hasLeftFixedDataColumns.value = _hasLeftFixedDataColumns;
        }
      });
      const hasEllipsis = vue.computed(() => {
        for (const col of dataColumns.value) {
          if (col.ellipsis) {
            return true;
          }
        }
        return false;
      });
      const handleChange = (type) => {
        const extra = {
          type,
          page: page.value,
          pageSize: pageSize.value,
          sorter: computedSorter.value,
          filters: computedFilters.value,
          dragTarget: type === "drag" ? dragState.data : void 0
        };
        emit("change", flattenRawData.value, extra, sortedData.value);
      };
      const handleFilterChange = (dataIndex, filteredValues) => {
        _filters.value = __spreadProps(__spreadValues({}, computedFilters.value), {
          [dataIndex]: filteredValues
        });
        emit("filterChange", dataIndex, filteredValues);
        handleChange("filter");
      };
      const handleSorterChange = (dataIndex, direction) => {
        _sorter.value = direction ? {
          field: dataIndex,
          direction
        } : void 0;
        emit("sorterChange", dataIndex, direction);
        handleChange("sorter");
      };
      const {
        _filters,
        computedFilters,
        resetFilters,
        clearFilters
      } = useFilter({
        columns: dataColumns,
        onFilterChange: handleFilterChange
      });
      const {
        _sorter,
        computedSorter,
        resetSorters,
        clearSorters
      } = useSorter({
        columns: dataColumns,
        onSorterChange: handleSorterChange
      });
      const disabledKeys = new Set();
      const allRowKeys = vue.computed(() => {
        const allRowKeys2 = [];
        disabledKeys.clear();
        const travelData = (data) => {
          if (isArray$1(data) && data.length > 0) {
            for (const record of data) {
              allRowKeys2.push(record[rowKey.value]);
              if (record.disabled) {
                disabledKeys.add(record[rowKey.value]);
              }
              if (record.children) {
                travelData(record.children);
              }
            }
          }
        };
        travelData(props.data);
        return allRowKeys2;
      });
      const currentAllRowKeys = vue.computed(() => {
        const keys = [];
        const travel = (data) => {
          for (const record of data) {
            keys.push(record.key);
            if (record.children) {
              travel(record.children);
            }
          }
        };
        travel(flattenData.value);
        return keys;
      });
      const currentAllEnabledRowKeys = vue.computed(() => {
        const keys = [];
        const travel = (data) => {
          for (const record of data) {
            if (!record.disabled) {
              keys.push(record.key);
            }
            if (record.children) {
              travel(record.children);
            }
          }
        };
        travel(flattenData.value);
        return keys;
      });
      const {
        isRadio,
        selectedRowKeys,
        currentSelectedRowKeys,
        handleSelect,
        handleSelectAllLeafs,
        handleSelectAll,
        select,
        selectAll,
        clearSelected
      } = useRowSelection({
        selectedKeys,
        defaultSelectedKeys,
        rowSelection,
        currentAllRowKeys,
        currentAllEnabledRowKeys,
        emit
      });
      const {
        expandedRowKeys,
        handleExpand,
        expand,
        expandAll
      } = useExpand({
        expandedKeys,
        defaultExpandedKeys,
        defaultExpandAllRows,
        expandable,
        allRowKeys,
        emit
      });
      const lazyLoadData = vue.reactive({});
      const addLazyLoadData = (children2, record) => {
        if (children2) {
          lazyLoadData[record.key] = children2;
        }
      };
      const isValidRecord = (record) => {
        var _a, _b;
        for (const field of Object.keys(computedFilters.value)) {
          const filteredValues = computedFilters.value[field];
          const column = dataColumnMap.get(field);
          if (column && ((_a = column.filterable) == null ? void 0 : _a.filter) && filteredValues.length > 0) {
            const result = (_b = column.filterable) == null ? void 0 : _b.filter(filteredValues, record.raw);
            if (!result) {
              return result;
            }
          }
        }
        return true;
      };
      const {
        dragType,
        dragState,
        handleDragStart,
        handleDragEnter,
        handleDragLeave,
        handleDragover,
        handleDragEnd,
        handleDrop
      } = useDrag(draggable);
      const processedData = vue.computed(() => {
        var _a;
        const travel = (data) => {
          const result = [];
          for (const _record of data) {
            const record = {
              raw: _record,
              key: _record[props.rowKey],
              disabled: _record.disabled,
              expand: _record.expand,
              isLeaf: _record.isLeaf
            };
            if (_record.children) {
              record.isLeaf = false;
              record.children = travel(_record.children);
            } else if (props.loadMore && !_record.isLeaf) {
              record.isLeaf = false;
              if (lazyLoadData[record.key]) {
                record.children = travel(lazyLoadData[record.key]);
              }
            } else {
              record.isLeaf = true;
            }
            record.hasSubtree = Boolean(record.children ? props.hideExpandButtonOnEmpty ? record.children.length > 0 : true : props.loadMore && !record.isLeaf);
            result.push(record);
          }
          return result;
        };
        return travel((_a = props.data) != null ? _a : []);
      });
      const validData = vue.computed(() => {
        const travel = (data) => data.filter((record) => {
          if (isValidRecord(record)) {
            if (record.children) {
              record.children = travel(record.children);
            }
            return true;
          }
          return false;
        });
        return Object.keys(computedFilters.value).length > 0 ? travel(processedData.value) : processedData.value;
      });
      const sortedData = vue.computed(() => {
        var _a, _b, _c;
        const data = mapArrayWithChildren(validData.value);
        if (data.length > 0) {
          if ((_a = computedSorter.value) == null ? void 0 : _a.field) {
            const column = dataColumnMap.get(computedSorter.value.field);
            if (column && ((_b = column.sortable) == null ? void 0 : _b.sorter) !== true) {
              const {
                field,
                direction
              } = computedSorter.value;
              data.sort((a, b) => {
                var _a2;
                const valueA = getValueByPath(a.raw, field);
                const valueB = getValueByPath(b.raw, field);
                if (((_a2 = column.sortable) == null ? void 0 : _a2.sorter) && isFunction$1(column.sortable.sorter)) {
                  return column.sortable.sorter(a.raw, b.raw, {
                    dataIndex: field,
                    direction
                  });
                }
                const result = valueA > valueB ? 1 : -1;
                return direction === "descend" ? -result : result;
              });
            }
          }
          const {
            sourcePath,
            targetPath
          } = dragState;
          if (dragState.dragging && targetPath.length && targetPath.toString() !== sourcePath.toString()) {
            if (sourcePath.length === targetPath.length && sourcePath.slice(0, -1).toString() === targetPath.slice(0, -1).toString()) {
              let children2 = data;
              for (let i = 0; i < sourcePath.length; i++) {
                const sourceIndex = sourcePath[i];
                const isLast = i >= sourcePath.length - 1;
                if (isLast) {
                  const sourceChild = children2[sourceIndex];
                  const targetIndex = targetPath[i];
                  if (targetIndex > sourceIndex) {
                    children2.splice(targetIndex + 1, 0, sourceChild);
                    children2.splice(sourceIndex, 1);
                  } else {
                    children2.splice(targetIndex, 0, sourceChild);
                    children2.splice(sourceIndex + 1, 1);
                  }
                } else {
                  children2 = (_c = children2[sourceIndex].children) != null ? _c : [];
                }
              }
            }
          }
        }
        return data;
      });
      const {
        page,
        pageSize,
        handlePageChange,
        handlePageSizeChange
      } = usePagination(props, emit);
      const onlyCurrent = vue.computed(() => {
        var _a, _b;
        return (_b = (_a = rowSelection.value) == null ? void 0 : _a.onlyCurrent) != null ? _b : false;
      });
      vue.watch(page, (cur, pre) => {
        if (cur !== pre && onlyCurrent.value) {
          clearSelected();
        }
      });
      const flattenData = vue.computed(() => {
        if (props.pagination && sortedData.value.length > pageSize.value) {
          return sortedData.value.slice((page.value - 1) * pageSize.value, page.value * pageSize.value);
        }
        return sortedData.value;
      });
      const flattenRawData = vue.computed(() => mapRawTableData(flattenData.value));
      const getSummaryData = () => {
        return dataColumns.value.reduce((per, column, index2) => {
          if (column.dataIndex) {
            if (index2 === 0) {
              setValueByPath(per, column.dataIndex, props.summaryText, {
                addPath: true
              });
            } else {
              let count = 0;
              let isNotNumber = false;
              flattenData.value.forEach((data) => {
                if (column.dataIndex) {
                  const _number = getValueByPath(data.raw, column.dataIndex);
                  if (isNumber$1(_number)) {
                    count += _number;
                  } else if (!isUndefined(_number) && !isNull(_number)) {
                    isNotNumber = true;
                  }
                }
              });
              setValueByPath(per, column.dataIndex, isNotNumber ? "" : count, {
                addPath: true
              });
            }
          }
          return per;
        }, {});
      };
      const getTableDataWithRaw = (data) => {
        if (data && data.length > 0) {
          return data.map((raw) => {
            return {
              raw,
              key: raw[props.rowKey]
            };
          });
        }
        return [];
      };
      const summaryData = vue.computed(() => {
        if (props.summary) {
          if (isFunction$1(props.summary)) {
            return getTableDataWithRaw(props.summary({
              columns: dataColumns.value,
              data: flattenRawData.value
            }));
          }
          return getTableDataWithRaw([getSummaryData()]);
        }
        return [];
      });
      const containerScrollLeft = vue.ref(0);
      const alignLeft = vue.ref(true);
      const alignRight = vue.ref(true);
      const setAlignPosition = () => {
        let _alignLeft = true;
        let _alignRight = true;
        const scrollContainer = containerElement.value;
        if (scrollContainer) {
          _alignLeft = containerScrollLeft.value === 0;
          _alignRight = Math.ceil(containerScrollLeft.value + scrollContainer.offsetWidth) >= scrollContainer.scrollWidth;
        }
        if (_alignLeft !== alignLeft.value) {
          alignLeft.value = _alignLeft;
        }
        if (_alignRight !== alignRight.value) {
          alignRight.value = _alignRight;
        }
      };
      const getTableScrollCls = () => {
        if (alignLeft.value && alignRight.value) {
          return `${prefixCls}-scroll-position-both`;
        }
        if (alignLeft.value) {
          return `${prefixCls}-scroll-position-left`;
        }
        if (alignRight.value) {
          return `${prefixCls}-scroll-position-right`;
        }
        return `${prefixCls}-scroll-position-middle`;
      };
      const getTableFixedCls = () => {
        const cls2 = [];
        if (hasLeftFixedColumn.value) {
          cls2.push(`${prefixCls}-has-fixed-col-left`);
        }
        if (hasRightFixedColumn.value) {
          cls2.push(`${prefixCls}-has-fixed-col-right`);
        }
        return cls2;
      };
      const handleScroll = (e2) => {
        if (e2.target.scrollLeft !== containerScrollLeft.value) {
          containerScrollLeft.value = e2.target.scrollLeft;
        }
        setAlignPosition();
      };
      const onTbodyScroll = (e2) => {
        handleScroll(e2);
        const {
          scrollLeft
        } = e2.target;
        if (theadRef.value) {
          theadRef.value.scrollLeft = scrollLeft;
        }
        if (summaryRef.value) {
          summaryRef.value.scrollLeft = scrollLeft;
        }
      };
      const handleRowClick = (record, ev) => {
        emit("rowClick", record.raw, ev);
      };
      const handleRowDblclick = (record, ev) => {
        emit("rowDblclick", record.raw, ev);
      };
      const handleRowContextMenu = (record, ev) => {
        emit("rowContextmenu", record.raw, ev);
      };
      const handleCellClick = (record, column, ev) => {
        emit("cellClick", record.raw, column, ev);
      };
      const handleCellMouseEnter = debounce((record, column, ev) => {
        emit("cellMouseEnter", record.raw, column, ev);
      }, 30);
      const handleCellMouseLeave = debounce((record, column, ev) => {
        emit("cellMouseLeave", record.raw, column, ev);
      }, 30);
      const handleCellDblclick = (record, column, ev) => {
        emit("cellDblclick", record.raw, column, ev);
      };
      const handleCellContextmenu = (record, column, ev) => {
        emit("cellContextmenu", record.raw, column, ev);
      };
      const handleHeaderClick = (column, ev) => {
        emit("headerClick", column, ev);
      };
      const operations = vue.computed(() => {
        var _a, _b;
        const operations2 = [];
        const hasFixedColumn = hasLeftFixedColumn.value || hasRightFixedColumn.value;
        let dragHandle;
        let expand2;
        let selection;
        if (((_a = props.draggable) == null ? void 0 : _a.type) === "handle") {
          dragHandle = {
            name: "drag-handle",
            title: props.draggable.title,
            width: props.draggable.width,
            fixed: props.draggable.fixed || hasFixedColumn
          };
          operations2.push(dragHandle);
        }
        if (props.expandable) {
          expand2 = {
            name: "expand",
            title: props.expandable.title,
            width: props.expandable.width,
            fixed: props.expandable.fixed || hasFixedColumn
          };
          operations2.push(expand2);
        }
        if (props.rowSelection) {
          selection = {
            name: props.rowSelection.type === "radio" ? "selection-radio" : "selection-checkbox",
            title: props.rowSelection.title,
            width: props.rowSelection.width,
            fixed: props.rowSelection.fixed || hasFixedColumn
          };
          operations2.push(selection);
        }
        if (!hasLeftFixedDataColumns.value && operations2.length > 0 && operations2[operations2.length - 1].fixed) {
          operations2[operations2.length - 1].isLastLeftFixed = true;
        }
        const operationsFn = (_b = props.components) == null ? void 0 : _b.operations;
        return isFunction$1(operationsFn) ? operationsFn({
          dragHandle,
          expand: expand2,
          selection
        }) : operations2;
      });
      const headerStyle = vue.computed(() => {
        var _a, _b, _c, _d;
        if (isScroll2.value.x) {
          const style2 = {
            width: isNumber$1((_a = props.scroll) == null ? void 0 : _a.x) ? `${(_b = props.scroll) == null ? void 0 : _b.x}px` : (_c = props.scroll) == null ? void 0 : _c.x
          };
          if ((_d = props.scroll) == null ? void 0 : _d.minWidth) {
            style2.minWidth = isNumber$1(props.scroll.minWidth) ? `${props.scroll.minWidth}px` : props.scroll.minWidth;
          }
          return style2;
        }
        return void 0;
      });
      const contentStyle = vue.computed(() => {
        var _a, _b, _c, _d;
        if (isScroll2.value.x && flattenData.value.length > 0) {
          const style2 = {
            width: isNumber$1((_a = props.scroll) == null ? void 0 : _a.x) ? `${(_b = props.scroll) == null ? void 0 : _b.x}px` : (_c = props.scroll) == null ? void 0 : _c.x
          };
          if ((_d = props.scroll) == null ? void 0 : _d.minWidth) {
            style2.minWidth = isNumber$1(props.scroll.minWidth) ? `${props.scroll.minWidth}px` : props.scroll.minWidth;
          }
          return style2;
        }
        return void 0;
      });
      const addColumn = (id, column) => {
        slotColumnMap.set(id, column);
      };
      const removeColumn = (id) => {
        slotColumnMap.delete(id);
      };
      vue.provide(tableInjectionKey, vue.reactive({
        loadMore,
        addLazyLoadData,
        slots,
        sorter: computedSorter,
        filters: computedFilters,
        filterIconAlignLeft,
        resizingColumn,
        checkStrictly,
        currentAllEnabledRowKeys,
        currentSelectedRowKeys,
        addColumn,
        removeColumn,
        onSelectAll: handleSelectAll,
        onSelect: handleSelect,
        onSelectAllLeafs: handleSelectAllLeafs,
        onSorterChange: handleSorterChange,
        onFilterChange: handleFilterChange,
        onThMouseDown: handleThMouseDown
      }));
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-size-${props.size}`, {
        [`${prefixCls}-border`]: bordered.value.wrapper,
        [`${prefixCls}-border-cell`]: bordered.value.cell,
        [`${prefixCls}-border-header-cell`]: !bordered.value.cell && bordered.value.headerCell,
        [`${prefixCls}-border-body-cell`]: !bordered.value.cell && bordered.value.bodyCell,
        [`${prefixCls}-stripe`]: props.stripe,
        [`${prefixCls}-hover`]: props.hoverable,
        [`${prefixCls}-dragging`]: dragState.dragging,
        [`${prefixCls}-type-selection`]: Boolean(props.rowSelection),
        [`${prefixCls}-empty`]: props.data && flattenData.value.length === 0,
        [`${prefixCls}-layout-fixed`]: props.tableLayoutFixed || isScroll2.value.x || splitTable.value || hasEllipsis.value
      }]);
      const paginationCls = vue.computed(() => [`${prefixCls}-pagination`, {
        [`${prefixCls}-pagination-left`]: props.pagePosition === "tl" || props.pagePosition === "bl",
        [`${prefixCls}-pagination-center`]: props.pagePosition === "top" || props.pagePosition === "bottom",
        [`${prefixCls}-pagination-right`]: props.pagePosition === "tr" || props.pagePosition === "br",
        [`${prefixCls}-pagination-top`]: isPaginationTop.value
      }]);
      const tableCls = vue.computed(() => {
        const cls2 = getTableFixedCls();
        if (isScroll2.value.x) {
          cls2.push(getTableScrollCls());
        }
        if (splitTable.value) {
          cls2.push(`${prefixCls}-scroll-y`);
        }
        return cls2;
      });
      const isVirtualList = vue.computed(() => Boolean(props.virtualListProps));
      const thWidth = vue.ref({});
      const getThWidth = () => {
        const width = {};
        for (const key of Object.keys(thRefs.value)) {
          width[key] = thRefs.value[key].offsetWidth;
        }
        thWidth.value = width;
      };
      const hasScrollBar = vue.ref(false);
      const isTbodyHasScrollBar = () => {
        if (tbodyRef.value) {
          return tbodyRef.value.offsetWidth > tbodyRef.value.clientWidth;
        }
        return false;
      };
      const handleTbodyResize = () => {
        const _hasScrollBar = isTbodyHasScrollBar();
        if (hasScrollBar.value !== _hasScrollBar) {
          hasScrollBar.value = _hasScrollBar;
        }
        setAlignPosition();
        getThWidth();
      };
      vue.onMounted(() => {
        hasScrollBar.value = isTbodyHasScrollBar();
        getThWidth();
      });
      const spinProps = vue.computed(() => isObject$1(props.loading) ? props.loading : {
        loading: props.loading
      });
      const renderEmpty = () => {
        return vue.createVNode(Tr, {
          "empty": true
        }, {
          default: () => [vue.createVNode(Td, {
            "colSpan": dataColumns.value.length + operations.value.length
          }, {
            default: () => {
              var _a, _b, _c, _d, _e;
              return [(_e = (_d = (_a = slots.empty) == null ? void 0 : _a.call(slots)) != null ? _d : (_c = configCtx == null ? void 0 : (_b = configCtx.slots).empty) == null ? void 0 : _c.call(_b, {
                component: "table"
              })) != null ? _e : vue.createVNode(Empty, null, null)];
            }
          })]
        });
      };
      const renderExpandContent = (record) => {
        var _a;
        if (record.expand) {
          return isFunction$1(record.expand) ? record.expand() : record.expand;
        }
        if (slots["expand-row"]) {
          return slots["expand-row"]({
            record: record.raw
          });
        }
        if ((_a = props.expandable) == null ? void 0 : _a.expandedRowRender) {
          return props.expandable.expandedRowRender(record.raw);
        }
        return void 0;
      };
      const allColumns = vue.computed(() => [].concat(operations.value, dataColumns.value));
      const spanColumns = vue.computed(() => props.spanAll ? allColumns.value : dataColumns.value);
      const {
        tableSpan,
        removedCells
      } = useSpan({
        spanMethod,
        data: flattenData,
        columns: spanColumns
      });
      const {
        tableSpan: tableSummarySpan,
        removedCells: removedSummaryCells
      } = useSpan({
        spanMethod: summarySpanMethod,
        data: summaryData,
        columns: allColumns
      });
      const getVirtualColumnStyle = (name) => {
        if (!isVirtualList.value || !name || !thWidth.value[name]) {
          return void 0;
        }
        return {
          width: `${thWidth.value[name]}px`
        };
      };
      const renderSummaryRow = (record, rowIndex) => {
        return vue.createVNode(Tr, {
          "key": `table-summary-${rowIndex}`,
          "class": [`${prefixCls}-tr-summary`, isFunction$1(props.rowClass) ? props.rowClass(record.raw, rowIndex) : props.rowClass],
          "onClick": (ev) => handleRowClick(record, ev)
        }, {
          default: () => [operations.value.map((operation, index2) => {
            var _a;
            const cellId = `${rowIndex}-${index2}-${record.key}`;
            const [rowspan, colspan] = (_a = tableSummarySpan.value[cellId]) != null ? _a : [1, 1];
            if (removedSummaryCells.value.includes(cellId)) {
              return null;
            }
            const style2 = getVirtualColumnStyle(operation.name);
            return vue.createVNode(OperationTd, {
              "style": style2,
              "operationColumn": operation,
              "operations": operations.value,
              "record": record,
              "rowSpan": rowspan,
              "colSpan": colspan,
              "summary": true
            }, null);
          }), dataColumns.value.map((column, index2) => {
            var _a;
            const cellId = `${rowIndex}-${operations.value.length + index2}-${record.key}`;
            const [rowspan, colspan] = (_a = tableSummarySpan.value[cellId]) != null ? _a : [1, 1];
            if (removedSummaryCells.value.includes(cellId)) {
              return null;
            }
            const style2 = getVirtualColumnStyle(column.dataIndex);
            return vue.createVNode(Td, {
              "key": `td-${cellId}`,
              "style": style2,
              "rowIndex": rowIndex,
              "record": record,
              "column": column,
              "operations": operations.value,
              "dataColumns": dataColumns.value,
              "rowSpan": rowspan,
              "colSpan": colspan,
              "summary": true,
              "onClick": (ev) => handleCellClick(record, column, ev),
              "onDblclick": (ev) => handleCellDblclick(record, column, ev),
              "onMouseenter": (ev) => handleCellMouseEnter(record, column, ev),
              "onMouseleave": (ev) => handleCellMouseLeave(record, column, ev),
              "onContextmenu": (ev) => handleCellContextmenu(record, column, ev)
            }, {
              td: slots.td,
              cell: slots["summary-cell"]
            });
          })],
          tr: slots.tr
        });
      };
      const renderSummary = () => {
        if (summaryData.value && summaryData.value.length > 0) {
          return vue.createVNode("tfoot", null, [summaryData.value.map((data, index2) => renderSummaryRow(data, index2))]);
        }
        return null;
      };
      const renderExpandBtn = (record, stopPropagation = true) => {
        var _a, _b, _c, _d, _e;
        const currentKey = record.key;
        const expanded = expandedRowKeys.value.includes(currentKey);
        return vue.createVNode("button", {
          "type": "button",
          "class": `${prefixCls}-expand-btn`,
          "onClick": (ev) => {
            handleExpand(currentKey, record.raw);
            if (stopPropagation) {
              ev.stopPropagation();
            }
          }
        }, [(_e = (_d = (_a = slots["expand-icon"]) == null ? void 0 : _a.call(slots, {
          expanded,
          record: record.raw
        })) != null ? _d : (_c = (_b = props.expandable) == null ? void 0 : _b.icon) == null ? void 0 : _c.call(_b, expanded, record.raw)) != null ? _e : expanded ? vue.createVNode(IconMinus, null, null) : vue.createVNode(IconPlus, null, null)]);
      };
      const renderExpand = (record, {
        indentSize,
        indexPath,
        allowDrag,
        expandContent
      }) => {
        var _a;
        if (record.hasSubtree) {
          return (_a = record.children) == null ? void 0 : _a.map((item, index2) => renderRecord(item, index2, {
            indentSize,
            indexPath,
            allowDrag
          }));
        }
        if (expandContent) {
          const scrollContainer = containerElement.value;
          return vue.createVNode(Tr, {
            "key": `${record.key}-expand`,
            "expand": true
          }, {
            default: () => [vue.createVNode(Td, {
              "isFixedExpand": hasLeftFixedColumn.value || hasRightFixedColumn.value,
              "containerWidth": scrollContainer == null ? void 0 : scrollContainer.clientWidth,
              "colSpan": dataColumns.value.length + operations.value.length
            }, _isSlot$3(expandContent) ? expandContent : {
              default: () => [expandContent]
            })]
          });
        }
        return null;
      };
      const renderRecord = (record, rowIndex, {
        indentSize = 0,
        indexPath,
        allowDrag = true
      } = {}) => {
        var _a;
        const currentKey = record.key;
        const currentPath = (indexPath != null ? indexPath : []).concat(rowIndex);
        const expandContent = renderExpandContent(record);
        const showExpand = expandedRowKeys.value.includes(currentKey);
        const isDragTarget = dragState.sourceKey === record.key;
        const dragSourceEvent = dragType.value ? {
          draggable: allowDrag,
          onDragstart: (ev) => {
            if (!allowDrag)
              return;
            handleDragStart(ev, record.key, currentPath, record.raw);
          },
          onDragend: (ev) => {
            if (!allowDrag)
              return;
            handleDragEnd(ev);
          }
        } : {};
        const dragTargetEvent = dragType.value ? {
          onDragenter: (ev) => {
            if (!allowDrag)
              return;
            handleDragEnter(ev, currentPath);
          },
          onDragover: (ev) => {
            if (!allowDrag)
              return;
            handleDragover(ev);
          },
          onDrop: (ev) => {
            if (!allowDrag)
              return;
            handleChange("drag");
            handleDrop(ev);
          }
        } : {};
        return vue.createVNode(vue.Fragment, null, [vue.createVNode(Tr, vue.mergeProps({
          "key": currentKey,
          "class": [{
            [`${prefixCls}-tr-draggable`]: dragType.value === "row",
            [`${prefixCls}-tr-drag`]: isDragTarget
          }, isFunction$1(props.rowClass) ? props.rowClass(record.raw, rowIndex) : props.rowClass],
          "rowIndex": rowIndex,
          "record": record,
          "checked": (_a = selectedRowKeys.value) == null ? void 0 : _a.includes(currentKey),
          "onClick": (ev) => handleRowClick(record, ev),
          "onDblclick": (ev) => handleRowDblclick(record, ev),
          "onContextmenu": (ev) => handleRowContextMenu(record, ev)
        }, dragType.value === "row" ? dragSourceEvent : {}, dragTargetEvent), {
          default: () => [operations.value.map((operation, index2) => {
            var _a2;
            const cellId = `${rowIndex}-${index2}-${record.key}`;
            const [rowspan, colspan] = props.spanAll ? (_a2 = tableSpan.value[cellId]) != null ? _a2 : [1, 1] : [1, 1];
            if (props.spanAll && removedCells.value.includes(cellId)) {
              return null;
            }
            const style2 = getVirtualColumnStyle(operation.name);
            return vue.createVNode(OperationTd, vue.mergeProps({
              "key": `operation-td-${index2}`,
              "style": style2,
              "operationColumn": operation,
              "operations": operations.value,
              "record": record,
              "hasExpand": Boolean(expandContent),
              "selectedRowKeys": currentSelectedRowKeys.value,
              "rowSpan": rowspan,
              "colSpan": colspan,
              "renderExpandBtn": renderExpandBtn
            }, dragType.value === "handle" ? dragSourceEvent : {}), {
              "drag-handle-icon": slots["drag-handle-icon"]
            });
          }), dataColumns.value.map((column, index2) => {
            var _a2;
            const cellId = `${rowIndex}-${props.spanAll ? operations.value.length + index2 : index2}-${record.key}`;
            const [rowspan, colspan] = (_a2 = tableSpan.value[cellId]) != null ? _a2 : [1, 1];
            if (removedCells.value.includes(cellId)) {
              return null;
            }
            const extraProps = index2 === 0 ? {
              showExpandBtn: record.hasSubtree,
              indentSize: record.hasSubtree ? indentSize - 20 : indentSize
            } : {};
            const style2 = getVirtualColumnStyle(column.dataIndex);
            return vue.createVNode(Td, vue.mergeProps({
              "key": `td-${index2}`,
              "style": style2,
              "rowIndex": rowIndex,
              "record": record,
              "column": column,
              "operations": operations.value,
              "dataColumns": dataColumns.value,
              "rowSpan": rowspan,
              "renderExpandBtn": renderExpandBtn,
              "colSpan": colspan
            }, extraProps, {
              "onClick": (ev) => handleCellClick(record, column, ev),
              "onDblclick": (ev) => handleCellDblclick(record, column, ev),
              "onMouseenter": (ev) => handleCellMouseEnter(record, column, ev),
              "onMouseleave": (ev) => handleCellMouseLeave(record, column, ev),
              "onContextmenu": (ev) => handleCellContextmenu(record, column, ev)
            }), {
              td: slots.td
            });
          })],
          tr: slots.tr
        }), showExpand && renderExpand(record, {
          indentSize: indentSize + props.indentSize,
          indexPath: currentPath,
          allowDrag: allowDrag && !isDragTarget,
          expandContent
        })]);
      };
      const renderBody = () => {
        const hasSubData = flattenData.value.some((record) => Boolean(record.hasSubtree));
        return vue.createVNode(Tbody, null, {
          default: () => [flattenData.value.length > 0 ? flattenData.value.map((record, index2) => renderRecord(record, index2, {
            indentSize: hasSubData ? 20 : 0
          })) : renderEmpty()],
          tbody: slots.tbody
        });
      };
      const renderHeader = () => vue.createVNode(Thead, null, {
        default: () => [groupColumns.value.map((row, index2) => vue.createVNode(Tr, {
          "key": `header-row-${index2}`
        }, {
          default: () => [index2 === 0 && operations.value.map((operation, index3) => {
            var _a;
            return vue.createVNode(OperationTh, {
              "key": `operation-th-${index3}`,
              "ref": (ins) => {
                if ((ins == null ? void 0 : ins.$el) && operation.name) {
                  thRefs.value[operation.name] = ins.$el;
                }
              },
              "operationColumn": operation,
              "operations": operations.value,
              "selectAll": Boolean(operation.name === "selection-checkbox" && ((_a = props.rowSelection) == null ? void 0 : _a.showCheckedAll)),
              "rowSpan": groupColumns.value.length
            }, null);
          }), row.map((column, index3) => {
            const resizable = props.columnResizable && Boolean(column.dataIndex) && index3 < row.length - 1;
            return vue.createVNode(Th, {
              "key": `th-${index3}`,
              "ref": (ins) => {
                if ((ins == null ? void 0 : ins.$el) && column.dataIndex) {
                  thRefs.value[column.dataIndex] = ins.$el;
                }
              },
              "column": column,
              "operations": operations.value,
              "dataColumns": dataColumns.value,
              "resizable": resizable,
              "onClick": (ev) => handleHeaderClick(column, ev)
            }, {
              th: slots.th
            });
          })]
        }))],
        thead: slots.thead
      });
      const renderContent = () => {
        if (splitTable.value) {
          const style2 = {};
          if (hasScrollBar.value) {
            style2.overflowY = "scroll";
          }
          if (isNumber$1(props.stickyHeader)) {
            style2.top = `${props.stickyHeader}px`;
          }
          const Component = displayScrollbar.value ? Scrollbar : "div";
          return vue.createVNode(vue.Fragment, null, [props.showHeader && vue.createVNode(Component, vue.mergeProps({
            "ref": theadComRef,
            "class": [`${prefixCls}-header`, {
              [`${prefixCls}-header-sticky`]: props.stickyHeader
            }],
            "style": style2
          }, scrollbar.value ? __spreadValues({
            hide: flattenData.value.length !== 0,
            disableVertical: true
          }, scrollbarProps.value) : void 0), {
            default: () => [vue.createVNode("table", {
              "class": `${prefixCls}-element`,
              "style": headerStyle.value,
              "cellpadding": 0,
              "cellspacing": 0
            }, [vue.createVNode(ColGroup, {
              "dataColumns": dataColumns.value,
              "operations": operations.value,
              "columnWidth": columnWidth
            }, null), renderHeader()])]
          }), vue.createVNode(ResizeObserver$1, {
            "onResize": handleTbodyResize
          }, {
            default: () => {
              var _a, _b;
              return [isVirtualList.value ? vue.createVNode(VirtualList, vue.mergeProps({
                "ref": (ins) => {
                  if (ins == null ? void 0 : ins.$el)
                    tbodyRef.value = ins.$el;
                },
                "class": `${prefixCls}-body`,
                "data": flattenData.value,
                "itemKey": "_key",
                "component": {
                  list: "table",
                  content: "tbody"
                },
                "listAttrs": {
                  class: `${prefixCls}-element`,
                  style: contentStyle.value
                },
                "paddingPosition": "list"
              }, props.virtualListProps, {
                "onScroll": onTbodyScroll
              }), {
                item: ({
                  item,
                  index: index2
                }) => renderRecord(item, index2)
              }) : vue.createVNode(Component, vue.mergeProps({
                "ref": tbodyComRef,
                "class": `${prefixCls}-body`,
                "style": {
                  maxHeight: isNumber$1((_a = props.scroll) == null ? void 0 : _a.y) ? `${(_b = props.scroll) == null ? void 0 : _b.y}px` : "100%"
                }
              }, scrollbar.value ? __spreadValues({
                outerStyle: {
                  display: "flex",
                  minHeight: "0"
                }
              }, scrollbarProps.value) : void 0, {
                "onScroll": onTbodyScroll
              }), {
                default: () => [vue.createVNode("table", {
                  "class": `${prefixCls}-element`,
                  "style": contentStyle.value,
                  "cellpadding": 0,
                  "cellspacing": 0
                }, [flattenData.value.length !== 0 && vue.createVNode(ColGroup, {
                  "dataColumns": dataColumns.value,
                  "operations": operations.value,
                  "columnWidth": columnWidth
                }, null), renderBody()])]
              })];
            }
          }), summaryData.value && summaryData.value.length > 0 && vue.createVNode("div", {
            "ref": summaryRef,
            "class": `${prefixCls}-tfoot`,
            "style": {
              overflowY: hasScrollBar.value ? "scroll" : "hidden"
            }
          }, [vue.createVNode("table", {
            "class": `${prefixCls}-element`,
            "style": contentStyle.value,
            "cellpadding": 0,
            "cellspacing": 0
          }, [vue.createVNode(ColGroup, {
            "dataColumns": dataColumns.value,
            "operations": operations.value,
            "columnWidth": columnWidth
          }, null), renderSummary()])])]);
        }
        return vue.createVNode(ResizeObserver$1, {
          "onResize": () => setAlignPosition()
        }, {
          default: () => [vue.createVNode("table", {
            "class": `${prefixCls}-element`,
            "cellpadding": 0,
            "cellspacing": 0,
            "style": contentStyle.value
          }, [vue.createVNode(ColGroup, {
            "dataColumns": dataColumns.value,
            "operations": operations.value,
            "columnWidth": columnWidth
          }, null), props.showHeader && renderHeader(), renderBody(), summaryData.value && summaryData.value.length > 0 && renderSummary()])]
        });
      };
      const renderTable = (content) => {
        var _a;
        const style2 = ((_a = props.scroll) == null ? void 0 : _a.maxHeight) ? {
          maxHeight: props.scroll.maxHeight
        } : void 0;
        const Component = displayScrollbar.value ? Scrollbar : "div";
        return vue.createVNode(vue.Fragment, null, [vue.createVNode("div", {
          "class": [`${prefixCls}-container`, tableCls.value]
        }, [vue.createVNode(Component, vue.mergeProps({
          "ref": contentComRef,
          "class": [`${prefixCls}-content`, {
            [`${prefixCls}-content-scroll-x`]: !splitTable.value
          }],
          "style": style2
        }, scrollbar.value ? __spreadValues({
          outerStyle: {
            height: "100%"
          }
        }, scrollbarProps.value) : void 0, {
          "onScroll": handleScroll
        }), {
          default: () => [content ? vue.createVNode("table", {
            "class": `${prefixCls}-element`,
            "cellpadding": 0,
            "cellspacing": 0
          }, [content()]) : renderContent()]
        })]), slots.footer && vue.createVNode("div", {
          "class": `${prefixCls}-footer`
        }, [slots.footer()])]);
      };
      const renderPagination = () => {
        var _a, _b;
        const paginationProps = isObject$1(props.pagination) ? omit(props.pagination, ["current", "pageSize", "defaultCurrent", "defaultPageSize"]) : {};
        return vue.createVNode("div", {
          "class": paginationCls.value
        }, [(_a = slots["pagination-left"]) == null ? void 0 : _a.call(slots), vue.createVNode(Pagination, vue.mergeProps({
          "total": validData.value.length,
          "current": page.value,
          "pageSize": pageSize.value,
          "onChange": (page2) => {
            handlePageChange(page2);
            handleChange("pagination");
          },
          "onPageSizeChange": (pageSize2) => {
            handlePageSizeChange(pageSize2);
            handleChange("pagination");
          }
        }, paginationProps), null), (_b = slots["pagination-right"]) == null ? void 0 : _b.call(slots)]);
      };
      const style = vue.computed(() => {
        var _a, _b;
        if (isString$1((_a = props.scroll) == null ? void 0 : _a.y)) {
          return {
            height: (_b = props.scroll) == null ? void 0 : _b.y
          };
        }
        return void 0;
      });
      const render = () => {
        var _a;
        if (slots.default) {
          return vue.createVNode("div", {
            "class": cls.value
          }, [renderTable(slots.default)]);
        }
        children.value = (_a = slots.columns) == null ? void 0 : _a.call(slots);
        return vue.createVNode("div", {
          "class": cls.value,
          "style": style.value
        }, [children.value, vue.createVNode(Spin, spinProps.value, {
          default: () => [props.pagination !== false && (flattenData.value.length > 0 || sortedData.value.length > 0) && isPaginationTop.value && renderPagination(), renderTable(), props.pagination !== false && (flattenData.value.length > 0 || sortedData.value.length > 0) && !isPaginationTop.value && renderPagination()]
        })]);
      };
      return {
        render,
        selfExpand: expand,
        selfExpandAll: expandAll,
        selfSelect: select,
        selfSelectAll: selectAll,
        selfResetFilters: resetFilters,
        selfClearFilters: clearFilters,
        selfResetSorters: resetSorters,
        selfClearSorters: clearSorters
      };
    },
    methods: {
      selectAll(checked) {
        return this.selfSelectAll(checked);
      },
      select(rowKey, checked) {
        return this.selfSelect(rowKey, checked);
      },
      expandAll(checked) {
        return this.selfExpandAll(checked);
      },
      expand(rowKey, checked) {
        return this.selfExpand(rowKey, checked);
      },
      resetFilters(dataIndex) {
        return this.selfResetFilters(dataIndex);
      },
      clearFilters(dataIndex) {
        return this.selfClearFilters(dataIndex);
      },
      resetSorters() {
        return this.selfResetSorters();
      },
      clearSorters() {
        return this.selfClearSorters();
      }
    },
    render() {
      return this.render();
    }
  });
  const usePureProp = (props, name) => {
    const _value = vue.toRef(props, name);
    const value = vue.ref(_value.value);
    vue.watch(_value, (cur, pre) => {
      if (!isEqual$1(cur, pre)) {
        value.value = cur;
      }
    });
    return value;
  };
  var TableColumn = vue.defineComponent({
    name: "TableColumn",
    props: {
      dataIndex: String,
      title: String,
      width: Number,
      align: {
        type: String
      },
      fixed: {
        type: String
      },
      ellipsis: {
        type: Boolean,
        default: false
      },
      sortable: {
        type: Object,
        default: void 0
      },
      filterable: {
        type: Object,
        default: void 0
      },
      cellClass: {
        type: [String, Array, Object]
      },
      headerCellClass: {
        type: [String, Array, Object]
      },
      bodyCellClass: {
        type: [String, Array, Object, Function]
      },
      summaryCellClass: {
        type: [String, Array, Object, Function]
      },
      cellStyle: {
        type: Object
      },
      headerCellStyle: {
        type: Object
      },
      bodyCellStyle: {
        type: [Object, Function]
      },
      summaryCellStyle: {
        type: [Object, Function]
      },
      index: {
        type: Number
      },
      tooltip: {
        type: [Boolean, Object],
        default: false
      }
    },
    setup(props, {
      slots
    }) {
      var _a;
      const {
        dataIndex,
        title,
        width,
        align,
        fixed,
        ellipsis,
        index: index2
      } = vue.toRefs(props);
      const sortable = usePureProp(props, "sortable");
      const filterable = usePureProp(props, "filterable");
      const cellClass = usePureProp(props, "cellClass");
      const headerCellClass = usePureProp(props, "headerCellClass");
      const bodyCellClass = usePureProp(props, "bodyCellClass");
      const summaryCellClass = usePureProp(props, "summaryCellClass");
      const cellStyle = usePureProp(props, "cellStyle");
      const headerCellStyle = usePureProp(props, "headerCellStyle");
      const bodyCellStyle = usePureProp(props, "bodyCellStyle");
      const summaryCellStyle = usePureProp(props, "summaryCellStyle");
      const tooltip = usePureProp(props, "tooltip");
      const instance = vue.getCurrentInstance();
      const tableCtx = vue.inject(tableInjectionKey, {});
      const tableColumnCtx = vue.inject(tableColumnInjectionKey, void 0);
      const {
        children,
        components: components2
      } = useChildrenComponents("TableColumn");
      const childrenColumnMap = vue.reactive(new Map());
      const addChild = (id, data) => {
        childrenColumnMap.set(id, data);
      };
      const removeChild = (id) => {
        childrenColumnMap.delete(id);
      };
      vue.provide(tableColumnInjectionKey, {
        addChild,
        removeChild
      });
      const childrenColumns = vue.ref();
      vue.watch([components2, childrenColumnMap], ([components3, childrenColumnMap2]) => {
        if (components3.length > 0) {
          const columns = [];
          components3.forEach((id) => {
            const column2 = childrenColumnMap2.get(id);
            if (column2)
              columns.push(column2);
          });
          childrenColumns.value = columns;
        } else {
          childrenColumns.value = void 0;
        }
      });
      const column = vue.reactive({
        dataIndex,
        title,
        width,
        align,
        fixed,
        ellipsis,
        sortable,
        filterable,
        cellClass,
        headerCellClass,
        bodyCellClass,
        summaryCellClass,
        cellStyle,
        headerCellStyle,
        bodyCellStyle,
        summaryCellStyle,
        index: index2,
        tooltip,
        children: childrenColumns,
        slots
      });
      if (instance) {
        if (tableColumnCtx) {
          tableColumnCtx.addChild(instance.uid, column);
        } else {
          (_a = tableCtx.addColumn) == null ? void 0 : _a.call(tableCtx, instance.uid, column);
        }
      }
      vue.onBeforeUnmount(() => {
        var _a2;
        if (instance) {
          if (tableColumnCtx) {
            tableColumnCtx.removeChild(instance.uid);
          } else {
            (_a2 = tableCtx.removeColumn) == null ? void 0 : _a2.call(tableCtx, instance.uid);
          }
        }
      });
      return () => {
        var _a2;
        children.value = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
        return children.value;
      };
    }
  });
  const Table = Object.assign(_Table, {
    Thead,
    Tbody,
    Tr,
    Th,
    Td,
    Column: TableColumn,
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Table.name, _Table);
      app.component(componentPrefix + Thead.name, Thead);
      app.component(componentPrefix + Tbody.name, Tbody);
      app.component(componentPrefix + Tr.name, Tr);
      app.component(componentPrefix + Th.name, Th);
      app.component(componentPrefix + Td.name, Td);
      app.component(componentPrefix + TableColumn.name, TableColumn);
    }
  });
  const getTabListStyle = ({
    direction,
    type,
    offset
  }) => {
    if (direction === "vertical") {
      return { transform: `translateY(${-offset}px)` };
    }
    return { transform: `translateX(${-offset}px)` };
  };
  const tabsInjectionKey = Symbol("ArcoTabs");
  const _sfc_main$q = vue.defineComponent({
    name: "TabsTab",
    components: {
      IconHover,
      IconClose
    },
    props: {
      tab: {
        type: Object,
        required: true
      },
      active: Boolean,
      editable: Boolean
    },
    emits: ["click", "delete"],
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("tabs-tab");
      const tabsCtx = vue.inject(tabsInjectionKey, {});
      const handleClick = (e2) => {
        if (!props.tab.disabled) {
          emit("click", props.tab.key, e2);
        }
      };
      const onKeyDown = (ev) => {
        if (ev.key === "Enter") {
          handleClick(ev);
        }
      };
      const eventHandlers = vue.computed(() => {
        return Object.assign(tabsCtx.trigger === "click" ? { onClick: handleClick } : { onMouseover: handleClick }, { onKeydown: onKeyDown });
      });
      const handleDelete = (e2) => {
        if (!props.tab.disabled) {
          emit("delete", props.tab.key, e2);
        }
      };
      const cls = vue.computed(() => [
        prefixCls,
        {
          [`${prefixCls}-active`]: props.active,
          [`${prefixCls}-closable`]: props.editable && props.tab.closable,
          [`${prefixCls}-disabled`]: props.tab.disabled
        }
      ]);
      return {
        prefixCls,
        cls,
        eventHandlers,
        handleDelete
      };
    }
  });
  function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_icon_close = vue.resolveComponent("icon-close");
    const _component_icon_hover = vue.resolveComponent("icon-hover");
    return vue.openBlock(), vue.createElementBlock("div", vue.mergeProps({
      tabindex: "0",
      class: _ctx.cls
    }, _ctx.eventHandlers), [
      vue.createElementVNode("span", {
        class: vue.normalizeClass(`${_ctx.prefixCls}-title`)
      }, [
        vue.renderSlot(_ctx.$slots, "default")
      ], 2),
      _ctx.editable && _ctx.tab.closable ? (vue.openBlock(), vue.createBlock(_component_icon_hover, {
        key: 0,
        class: vue.normalizeClass(`${_ctx.prefixCls}-close-btn`),
        onClick: vue.withModifiers(_ctx.handleDelete, ["stop"])
      }, {
        default: vue.withCtx(() => [
          vue.createVNode(_component_icon_close)
        ]),
        _: 1
      }, 8, ["class", "onClick"])) : vue.createCommentVNode("v-if", true)
    ], 16);
  }
  var TabsTab = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["render", _sfc_render$p]]);
  function _isSlot$2(s) {
    return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !vue.isVNode(s);
  }
  var TabsButton = vue.defineComponent({
    name: "TabsButton",
    props: {
      type: {
        type: String,
        default: "next"
      },
      direction: {
        type: String,
        default: "horizontal"
      },
      disabled: {
        type: Boolean,
        default: false
      },
      onClick: {
        type: Function
      }
    },
    emits: ["click"],
    setup(props, {
      emit
    }) {
      const prefixCls = getPrefixCls("tabs-nav-button");
      const handleClick = (ev) => {
        if (!props.disabled) {
          emit("click", props.type, ev);
        }
      };
      const renderIcon = () => {
        if (props.direction === "horizontal") {
          if (props.type === "next") {
            return vue.createVNode(IconRight, null, null);
          }
          return vue.createVNode(IconLeft, null, null);
        }
        if (props.type === "next") {
          return vue.createVNode(IconDown, null, null);
        }
        return vue.createVNode(IconUp, null, null);
      };
      const cls = vue.computed(() => [prefixCls, {
        [`${prefixCls}-disabled`]: props.disabled,
        [`${prefixCls}-left`]: props.direction === "horizontal" && props.type === "previous",
        [`${prefixCls}-right`]: props.direction === "horizontal" && props.type === "next",
        [`${prefixCls}-up`]: props.direction === "vertical" && props.type === "previous",
        [`${prefixCls}-down`]: props.direction === "vertical" && props.type === "next"
      }]);
      return () => {
        let _slot;
        return vue.createVNode("div", {
          "class": cls.value,
          "onClick": handleClick
        }, [vue.createVNode(IconHover, {
          "disabled": props.disabled
        }, _isSlot$2(_slot = renderIcon()) ? _slot : {
          default: () => [_slot]
        })]);
      };
    }
  });
  const _sfc_main$p = vue.defineComponent({
    name: "TabsNavInk",
    props: {
      activeTabRef: {
        type: Object
      },
      direction: {
        type: String
      },
      disabled: Boolean,
      animation: Boolean
    },
    setup(props) {
      const { activeTabRef } = vue.toRefs(props);
      const prefixCls = getPrefixCls("tabs-nav-ink");
      const position = vue.ref(0);
      const size = vue.ref(0);
      const style = vue.computed(() => {
        if (props.direction === "vertical") {
          return {
            top: `${position.value}px`,
            height: `${size.value}px`
          };
        }
        return {
          left: `${position.value}px`,
          width: `${size.value}px`
        };
      });
      const getInkStyle = () => {
        if (activeTabRef.value) {
          const _position = props.direction === "vertical" ? activeTabRef.value.offsetTop : activeTabRef.value.offsetLeft;
          const _size = props.direction === "vertical" ? activeTabRef.value.offsetHeight : activeTabRef.value.offsetWidth;
          if (_position !== position.value || _size !== size.value) {
            position.value = _position;
            size.value = _size;
          }
        }
      };
      vue.onMounted(() => {
        vue.nextTick(() => getInkStyle());
      });
      vue.onUpdated(() => {
        getInkStyle();
      });
      const cls = vue.computed(() => [
        prefixCls,
        {
          [`${prefixCls}-animation`]: props.animation,
          [`${prefixCls}-disabled`]: props.disabled
        }
      ]);
      return {
        prefixCls,
        cls,
        style
      };
    }
  });
  function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.style)
    }, null, 6);
  }
  var TabsNavInk = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["render", _sfc_render$o]]);
  var TabsNav = vue.defineComponent({
    name: "TabsNav",
    props: {
      tabs: {
        type: Array,
        required: true
      },
      direction: {
        type: String,
        required: true
      },
      type: {
        type: String,
        required: true
      },
      activeKey: {
        type: [String, Number]
      },
      activeIndex: {
        type: Number,
        required: true
      },
      position: {
        type: String,
        required: true
      },
      size: {
        type: String,
        required: true
      },
      showAddButton: {
        type: Boolean,
        default: false
      },
      editable: {
        type: Boolean,
        default: false
      },
      animation: {
        type: Boolean,
        required: true
      },
      headerPadding: {
        type: Boolean,
        default: true
      }
    },
    emits: ["click", "add", "delete"],
    setup(props, {
      emit,
      slots
    }) {
      const {
        tabs,
        activeKey,
        activeIndex,
        direction
      } = vue.toRefs(props);
      const prefixCls = getPrefixCls("tabs-nav");
      const wrapperRef = vue.ref();
      const listRef = vue.ref();
      const tabsRef = vue.ref({});
      const activeTabRef = vue.computed(() => {
        if (!isUndefined(activeKey.value)) {
          return tabsRef.value[activeKey.value];
        }
        return void 0;
      });
      const inkRef = vue.ref();
      const mergedEditable = vue.computed(() => props.editable && ["line", "card", "card-gutter"].includes(props.type));
      const isScroll2 = vue.ref(false);
      const wrapperLength = vue.ref(0);
      const maxOffset = vue.ref(0);
      const tabEndOffsets = vue.ref([]);
      const offset = vue.ref(0);
      const getWrapperLength = () => {
        var _a, _b, _c;
        return (_c = direction.value === "vertical" ? (_a = wrapperRef.value) == null ? void 0 : _a.offsetHeight : (_b = wrapperRef.value) == null ? void 0 : _b.offsetWidth) != null ? _c : 0;
      };
      const getMaxOffset = () => {
        if (!listRef.value || !wrapperRef.value) {
          return 0;
        }
        if (direction.value === "vertical") {
          return listRef.value.offsetHeight - wrapperRef.value.offsetHeight;
        }
        return listRef.value.offsetWidth - wrapperRef.value.offsetWidth;
      };
      const getTabEndOffsets = () => {
        return tabs.value.map((item) => {
          const ele = tabsRef.value[item.key];
          if (direction.value === "vertical") {
            return ele.offsetTop + ele.offsetHeight;
          }
          return ele.offsetLeft + ele.offsetWidth;
        });
      };
      const getSize = () => {
        isScroll2.value = isOverflow();
        if (isScroll2.value) {
          wrapperLength.value = getWrapperLength();
          maxOffset.value = getMaxOffset();
          tabEndOffsets.value = getTabEndOffsets();
          if (offset.value > maxOffset.value) {
            offset.value = maxOffset.value;
          }
        } else {
          offset.value = 0;
        }
      };
      const isOverflow = () => {
        if (wrapperRef.value && listRef.value) {
          return props.direction === "vertical" ? listRef.value.offsetHeight > wrapperRef.value.offsetHeight : listRef.value.offsetWidth > wrapperRef.value.offsetWidth;
        }
        return false;
      };
      const isInView = (index2) => {
        var _a;
        return ((_a = tabEndOffsets.value[index2 - 1]) != null ? _a : 0) >= offset.value && tabEndOffsets.value[index2] <= offset.value + wrapperLength.value;
      };
      const getNextOffset = (type) => {
        if (!wrapperRef.value) {
          return 0;
        }
        return type === "previous" ? offset.value - wrapperLength.value : offset.value + wrapperLength.value;
      };
      const getValidOffset = (offset2) => {
        if (!wrapperRef.value || !listRef.value || offset2 < 0) {
          return 0;
        }
        if (offset2 > maxOffset.value) {
          return maxOffset.value;
        }
        return offset2;
      };
      const handleClick = (key, ev) => {
        emit("click", key, ev);
      };
      const handleDelete = (key, ev) => {
        emit("delete", key, ev);
      };
      const handleButtonClick = (type) => {
        offset.value = getValidOffset(getNextOffset(type));
      };
      const handleResize = () => {
        getSize();
        if (inkRef.value) {
          inkRef.value.$forceUpdate();
        }
      };
      vue.watch(tabs, () => {
        vue.nextTick(() => {
          getSize();
        });
      });
      vue.watch(activeIndex, (current, pre) => {
        vue.nextTick(() => {
          var _a;
          if (isScroll2.value) {
            if (current >= pre) {
              const offsetIndex = current < tabEndOffsets.value.length - 1 ? current + 1 : current;
              if (!isInView(offsetIndex)) {
                offset.value = tabEndOffsets.value[offsetIndex] - wrapperLength.value;
              }
            } else {
              const offsetIndex = current > 0 ? current - 1 : current;
              if (!isInView(offsetIndex)) {
                offset.value = (_a = tabEndOffsets.value[offsetIndex - 1]) != null ? _a : 0;
              }
            }
          }
        });
      });
      vue.onMounted(() => {
        getSize();
      });
      const renderAddBtn = () => {
        if (!mergedEditable.value || !props.showAddButton) {
          return null;
        }
        return vue.createVNode("div", {
          "class": `${prefixCls}-add-btn`,
          "onClick": (ev) => emit("add", ev)
        }, [vue.createVNode(IconHover, null, {
          default: () => [vue.createVNode(IconPlus, null, null)]
        })]);
      };
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-${props.direction}`, `${prefixCls}-${props.position}`, `${prefixCls}-size-${props.size}`, `${prefixCls}-type-${props.type}`]);
      const listCls = vue.computed(() => [`${prefixCls}-tab-list`, {
        [`${prefixCls}-tab-list-no-padding`]: !props.headerPadding && ["line", "text"].includes(props.type) && props.direction === "horizontal"
      }]);
      const listStyle = vue.computed(() => getTabListStyle({
        direction: props.direction,
        type: props.type,
        offset: offset.value
      }));
      const tabCls = vue.computed(() => [`${prefixCls}-tab`, {
        [`${prefixCls}-tab-scroll`]: isScroll2.value
      }]);
      return () => {
        var _a;
        return vue.createVNode("div", {
          "class": cls.value
        }, [isScroll2.value && vue.createVNode(TabsButton, {
          "type": "previous",
          "direction": props.direction,
          "disabled": offset.value <= 0,
          "onClick": handleButtonClick
        }, null), vue.createVNode(ResizeObserver$1, {
          "onResize": () => getSize()
        }, {
          default: () => [vue.createVNode("div", {
            "class": tabCls.value,
            "ref": wrapperRef
          }, [vue.createVNode(ResizeObserver$1, {
            "onResize": handleResize
          }, {
            default: () => [vue.createVNode("div", {
              "ref": listRef,
              "class": listCls.value,
              "style": listStyle.value
            }, [props.tabs.map((tab, index2) => vue.createVNode(TabsTab, {
              "key": tab.key,
              "ref": (component) => {
                if (component == null ? void 0 : component.$el) {
                  tabsRef.value[tab.key] = component.$el;
                }
              },
              "active": tab.key === activeKey.value,
              "tab": tab,
              "editable": props.editable,
              "onClick": handleClick,
              "onDelete": handleDelete
            }, {
              default: () => {
                var _a2, _b, _c;
                return [(_c = (_b = (_a2 = tab.slots).title) == null ? void 0 : _b.call(_a2)) != null ? _c : tab.title];
              }
            })), props.type === "line" && activeTabRef.value && vue.createVNode(TabsNavInk, {
              "ref": inkRef,
              "activeTabRef": activeTabRef.value,
              "direction": props.direction,
              "disabled": false,
              "animation": props.animation
            }, null)])]
          }), !isScroll2.value && renderAddBtn()])]
        }), isScroll2.value && vue.createVNode(TabsButton, {
          "type": "next",
          "direction": props.direction,
          "disabled": offset.value >= maxOffset.value,
          "onClick": handleButtonClick
        }, null), vue.createVNode("div", {
          "class": `${prefixCls}-extra`
        }, [isScroll2.value && renderAddBtn(), (_a = slots.extra) == null ? void 0 : _a.call(slots)])]);
      };
    }
  });
  var _Tabs = vue.defineComponent({
    name: "Tabs",
    props: {
      activeKey: {
        type: [String, Number],
        default: void 0
      },
      defaultActiveKey: {
        type: [String, Number],
        default: void 0
      },
      position: {
        type: String,
        default: "top"
      },
      size: {
        type: String
      },
      type: {
        type: String,
        default: "line"
      },
      direction: {
        type: String,
        default: "horizontal"
      },
      editable: {
        type: Boolean,
        default: false
      },
      showAddButton: {
        type: Boolean,
        default: false
      },
      destroyOnHide: {
        type: Boolean,
        default: false
      },
      lazyLoad: {
        type: Boolean,
        default: false
      },
      justify: {
        type: Boolean,
        default: false
      },
      animation: {
        type: Boolean,
        default: false
      },
      headerPadding: {
        type: Boolean,
        default: true
      },
      autoSwitch: {
        type: Boolean,
        default: false
      },
      hideContent: {
        type: Boolean,
        default: false
      },
      trigger: {
        type: String,
        default: "click"
      }
    },
    emits: {
      "update:activeKey": (key) => true,
      "change": (key) => true,
      "tabClick": (key, ev) => true,
      "add": (ev) => true,
      "delete": (key, ev) => true
    },
    setup(props, {
      emit,
      slots
    }) {
      const {
        size,
        lazyLoad,
        destroyOnHide,
        trigger
      } = vue.toRefs(props);
      const prefixCls = getPrefixCls("tabs");
      const {
        mergedSize
      } = useSize$1(size);
      const mergedPosition = vue.computed(() => props.direction === "vertical" ? "left" : props.position);
      const mergedDirection = vue.computed(() => ["left", "right"].includes(mergedPosition.value) ? "vertical" : "horizontal");
      const {
        children,
        components: components2
      } = useChildrenComponents("TabPane");
      const tabMap = vue.reactive(new Map());
      const sortedTabs = vue.computed(() => {
        const tabData = [];
        components2.value.forEach((id) => {
          const tab = tabMap.get(id);
          if (tab)
            tabData.push(tab);
        });
        return tabData;
      });
      const tabKeys = vue.computed(() => sortedTabs.value.map((item) => item.key));
      const addItem = (id, data) => {
        tabMap.set(id, data);
      };
      const removeItem = (id) => {
        tabMap.delete(id);
      };
      const _activeKey = vue.ref(props.defaultActiveKey);
      const computedActiveKey = vue.computed(() => {
        var _a;
        const activeKey = (_a = props.activeKey) != null ? _a : _activeKey.value;
        if (isUndefined(activeKey)) {
          return tabKeys.value[0];
        }
        return activeKey;
      });
      const activeIndex = vue.computed(() => {
        const index2 = tabKeys.value.indexOf(computedActiveKey.value);
        if (index2 === -1) {
          return 0;
        }
        return index2;
      });
      vue.provide(tabsInjectionKey, vue.reactive({
        lazyLoad,
        destroyOnHide,
        activeKey: computedActiveKey,
        addItem,
        removeItem,
        trigger
      }));
      const handleChange = (key) => {
        if (key !== computedActiveKey.value) {
          _activeKey.value = key;
          emit("update:activeKey", key);
          emit("change", key);
        }
      };
      const handleClick = (key, e2) => {
        handleChange(key);
        emit("tabClick", key, e2);
      };
      const handleAdd = (ev) => {
        emit("add", ev);
        if (props.autoSwitch) {
          vue.nextTick(() => {
            const lastKey = tabKeys.value[tabKeys.value.length - 1];
            handleChange(lastKey);
          });
        }
      };
      const handleDelete = (key, ev) => {
        emit("delete", key, ev);
      };
      const renderContent = () => {
        return vue.createVNode("div", {
          "class": [`${prefixCls}-content`, {
            [`${prefixCls}-content-hide`]: props.hideContent
          }]
        }, [vue.createVNode("div", {
          "class": [`${prefixCls}-content-list`, {
            [`${prefixCls}-content-animation`]: props.animation
          }],
          "style": {
            marginLeft: `-${activeIndex.value * 100}%`
          }
        }, [children.value])]);
      };
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-${mergedDirection.value}`, `${prefixCls}-${mergedPosition.value}`, `${prefixCls}-type-${props.type}`, `${prefixCls}-size-${mergedSize.value}`, {
        [`${prefixCls}-justify`]: props.justify
      }]);
      return () => {
        var _a;
        children.value = (_a = slots.default) == null ? void 0 : _a.call(slots);
        return vue.createVNode("div", {
          "class": cls.value
        }, [mergedPosition.value === "bottom" && renderContent(), vue.createVNode(TabsNav, {
          "tabs": sortedTabs.value,
          "activeKey": computedActiveKey.value,
          "activeIndex": activeIndex.value,
          "direction": mergedDirection.value,
          "position": mergedPosition.value,
          "editable": props.editable,
          "animation": props.animation,
          "showAddButton": props.showAddButton,
          "headerPadding": props.headerPadding,
          "size": mergedSize.value,
          "type": props.type,
          "onClick": handleClick,
          "onAdd": handleAdd,
          "onDelete": handleDelete
        }, {
          extra: slots.extra
        }), mergedPosition.value !== "bottom" && renderContent()]);
      };
    }
  });
  const _sfc_main$o = vue.defineComponent({
    name: "TabPane",
    props: {
      title: String,
      disabled: {
        type: Boolean,
        default: false
      },
      closable: {
        type: Boolean,
        default: true
      },
      destroyOnHide: {
        type: Boolean,
        default: false
      }
    },
    setup(props, { slots }) {
      var _a;
      const { title, disabled, closable } = vue.toRefs(props);
      const instance = vue.getCurrentInstance();
      const prefixCls = getPrefixCls("tabs");
      const tabsCtx = vue.inject(tabsInjectionKey, {});
      const itemRef = vue.ref();
      const key = vue.computed(() => instance == null ? void 0 : instance.vnode.key);
      const active = vue.computed(() => key.value === tabsCtx.activeKey);
      const mounted = vue.ref(tabsCtx.lazyLoad ? active.value : true);
      const data = vue.reactive({
        key,
        title,
        disabled,
        closable,
        slots
      });
      if (instance == null ? void 0 : instance.uid) {
        (_a = tabsCtx.addItem) == null ? void 0 : _a.call(tabsCtx, instance.uid, data);
      }
      vue.onBeforeUnmount(() => {
        var _a2;
        if (instance == null ? void 0 : instance.uid) {
          (_a2 = tabsCtx.removeItem) == null ? void 0 : _a2.call(tabsCtx, instance.uid);
        }
      });
      vue.watch(active, (active2) => {
        if (active2) {
          if (!mounted.value) {
            mounted.value = true;
          }
        } else if (props.destroyOnHide || tabsCtx.destroyOnHide) {
          mounted.value = false;
        }
      });
      vue.onUpdated(() => {
        data.slots = __spreadValues({}, slots);
      });
      return {
        prefixCls,
        active,
        itemRef,
        mounted
      };
    }
  });
  function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      ref: "itemRef",
      class: vue.normalizeClass([
        `${_ctx.prefixCls}-content-item`,
        { [`${_ctx.prefixCls}-content-item-active`]: _ctx.active }
      ])
    }, [
      _ctx.mounted ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: vue.normalizeClass(`${_ctx.prefixCls}-pane`)
      }, [
        vue.renderSlot(_ctx.$slots, "default")
      ], 2)) : vue.createCommentVNode("v-if", true)
    ], 2);
  }
  var TabPane = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["render", _sfc_render$n]]);
  const Tabs = Object.assign(_Tabs, {
    TabPane,
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Tabs.name, _Tabs);
      app.component(componentPrefix + TabPane.name, TabPane);
    }
  });
  function useTimeState(props) {
    const { modelValue, defaultValue, format, isRange } = vue.toRefs(props);
    function getLocalEmptyValue() {
      return isRange.value ? [] : void 0;
    }
    function normalizeValue(time) {
      if (isUndefined(time)) {
        return void 0;
      }
      if (isRange.value) {
        return isArray$1(time) ? time : [time, void 0];
      }
      return time;
    }
    const computedModelValue = vue.computed(() => {
      const time = normalizeValue(modelValue.value);
      return getDayjsValue(time, format.value);
    });
    const computedDefaultValue = vue.computed(() => {
      const time = normalizeValue(defaultValue.value);
      return getDayjsValue(time, format.value);
    });
    const [localValue, setLocalValue] = useState(!isUndefined(computedModelValue.value) ? computedModelValue.value : !isUndefined(computedDefaultValue.value) ? computedDefaultValue.value : getLocalEmptyValue());
    vue.watch(computedModelValue, () => {
      if (isUndefined(computedModelValue.value)) {
        setLocalValue(getLocalEmptyValue());
      }
    });
    const computedValue = vue.computed(() => computedModelValue.value || localValue.value);
    const [panelValue, setPanelValue] = useState(computedValue.value);
    vue.watch([computedValue], () => {
      setPanelValue(computedValue.value);
    });
    const [inputValue, setInputValue] = useState();
    vue.watch([panelValue], () => {
      setInputValue(void 0);
    });
    return {
      computedValue,
      panelValue,
      inputValue,
      setValue: setLocalValue,
      setPanelValue,
      setInputValue
    };
  }
  var RangePanel = vue.defineComponent({
    name: "TimePickerRangePanel",
    components: {
      Panel: Panel$1
    },
    props: {
      value: {
        type: Array
      },
      displayIndex: {
        type: Number,
        default: 0
      }
    },
    emits: ["select", "confirm", "update:displayIndex", "display-index-change"],
    setup(props, {
      emit
    }) {
      const {
        value,
        displayIndex
      } = vue.toRefs(props);
      const localDisplayIndex = vue.ref(displayIndex.value);
      vue.watch(displayIndex, () => {
        localDisplayIndex.value = displayIndex.value;
      });
      const displayValue = vue.computed(() => (value == null ? void 0 : value.value) ? value.value[localDisplayIndex.value] : void 0);
      function onSelect(selectedValue) {
        const newValue = isUndefined(value) || isUndefined(value == null ? void 0 : value.value) ? [] : [...value.value];
        newValue[localDisplayIndex.value] = selectedValue;
        emit("select", newValue);
      }
      function onConfirm() {
        if (!isValidRangeValue$1(value == null ? void 0 : value.value)) {
          const newIndex = (localDisplayIndex.value + 1) % 2;
          localDisplayIndex.value = newIndex;
          emit("display-index-change", newIndex);
          emit("update:displayIndex", newIndex);
        } else {
          emit("confirm", value == null ? void 0 : value.value);
        }
      }
      return {
        displayValue,
        onSelect,
        onConfirm
      };
    },
    render() {
      const _props = __spreadProps(__spreadValues({}, this.$attrs), {
        isRange: true,
        value: this.displayValue,
        onSelect: this.onSelect,
        onConfirm: this.onConfirm
      });
      return vue.createVNode(Panel$1, _props, this.$slots);
    }
  });
  const _sfc_main$n = vue.defineComponent({
    name: "TimePicker",
    components: {
      Trigger,
      DateInput,
      DateRangeInput,
      Panel: Panel$1,
      RangePanel,
      IconClockCircle
    },
    inheritAttrs: false,
    props: {
      type: {
        type: String,
        default: "time"
      },
      modelValue: {
        type: [String, Number, Date, Array]
      },
      defaultValue: {
        type: [String, Number, Date, Array]
      },
      disabled: {
        type: Boolean
      },
      allowClear: {
        type: Boolean,
        default: true
      },
      readonly: {
        type: Boolean
      },
      error: {
        type: Boolean
      },
      format: {
        type: String,
        default: "HH:mm:ss"
      },
      placeholder: {
        type: String
      },
      size: {
        type: String
      },
      popupContainer: {
        type: [String, Object]
      },
      use12Hours: {
        type: Boolean
      },
      step: {
        type: Object
      },
      disabledHours: {
        type: Function
      },
      disabledMinutes: {
        type: Function
      },
      disabledSeconds: {
        type: Function
      },
      hideDisabledOptions: {
        type: Boolean
      },
      disableConfirm: {
        type: Boolean
      },
      position: {
        type: String,
        default: "bl"
      },
      popupVisible: {
        type: Boolean,
        default: void 0
      },
      defaultPopupVisible: {
        type: Boolean,
        default: false
      },
      triggerProps: {
        type: Object
      },
      unmountOnClose: {
        type: Boolean
      }
    },
    emits: {
      "change": (timeString, time) => true,
      "update:modelValue": (timeString) => true,
      "select": (timeString, time) => true,
      "clear": () => true,
      "popup-visible-change": (visible) => true,
      "update:popupVisible": (visible) => true
    },
    setup(props, { emit }) {
      const {
        type,
        format,
        use12Hours,
        modelValue,
        defaultValue,
        popupVisible,
        defaultPopupVisible,
        disabled,
        placeholder,
        disableConfirm,
        disabledHours,
        disabledMinutes,
        disabledSeconds
      } = vue.toRefs(props);
      const { mergedDisabled, eventHandlers } = useFormItem({ disabled });
      const isRange = vue.computed(() => type.value === "time-range");
      const prefixCls = getPrefixCls("timepicker");
      const refInput = vue.ref();
      const { format: computedFormat, use12Hours: computedUse12Hours } = useTimeFormat(vue.reactive({
        format,
        use12Hours
      }));
      const {
        computedValue,
        panelValue,
        inputValue,
        setValue,
        setPanelValue,
        setInputValue
      } = useTimeState(vue.reactive({
        modelValue,
        defaultValue,
        isRange,
        format: computedFormat
      }));
      const [panelVisible, setLocalVisible] = useMergeState(defaultPopupVisible.value, vue.reactive({ value: popupVisible }));
      const setPanelVisible = (newVisible) => {
        if (newVisible !== panelVisible.value) {
          setLocalVisible(newVisible);
          emit("popup-visible-change", newVisible);
          emit("update:popupVisible", newVisible);
        }
      };
      const { t: t2 } = useI18n();
      const [focusedInputIndex, setFocusedInputIndex] = useState(0);
      const computedPlaceholder = vue.computed(() => {
        const _placeholder = placeholder == null ? void 0 : placeholder.value;
        if (!isRange.value) {
          return !isUndefined(_placeholder) ? _placeholder : t2("datePicker.placeholder.time");
        }
        if (isUndefined(_placeholder)) {
          return t2("datePicker.rangePlaceholder.time");
        }
        if (!isArray$1(_placeholder)) {
          return [_placeholder, _placeholder];
        }
        return _placeholder;
      });
      const isDisabledTime2 = useIsDisabledTime(vue.reactive({
        disabledHours,
        disabledMinutes,
        disabledSeconds
      }));
      function emitChange(value) {
        var _a, _b;
        if (isValueChange(value, computedValue.value)) {
          const formattedValue = getFormattedValue(value, computedFormat.value);
          const dateValue = getDateValue$1(value);
          emit("update:modelValue", formattedValue);
          emit("change", formattedValue, dateValue);
          (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a);
        }
      }
      function confirm(value, showPanel) {
        if (isDisabledTime2(value))
          return;
        let newValue = value;
        if (isArray$1(value)) {
          const now = dayjs();
          newValue = value.map((item) => {
            if (item) {
              item = item.year(now.year());
              item = item.month(now.month());
              item = item.date(now.date());
            }
            return item;
          });
          if (isValidRangeValue$1(newValue)) {
            newValue = getSortedDayjsArray(newValue);
          }
          if ((newValue == null ? void 0 : newValue.length) === 0) {
            newValue = void 0;
          }
        }
        emitChange(newValue);
        setValue(newValue);
        if (showPanel !== panelVisible.value) {
          setPanelVisible(showPanel);
        }
      }
      function select(value, showPanel) {
        setPanelValue(value);
        if (showPanel !== panelVisible.value) {
          setPanelVisible(showPanel);
        }
      }
      function focusInput(index2) {
        refInput.value && refInput.value.focus && refInput.value.focus(index2);
      }
      function onPanelVisibleChange(newVisible) {
        if (mergedDisabled.value)
          return;
        setPanelVisible(newVisible);
        if (newVisible) {
          vue.nextTick(() => {
            focusInput(focusedInputIndex.value);
          });
        }
      }
      function onPanelSelect(value) {
        const formattedValue = getFormattedValue(value, computedFormat.value);
        const dateValue = getDateValue$1(value);
        emit("select", formattedValue, dateValue);
        if (disableConfirm.value && (!isRange.value || isValidRangeValue$1(value))) {
          confirm(value, true);
        } else {
          select(value, true);
          setInputValue(void 0);
        }
      }
      function onPanelConfirm(value) {
        confirm(value, false);
      }
      function onInputPressEnter() {
        confirm(panelValue.value || computedValue.value, false);
      }
      function onRangeInputPressEnter() {
        if (isValidRangeValue$1(panelValue.value)) {
          confirm(panelValue.value, false);
        } else {
          const newFocusedInputIndex = (focusedInputIndex.value + 1) % 2;
          setFocusedInputIndex(newFocusedInputIndex);
          focusInput(newFocusedInputIndex);
        }
      }
      function onInputChange(e2) {
        setPanelVisible(true);
        const targetValue = e2.target.value;
        setInputValue(targetValue);
        if (!isValidInputValue(targetValue, computedFormat.value))
          return;
        const newValue = dayjs(targetValue, computedFormat.value);
        if (isDisabledTime2(newValue))
          return;
        if (disableConfirm.value) {
          confirm(newValue, true);
        } else {
          select(newValue, true);
        }
      }
      function onRangeInputChange(e2) {
        setPanelVisible(true);
        const targetValue = e2.target.value;
        const newInputValue = isArray$1(inputValue.value) ? [...inputValue.value] : isArray$1(panelValue.value) && getFormattedValue(panelValue.value, computedFormat.value) || [];
        newInputValue[focusedInputIndex.value] = targetValue;
        setInputValue(newInputValue);
        if (!isValidInputValue(targetValue, computedFormat.value))
          return;
        const targetValueDayjs = dayjs(targetValue, computedFormat.value);
        if (isDisabledTime2(targetValueDayjs))
          return;
        const newValue = isArray$1(panelValue.value) ? [...panelValue.value] : [];
        newValue[focusedInputIndex.value] = targetValueDayjs;
        if (disableConfirm.value && isValidRangeValue$1(newValue)) {
          confirm(newValue, true);
        } else {
          select(newValue, true);
        }
      }
      function onClear(e2) {
        e2.stopPropagation();
        setPanelValue(void 0);
        confirm(void 0, isRange.value);
      }
      vue.watch(panelVisible, (curVal, preVal) => {
        if (curVal !== preVal) {
          setPanelValue(computedValue.value);
        }
        if (!curVal) {
          setInputValue(void 0);
        }
      });
      const inputProps = vue.computed(() => {
        if (isRange.value) {
          return {
            focusedIndex: focusedInputIndex.value,
            onFocusedIndexChange: (index2) => {
              setFocusedInputIndex(index2);
            },
            onChange: onRangeInputChange,
            onPressEnter: onRangeInputPressEnter
          };
        }
        return {
          onChange: onInputChange,
          onPressEnter: onInputPressEnter
        };
      });
      const panelProps = vue.computed(() => {
        if (isRange.value) {
          return {
            displayIndex: focusedInputIndex.value,
            onDisplayIndexChange: (index2) => {
              setFocusedInputIndex(index2);
              focusInput(index2);
            }
          };
        }
        return {};
      });
      return {
        refInput,
        isRange,
        prefixCls,
        panelVisible,
        focusedInputIndex,
        computedPlaceholder,
        panelValue,
        inputValue,
        computedFormat,
        computedUse12Hours,
        inputProps,
        panelProps,
        mergedDisabled,
        onPanelVisibleChange,
        onInputClear: onClear,
        onPanelSelect,
        onPanelConfirm,
        onPanelClick: () => {
          focusInput(focusedInputIndex.value);
        }
      };
    }
  });
  function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_IconClockCircle = vue.resolveComponent("IconClockCircle");
    const _component_Trigger = vue.resolveComponent("Trigger");
    return vue.openBlock(), vue.createBlock(_component_Trigger, {
      trigger: "click",
      "animation-name": "slide-dynamic-origin",
      "auto-fit-transform-origin": "",
      "click-to-close": false,
      position: _ctx.position,
      disabled: _ctx.mergedDisabled || _ctx.readonly,
      "popup-offset": 4,
      "popup-visible": _ctx.panelVisible,
      "prevent-focus": true,
      "unmount-on-close": _ctx.unmountOnClose,
      "popup-container": _ctx.popupContainer,
      onPopupVisibleChange: _ctx.onPanelVisibleChange
    }, {
      content: vue.withCtx(() => [
        vue.createElementVNode("div", {
          class: vue.normalizeClass(`${_ctx.prefixCls}-container`),
          onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onPanelClick && _ctx.onPanelClick(...args))
        }, [
          (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.isRange ? "RangePanel" : "Panel"), vue.mergeProps(_ctx.panelProps, {
            value: _ctx.panelValue,
            visible: _ctx.panelVisible,
            format: _ctx.computedFormat,
            "use12-hours": _ctx.computedUse12Hours,
            step: _ctx.step,
            "disabled-hours": _ctx.disabledHours,
            "disabled-minutes": _ctx.disabledMinutes,
            "disabled-seconds": _ctx.disabledSeconds,
            "hide-disabled-options": _ctx.hideDisabledOptions,
            "hide-footer": _ctx.disableConfirm,
            onSelect: _ctx.onPanelSelect,
            onConfirm: _ctx.onPanelConfirm
          }), vue.createSlots({ _: 2 }, [
            _ctx.$slots.extra ? {
              name: "extra-footer",
              fn: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "extra")
              ])
            } : void 0
          ]), 1040, ["value", "visible", "format", "use12-hours", "step", "disabled-hours", "disabled-minutes", "disabled-seconds", "hide-disabled-options", "hide-footer", "onSelect", "onConfirm"]))
        ], 2)
      ]),
      default: vue.withCtx(() => [
        (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.isRange ? "DateRangeInput" : "DateInput"), vue.mergeProps(__spreadValues(__spreadValues({}, _ctx.$attrs), _ctx.inputProps), {
          ref: "refInput",
          "input-value": _ctx.inputValue,
          value: _ctx.panelValue,
          size: _ctx.size,
          focused: _ctx.panelVisible,
          format: _ctx.computedFormat,
          visible: _ctx.panelVisible,
          disabled: _ctx.mergedDisabled,
          error: _ctx.error,
          editable: !_ctx.readonly,
          "allow-clear": _ctx.allowClear && !_ctx.readonly,
          placeholder: _ctx.computedPlaceholder,
          onClear: _ctx.onInputClear
        }), vue.createSlots({
          "suffix-icon": vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "suffix-icon", {}, () => [
              vue.createVNode(_component_IconClockCircle)
            ])
          ]),
          _: 2
        }, [
          _ctx.$slots.prefix ? {
            name: "prefix",
            fn: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "prefix")
            ])
          } : void 0
        ]), 1040, ["input-value", "value", "size", "focused", "format", "visible", "disabled", "error", "editable", "allow-clear", "placeholder", "onClear"]))
      ]),
      _: 3
    }, 8, ["position", "disabled", "popup-visible", "unmount-on-close", "popup-container", "onPopupVisibleChange"]);
  }
  var _TimePicker = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", _sfc_render$m]]);
  const TimePicker = Object.assign(_TimePicker, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _TimePicker.name, _TimePicker);
    }
  });
  const timelineInjectionKey = Symbol("ArcoTimeline");
  const getDefaultPosition = (index2, mode, direction, position) => {
    let map = ["left", "right"];
    if (direction === "horizontal") {
      map = ["top", "bottom"];
    }
    const res = mode === "alternate" ? position || map[index2 % 2] : mode;
    return map.indexOf(res) > -1 ? res : map[0];
  };
  const _sfc_main$m = vue.defineComponent({
    name: "TimelineItem",
    props: {
      dotColor: {
        type: String
      },
      dotType: {
        type: String,
        default: "solid"
      },
      lineType: {
        type: String,
        default: "solid"
      },
      lineColor: {
        type: String
      },
      label: {
        type: String
      },
      position: {
        type: String
      }
    },
    setup(props) {
      const prefixCls = getPrefixCls("timeline-item");
      const instance = vue.getCurrentInstance();
      const context = vue.inject(timelineInjectionKey, {});
      const index2 = vue.computed(() => {
        var _a, _b, _c;
        return (_c = (_b = context.items) == null ? void 0 : _b.indexOf((_a = instance == null ? void 0 : instance.uid) != null ? _a : -1)) != null ? _c : -1;
      });
      const contextDirection = vue.computed(() => {
        var _a;
        return (_a = context == null ? void 0 : context.direction) != null ? _a : "vertical";
      });
      const contextLabelPosition = vue.computed(() => {
        var _a;
        return (_a = context == null ? void 0 : context.labelPosition) != null ? _a : "same";
      });
      const cls = vue.computed(() => {
        const { items = [], reverse, labelPosition, mode = "left" } = context;
        const direction = contextDirection.value;
        const computedPosition = getDefaultPosition(index2.value, mode, direction, props.position);
        return [
          prefixCls,
          {
            [`${prefixCls}-${direction}-${computedPosition}`]: direction,
            [`${prefixCls}-label-${labelPosition}`]: labelPosition,
            [`${prefixCls}-last`]: index2.value === (reverse === true ? 0 : items.length - 1)
          }
        ];
      });
      const dotLineCls = vue.computed(() => {
        return [
          `${prefixCls}-dot-line`,
          `${prefixCls}-dot-line-is-${contextDirection.value}`
        ];
      });
      const computedDotLineStyle = vue.computed(() => {
        const { direction } = context || {};
        return __spreadValues({
          [direction === "horizontal" ? "borderTopStyle" : "borderLeftStyle"]: props.lineType
        }, props.lineColor ? { borderColor: props.lineColor } : {});
      });
      const dotTypeCls = vue.computed(() => {
        return [`${prefixCls}-dot`, `${prefixCls}-dot-${props.dotType}`];
      });
      const computedDotStyle = vue.computed(() => {
        return {
          [props.dotType === "solid" ? "backgroundColor" : "borderColor"]: props.dotColor
        };
      });
      return {
        cls,
        dotLineCls,
        dotTypeCls,
        prefixCls,
        computedDotLineStyle,
        computedDotStyle,
        labelPosition: contextLabelPosition
      };
    }
  });
  function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      role: "listitem",
      class: vue.normalizeClass(_ctx.cls)
    }, [
      vue.createElementVNode("div", {
        class: vue.normalizeClass(`${_ctx.prefixCls}-dot-wrapper`)
      }, [
        vue.createElementVNode("div", {
          class: vue.normalizeClass(_ctx.dotLineCls),
          style: vue.normalizeStyle(_ctx.computedDotLineStyle)
        }, null, 6),
        vue.createElementVNode("div", {
          class: vue.normalizeClass(`${_ctx.prefixCls}-dot-content`)
        }, [
          _ctx.$slots.dot ? (vue.openBlock(), vue.createElementBlock("div", {
            key: 0,
            class: vue.normalizeClass(`${_ctx.prefixCls}-dot-custom`)
          }, [
            vue.renderSlot(_ctx.$slots, "dot")
          ], 2)) : (vue.openBlock(), vue.createElementBlock("div", {
            key: 1,
            class: vue.normalizeClass(_ctx.dotTypeCls),
            style: vue.normalizeStyle(_ctx.computedDotStyle)
          }, null, 6))
        ], 2)
      ], 2),
      vue.createElementVNode("div", {
        class: vue.normalizeClass(`${_ctx.prefixCls}-content-wrapper`)
      }, [
        _ctx.$slots.default ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 0,
          class: vue.normalizeClass(`${_ctx.prefixCls}-content`)
        }, [
          vue.renderSlot(_ctx.$slots, "default")
        ], 2)) : vue.createCommentVNode("v-if", true),
        _ctx.labelPosition !== "relative" ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 1,
          class: vue.normalizeClass(`${_ctx.prefixCls}-label`)
        }, vue.toDisplayString(_ctx.label), 3)) : vue.createCommentVNode("v-if", true)
      ], 2),
      _ctx.labelPosition === "relative" ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: vue.normalizeClass(`${_ctx.prefixCls}-label`)
      }, vue.toDisplayString(_ctx.label), 3)) : vue.createCommentVNode("v-if", true)
    ], 2);
  }
  var TimelineItem = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["render", _sfc_render$l]]);
  var _Timeline = vue.defineComponent({
    name: "Timeline",
    components: {
      Item: TimelineItem,
      Spin
    },
    props: {
      reverse: {
        type: Boolean
      },
      direction: {
        type: String,
        default: "vertical"
      },
      mode: {
        type: String,
        default: "left"
      },
      pending: {
        type: [Boolean, String]
      },
      labelPosition: {
        type: String,
        default: "same"
      }
    },
    setup(props, {
      slots
    }) {
      const prefixCls = getPrefixCls("timeline");
      const hasPending = vue.computed(() => {
        return props.pending || slots.pending;
      });
      const {
        children,
        components: components2
      } = useChildrenComponents("TimelineItem");
      const {
        reverse: reverseRef,
        direction: directionRef,
        labelPosition: labelPositionRef,
        mode: modeRef
      } = vue.toRefs(props);
      const timelineContext = vue.reactive({
        items: components2,
        direction: directionRef,
        reverse: reverseRef,
        labelPosition: labelPositionRef,
        mode: modeRef
      });
      vue.provide(timelineInjectionKey, timelineContext);
      const cls = vue.computed(() => {
        return [prefixCls, `${prefixCls}-${props.mode}`, `${prefixCls}-direction-${props.direction}`, {
          [`${prefixCls}-is-reverse`]: props.reverse
        }];
      });
      return () => {
        var _a, _b;
        if (hasPending.value) {
          children.value = (_a = slots.default) == null ? void 0 : _a.call(slots).concat(vue.createVNode(TimelineItem, {
            "lineType": "dashed"
          }, {
            default: () => [props.pending !== true && vue.createVNode("div", null, [props.pending])],
            dot: () => {
              var _a2, _b2;
              return (_b2 = (_a2 = slots.dot) == null ? void 0 : _a2.call(slots)) != null ? _b2 : vue.createVNode(Spin, {
                "size": 12
              }, null);
            }
          }));
        } else {
          children.value = (_b = slots.default) == null ? void 0 : _b.call(slots);
        }
        return vue.createVNode("div", {
          "role": "list",
          "class": cls.value
        }, [children.value]);
      };
    }
  });
  const Timeline = Object.assign(_Timeline, {
    Item: TimelineItem,
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Timeline.name, _Timeline);
      app.component(componentPrefix + TimelineItem.name, TimelineItem);
    }
  });
  const _sfc_main$l = vue.defineComponent({
    name: "IconDelete",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-delete`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$b = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$b = /* @__PURE__ */ vue.createElementVNode("path", { d: "M5 11h5.5m0 0v29a1 1 0 0 0 1 1h25a1 1 0 0 0 1-1V11m-27 0H16m21.5 0H43m-5.5 0H32m-16 0V7h16v4m-16 0h16M20 18v15m8-15v15" }, null, -1);
  const _hoisted_3$a = [
    _hoisted_2$b
  ];
  function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$a, 14, _hoisted_1$b);
  }
  var _IconDelete = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["render", _sfc_render$k]]);
  const IconDelete = Object.assign(_IconDelete, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconDelete.name, _IconDelete);
    }
  });
  const transferInjectionKey = Symbol("ArcoTransfer");
  var TransferListItem = vue.defineComponent({
    name: "TransferListItem",
    props: {
      type: {
        type: String
      },
      data: {
        type: Object,
        required: true
      },
      allowClear: {
        type: Boolean
      },
      disabled: {
        type: Boolean
      },
      draggable: {
        type: Boolean
      },
      simple: Boolean
    },
    setup(props) {
      const prefixCls = getPrefixCls("transfer-list-item");
      const transferCtx = vue.inject(transferInjectionKey, void 0);
      const handleClick = () => {
        if (!props.simple) {
          return;
        }
        transferCtx == null ? void 0 : transferCtx.moveTo([props.data.value], props.type === "target" ? "source" : "target");
      };
      const cls = vue.computed(() => [prefixCls, {
        [`${prefixCls}-disabled`]: props.disabled,
        [`${prefixCls}-draggable`]: props.draggable
      }]);
      const handleRemove = () => {
        transferCtx == null ? void 0 : transferCtx.moveTo([props.data.value], "source");
      };
      return () => {
        var _a, _b, _c;
        return vue.createVNode("div", {
          "class": cls.value,
          "onClick": handleClick
        }, [props.allowClear || props.simple ? vue.createVNode("span", {
          "class": `${prefixCls}-content`
        }, [(_c = (_b = transferCtx == null ? void 0 : (_a = transferCtx.slots).item) == null ? void 0 : _b.call(_a, {
          label: props.data.label,
          value: props.data.value
        })) != null ? _c : props.data.label]) : vue.createVNode(Checkbox, {
          "class": [`${prefixCls}-content`, `${prefixCls}-checkbox`],
          "modelValue": transferCtx == null ? void 0 : transferCtx.selected,
          "value": props.data.value,
          "onChange": (value) => transferCtx == null ? void 0 : transferCtx.onSelect(value),
          "uninjectGroupContext": true,
          "disabled": props.disabled
        }, {
          default: () => {
            var _a2, _b2, _c2;
            return [(_c2 = (_b2 = transferCtx == null ? void 0 : (_a2 = transferCtx.slots).item) == null ? void 0 : _b2.call(_a2, {
              label: props.data.label,
              value: props.data.value
            })) != null ? _c2 : props.data.label];
          }
        }), props.allowClear && !props.disabled && vue.createVNode(IconHover, {
          "class": `${prefixCls}-remove-btn`,
          "onClick": handleRemove
        }, {
          default: () => [vue.createVNode(IconClose, null, null)]
        })]);
      };
    }
  });
  const _sfc_main$k = vue.defineComponent({
    name: "TransferView",
    components: {
      Empty: Empty$1,
      Checkbox,
      IconHover,
      IconDelete,
      InputSearch: Input.Search,
      List,
      TransferListItem,
      Scrollbar
    },
    props: {
      type: {
        type: String
      },
      dataInfo: {
        type: Object,
        required: true
      },
      title: String,
      data: {
        type: Array,
        required: true
      },
      allowClear: Boolean,
      selected: {
        type: Array,
        required: true
      },
      showSearch: Boolean,
      showSelectAll: Boolean,
      simple: Boolean
    },
    emits: ["search"],
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("transfer-view");
      const filter = vue.ref("");
      const transferCtx = vue.inject(transferInjectionKey, void 0);
      const countSelected = vue.computed(() => props.dataInfo.selected.length);
      const countRendered = vue.computed(() => props.dataInfo.data.length);
      const checked = vue.computed(() => props.dataInfo.selected.length > 0 && props.dataInfo.selected.length === props.dataInfo.allValidValues.length);
      const indeterminate = vue.computed(() => props.dataInfo.selected.length > 0 && props.dataInfo.selected.length < props.dataInfo.allValidValues.length);
      const handleSelectAllChange = (checked2) => {
        if (checked2) {
          transferCtx == null ? void 0 : transferCtx.onSelect([
            ...props.selected,
            ...props.dataInfo.allValidValues
          ]);
        } else {
          transferCtx == null ? void 0 : transferCtx.onSelect(props.selected.filter((value) => !props.dataInfo.allValidValues.includes(value)));
        }
      };
      const filteredData = vue.computed(() => props.dataInfo.data.filter((item) => {
        if (filter.value) {
          return item.label.includes(filter.value);
        }
        return true;
      }));
      const handleSearch = (value) => {
        emit("search", value, props.type);
      };
      const handleClear = () => {
        transferCtx == null ? void 0 : transferCtx.moveTo(props.dataInfo.allValidValues, "source");
      };
      return {
        prefixCls,
        filteredData,
        filter,
        checked,
        indeterminate,
        countSelected,
        countRendered,
        handleSelectAllChange,
        handleSearch,
        handleClear,
        transferCtx
      };
    }
  });
  function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_checkbox = vue.resolveComponent("checkbox");
    const _component_icon_delete = vue.resolveComponent("icon-delete");
    const _component_icon_hover = vue.resolveComponent("icon-hover");
    const _component_input_search = vue.resolveComponent("input-search");
    const _component_transfer_list_item = vue.resolveComponent("transfer-list-item");
    const _component_list = vue.resolveComponent("list");
    const _component_Scrollbar = vue.resolveComponent("Scrollbar");
    const _component_Empty = vue.resolveComponent("Empty");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.prefixCls)
    }, [
      vue.createElementVNode("div", {
        class: vue.normalizeClass(`${_ctx.prefixCls}-header`)
      }, [
        vue.renderSlot(_ctx.$slots, "title", {
          countTotal: _ctx.dataInfo.data.length,
          countSelected: _ctx.dataInfo.selected.length,
          searchValue: _ctx.filter,
          checked: _ctx.checked,
          indeterminate: _ctx.indeterminate,
          onSelectAllChange: _ctx.handleSelectAllChange,
          onClear: _ctx.handleClear
        }, () => [
          vue.createElementVNode("span", {
            class: vue.normalizeClass(`${_ctx.prefixCls}-header-title`)
          }, [
            _ctx.allowClear || _ctx.simple || !_ctx.showSelectAll ? (vue.openBlock(), vue.createElementBlock("span", {
              key: 0,
              class: vue.normalizeClass(`${_ctx.prefixCls}-header-title-simple`)
            }, vue.toDisplayString(_ctx.title), 3)) : (vue.openBlock(), vue.createBlock(_component_checkbox, {
              key: 1,
              "model-value": _ctx.checked,
              indeterminate: _ctx.indeterminate,
              "uninject-group-context": "",
              onChange: _ctx.handleSelectAllChange
            }, {
              default: vue.withCtx(() => [
                vue.createTextVNode(vue.toDisplayString(_ctx.title), 1)
              ]),
              _: 1
            }, 8, ["model-value", "indeterminate", "onChange"]))
          ], 2),
          _ctx.allowClear ? (vue.openBlock(), vue.createBlock(_component_icon_hover, {
            key: 0,
            class: vue.normalizeClass(`${_ctx.prefixCls}-header-clear-btn`),
            onClick: _ctx.handleClear
          }, {
            default: vue.withCtx(() => [
              vue.createVNode(_component_icon_delete)
            ]),
            _: 1
          }, 8, ["class", "onClick"])) : !_ctx.simple ? (vue.openBlock(), vue.createElementBlock("span", {
            key: 1,
            class: vue.normalizeClass(`${_ctx.prefixCls}-header-count`)
          }, vue.toDisplayString(_ctx.dataInfo.selected.length) + " / " + vue.toDisplayString(_ctx.dataInfo.data.length), 3)) : vue.createCommentVNode("v-if", true)
        ])
      ], 2),
      _ctx.showSearch ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: vue.normalizeClass(`${_ctx.prefixCls}-search`)
      }, [
        vue.createVNode(_component_input_search, {
          modelValue: _ctx.filter,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.filter = $event),
          onChange: _ctx.handleSearch
        }, null, 8, ["modelValue", "onChange"])
      ], 2)) : vue.createCommentVNode("v-if", true),
      vue.createElementVNode("div", {
        class: vue.normalizeClass(`${_ctx.prefixCls}-body`)
      }, [
        _ctx.filteredData.length > 0 ? (vue.openBlock(), vue.createBlock(_component_Scrollbar, { key: 0 }, {
          default: vue.withCtx(() => {
            var _a, _b;
            return [
              vue.renderSlot(_ctx.$slots, "default", {
                data: _ctx.filteredData,
                selectedKeys: (_a = _ctx.transferCtx) == null ? void 0 : _a.selected,
                onSelect: (_b = _ctx.transferCtx) == null ? void 0 : _b.onSelect
              }, () => [
                vue.createVNode(_component_list, {
                  class: vue.normalizeClass(`${_ctx.prefixCls}-list`),
                  bordered: false,
                  scrollbar: false
                }, {
                  default: vue.withCtx(() => [
                    (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.filteredData, (item) => {
                      return vue.openBlock(), vue.createBlock(_component_transfer_list_item, {
                        key: item.value,
                        type: _ctx.type,
                        data: item,
                        simple: _ctx.simple,
                        "allow-clear": _ctx.allowClear,
                        disabled: item.disabled
                      }, null, 8, ["type", "data", "simple", "allow-clear", "disabled"]);
                    }), 128))
                  ]),
                  _: 1
                }, 8, ["class"])
              ])
            ];
          }),
          _: 3
        })) : (vue.openBlock(), vue.createBlock(_component_Empty, {
          key: 1,
          class: vue.normalizeClass(`${_ctx.prefixCls}-empty`)
        }, null, 8, ["class"]))
      ], 2)
    ], 2);
  }
  var TransferView = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$j]]);
  const _sfc_main$j = vue.defineComponent({
    name: "Transfer",
    components: {
      ArcoButton: Button,
      TransferView,
      IconLeft,
      IconRight
    },
    props: {
      data: {
        type: Array,
        default: () => []
      },
      modelValue: {
        type: Array,
        default: void 0
      },
      defaultValue: {
        type: Array,
        default: () => []
      },
      selected: {
        type: Array,
        default: void 0
      },
      defaultSelected: {
        type: Array,
        default: () => []
      },
      disabled: {
        type: Boolean,
        default: false
      },
      simple: {
        type: Boolean,
        default: false
      },
      oneWay: {
        type: Boolean,
        default: false
      },
      showSearch: {
        type: Boolean,
        default: false
      },
      showSelectAll: {
        type: Boolean,
        default: true
      },
      title: {
        type: Array,
        default: () => ["Source", "Target"]
      }
    },
    emits: {
      "update:modelValue": (value) => true,
      "update:selected": (selected) => true,
      "change": (value) => true,
      "select": (selected) => true,
      "search": (value, type) => true
    },
    setup(props, { emit, slots }) {
      const { mergedDisabled, eventHandlers } = useFormItem({
        disabled: vue.toRef(props, "disabled")
      });
      const prefixCls = getPrefixCls("transfer");
      const _target = vue.ref(props.defaultValue);
      const computedTarget = vue.computed(() => {
        var _a;
        return (_a = props.modelValue) != null ? _a : _target.value;
      });
      const _selected = vue.ref(props.defaultSelected);
      const computedSelected = vue.computed(() => {
        var _a;
        return (_a = props.selected) != null ? _a : _selected.value;
      });
      const sourceTitle = vue.computed(() => {
        var _a;
        return (_a = props.title) == null ? void 0 : _a[0];
      });
      const targetTitle = vue.computed(() => {
        var _a;
        return (_a = props.title) == null ? void 0 : _a[1];
      });
      const dataInfo = vue.computed(() => {
        const sourceInfo = {
          data: [],
          allValidValues: [],
          selected: [],
          validSelected: []
        };
        const targetInfo = {
          data: [],
          allValidValues: [],
          selected: [],
          validSelected: []
        };
        for (const item of props.data) {
          if (computedTarget.value.includes(item.value)) {
            targetInfo.data.push(item);
            if (!item.disabled) {
              targetInfo.allValidValues.push(item.value);
            }
            if (computedSelected.value.includes(item.value)) {
              targetInfo.selected.push(item.value);
              if (!item.disabled) {
                targetInfo.validSelected.push(item.value);
              }
            }
          } else {
            sourceInfo.data.push(item);
            if (!item.disabled) {
              sourceInfo.allValidValues.push(item.value);
            }
            if (computedSelected.value.includes(item.value)) {
              sourceInfo.selected.push(item.value);
              if (!item.disabled) {
                sourceInfo.validSelected.push(item.value);
              }
            }
          }
        }
        return {
          sourceInfo,
          targetInfo
        };
      });
      const handleSearch = (value, type) => {
        emit("search", value, type);
      };
      const moveTo = (values, target2) => {
        var _a, _b;
        const newTarget = target2 === "target" ? [...computedTarget.value, ...values] : computedTarget.value.filter((value) => !values.includes(value));
        handleSelect(dataInfo.value[target2 === "target" ? "targetInfo" : "sourceInfo"].selected);
        _target.value = newTarget;
        emit("update:modelValue", newTarget);
        emit("change", newTarget);
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a);
      };
      const handleClick = (target2) => {
        const values = target2 === "target" ? dataInfo.value.sourceInfo.validSelected : dataInfo.value.targetInfo.validSelected;
        moveTo(values, target2);
      };
      const handleSelect = (values) => {
        _selected.value = values;
        emit("update:selected", values);
        emit("select", values);
      };
      vue.provide(transferInjectionKey, vue.reactive({
        selected: computedSelected,
        slots,
        moveTo,
        onSelect: handleSelect
      }));
      const cls = vue.computed(() => [
        prefixCls,
        {
          [`${prefixCls}-simple`]: props.simple,
          [`${prefixCls}-disabled`]: mergedDisabled.value
        }
      ]);
      return {
        prefixCls,
        cls,
        dataInfo,
        computedSelected,
        sourceTitle,
        targetTitle,
        handleClick,
        handleSearch
      };
    }
  });
  function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_transfer_view = vue.resolveComponent("transfer-view");
    const _component_icon_right = vue.resolveComponent("icon-right");
    const _component_arco_button = vue.resolveComponent("arco-button");
    const _component_icon_left = vue.resolveComponent("icon-left");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.cls)
    }, [
      vue.createVNode(_component_transfer_view, {
        type: "source",
        class: vue.normalizeClass(`${_ctx.prefixCls}-view-source`),
        title: _ctx.sourceTitle,
        "data-info": _ctx.dataInfo.sourceInfo,
        data: _ctx.dataInfo.sourceInfo.data,
        selected: _ctx.computedSelected,
        "show-search": _ctx.showSearch,
        "show-select-all": _ctx.showSelectAll,
        simple: _ctx.simple,
        onSearch: _ctx.handleSearch
      }, vue.createSlots({ _: 2 }, [
        _ctx.$slots.source ? {
          name: "default",
          fn: vue.withCtx((slotData) => [
            vue.renderSlot(_ctx.$slots, "source", vue.normalizeProps(vue.guardReactiveProps(slotData)))
          ])
        } : void 0,
        _ctx.$slots["source-title"] ? {
          name: "title",
          fn: vue.withCtx((titleProps) => [
            vue.renderSlot(_ctx.$slots, "source-title", vue.normalizeProps(vue.guardReactiveProps(titleProps)))
          ])
        } : void 0
      ]), 1032, ["class", "title", "data-info", "data", "selected", "show-search", "show-select-all", "simple", "onSearch"]),
      !_ctx.simple ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: vue.normalizeClass([`${_ctx.prefixCls}-operations`])
      }, [
        vue.createVNode(_component_arco_button, {
          tabindex: "-1",
          "aria-label": "Move selected right",
          size: "small",
          shape: "round",
          disabled: _ctx.dataInfo.sourceInfo.validSelected.length === 0,
          onClick: _cache[0] || (_cache[0] = ($event) => _ctx.handleClick("target"))
        }, {
          icon: vue.withCtx(() => [
            vue.createVNode(_component_icon_right)
          ]),
          _: 1
        }, 8, ["disabled"]),
        !_ctx.oneWay ? (vue.openBlock(), vue.createBlock(_component_arco_button, {
          key: 0,
          tabindex: "-1",
          "aria-label": "Move selected left",
          size: "small",
          shape: "round",
          disabled: _ctx.dataInfo.targetInfo.validSelected.length === 0,
          onClick: _cache[1] || (_cache[1] = ($event) => _ctx.handleClick("source"))
        }, {
          icon: vue.withCtx(() => [
            vue.createVNode(_component_icon_left)
          ]),
          _: 1
        }, 8, ["disabled"])) : vue.createCommentVNode("v-if", true)
      ], 2)) : vue.createCommentVNode("v-if", true),
      vue.createVNode(_component_transfer_view, {
        type: "target",
        class: vue.normalizeClass(`${_ctx.prefixCls}-view-target`),
        title: _ctx.targetTitle,
        "data-info": _ctx.dataInfo.targetInfo,
        data: _ctx.dataInfo.targetInfo.data,
        selected: _ctx.computedSelected,
        "allow-clear": _ctx.oneWay,
        "show-search": _ctx.showSearch,
        "show-select-all": _ctx.showSelectAll,
        simple: _ctx.simple,
        onSearch: _ctx.handleSearch
      }, vue.createSlots({ _: 2 }, [
        _ctx.$slots.target ? {
          name: "default",
          fn: vue.withCtx((slotData) => [
            vue.renderSlot(_ctx.$slots, "target", vue.normalizeProps(vue.guardReactiveProps(slotData)))
          ])
        } : void 0,
        _ctx.$slots["target-title"] ? {
          name: "title",
          fn: vue.withCtx((titleProps) => [
            vue.renderSlot(_ctx.$slots, "target-title", vue.normalizeProps(vue.guardReactiveProps(titleProps)))
          ])
        } : void 0
      ]), 1032, ["class", "title", "data-info", "data", "selected", "allow-clear", "show-search", "show-select-all", "simple", "onSearch"])
    ], 2);
  }
  var _Transfer = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["render", _sfc_render$i]]);
  const Transfer = Object.assign(_Transfer, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Transfer.name, _Transfer);
    }
  });
  const TreeInjectionKey = Symbol("TreeInjectionKey");
  function getFlattenTreeData(tree) {
    const flattenTreeData = [];
    function preOrder(tree2) {
      if (!tree2)
        return;
      tree2.forEach((node) => {
        flattenTreeData.push(node);
        preOrder(node.children);
      });
    }
    preOrder(tree);
    return flattenTreeData;
  }
  function getKey2TreeNode(flattenTreeData) {
    const key2TreeNode = new Map();
    flattenTreeData.forEach((node) => {
      key2TreeNode.set(node.key, node);
    });
    return key2TreeNode;
  }
  function isNodeSelectable(node) {
    return node.selectable && !node.disabled;
  }
  function isNodeExpandable(node) {
    return !node.isLeaf && node.children;
  }
  function isLeafNode(node) {
    if (isBoolean$1(node.isLeaf))
      return node.isLeaf;
    return !node.children;
  }
  function SetAdd(set) {
    return Set.prototype.add.bind(set);
  }
  function SetDelete(set) {
    return Set.prototype.delete.bind(set);
  }
  function isNodeCheckable(node) {
    if (node.disabled || node.disableCheckbox)
      return false;
    return !!node.checkable;
  }
  function getChildrenKeys(node) {
    var _a;
    const keys = [];
    (_a = node.children) == null ? void 0 : _a.forEach((child) => {
      if (isNodeCheckable(child)) {
        keys.push(child.key, ...getChildrenKeys(child));
      }
    });
    return keys;
  }
  function updateParent(options) {
    var _a;
    const { node, checkedKeySet, indeterminateKeySet } = options;
    let parentNode = node.parent;
    while (parentNode) {
      if (isNodeCheckable(parentNode)) {
        const parentKey = parentNode.key;
        const children = ((_a = parentNode.children) == null ? void 0 : _a.filter(isNodeCheckable)) || [];
        let checkedCount = 0;
        const total = children.length;
        children.some(({ key: childKey }) => {
          if (checkedKeySet.has(childKey)) {
            checkedCount += 1;
          } else if (indeterminateKeySet.has(childKey)) {
            checkedCount += 0.5;
            return true;
          }
          return false;
        });
        if (checkedCount && checkedCount !== total) {
          indeterminateKeySet.add(parentKey);
        } else {
          indeterminateKeySet.delete(parentKey);
        }
        if (checkedCount && checkedCount === total) {
          checkedKeySet.add(parentKey);
        } else {
          checkedKeySet.delete(parentKey);
        }
      }
      parentNode = parentNode.parent;
    }
  }
  function getCheckedStateByCheck(options) {
    const {
      node,
      checked,
      checkedKeys,
      indeterminateKeys,
      checkStrictly = false
    } = options;
    const { key } = node;
    const checkedKeySet = new Set(checkedKeys);
    const indeterminateKeySet = new Set(indeterminateKeys);
    checked ? checkedKeySet.add(key) : checkedKeySet.delete(key);
    indeterminateKeySet.delete(key);
    if (!checkStrictly) {
      const childKeys = getChildrenKeys(node);
      if (checked) {
        childKeys.forEach(SetAdd(checkedKeySet));
      } else {
        childKeys.forEach(SetDelete(checkedKeySet));
      }
      childKeys.forEach(SetDelete(indeterminateKeySet));
      updateParent({ node, checkedKeySet, indeterminateKeySet });
    }
    return [[...checkedKeySet], [...indeterminateKeySet]];
  }
  function getCheckedStateByInitKeys(options) {
    const { initCheckedKeys, key2TreeNode, checkStrictly, onlyCheckLeaf } = options;
    const checkedKeySet = new Set();
    const childCheckedKeySet = new Set();
    const indeterminateKeySet = new Set();
    if (!checkStrictly) {
      initCheckedKeys.forEach((key) => {
        var _a;
        const node = key2TreeNode.get(key);
        if (!node || childCheckedKeySet.has(key) || onlyCheckLeaf && ((_a = node.children) == null ? void 0 : _a.length)) {
          return;
        }
        const childKeys = getChildrenKeys(node);
        childKeys.forEach(SetAdd(childCheckedKeySet));
        childKeys.forEach(SetDelete(indeterminateKeySet));
        checkedKeySet.add(key);
        indeterminateKeySet.delete(key);
        updateParent({ node, checkedKeySet, indeterminateKeySet });
      });
    } else {
      initCheckedKeys.forEach(SetAdd(checkedKeySet));
    }
    return [[...checkedKeySet, ...childCheckedKeySet], [...indeterminateKeySet]];
  }
  function useTreeContext() {
    const treeContext = vue.inject(TreeInjectionKey);
    return treeContext || {};
  }
  const _sfc_main$i = vue.defineComponent({
    name: "IconFile",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-file`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$a = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$a = /* @__PURE__ */ vue.createElementVNode("path", { d: "M16 21h16m-16 8h10m11 13H11a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h21l7 7v27a2 2 0 0 1-2 2Z" }, null, -1);
  const _hoisted_3$9 = [
    _hoisted_2$a
  ];
  function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$9, 14, _hoisted_1$a);
  }
  var _IconFile = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["render", _sfc_render$h]]);
  const IconFile = Object.assign(_IconFile, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconFile.name, _IconFile);
    }
  });
  var _sfc_main$h = vue.defineComponent({
    name: "TreeNodeSwitcher",
    components: {
      IconLoading,
      RenderFunction
    },
    props: {
      prefixCls: String,
      loading: Boolean,
      showLine: Boolean,
      treeNodeData: {
        type: Object
      },
      icons: {
        type: Object
      },
      nodeStatus: {
        type: Object
      }
    },
    emits: ["click"],
    setup(props, {
      slots,
      emit
    }) {
      const {
        icons,
        nodeStatus,
        treeNodeData
      } = vue.toRefs(props);
      const treeContext = useTreeContext();
      const nodeSwitcherIcon = usePickSlots(slots, "switcher-icon");
      const nodeLoadingIcon = usePickSlots(slots, "loading-icon");
      return {
        getSwitcherIcon: () => {
          var _a, _b, _c;
          const icon = (_b = (_a = icons == null ? void 0 : icons.value) == null ? void 0 : _a.switcherIcon) != null ? _b : nodeSwitcherIcon.value;
          return icon ? icon(nodeStatus.value) : (_c = treeContext.switcherIcon) == null ? void 0 : _c.call(treeContext, treeNodeData.value, nodeStatus.value);
        },
        getLoadingIcon: () => {
          var _a, _b, _c;
          const icon = (_b = (_a = icons == null ? void 0 : icons.value) == null ? void 0 : _a.loadingIcon) != null ? _b : nodeLoadingIcon.value;
          return icon ? icon(nodeStatus.value) : (_c = treeContext.loadingIcon) == null ? void 0 : _c.call(treeContext, treeNodeData.value, nodeStatus.value);
        },
        onClick(e2) {
          emit("click", e2);
        }
      };
    },
    render() {
      var _a, _b, _c;
      const {
        prefixCls,
        getSwitcherIcon,
        getLoadingIcon,
        onClick,
        nodeStatus = {},
        loading,
        showLine
      } = this;
      const {
        expanded,
        isLeaf
      } = nodeStatus;
      if (loading) {
        return (_a = getLoadingIcon()) != null ? _a : vue.h(IconLoading);
      }
      let icon = null;
      let needIconHover = false;
      if (!isLeaf) {
        const defaultIcon = showLine ? vue.h("span", {
          class: `${prefixCls}-${expanded ? "minus" : "plus"}-icon`
        }) : vue.h(IconCaretDown);
        icon = (_b = getSwitcherIcon()) != null ? _b : defaultIcon;
        needIconHover = !showLine;
      } else if (showLine) {
        icon = (_c = getSwitcherIcon()) != null ? _c : vue.h(IconFile);
      }
      if (!icon)
        return null;
      const content = vue.h("span", {
        class: `${prefixCls}-switcher-icon`,
        onClick
      }, icon);
      return needIconHover ? vue.h(IconHover, {
        class: `${prefixCls}-icon-hover`
      }, () => content) : content;
    }
  });
  const generateKey = (() => {
    let i = 0;
    return () => {
      i += 1;
      return `__arco_tree${i}`;
    };
  })();
  function getBoolean(val1, val2) {
    return !!(isUndefined(val1) ? val2 : val1);
  }
  function mapObject(obj, nameMap) {
    const _obj = __spreadValues({}, obj);
    if (nameMap) {
      const names = Object.keys(nameMap);
      names.forEach((name) => {
        const sourceName = nameMap[name];
        if (sourceName !== name) {
          _obj[name] = obj[sourceName];
          delete _obj[sourceName];
        }
      });
    }
    return _obj;
  }
  function getEnableResult({
    subEnable,
    superEnable,
    isLeaf,
    treeNodeData,
    level
  }) {
    if (!isUndefined(subEnable))
      return subEnable;
    if (isFunction$1(superEnable)) {
      return superEnable(treeNodeData, { isLeaf, level });
    }
    return superEnable != null ? superEnable : false;
  }
  function generateNode(options) {
    var _a, _b;
    const { treeNodeData, parentNode, isTail = true, treeProps } = options;
    const { fieldNames } = treeProps || {};
    const mapTreeNodeData = mapObject(treeNodeData, fieldNames);
    const isLeaf = treeProps.loadMore ? !!mapTreeNodeData.isLeaf : !((_a = mapTreeNodeData.children) == null ? void 0 : _a.length);
    const level = parentNode ? parentNode.level + 1 : 0;
    const treeNodeProps = __spreadProps(__spreadValues({}, omit(mapTreeNodeData, ["children"])), {
      key: (_b = mapTreeNodeData.key) != null ? _b : generateKey(),
      selectable: getEnableResult({
        subEnable: mapTreeNodeData.selectable,
        superEnable: treeProps == null ? void 0 : treeProps.selectable,
        isLeaf,
        level,
        treeNodeData
      }),
      disabled: !!mapTreeNodeData.disabled,
      disableCheckbox: !!mapTreeNodeData.disableCheckbox,
      checkable: getEnableResult({
        subEnable: mapTreeNodeData.checkable,
        superEnable: treeProps == null ? void 0 : treeProps.checkable,
        isLeaf,
        level,
        treeNodeData
      }),
      isLeaf,
      isTail,
      blockNode: !!(treeProps == null ? void 0 : treeProps.blockNode),
      showLine: !!(treeProps == null ? void 0 : treeProps.showLine),
      level,
      lineless: parentNode ? [...parentNode.lineless, parentNode.isTail] : [],
      draggable: getBoolean(mapTreeNodeData.draggable, treeProps == null ? void 0 : treeProps.draggable)
    });
    const node = __spreadProps(__spreadValues({}, treeNodeProps), {
      treeNodeProps,
      treeNodeData,
      parent: parentNode,
      parentKey: parentNode == null ? void 0 : parentNode.key,
      pathParentKeys: parentNode ? [...parentNode.pathParentKeys, parentNode.key] : []
    });
    return node;
  }
  function generateTreeData(treeData, treeProps) {
    function preOrder(tree, parentNode) {
      if (!tree)
        return void 0;
      const { fieldNames } = treeProps;
      const nodes = [];
      tree.forEach((treeNodeData, index2) => {
        const node = generateNode({
          treeNodeData,
          treeProps,
          parentNode,
          isTail: index2 === tree.length - 1
        });
        node.children = preOrder(treeNodeData[(fieldNames == null ? void 0 : fieldNames.children) || "children"], node);
        nodes.push(node);
      });
      return nodes;
    }
    return preOrder(treeData);
  }
  function useNodeKey() {
    const instance = vue.getCurrentInstance();
    const getKey2 = () => {
      var _a;
      return (_a = instance == null ? void 0 : instance.vnode.key) != null ? _a : generateKey();
    };
    const key = vue.ref(getKey2());
    vue.onUpdated(() => {
      key.value = getKey2();
    });
    return key;
  }
  function useDraggable(props) {
    const { key, refTitle } = vue.toRefs(props);
    const treeContext = useTreeContext();
    const isDragOver = vue.ref(false);
    const isDragging = vue.ref(false);
    const isAllowDrop = vue.ref(false);
    const dropPosition = vue.ref(0);
    const updateDropPosition = throttleByRaf((e2) => {
      if (!refTitle.value)
        return;
      const rect = refTitle.value.getBoundingClientRect();
      const offsetY = window.pageYOffset + rect.top;
      const { pageY } = e2;
      const gapHeight = rect.height / 4;
      const diff = pageY - offsetY;
      dropPosition.value = diff < gapHeight ? -1 : diff < rect.height - gapHeight ? 0 : 1;
      isAllowDrop.value = treeContext.allowDrop ? treeContext.allowDrop(key.value, dropPosition.value) : true;
    });
    return {
      isDragOver,
      isDragging,
      isAllowDrop,
      dropPosition,
      setDragStatus(status, e2) {
        switch (status) {
          case "dragStart":
            isDragging.value = true;
            dropPosition.value = 0;
            treeContext.onDragStart && treeContext.onDragStart(key.value, e2);
            break;
          case "dragEnd":
            isDragging.value = false;
            isDragOver.value = false;
            dropPosition.value = 0;
            updateDropPosition.cancel();
            treeContext.onDragEnd && treeContext.onDragEnd(key.value, e2);
            break;
          case "dragOver":
            isDragOver.value = true;
            updateDropPosition(e2);
            treeContext.onDragOver && treeContext.onDragOver(key.value, e2);
            break;
          case "dragLeave":
            isDragOver.value = false;
            dropPosition.value = 0;
            updateDropPosition.cancel();
            treeContext.onDragLeave && treeContext.onDragLeave(key.value, e2);
            break;
          case "drop":
            treeContext.onDrop && treeContext.onDrop(key.value, dropPosition.value, e2);
            isDragOver.value = false;
            dropPosition.value = 0;
            updateDropPosition.cancel();
            break;
        }
      }
    };
  }
  function toArray(val) {
    return isArray$1(val) ? val : [val];
  }
  const _sfc_main$g = vue.defineComponent({
    name: "BaseTreeNode",
    components: {
      NodeSwitcher: _sfc_main$h,
      Checkbox,
      RenderFunction,
      IconDragDotVertical
    },
    props: {
      key: {
        type: [String, Number]
      },
      title: {
        type: String
      },
      selectable: {
        type: Boolean
      },
      disabled: {
        type: Boolean
      },
      disableCheckbox: {
        type: Boolean
      },
      checkable: {
        type: Boolean
      },
      draggable: {
        type: Boolean
      },
      isLeaf: {
        type: Boolean
      },
      icon: {
        type: Function
      },
      switcherIcon: {
        type: Function
      },
      loadingIcon: {
        type: Function
      },
      dragIcon: {
        type: Function
      },
      isTail: {
        type: Boolean
      },
      blockNode: {
        type: Boolean
      },
      showLine: {
        type: Boolean
      },
      level: {
        type: Number,
        default: 0
      },
      lineless: {
        type: Array,
        default: () => []
      }
    },
    setup(props) {
      const key = useNodeKey();
      const prefixCls = getPrefixCls("tree-node");
      const treeContext = useTreeContext();
      const node = vue.computed(() => {
        var _a;
        return (_a = treeContext.key2TreeNode) == null ? void 0 : _a.get(key.value);
      });
      const treeNodeData = vue.computed(() => node.value.treeNodeData);
      const children = vue.computed(() => node.value.children);
      const actionOnNodeClick = vue.computed(() => {
        var _a;
        const action = (_a = treeContext.treeProps) == null ? void 0 : _a.actionOnNodeClick;
        return action ? toArray(action) : [];
      });
      const { isLeaf, isTail, selectable, disabled, disableCheckbox, draggable } = vue.toRefs(props);
      const classNames = vue.computed(() => {
        var _a;
        return [
          `${prefixCls}`,
          {
            [`${prefixCls}-selected`]: selected.value,
            [`${prefixCls}-is-leaf`]: isLeaf.value,
            [`${prefixCls}-is-tail`]: isTail.value,
            [`${prefixCls}-expanded`]: expanded.value,
            [`${prefixCls}-disabled-selectable`]: !selectable.value && !((_a = treeContext.treeProps) == null ? void 0 : _a.disableSelectActionOnly),
            [`${prefixCls}-disabled`]: disabled.value
          }
        ];
      });
      const refTitle = vue.ref();
      const { isDragOver, isDragging, isAllowDrop, dropPosition, setDragStatus } = useDraggable(vue.reactive({
        key,
        refTitle
      }));
      const titleClassNames = vue.computed(() => [
        `${prefixCls}-title`,
        {
          [`${prefixCls}-title-draggable`]: draggable.value,
          [`${prefixCls}-title-gap-top`]: isDragOver.value && isAllowDrop.value && dropPosition.value < 0,
          [`${prefixCls}-title-gap-bottom`]: isDragOver.value && isAllowDrop.value && dropPosition.value > 0,
          [`${prefixCls}-title-highlight`]: !isDragging.value && isDragOver.value && isAllowDrop.value && dropPosition.value === 0,
          [`${prefixCls}-title-dragging`]: isDragging.value,
          [`${prefixCls}-title-block`]: node.value.blockNode
        }
      ]);
      const checked = vue.computed(() => {
        var _a, _b;
        return (_b = (_a = treeContext.checkedKeys) == null ? void 0 : _a.includes) == null ? void 0 : _b.call(_a, key.value);
      });
      const indeterminate = vue.computed(() => {
        var _a, _b;
        return (_b = (_a = treeContext.indeterminateKeys) == null ? void 0 : _a.includes) == null ? void 0 : _b.call(_a, key.value);
      });
      const selected = vue.computed(() => {
        var _a, _b;
        return (_b = (_a = treeContext.selectedKeys) == null ? void 0 : _a.includes) == null ? void 0 : _b.call(_a, key.value);
      });
      const expanded = vue.computed(() => {
        var _a, _b;
        return (_b = (_a = treeContext.expandedKeys) == null ? void 0 : _a.includes) == null ? void 0 : _b.call(_a, key.value);
      });
      const loading = vue.computed(() => {
        var _a, _b;
        return (_b = (_a = treeContext.loadingKeys) == null ? void 0 : _a.includes) == null ? void 0 : _b.call(_a, key.value);
      });
      const treeDragIcon = vue.computed(() => treeContext.dragIcon);
      const treeNodeIcon = vue.computed(() => treeContext.nodeIcon);
      function onSwitcherClick(e2) {
        var _a, _b;
        if (isLeaf.value)
          return;
        if (!((_a = children.value) == null ? void 0 : _a.length) && isFunction$1(treeContext.onLoadMore)) {
          treeContext.onLoadMore(key.value);
        } else {
          (_b = treeContext == null ? void 0 : treeContext.onExpand) == null ? void 0 : _b.call(treeContext, !expanded.value, key.value, e2);
        }
      }
      const nodeStatus = vue.reactive({
        loading,
        checked,
        selected,
        indeterminate,
        expanded,
        isLeaf
      });
      const treeTitle = vue.computed(() => treeContext.nodeTitle ? () => {
        var _a;
        return (_a = treeContext.nodeTitle) == null ? void 0 : _a.call(treeContext, treeNodeData.value, nodeStatus);
      } : void 0);
      const extra = vue.computed(() => treeContext.nodeExtra ? () => {
        var _a;
        return (_a = treeContext.nodeExtra) == null ? void 0 : _a.call(treeContext, treeNodeData.value, nodeStatus);
      } : void 0);
      return {
        nodekey: key,
        refTitle,
        prefixCls,
        classNames,
        titleClassNames,
        indeterminate,
        checked,
        expanded,
        selected,
        treeTitle,
        treeNodeData,
        loading,
        treeDragIcon,
        treeNodeIcon,
        extra,
        nodeStatus,
        onCheckboxChange(checked2, e2) {
          var _a;
          if (disableCheckbox.value || disabled.value) {
            return;
          }
          (_a = treeContext.onCheck) == null ? void 0 : _a.call(treeContext, checked2, key.value, e2);
        },
        onTitleClick(e2) {
          var _a;
          if (actionOnNodeClick.value.includes("expand")) {
            onSwitcherClick(e2);
          }
          if (!selectable.value || disabled.value)
            return;
          (_a = treeContext.onSelect) == null ? void 0 : _a.call(treeContext, key.value, e2);
        },
        onSwitcherClick,
        onDragStart(e2) {
          var _a;
          if (!draggable.value)
            return;
          e2.stopPropagation();
          setDragStatus("dragStart", e2);
          try {
            (_a = e2.dataTransfer) == null ? void 0 : _a.setData("text/plain", "");
          } catch (error) {
          }
        },
        onDragEnd(e2) {
          if (!draggable.value)
            return;
          e2.stopPropagation();
          setDragStatus("dragEnd", e2);
        },
        onDragOver(e2) {
          if (!draggable)
            return;
          e2.stopPropagation();
          e2.preventDefault();
          setDragStatus("dragOver", e2);
        },
        onDragLeave(e2) {
          if (!draggable.value)
            return;
          e2.stopPropagation();
          setDragStatus("dragLeave", e2);
        },
        onDrop(e2) {
          if (!draggable.value || !isAllowDrop.value)
            return;
          e2.stopPropagation();
          e2.preventDefault();
          setDragStatus("drop", e2);
        }
      };
    }
  });
  const _hoisted_1$9 = ["data-level", "data-key"];
  const _hoisted_2$9 = ["draggable"];
  function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_NodeSwitcher = vue.resolveComponent("NodeSwitcher");
    const _component_Checkbox = vue.resolveComponent("Checkbox");
    const _component_RenderFunction = vue.resolveComponent("RenderFunction");
    const _component_IconDragDotVertical = vue.resolveComponent("IconDragDotVertical");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.classNames),
      "data-level": _ctx.level,
      "data-key": _ctx.nodekey
    }, [
      vue.createCommentVNode(" \u7F29\u8FDB "),
      vue.createElementVNode("span", {
        class: vue.normalizeClass(`${_ctx.prefixCls}-indent`)
      }, [
        (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.level, (i) => {
          return vue.openBlock(), vue.createElementBlock("span", {
            key: i,
            class: vue.normalizeClass([
              `${_ctx.prefixCls}-indent-block`,
              {
                [`${_ctx.prefixCls}-indent-block-lineless`]: _ctx.lineless[i - 1]
              }
            ])
          }, null, 2);
        }), 128))
      ], 2),
      vue.createCommentVNode(" switcher "),
      vue.createElementVNode("span", {
        class: vue.normalizeClass([
          `${_ctx.prefixCls}-switcher`,
          {
            [`${_ctx.prefixCls}-switcher-expanded`]: _ctx.expanded
          }
        ])
      }, [
        vue.createVNode(_component_NodeSwitcher, {
          "prefix-cls": _ctx.prefixCls,
          loading: _ctx.loading,
          "show-line": _ctx.showLine,
          "tree-node-data": _ctx.treeNodeData,
          icons: {
            switcherIcon: _ctx.switcherIcon,
            loadingIcon: _ctx.loadingIcon
          },
          "node-status": _ctx.nodeStatus,
          onClick: _ctx.onSwitcherClick
        }, vue.createSlots({ _: 2 }, [
          _ctx.$slots["switcher-icon"] ? {
            name: "switcher-icon",
            fn: vue.withCtx(() => [
              vue.createCommentVNode(" @slot \u5B9A\u5236 switcher \u56FE\u6807\uFF0C\u4F1A\u8986\u76D6 Tree \u7684\u914D\u7F6E "),
              vue.renderSlot(_ctx.$slots, "switcher-icon")
            ])
          } : void 0,
          _ctx.$slots["loading-icon"] ? {
            name: "loading-icon",
            fn: vue.withCtx(() => [
              vue.createCommentVNode(" @slot \u5B9A\u5236 loading \u56FE\u6807\uFF0C\u4F1A\u8986\u76D6 Tree \u7684\u914D\u7F6E "),
              vue.renderSlot(_ctx.$slots, "loading-icon")
            ])
          } : void 0
        ]), 1032, ["prefix-cls", "loading", "show-line", "tree-node-data", "icons", "node-status", "onClick"])
      ], 2),
      vue.createCommentVNode(" checkbox "),
      _ctx.checkable ? (vue.openBlock(), vue.createBlock(_component_Checkbox, {
        key: 0,
        disabled: _ctx.disableCheckbox || _ctx.disabled,
        "model-value": _ctx.checked,
        indeterminate: _ctx.indeterminate,
        "uninject-group-context": "",
        onChange: _ctx.onCheckboxChange
      }, null, 8, ["disabled", "model-value", "indeterminate", "onChange"])) : vue.createCommentVNode("v-if", true),
      vue.createCommentVNode(" \u5185\u5BB9 "),
      vue.createElementVNode("span", {
        ref: "refTitle",
        class: vue.normalizeClass(_ctx.titleClassNames),
        draggable: _ctx.draggable,
        onDragstart: _cache[0] || (_cache[0] = (...args) => _ctx.onDragStart && _ctx.onDragStart(...args)),
        onDragend: _cache[1] || (_cache[1] = (...args) => _ctx.onDragEnd && _ctx.onDragEnd(...args)),
        onDragover: _cache[2] || (_cache[2] = (...args) => _ctx.onDragOver && _ctx.onDragOver(...args)),
        onDragleave: _cache[3] || (_cache[3] = (...args) => _ctx.onDragLeave && _ctx.onDragLeave(...args)),
        onDrop: _cache[4] || (_cache[4] = (...args) => _ctx.onDrop && _ctx.onDrop(...args)),
        onClick: _cache[5] || (_cache[5] = (...args) => _ctx.onTitleClick && _ctx.onTitleClick(...args))
      }, [
        _ctx.$slots.icon || _ctx.icon || _ctx.treeNodeIcon ? (vue.openBlock(), vue.createElementBlock("span", {
          key: 0,
          class: vue.normalizeClass([`${_ctx.prefixCls}-icon`, `${_ctx.prefixCls}-custom-icon`])
        }, [
          vue.createCommentVNode(" \u8282\u70B9\u56FE\u6807 "),
          _ctx.$slots.icon ? vue.renderSlot(_ctx.$slots, "icon", vue.normalizeProps(vue.mergeProps({ key: 0 }, _ctx.nodeStatus))) : _ctx.icon ? (vue.openBlock(), vue.createBlock(_component_RenderFunction, vue.mergeProps({
            key: 1,
            "render-func": _ctx.icon
          }, _ctx.nodeStatus), null, 16, ["render-func"])) : _ctx.treeNodeIcon ? (vue.openBlock(), vue.createBlock(_component_RenderFunction, vue.mergeProps({
            key: 2,
            "render-func": _ctx.treeNodeIcon,
            node: _ctx.treeNodeData
          }, _ctx.nodeStatus), null, 16, ["render-func", "node"])) : vue.createCommentVNode("v-if", true)
        ], 2)) : vue.createCommentVNode("v-if", true),
        vue.createElementVNode("span", {
          class: vue.normalizeClass(`${_ctx.prefixCls}-title-text`)
        }, [
          _ctx.treeTitle ? (vue.openBlock(), vue.createBlock(_component_RenderFunction, {
            key: 0,
            "render-func": _ctx.treeTitle
          }, null, 8, ["render-func"])) : (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 1 }, [
            vue.createCommentVNode(" \u6807\u9898\uFF0CtreeTitle \u4F18\u5148\u7EA7\u9AD8\u4E8E\u8282\u70B9\u7684 title "),
            vue.renderSlot(_ctx.$slots, "title", {}, () => [
              vue.createTextVNode(vue.toDisplayString(_ctx.title), 1)
            ])
          ], 2112)),
          _ctx.draggable ? (vue.openBlock(), vue.createElementBlock("span", {
            key: 2,
            class: vue.normalizeClass([`${_ctx.prefixCls}-icon`, `${_ctx.prefixCls}-drag-icon`])
          }, [
            vue.createCommentVNode(" \u62D6\u62FD\u56FE\u6807 "),
            _ctx.$slots["drag-icon"] ? vue.renderSlot(_ctx.$slots, "drag-icon", vue.normalizeProps(vue.mergeProps({ key: 0 }, _ctx.nodeStatus))) : _ctx.dragIcon ? (vue.openBlock(), vue.createBlock(_component_RenderFunction, vue.mergeProps({
              key: 1,
              "render-func": _ctx.dragIcon
            }, _ctx.nodeStatus), null, 16, ["render-func"])) : _ctx.treeDragIcon ? (vue.openBlock(), vue.createBlock(_component_RenderFunction, vue.mergeProps({
              key: 2,
              "render-func": _ctx.treeDragIcon,
              node: _ctx.treeNodeData
            }, _ctx.nodeStatus), null, 16, ["render-func", "node"])) : (vue.openBlock(), vue.createBlock(_component_IconDragDotVertical, { key: 3 }))
          ], 2)) : vue.createCommentVNode("v-if", true)
        ], 2)
      ], 42, _hoisted_2$9),
      vue.createCommentVNode(" \u989D\u5916 "),
      _ctx.extra ? (vue.openBlock(), vue.createBlock(_component_RenderFunction, {
        key: 1,
        "render-func": _ctx.extra
      }, null, 8, ["render-func"])) : vue.createCommentVNode("v-if", true)
    ], 10, _hoisted_1$9);
  }
  var BaseTreeNode = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$g]]);
  const _sfc_main$f = vue.defineComponent({
    name: "ExpandTransition",
    props: {
      expanded: Boolean
    },
    emits: ["end"],
    setup(props, { emit }) {
      return {
        onBeforeEnter(el) {
          el.style.height = props.expanded ? "0" : `${el.scrollHeight}px`;
        },
        onEnter(el) {
          el.style.height = props.expanded ? `${el.scrollHeight}px` : "0";
        },
        onAfterEnter(el) {
          el.style.height = props.expanded ? "" : "0";
          emit("end");
        },
        onBeforeLeave(el) {
          el.style.display = "none";
        }
      };
    }
  });
  function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createBlock(vue.Transition, {
      onBeforeEnter: _ctx.onBeforeEnter,
      onEnter: _ctx.onEnter,
      onAfterEnter: _ctx.onAfterEnter,
      onBeforeLeave: _ctx.onBeforeLeave
    }, {
      default: vue.withCtx(() => [
        vue.renderSlot(_ctx.$slots, "default")
      ]),
      _: 3
    }, 8, ["onBeforeEnter", "onEnter", "onAfterEnter", "onBeforeLeave"]);
  }
  var ExpandTransition = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$f]]);
  const _sfc_main$e = vue.defineComponent({
    name: "TransitionNodeList",
    components: {
      ExpandTransition,
      BaseTreeNode
    },
    props: {
      nodeKey: {
        type: [String, Number],
        required: true
      }
    },
    setup(props) {
      const prefixCls = getPrefixCls("tree");
      const classNames = [`${prefixCls}-node-list`];
      const treeContext = useTreeContext();
      const { nodeKey } = vue.toRefs(props);
      const expanded = vue.computed(() => {
        var _a, _b;
        return (_b = (_a = treeContext.expandedKeys) == null ? void 0 : _a.includes) == null ? void 0 : _b.call(_a, nodeKey.value);
      });
      const visibleNodeList = vue.computed(() => {
        var _a;
        const expandedKeysSet = new Set(treeContext.expandedKeys || []);
        const childNodeList = (_a = treeContext.flattenTreeData) == null ? void 0 : _a.filter((node) => {
          var _a2, _b;
          if ((_a2 = node.pathParentKeys) == null ? void 0 : _a2.includes(nodeKey.value)) {
            return !treeContext.filterTreeNode || ((_b = treeContext.filterTreeNode) == null ? void 0 : _b.call(treeContext, node.treeNodeData));
          }
          return false;
        });
        return childNodeList == null ? void 0 : childNodeList.filter((node) => {
          var _a2;
          if (expanded.value) {
            return (_a2 = node.pathParentKeys) == null ? void 0 : _a2.every((_key) => expandedKeysSet.has(_key));
          }
          const index2 = node.pathParentKeys.indexOf(nodeKey.value);
          return node.pathParentKeys.slice(index2 + 1).every((_key) => expandedKeysSet.has(_key));
        });
      });
      const show = vue.computed(() => {
        var _a, _b;
        return ((_a = treeContext.currentExpandKeys) == null ? void 0 : _a.includes(nodeKey.value)) && ((_b = visibleNodeList.value) == null ? void 0 : _b.length);
      });
      return {
        classNames,
        visibleNodeList,
        show,
        expanded,
        onTransitionEnd() {
          var _a;
          (_a = treeContext.onExpandEnd) == null ? void 0 : _a.call(treeContext, nodeKey.value);
        }
      };
    }
  });
  function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_BaseTreeNode = vue.resolveComponent("BaseTreeNode");
    const _component_ExpandTransition = vue.resolveComponent("ExpandTransition");
    return vue.openBlock(), vue.createBlock(_component_ExpandTransition, {
      expanded: _ctx.expanded,
      onEnd: _ctx.onTransitionEnd
    }, {
      default: vue.withCtx(() => [
        _ctx.show ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 0,
          class: vue.normalizeClass(_ctx.classNames)
        }, [
          (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.visibleNodeList, (node) => {
            return vue.openBlock(), vue.createBlock(_component_BaseTreeNode, vue.mergeProps({
              key: node.key
            }, node.treeNodeProps), null, 16);
          }), 128))
        ], 2)) : vue.createCommentVNode("v-if", true)
      ]),
      _: 1
    }, 8, ["expanded", "onEnd"]);
  }
  var TransitionNodeList = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$e]]);
  var TreeNode = vue.defineComponent({
    name: "TreeNode",
    inheritAttrs: false,
    props: __spreadValues({}, BaseTreeNode.props),
    setup(props, {
      slots,
      attrs
    }) {
      const key = useNodeKey();
      return () => {
        return vue.createVNode(vue.Fragment, null, [vue.createVNode(BaseTreeNode, vue.mergeProps(props, attrs, {
          "key": key.value
        }), slots), vue.createVNode(TransitionNodeList, {
          "key": key.value,
          "nodeKey": key.value
        }, null)]);
      };
    }
  });
  function useCheckedState(props) {
    const {
      defaultCheckedKeys,
      checkedKeys: propCheckedKeys,
      key2TreeNode,
      checkStrictly,
      halfCheckedKeys,
      onlyCheckLeaf
    } = vue.toRefs(props);
    const isInitialized = vue.ref(false);
    const localCheckedKeys = vue.ref([]);
    const localIndeterminateKeys = vue.ref([]);
    const computedCheckedKeys = vue.ref();
    const computedIndeterminateKeys = vue.ref();
    const getStateByKeys = (keys) => {
      return getCheckedStateByInitKeys({
        initCheckedKeys: keys,
        key2TreeNode: key2TreeNode.value,
        checkStrictly: checkStrictly.value,
        onlyCheckLeaf: onlyCheckLeaf.value
      });
    };
    const init = (keys) => {
      const initState = getStateByKeys(keys);
      [localCheckedKeys.value, localIndeterminateKeys.value] = initState;
    };
    init(propCheckedKeys.value || (defaultCheckedKeys == null ? void 0 : defaultCheckedKeys.value) || []);
    vue.watchEffect(() => {
      if (propCheckedKeys.value) {
        [computedCheckedKeys.value, computedIndeterminateKeys.value] = getStateByKeys(propCheckedKeys.value);
      } else if (isInitialized.value) {
        computedCheckedKeys.value = void 0;
        computedIndeterminateKeys.value = void 0;
        localCheckedKeys.value = [];
        localIndeterminateKeys.value = [];
      }
      if (!isInitialized.value) {
        isInitialized.value = true;
      }
    });
    return {
      checkedKeys: vue.computed(() => computedCheckedKeys.value || localCheckedKeys.value),
      indeterminateKeys: vue.computed(() => {
        if (checkStrictly.value && halfCheckedKeys.value) {
          return halfCheckedKeys.value;
        }
        return computedIndeterminateKeys.value || localIndeterminateKeys.value;
      }),
      setCheckedState(newCheckedKeys, newIndeterminateKeys, reinitialize = false) {
        if (reinitialize) {
          init(newCheckedKeys);
        } else {
          localCheckedKeys.value = newCheckedKeys;
          localIndeterminateKeys.value = newIndeterminateKeys;
        }
        return [localCheckedKeys.value, localIndeterminateKeys.value];
      }
    };
  }
  function useTreeData(props) {
    const {
      treeData: propTreeData,
      fieldNames,
      selectable,
      showLine,
      blockNode,
      checkable,
      loadMore,
      draggable
    } = vue.toRefs(props);
    const treeData = vue.ref([]);
    vue.watchEffect(() => {
      var _a, _b;
      treeData.value = generateTreeData(propTreeData.value || [], {
        selectable: (_a = selectable == null ? void 0 : selectable.value) != null ? _a : false,
        showLine: !!(showLine == null ? void 0 : showLine.value),
        blockNode: !!(blockNode == null ? void 0 : blockNode.value),
        checkable: (_b = checkable == null ? void 0 : checkable.value) != null ? _b : false,
        fieldNames: fieldNames == null ? void 0 : fieldNames.value,
        loadMore: !!(loadMore == null ? void 0 : loadMore.value),
        draggable: !!(draggable == null ? void 0 : draggable.value)
      });
    });
    const flattenTreeData = vue.computed(() => getFlattenTreeData(treeData.value));
    const key2TreeNode = vue.computed(() => getKey2TreeNode(flattenTreeData.value));
    return { treeData, flattenTreeData, key2TreeNode };
  }
  const _sfc_main$d = vue.defineComponent({
    name: "Tree",
    components: {
      VirtualList,
      TreeNode
    },
    props: {
      size: {
        type: String,
        default: "medium"
      },
      blockNode: {
        type: Boolean
      },
      defaultExpandAll: {
        type: Boolean,
        default: true
      },
      multiple: {
        type: Boolean
      },
      checkable: {
        type: [Boolean, String, Function],
        default: false
      },
      selectable: {
        type: [Boolean, Function],
        default: true
      },
      checkStrictly: {
        type: Boolean
      },
      checkedStrategy: {
        type: String,
        default: "all"
      },
      defaultSelectedKeys: {
        type: Array
      },
      selectedKeys: {
        type: Array
      },
      defaultCheckedKeys: {
        type: Array
      },
      checkedKeys: {
        type: Array
      },
      defaultExpandedKeys: {
        type: Array
      },
      expandedKeys: {
        type: Array
      },
      data: {
        type: Array,
        default: () => []
      },
      fieldNames: {
        type: Object
      },
      showLine: {
        type: Boolean
      },
      loadMore: {
        type: Function
      },
      draggable: {
        type: Boolean
      },
      allowDrop: {
        type: Function
      },
      filterTreeNode: {
        type: Function
      },
      searchValue: {
        type: String,
        default: ""
      },
      virtualListProps: {
        type: Object
      },
      defaultExpandSelected: {
        type: Boolean
      },
      defaultExpandChecked: {
        type: Boolean
      },
      autoExpandParent: {
        type: Boolean,
        default: true
      },
      halfCheckedKeys: {
        type: Array
      },
      onlyCheckLeaf: {
        type: Boolean,
        default: false
      },
      animation: {
        type: Boolean,
        default: true
      },
      actionOnNodeClick: {
        type: String
      },
      disableSelectActionOnly: {
        type: Boolean,
        default: false
      }
    },
    emits: {
      "select": (selectedKeys, data) => true,
      "update:selectedKeys": (selectedKeys) => true,
      "check": (checkedKeys, data) => true,
      "update:checkedKeys": (checkedKeys) => true,
      "update:halfCheckedKeys": (halfCheckedKeys) => true,
      "expand": (expandKeys, data) => true,
      "update:expandedKeys": (expandKeys) => true,
      "dragStart": (ev, node) => true,
      "dragEnd": (ev, node) => true,
      "dragOver": (ev, node) => true,
      "dragLeave": (ev, node) => true,
      "drop": (data) => true
    },
    setup(props, { emit, slots }) {
      const {
        data: propTreeData,
        showLine,
        multiple,
        loadMore,
        checkStrictly,
        checkedKeys: propCheckedKeys,
        defaultCheckedKeys,
        selectedKeys: propSelectedKeys,
        defaultSelectedKeys,
        expandedKeys: propExpandedKeys,
        defaultExpandedKeys,
        checkedStrategy,
        selectable,
        checkable,
        blockNode,
        fieldNames,
        size,
        defaultExpandAll,
        filterTreeNode,
        draggable,
        allowDrop,
        defaultExpandSelected,
        defaultExpandChecked,
        autoExpandParent,
        halfCheckedKeys,
        onlyCheckLeaf,
        animation
      } = vue.toRefs(props);
      const prefixCls = getPrefixCls("tree");
      const classNames = vue.computed(() => [
        `${prefixCls}`,
        {
          [`${prefixCls}-checkable`]: checkable.value,
          [`${prefixCls}-show-line`]: showLine.value
        },
        `${prefixCls}-size-${size.value}`
      ]);
      const switcherIcon = usePickSlots(slots, "switcher-icon");
      const loadingIcon = usePickSlots(slots, "loading-icon");
      const dragIcon = usePickSlots(slots, "drag-icon");
      const nodeIcon = usePickSlots(slots, "icon");
      const nodeTitle = usePickSlots(slots, "title");
      const nodeExtra = usePickSlots(slots, "extra");
      const { treeData, flattenTreeData, key2TreeNode } = useTreeData(vue.reactive({
        treeData: propTreeData,
        selectable,
        showLine,
        blockNode,
        checkable,
        fieldNames,
        loadMore,
        draggable
      }));
      const { checkedKeys, indeterminateKeys, setCheckedState } = useCheckedState(vue.reactive({
        defaultCheckedKeys,
        checkedKeys: propCheckedKeys,
        checkStrictly,
        key2TreeNode,
        halfCheckedKeys,
        onlyCheckLeaf
      }));
      const [selectedKeys, setSelectedState] = useMergeState((defaultSelectedKeys == null ? void 0 : defaultSelectedKeys.value) || [], vue.reactive({
        value: propSelectedKeys
      }));
      const loadingKeys = vue.ref([]);
      const dragNode = vue.ref();
      function getDefaultExpandedKeys() {
        if (defaultExpandedKeys == null ? void 0 : defaultExpandedKeys.value) {
          const expandedKeysSet = new Set([]);
          defaultExpandedKeys.value.forEach((_key) => {
            if (expandedKeysSet.has(_key))
              return;
            const node = key2TreeNode.value.get(_key);
            if (!node)
              return;
            [
              ...autoExpandParent.value ? node.pathParentKeys : [],
              _key
            ].forEach((_key2) => expandedKeysSet.add(_key2));
          });
          return [...expandedKeysSet];
        }
        if (defaultExpandAll.value) {
          return flattenTreeData.value.filter((node) => node.children && node.children.length).map((node) => node.key);
        }
        if (defaultExpandSelected.value || defaultExpandChecked.value) {
          const expandedKeysSet = new Set([]);
          const addToExpandKeysSet = (keys) => {
            keys.forEach((key) => {
              const node = key2TreeNode.value.get(key);
              if (!node)
                return;
              (node.pathParentKeys || []).forEach((k) => expandedKeysSet.add(k));
            });
          };
          if (defaultExpandSelected.value) {
            addToExpandKeysSet(selectedKeys.value);
          }
          if (defaultExpandChecked.value) {
            addToExpandKeysSet(checkedKeys.value);
          }
          return [...expandedKeysSet];
        }
        return [];
      }
      const [expandedKeys, setExpandState] = useMergeState(getDefaultExpandedKeys(), vue.reactive({
        value: propExpandedKeys
      }));
      const currentExpandKeys = vue.ref([]);
      const visibleTreeNodeList = vue.computed(() => {
        const expandedKeysSet = new Set(expandedKeys.value);
        const currentExpandKeysSet = new Set(currentExpandKeys.value);
        return flattenTreeData.value.filter((node) => {
          var _a;
          const passFilter = !filterTreeNode || !filterTreeNode.value || (filterTreeNode == null ? void 0 : filterTreeNode.value(node.treeNodeData));
          if (!passFilter)
            return false;
          const isRoot = isUndefined(node.parentKey);
          const isVisibleNode = (_a = node.pathParentKeys) == null ? void 0 : _a.every((_key) => expandedKeysSet.has(_key) && !currentExpandKeysSet.has(_key));
          return isRoot || isVisibleNode;
        });
      });
      function getPublicCheckedKeys(rawCheckedKeys, rawCheckedStrategy = checkedStrategy.value) {
        let publicCheckedKeys = [...rawCheckedKeys];
        if (rawCheckedStrategy === "parent") {
          publicCheckedKeys = rawCheckedKeys.filter((_key) => {
            const item = key2TreeNode.value.get(_key);
            return item && !(!isUndefined(item.parentKey) && rawCheckedKeys.includes(item.parentKey));
          });
        } else if (rawCheckedStrategy === "child") {
          publicCheckedKeys = rawCheckedKeys.filter((_key) => {
            var _a, _b;
            return !((_b = (_a = key2TreeNode.value.get(_key)) == null ? void 0 : _a.children) == null ? void 0 : _b.length);
          });
        }
        return publicCheckedKeys;
      }
      function getNodes(keys) {
        return keys.map((key) => {
          var _a;
          return ((_a = key2TreeNode.value.get(key)) == null ? void 0 : _a.treeNodeData) || void 0;
        }).filter(Boolean);
      }
      function emitCheckEvent(options) {
        const {
          targetKey,
          targetChecked,
          newCheckedKeys,
          newIndeterminateKeys,
          event
        } = options;
        const targetNode = targetKey ? key2TreeNode.value.get(targetKey) : void 0;
        const publicCheckedKeys = getPublicCheckedKeys(newCheckedKeys);
        emit("update:checkedKeys", publicCheckedKeys);
        emit("update:halfCheckedKeys", newIndeterminateKeys);
        emit("check", publicCheckedKeys, {
          checked: targetChecked,
          node: targetNode == null ? void 0 : targetNode.treeNodeData,
          checkedNodes: getNodes(publicCheckedKeys),
          halfCheckedKeys: newIndeterminateKeys,
          halfCheckedNodes: getNodes(newIndeterminateKeys),
          e: event
        });
      }
      function emitSelectEvent(options) {
        const { targetKey, targetSelected, newSelectedKeys, event } = options;
        const targetNode = targetKey ? key2TreeNode.value.get(targetKey) : void 0;
        emit("update:selectedKeys", newSelectedKeys);
        emit("select", newSelectedKeys, {
          selected: targetSelected,
          node: targetNode == null ? void 0 : targetNode.treeNodeData,
          selectedNodes: getNodes(newSelectedKeys),
          e: event
        });
      }
      function emitExpandEvent(options) {
        const { targetKey, targetExpanded, newExpandedKeys, event } = options;
        const targetNode = targetKey ? key2TreeNode.value.get(targetKey) : void 0;
        emit("expand", newExpandedKeys, {
          expanded: targetExpanded,
          node: targetNode == null ? void 0 : targetNode.treeNodeData,
          expandedNodes: getNodes(newExpandedKeys),
          e: event
        });
        emit("update:expandedKeys", newExpandedKeys);
      }
      function setCheckedKeys(keys) {
        const [newCheckedKeys, newIndeterminateKeys] = setCheckedState(keys, [], true);
        emitCheckEvent({ newCheckedKeys, newIndeterminateKeys });
      }
      function setSelectedKeys(keys) {
        let newSelectedKeys = keys;
        if (!multiple.value && keys.length > 1) {
          newSelectedKeys = [keys[0]];
        }
        setSelectedState(newSelectedKeys);
        emitSelectEvent({
          newSelectedKeys
        });
      }
      function setExpandedKeys(keys) {
        currentExpandKeys.value = [];
        setExpandState(keys);
        emitExpandEvent({ newExpandedKeys: keys });
      }
      function checkNodes(keys, checked, targetKey) {
        if (!keys.length)
          return;
        let newCheckedKeys = [...checkedKeys.value];
        let newIndeterminateKeys = [...indeterminateKeys.value];
        keys.forEach((key) => {
          const node = key2TreeNode.value.get(key);
          if (node) {
            [newCheckedKeys, newIndeterminateKeys] = getCheckedStateByCheck({
              node,
              checked,
              checkedKeys: [...newCheckedKeys],
              indeterminateKeys: [...newIndeterminateKeys],
              checkStrictly: checkStrictly.value
            });
          }
        });
        setCheckedState(newCheckedKeys, newIndeterminateKeys);
        emitCheckEvent({
          targetKey,
          targetChecked: isUndefined(targetKey) ? void 0 : checked,
          newCheckedKeys,
          newIndeterminateKeys
        });
      }
      function selectNodes(keys, selected, targetKey) {
        if (!keys.length)
          return;
        let newSelectedKeys;
        if (multiple.value) {
          const selectedKeysSet = new Set(selectedKeys.value);
          keys.forEach((key) => {
            selected ? selectedKeysSet.add(key) : selectedKeysSet.delete(key);
          });
          newSelectedKeys = [...selectedKeysSet];
        } else {
          newSelectedKeys = selected ? [keys[0]] : [];
        }
        setSelectedState(newSelectedKeys);
        emitSelectEvent({
          targetKey,
          targetSelected: isUndefined(targetKey) ? void 0 : selected,
          newSelectedKeys
        });
      }
      function expandNodes(keys, expanded, targetKey) {
        const expandedKeysSet = new Set(expandedKeys.value);
        keys.forEach((key) => {
          expanded ? expandedKeysSet.add(key) : expandedKeysSet.delete(key);
          onExpandEnd(key);
        });
        const newExpandedKeys = [...expandedKeysSet];
        setExpandState(newExpandedKeys);
        emitExpandEvent({
          targetKey,
          targetExpanded: isUndefined(targetKey) ? void 0 : expanded,
          newExpandedKeys
        });
      }
      function onCheck(checked, key, e2) {
        const node = key2TreeNode.value.get(key);
        if (!node)
          return;
        const [newCheckedKeys, newIndeterminateKeys] = getCheckedStateByCheck({
          node,
          checked,
          checkedKeys: checkedKeys.value,
          indeterminateKeys: indeterminateKeys.value,
          checkStrictly: checkStrictly.value
        });
        setCheckedState(newCheckedKeys, newIndeterminateKeys);
        emitCheckEvent({
          targetKey: key,
          targetChecked: checked,
          newCheckedKeys,
          newIndeterminateKeys,
          event: e2
        });
      }
      function onSelect(key, e2) {
        const node = key2TreeNode.value.get(key);
        if (!node)
          return;
        let newSelectedKeys;
        let selected;
        if (multiple.value) {
          const selectedKeysSet = new Set(selectedKeys.value);
          selected = !selectedKeysSet.has(key);
          selected ? selectedKeysSet.add(key) : selectedKeysSet.delete(key);
          newSelectedKeys = [...selectedKeysSet];
        } else {
          selected = true;
          newSelectedKeys = [key];
        }
        setSelectedState(newSelectedKeys);
        emitSelectEvent({
          targetKey: key,
          targetSelected: selected,
          newSelectedKeys,
          event: e2
        });
      }
      function onExpand(expanded, key, e2) {
        if (currentExpandKeys.value.includes(key))
          return;
        const node = key2TreeNode.value.get(key);
        if (!node)
          return;
        const expandedKeysSet = new Set(expandedKeys.value);
        expanded ? expandedKeysSet.add(key) : expandedKeysSet.delete(key);
        const newExpandedKeys = [...expandedKeysSet];
        setExpandState(newExpandedKeys);
        if (animation.value) {
          currentExpandKeys.value.push(key);
        }
        emitExpandEvent({
          targetKey: key,
          targetExpanded: expanded,
          newExpandedKeys,
          event: e2
        });
      }
      function onExpandEnd(key) {
        const index2 = currentExpandKeys.value.indexOf(key);
        currentExpandKeys.value.splice(index2, 1);
      }
      const onLoadMore = vue.computed(() => (loadMore == null ? void 0 : loadMore.value) ? async (key) => {
        if (!isFunction$1(loadMore.value))
          return;
        const node = key2TreeNode.value.get(key);
        if (!node)
          return;
        const { treeNodeData } = node;
        loadingKeys.value = [...new Set([...loadingKeys.value, key])];
        try {
          await loadMore.value(treeNodeData);
          loadingKeys.value = loadingKeys.value.filter((v) => v !== key);
          onExpand(true, key);
          if (checkedKeys.value.includes(key)) {
            onCheck(true, key);
          }
        } catch (err) {
          loadingKeys.value = loadingKeys.value.filter((v) => v !== key);
          console.error("[tree]load data error: ", err);
        }
      } : void 0);
      const treeContext = vue.reactive({
        treeProps: props,
        switcherIcon,
        loadingIcon,
        dragIcon,
        nodeIcon,
        nodeTitle,
        nodeExtra,
        treeData,
        flattenTreeData,
        key2TreeNode,
        checkedKeys,
        indeterminateKeys,
        selectedKeys,
        expandedKeys,
        loadingKeys,
        currentExpandKeys,
        onLoadMore,
        filterTreeNode,
        onCheck,
        onSelect,
        onExpand,
        onExpandEnd,
        allowDrop(key, dropPosition) {
          const node = key2TreeNode.value.get(key);
          if (node && isFunction$1(allowDrop.value)) {
            return !!allowDrop.value({
              dropNode: node.treeNodeData,
              dropPosition
            });
          }
          return true;
        },
        onDragStart(key, e2) {
          const node = key2TreeNode.value.get(key);
          dragNode.value = node;
          if (node) {
            emit("dragStart", e2, node.treeNodeData);
          }
        },
        onDragEnd(key, e2) {
          const node = key2TreeNode.value.get(key);
          dragNode.value = void 0;
          if (node) {
            emit("dragEnd", e2, node.treeNodeData);
          }
        },
        onDragOver(key, e2) {
          const node = key2TreeNode.value.get(key);
          if (node) {
            emit("dragOver", e2, node.treeNodeData);
          }
        },
        onDragLeave(key, e2) {
          const node = key2TreeNode.value.get(key);
          if (node) {
            emit("dragLeave", e2, node.treeNodeData);
          }
        },
        onDrop(key, dropPosition, e2) {
          const node = key2TreeNode.value.get(key);
          if (dragNode.value && node && !(node.key === dragNode.value.key || node.pathParentKeys.includes(dragNode.value.key || ""))) {
            emit("drop", {
              e: e2,
              dragNode: dragNode.value.treeNodeData,
              dropNode: node.treeNodeData,
              dropPosition
            });
          }
        }
      });
      vue.provide(TreeInjectionKey, treeContext);
      return {
        classNames,
        visibleTreeNodeList,
        treeContext,
        virtualListRef: vue.ref(),
        computedSelectedKeys: selectedKeys,
        computedExpandedKeys: expandedKeys,
        computedCheckedKeys: checkedKeys,
        computedIndeterminateKeys: indeterminateKeys,
        getPublicCheckedKeys,
        getNodes,
        internalCheckNodes: checkNodes,
        internalSetCheckedKeys: setCheckedKeys,
        internalSelectNodes: selectNodes,
        internalSetSelectedKeys: setSelectedKeys,
        internalExpandNodes: expandNodes,
        internalSetExpandedKeys: setExpandedKeys
      };
    },
    methods: {
      toggleCheck(key, e2) {
        const { key2TreeNode, onCheck, checkedKeys } = this.treeContext;
        const checked = !checkedKeys.includes(key);
        const node = key2TreeNode.get(key);
        if (node && isNodeCheckable(node)) {
          onCheck(checked, key, e2);
        }
      },
      scrollIntoView(options) {
        this.virtualListRef && this.virtualListRef.scrollTo(options);
      },
      getSelectedNodes() {
        return this.getNodes(this.computedSelectedKeys);
      },
      getCheckedNodes(options = {}) {
        const { checkedStrategy, includeHalfChecked } = options;
        const checkedKeys = this.getPublicCheckedKeys(this.computedCheckedKeys, checkedStrategy);
        const checkedNodes = this.getNodes(checkedKeys);
        return [
          ...checkedNodes,
          ...includeHalfChecked ? this.getHalfCheckedNodes() : []
        ];
      },
      getHalfCheckedNodes() {
        return this.getNodes(this.computedIndeterminateKeys);
      },
      getExpandedNodes() {
        return this.getNodes(this.computedExpandedKeys);
      },
      checkAll(checked = true) {
        const { key2TreeNode } = this.treeContext;
        const newKeys = checked ? [...key2TreeNode.keys()].filter((key) => {
          const node = key2TreeNode.get(key);
          return node && isNodeCheckable(node);
        }) : [];
        this.internalSetCheckedKeys(newKeys);
      },
      checkNode(key, checked = true, onlyCheckLeaf = false) {
        const { checkStrictly, treeContext } = this;
        const { key2TreeNode } = treeContext;
        const isBatch = isArray$1(key);
        const keys = (isBatch ? key : [key]).filter((key2) => {
          const node = key2TreeNode.get(key2);
          return node && isNodeCheckable(node) && (checkStrictly || !onlyCheckLeaf || isLeafNode(node));
        });
        this.internalCheckNodes(keys, checked, isBatch ? void 0 : key);
      },
      selectAll(selected = true) {
        const { key2TreeNode } = this.treeContext;
        const newKeys = selected ? [...key2TreeNode.keys()].filter((key) => {
          const node = key2TreeNode.get(key);
          return node && isNodeSelectable(node);
        }) : [];
        this.internalSetSelectedKeys(newKeys);
      },
      selectNode(key, selected = true) {
        const { key2TreeNode } = this.treeContext;
        const isBatch = isArray$1(key);
        const keys = (isBatch ? key : [key]).filter((key2) => {
          const node = key2TreeNode.get(key2);
          return node && isNodeSelectable(node);
        });
        this.internalSelectNodes(keys, selected, isBatch ? void 0 : key);
      },
      expandAll(expanded = true) {
        const { key2TreeNode } = this.treeContext;
        const newKeys = expanded ? [...key2TreeNode.keys()].filter((key) => {
          const node = key2TreeNode.get(key);
          return node && isNodeExpandable(node);
        }) : [];
        this.internalSetExpandedKeys(newKeys);
      },
      expandNode(key, expanded = true) {
        const { key2TreeNode } = this.treeContext;
        const isBatch = isArray$1(key);
        const keys = (isBatch ? key : [key]).filter((key2) => {
          const node = key2TreeNode.get(key2);
          return node && isNodeExpandable(node);
        });
        this.internalExpandNodes(keys, expanded, isBatch ? void 0 : key);
      }
    }
  });
  function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_TreeNode = vue.resolveComponent("TreeNode");
    const _component_VirtualList = vue.resolveComponent("VirtualList");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.classNames)
    }, [
      _ctx.virtualListProps ? (vue.openBlock(), vue.createBlock(_component_VirtualList, vue.mergeProps({
        key: 0,
        ref: "virtualListRef"
      }, _ctx.virtualListProps, { data: _ctx.visibleTreeNodeList }), {
        item: vue.withCtx(({ item: node }) => [
          vue.createVNode(_component_TreeNode, vue.mergeProps({
            key: `${_ctx.searchValue}-${node.key}`
          }, node.treeNodeProps), null, 16)
        ]),
        _: 1
      }, 16, ["data"])) : (vue.openBlock(true), vue.createElementBlock(vue.Fragment, { key: 1 }, vue.renderList(_ctx.visibleTreeNodeList, (node) => {
        return vue.openBlock(), vue.createBlock(_component_TreeNode, vue.mergeProps({
          key: node.key
        }, node.treeNodeProps), null, 16);
      }), 128))
    ], 2);
  }
  var _Tree = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$d]]);
  const Tree = Object.assign(_Tree, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Tree.name, _Tree);
    }
  });
  const _sfc_main$c = vue.defineComponent({
    name: "Typography",
    setup() {
      const prefixCls = getPrefixCls("typography");
      return {
        classNames: [prefixCls]
      };
    }
  });
  function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("article", {
      class: vue.normalizeClass(_ctx.classNames)
    }, [
      vue.renderSlot(_ctx.$slots, "default")
    ], 2);
  }
  var _Typography = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$c]]);
  const _sfc_main$b = vue.defineComponent({
    name: "TypographyEditContent",
    components: {
      Input
    },
    props: {
      text: {
        type: String,
        required: true
      }
    },
    emits: ["change", "end", "update:text"],
    setup(_, { emit }) {
      const prefixCls = getPrefixCls("typography");
      const classNames = [`${prefixCls}-edit-content`];
      const inputRef = vue.ref();
      function onChange(value) {
        emit("update:text", value);
        emit("change", value);
      }
      function onEnd() {
        emit("end");
      }
      vue.onMounted(() => {
        if (!inputRef.value || !inputRef.value.$el)
          return;
        const inputEl = inputRef.value.$el.querySelector("input");
        if (!inputEl)
          return;
        inputEl.focus && inputEl.focus();
        const { length } = inputEl.value;
        inputEl.setSelectionRange(length, length);
      });
      return {
        classNames,
        inputRef,
        onBlur: onEnd,
        onChange,
        onEnd
      };
    }
  });
  function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Input = vue.resolveComponent("Input");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.classNames)
    }, [
      vue.createVNode(_component_Input, {
        ref: "inputRef",
        "auto-size": "",
        "model-value": _ctx.text,
        onBlur: _ctx.onBlur,
        onInput: _ctx.onChange,
        onKeydown: vue.withKeys(_ctx.onEnd, ["enter"])
      }, null, 8, ["model-value", "onBlur", "onInput", "onKeydown"])
    ], 2);
  }
  var EditContent = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$b]]);
  const _sfc_main$a = vue.defineComponent({
    name: "IconCopy",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-copy`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$8 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$8 = /* @__PURE__ */ vue.createElementVNode("path", { d: "M20 6h18a2 2 0 0 1 2 2v22M8 16v24c0 1.105.891 2 1.996 2h20.007A1.99 1.99 0 0 0 32 40.008V15.997A1.997 1.997 0 0 0 30 14H10a2 2 0 0 0-2 2Z" }, null, -1);
  const _hoisted_3$8 = [
    _hoisted_2$8
  ];
  function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$8, 14, _hoisted_1$8);
  }
  var _IconCopy = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$a]]);
  const IconCopy = Object.assign(_IconCopy, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconCopy.name, _IconCopy);
    }
  });
  const _sfc_main$9 = vue.defineComponent({
    name: "IconEdit",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-edit`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$7 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$7 = /* @__PURE__ */ vue.createElementVNode("path", { d: "m30.48 19.038 5.733-5.734a1 1 0 0 0 0-1.414l-5.586-5.586a1 1 0 0 0-1.414 0l-5.734 5.734m7 7L15.763 33.754a1 1 0 0 1-.59.286l-6.048.708a1 1 0 0 1-1.113-1.069l.477-6.31a1 1 0 0 1 .29-.631l14.7-14.7m7 7-7-7M6 42h36" }, null, -1);
  const _hoisted_3$7 = [
    _hoisted_2$7
  ];
  function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$7, 14, _hoisted_1$7);
  }
  var _IconEdit = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$9]]);
  const IconEdit = Object.assign(_IconEdit, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconEdit.name, _IconEdit);
    }
  });
  const _sfc_main$8 = vue.defineComponent({
    name: "TypographyOperations",
    components: {
      Tooltip,
      IconCheckCircleFill,
      IconCopy,
      IconEdit
    },
    props: {
      editable: Boolean,
      copyable: Boolean,
      expandable: Boolean,
      isCopied: Boolean,
      isEllipsis: Boolean,
      expanded: Boolean,
      forceRenderExpand: Boolean,
      editTooltipProps: Object,
      copyTooltipProps: Object
    },
    emits: {
      edit: () => true,
      copy: () => true,
      expand: () => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("typography");
      const showExpand = vue.computed(() => props.forceRenderExpand || props.expandable && props.isEllipsis);
      const { t: t2 } = useI18n();
      return {
        prefixCls,
        showExpand,
        t: t2,
        onEditClick() {
          emit("edit");
        },
        onCopyClick() {
          emit("copy");
        },
        onExpandClick() {
          emit("expand");
        }
      };
    }
  });
  function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_IconEdit = vue.resolveComponent("IconEdit");
    const _component_Tooltip = vue.resolveComponent("Tooltip");
    const _component_IconCheckCircleFill = vue.resolveComponent("IconCheckCircleFill");
    const _component_IconCopy = vue.resolveComponent("IconCopy");
    return vue.openBlock(), vue.createElementBlock(vue.Fragment, null, [
      _ctx.editable ? (vue.openBlock(), vue.createBlock(_component_Tooltip, vue.mergeProps({
        key: 0,
        content: _ctx.t("typography.edit")
      }, _ctx.editTooltipProps), {
        default: vue.withCtx(() => [
          vue.createElementVNode("span", {
            class: vue.normalizeClass(`${_ctx.prefixCls}-operation-edit`),
            onClick: _cache[0] || (_cache[0] = vue.withModifiers((...args) => _ctx.onEditClick && _ctx.onEditClick(...args), ["stop"]))
          }, [
            vue.createVNode(_component_IconEdit)
          ], 2)
        ]),
        _: 1
      }, 16, ["content"])) : vue.createCommentVNode("v-if", true),
      _ctx.copyable ? (vue.openBlock(), vue.createBlock(_component_Tooltip, vue.normalizeProps(vue.mergeProps({ key: 1 }, _ctx.copyTooltipProps)), {
        content: vue.withCtx(() => [
          vue.renderSlot(_ctx.$slots, "copy-tooltip", { copied: _ctx.isCopied }, () => [
            vue.createTextVNode(vue.toDisplayString(_ctx.isCopied ? _ctx.t("typography.copied") : _ctx.t("typography.copy")), 1)
          ])
        ]),
        default: vue.withCtx(() => [
          vue.createElementVNode("span", {
            class: vue.normalizeClass({
              [`${_ctx.prefixCls}-operation-copied`]: _ctx.isCopied,
              [`${_ctx.prefixCls}-operation-copy`]: !_ctx.isCopied
            }),
            onClick: _cache[1] || (_cache[1] = vue.withModifiers((...args) => _ctx.onCopyClick && _ctx.onCopyClick(...args), ["stop"]))
          }, [
            vue.renderSlot(_ctx.$slots, "copy-icon", { copied: _ctx.isCopied }, () => [
              _ctx.isCopied ? (vue.openBlock(), vue.createBlock(_component_IconCheckCircleFill, { key: 0 })) : (vue.openBlock(), vue.createBlock(_component_IconCopy, { key: 1 }))
            ])
          ], 2)
        ]),
        _: 3
      }, 16)) : vue.createCommentVNode("v-if", true),
      _ctx.showExpand ? (vue.openBlock(), vue.createElementBlock("a", {
        key: 2,
        class: vue.normalizeClass(`${_ctx.prefixCls}-operation-expand`),
        onClick: _cache[2] || (_cache[2] = vue.withModifiers((...args) => _ctx.onExpandClick && _ctx.onExpandClick(...args), ["stop"]))
      }, [
        vue.renderSlot(_ctx.$slots, "expand-node", { expanded: _ctx.expanded }, () => [
          vue.createTextVNode(vue.toDisplayString(_ctx.expanded ? _ctx.t("typography.collapse") : _ctx.t("typography.expand")), 1)
        ])
      ], 2)) : vue.createCommentVNode("v-if", true)
    ], 64);
  }
  var Operations = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$8]]);
  let ellipsisContainer;
  function styleToString(style) {
    const styleNames = Array.prototype.slice.apply(style);
    return styleNames.map((name) => `${name}: ${style.getPropertyValue(name)};`).join("");
  }
  function pxToNumber(value) {
    if (!value)
      return 0;
    const match = value.match(/^\d*(\.\d*)?/);
    return match ? Number(match[0]) : 0;
  }
  var measure = (originElement, ellipsisConfig, operations, fullText) => {
    if (!ellipsisContainer) {
      ellipsisContainer = document.createElement("div");
      document.body.appendChild(ellipsisContainer);
    }
    const {
      rows,
      suffix,
      ellipsisStr
    } = ellipsisConfig;
    const originStyle = window.getComputedStyle(originElement);
    const styleString = styleToString(originStyle);
    const lineHeight = pxToNumber(originStyle.lineHeight);
    const maxHeight = Math.round(lineHeight * rows + pxToNumber(originStyle.paddingTop) + pxToNumber(originStyle.paddingBottom));
    ellipsisContainer.setAttribute("style", styleString);
    ellipsisContainer.setAttribute("aria-hidden", "true");
    ellipsisContainer.style.height = "auto";
    ellipsisContainer.style.minHeight = "auto";
    ellipsisContainer.style.maxHeight = "auto";
    ellipsisContainer.style.position = "fixed";
    ellipsisContainer.style.left = "0";
    ellipsisContainer.style.top = "-99999999px";
    ellipsisContainer.style.zIndex = "-200";
    ellipsisContainer.style.whiteSpace = "normal";
    const vm = vue.createApp({
      render() {
        return vue.createVNode("span", null, [operations]);
      }
    });
    vm.mount(ellipsisContainer);
    const operationsChildNodes = Array.prototype.slice.apply(ellipsisContainer.childNodes[0].cloneNode(true).childNodes);
    vm.unmount();
    ellipsisContainer.innerHTML = "";
    const ellipsisTextNode = document.createTextNode(`${ellipsisStr}${suffix}`);
    ellipsisContainer.appendChild(ellipsisTextNode);
    operationsChildNodes.forEach((operationNode) => {
      ellipsisContainer.appendChild(operationNode);
    });
    const textNode = document.createTextNode(fullText);
    ellipsisContainer.insertBefore(textNode, ellipsisTextNode);
    function inRange() {
      return ellipsisContainer.offsetHeight <= maxHeight;
    }
    if (inRange()) {
      return {
        ellipsis: false,
        text: fullText
      };
    }
    function measureText(textNode2, startLoc = 0, endLoc = fullText.length, lastSuccessLoc = 0) {
      const midLoc = Math.floor((startLoc + endLoc) / 2);
      const currentText = fullText.slice(0, midLoc);
      textNode2.textContent = currentText;
      if (startLoc >= endLoc - 1) {
        for (let step = endLoc; step >= startLoc; step -= 1) {
          const currentStepText = fullText.slice(0, step);
          textNode2.textContent = currentStepText;
          if (inRange() || !currentStepText) {
            return;
          }
        }
      }
      if (inRange()) {
        measureText(textNode2, midLoc, endLoc, midLoc);
      } else {
        measureText(textNode2, startLoc, midLoc, lastSuccessLoc);
      }
    }
    measureText(textNode);
    return {
      text: textNode.textContent,
      ellipsis: true
    };
  };
  const clipboard = async (text) => {
    var _a;
    if ((_a = navigator.clipboard) == null ? void 0 : _a.writeText) {
      try {
        await navigator.clipboard.writeText(text);
        return;
      } catch (err) {
        console.error(err != null ? err : new DOMException("The request is not allowed", "NotAllowedError"));
      }
    }
    const span = document.createElement("span");
    span.textContent = text;
    span.style.whiteSpace = "pre";
    document.body.appendChild(span);
    const selection = window.getSelection();
    const range = window.document.createRange();
    selection == null ? void 0 : selection.removeAllRanges();
    range.selectNode(span);
    selection == null ? void 0 : selection.addRange(range);
    try {
      window.document.execCommand("copy");
    } catch (err) {
      console.error(`execCommand Error: ${err}`);
    }
    selection == null ? void 0 : selection.removeAllRanges();
    window.document.body.removeChild(span);
  };
  let container;
  function getInnerText(node) {
    if (!node)
      return "";
    if (!container) {
      container = document.createElement("div");
      container.setAttribute("aria-hidden", "true");
      document.body.appendChild(container);
    }
    const vm = vue.createApp({
      render() {
        return vue.createVNode("div", null, [node]);
      }
    });
    vm.mount(container);
    const text = container.innerText;
    vm.unmount();
    return text;
  }
  function _isSlot$1(s) {
    return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !vue.isVNode(s);
  }
  function getComponentTags(props) {
    const {
      bold,
      mark,
      underline,
      delete: propDelete,
      code
    } = props;
    const componentTags = [];
    if (bold) {
      componentTags.push("b");
    }
    if (underline) {
      componentTags.push("u");
    }
    if (propDelete) {
      componentTags.push("del");
    }
    if (code) {
      componentTags.push("code");
    }
    if (mark) {
      componentTags.push("mark");
    }
    return componentTags;
  }
  function Wrap(props, children) {
    const {
      mark
    } = props;
    const componentTags = getComponentTags(props);
    const markStyle = isObject$1(mark) && mark.color ? {
      backgroundColor: mark.color
    } : {};
    return componentTags.reduce((content, Tag2) => {
      const attrs = Tag2 === "mark" ? {
        style: markStyle
      } : {};
      return vue.createVNode(Tag2, attrs, _isSlot$1(content) ? content : {
        default: () => [content]
      });
    }, children);
  }
  function normalizeEllipsisConfig(config) {
    const showTooltip = !!config.showTooltip;
    const TooltipComponent = isObject$1(config.showTooltip) && config.showTooltip.type === "popover" ? Popover : Tooltip;
    const tooltipProps = isObject$1(config.showTooltip) && config.showTooltip.props || {};
    return __spreadProps(__spreadValues({
      rows: 1,
      suffix: "",
      ellipsisStr: "...",
      expandable: false,
      css: false
    }, omit(config, ["showTooltip"])), {
      showTooltip,
      TooltipComponent,
      tooltipProps
    });
  }
  var Base = vue.defineComponent({
    name: "TypographyBase",
    inheritAttrs: false,
    props: {
      component: {
        type: String,
        required: true
      },
      type: {
        type: String
      },
      bold: {
        type: Boolean
      },
      mark: {
        type: [Boolean, Object],
        default: false
      },
      underline: {
        type: Boolean
      },
      delete: {
        type: Boolean
      },
      code: {
        type: Boolean
      },
      disabled: {
        type: Boolean
      },
      editable: {
        type: Boolean
      },
      editing: {
        type: Boolean,
        default: void 0
      },
      defaultEditing: {
        type: Boolean
      },
      editText: {
        type: String
      },
      copyable: {
        type: Boolean
      },
      copyText: {
        type: String
      },
      copyDelay: {
        type: Number,
        default: 3e3
      },
      ellipsis: {
        type: [Boolean, Object],
        default: false
      },
      editTooltipProps: {
        type: Object
      },
      copyTooltipProps: {
        type: Object
      }
    },
    emits: {
      "editStart": () => true,
      "change": (text) => true,
      "update:editText": (text) => true,
      "editEnd": () => true,
      "update:editing": (editing) => true,
      "copy": (text) => true,
      "ellipsis": (isEllipsis) => true,
      "expand": (expanded) => true
    },
    setup(props, {
      slots,
      emit,
      attrs
    }) {
      const {
        editing: propEditing,
        defaultEditing,
        ellipsis,
        copyable,
        editable,
        copyText,
        editText,
        copyDelay,
        component
      } = vue.toRefs(props);
      const prefixCls = getPrefixCls("typography");
      const classNames = vue.computed(() => [prefixCls, {
        [`${prefixCls}-${props.type}`]: props.type,
        [`${prefixCls}-disabled`]: props.disabled
      }]);
      const wrapperRef = vue.ref();
      const fullText = vue.ref("");
      const [editing, setEditing] = useMergeState(defaultEditing.value, vue.reactive({
        value: propEditing
      }));
      const mergeEditing = vue.computed(() => editable.value && editing.value);
      function onEditStart() {
        emit("update:editing", true);
        emit("editStart");
        setEditing(true);
      }
      function onEditChange(text) {
        emit("update:editText", text);
        emit("change", text);
      }
      function onEditEnd() {
        if (!editing.value)
          return;
        emit("update:editing", false);
        emit("editEnd");
        setEditing(false);
      }
      const isCopied = vue.ref(false);
      let copyTimer = null;
      function onCopyClick() {
        var _a;
        const text = (_a = copyText.value) != null ? _a : fullText.value;
        clipboard(text || "");
        isCopied.value = true;
        emit("copy", text);
        copyTimer = setTimeout(() => {
          isCopied.value = false;
        }, copyDelay.value);
      }
      vue.onUnmounted(() => {
        copyTimer && clearTimeout(copyTimer);
        copyTimer = null;
      });
      const isEllipsis = vue.ref(false);
      const expanded = vue.ref(false);
      const ellipsisText = vue.ref("");
      const ellipsisConfig = vue.computed(() => normalizeEllipsisConfig(isObject$1(ellipsis.value) && ellipsis.value || {}));
      let rafId = null;
      function onExpandClick() {
        const newVal = !expanded.value;
        expanded.value = newVal;
        emit("expand", newVal);
      }
      function renderOperations(forceRenderExpand = false) {
        if (ellipsisConfig.value.css) {
          return vue.createVNode(Operations, {
            "editable": editable.value,
            "copyable": copyable.value,
            "expandable": ellipsisConfig.value.expandable,
            "isCopied": isCopied.value,
            "isEllipsis": showCSSTooltip.value,
            "expanded": expanded.value,
            "forceRenderExpand": forceRenderExpand || expanded.value,
            "editTooltipProps": props.editTooltipProps,
            "copyTooltipProps": props.copyTooltipProps,
            "onEdit": onEditStart,
            "onCopy": onCopyClick,
            "onExpand": onExpandClick
          }, {
            "copy-tooltip": slots["copy-tooltip"],
            "copy-icon": slots["copy-icon"],
            "expand-node": slots["expand-node"]
          });
        }
        return vue.createVNode(Operations, {
          "editable": editable.value,
          "copyable": copyable.value,
          "expandable": ellipsisConfig.value.expandable,
          "isCopied": isCopied.value,
          "isEllipsis": isEllipsis.value,
          "expanded": expanded.value,
          "forceRenderExpand": forceRenderExpand,
          "editTooltipProps": props.editTooltipProps,
          "copyTooltipProps": props.copyTooltipProps,
          "onEdit": onEditStart,
          "onCopy": onCopyClick,
          "onExpand": onExpandClick
        }, {
          "copy-tooltip": slots["copy-tooltip"],
          "copy-icon": slots["copy-icon"],
          "expand-node": slots["expand-node"]
        });
      }
      function calEllipsis() {
        if (!wrapperRef.value)
          return;
        const {
          ellipsis: ellipsis2,
          text
        } = measure(wrapperRef.value, ellipsisConfig.value, renderOperations(!!ellipsisConfig.value.expandable), fullText.value);
        if (isEllipsis.value !== ellipsis2) {
          isEllipsis.value = ellipsis2;
          if (!ellipsisConfig.value.css) {
            emit("ellipsis", ellipsis2);
          }
        }
        if (ellipsisText.value !== text) {
          ellipsisText.value = text || "";
        }
      }
      function resizeOnNextFrame() {
        const needCalEllipsis = ellipsis.value && !expanded.value;
        if (!needCalEllipsis)
          return;
        caf(rafId);
        rafId = raf(() => {
          calEllipsis();
        });
      }
      vue.onUnmounted(() => {
        caf(rafId);
      });
      vue.watch(() => ellipsisConfig.value.rows, () => {
        resizeOnNextFrame();
      });
      vue.watch(ellipsis, (newVal) => {
        if (newVal) {
          resizeOnNextFrame();
        } else {
          isEllipsis.value = false;
        }
      });
      let children = [];
      const updateFullText = () => {
        if (ellipsis.value || copyable.value || editable.value) {
          const _fullText = getInnerText(children);
          if (_fullText !== fullText.value) {
            fullText.value = _fullText;
            resizeOnNextFrame();
          }
        }
      };
      vue.onMounted(updateFullText);
      vue.onUpdated(updateFullText);
      const contentRef = vue.ref();
      const showCSSTooltip = vue.ref(false);
      const calTooltip = () => {
        if (wrapperRef.value && contentRef.value) {
          const _show = contentRef.value.offsetHeight > wrapperRef.value.offsetHeight;
          if (_show !== showCSSTooltip.value) {
            showCSSTooltip.value = _show;
            emit("ellipsis", _show);
          }
        }
      };
      const ellipsisStyle = vue.computed(() => {
        if (expanded.value) {
          return {};
        }
        return {
          "overflow": "hidden",
          "text-overflow": "ellipsis",
          "display": "-webkit-box",
          "-webkit-line-clamp": ellipsisConfig.value.rows,
          "-webkit-box-orient": "vertical"
        };
      });
      return () => {
        var _a, _b;
        children = ((_a = slots.default) == null ? void 0 : _a.call(slots)) || [];
        if (mergeEditing.value) {
          const _editText = (_b = editText.value) != null ? _b : fullText.value;
          return vue.createVNode(EditContent, {
            "text": _editText,
            "onChange": (text) => {
              if (text !== _editText) {
                onEditChange(text);
              }
            },
            "onEnd": onEditEnd
          }, null);
        }
        const {
          suffix,
          ellipsisStr,
          showTooltip,
          tooltipProps,
          TooltipComponent
        } = ellipsisConfig.value;
        const showEllipsis = isEllipsis.value && !expanded.value;
        const titleAttrs = showEllipsis && !showTooltip ? {
          title: fullText.value
        } : {};
        const Component = component.value;
        if (ellipsisConfig.value.css) {
          const Content2 = Wrap(props, children);
          const Outer = vue.createVNode(Component, vue.mergeProps({
            "class": classNames.value,
            "ref": wrapperRef,
            "style": ellipsisStyle.value
          }, titleAttrs, attrs), {
            default: () => [vue.createVNode("span", {
              "ref": contentRef
            }, [Content2])]
          });
          if (showCSSTooltip.value) {
            return vue.createVNode(TooltipComponent, vue.mergeProps(tooltipProps, {
              "onResize": () => calTooltip()
            }), {
              default: () => [Outer],
              content: () => fullText.value
            });
          }
          return vue.createVNode(ResizeObserver$1, {
            "onResize": () => {
              calTooltip();
            }
          }, _isSlot$1(Outer) ? Outer : {
            default: () => [Outer]
          });
        }
        const Content = Wrap(props, showEllipsis ? ellipsisText.value : children);
        return vue.createVNode(ResizeObserver$1, {
          "onResize": () => resizeOnNextFrame()
        }, {
          default: () => [vue.createVNode(Component, vue.mergeProps({
            "class": classNames.value,
            "ref": wrapperRef
          }, titleAttrs, attrs), {
            default: () => [showEllipsis && showTooltip ? vue.createVNode(TooltipComponent, tooltipProps, {
              default: () => [vue.createVNode("span", null, [Content])],
              content: () => fullText.value
            }) : Content, showEllipsis ? ellipsisStr : null, suffix, renderOperations()]
          })]
        });
      };
    }
  });
  var TypographyParagraph = vue.defineComponent({
    name: "TypographyParagraph",
    inheritAttrs: false,
    props: {
      blockquote: {
        type: Boolean
      },
      spacing: {
        type: String,
        default: "default"
      }
    },
    setup(props) {
      const {
        blockquote,
        spacing
      } = vue.toRefs(props);
      const prefixCls = getPrefixCls("typography");
      const component = vue.computed(() => (blockquote == null ? void 0 : blockquote.value) ? "blockquote" : "div");
      const classNames = vue.computed(() => [{
        [`${prefixCls}-spacing-close`]: (spacing == null ? void 0 : spacing.value) === "close"
      }]);
      return {
        component,
        classNames
      };
    },
    render() {
      const {
        component,
        classNames
      } = this;
      return vue.createVNode(Base, vue.mergeProps({
        "class": classNames
      }, this.$attrs, {
        "component": component
      }), this.$slots);
    }
  });
  var TypographyTitle = vue.defineComponent({
    name: "TypographyTitle",
    inheritAttrs: false,
    props: {
      heading: {
        type: Number,
        default: 1
      }
    },
    setup(props) {
      const {
        heading
      } = vue.toRefs(props);
      const component = vue.computed(() => `h${heading == null ? void 0 : heading.value}`);
      return {
        component
      };
    },
    render() {
      const {
        component
      } = this;
      return vue.createVNode(Base, vue.mergeProps(this.$attrs, {
        "component": component
      }), this.$slots);
    }
  });
  var TypographyText = vue.defineComponent({
    name: "TypographyText",
    inheritAttrs: false,
    props: {
      ellipsis: {
        type: [Boolean, Object],
        default: false
      }
    },
    setup(props) {
      const {
        ellipsis
      } = vue.toRefs(props);
      const component = vue.computed(() => (ellipsis == null ? void 0 : ellipsis.value) ? "div" : "span");
      return {
        component
      };
    },
    render() {
      const {
        ellipsis,
        component
      } = this;
      return vue.createVNode(Base, vue.mergeProps(this.$attrs, {
        "ellipsis": ellipsis,
        "component": component
      }), this.$slots);
    }
  });
  const Typography = Object.assign(_Typography, {
    Paragraph: TypographyParagraph,
    Title: TypographyTitle,
    Text: TypographyText,
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Typography.name, _Typography);
      app.component(componentPrefix + TypographyParagraph.name, TypographyParagraph);
      app.component(componentPrefix + TypographyTitle.name, TypographyTitle);
      app.component(componentPrefix + TypographyText.name, TypographyText);
    }
  });
  const getResponse = (xhr) => {
    const res = xhr.responseText || xhr.response;
    if (!res) {
      return void 0;
    }
    const contentType = xhr.getResponseHeader("Content-Type");
    if (contentType && contentType.includes("json")) {
      try {
        return JSON.parse(res);
      } catch {
        return res;
      }
    }
    return res;
  };
  const getProgressStatus = (status) => {
    switch (status) {
      case "done":
        return "success";
      case "error":
        return "danger";
      default:
        return "normal";
    }
  };
  const getValue = (obj, fileItem) => {
    if (isFunction$1(obj)) {
      return obj(fileItem);
    }
    return obj;
  };
  const uploadRequest = ({
    fileItem,
    action,
    name: originName,
    data: originData,
    headers = {},
    withCredentials = false,
    onProgress = NOOP,
    onSuccess = NOOP,
    onError = NOOP
  }) => {
    const name = getValue(originName, fileItem) || "file";
    const data = getValue(originData, fileItem);
    const xhr = new XMLHttpRequest();
    if (withCredentials) {
      xhr.withCredentials = true;
    }
    xhr.upload.onprogress = (e2) => {
      const percent = e2.total > 0 ? index.round(e2.loaded / e2.total, 2) : 0;
      onProgress(percent, e2);
    };
    xhr.onerror = function error(e2) {
      onError(e2);
    };
    xhr.onload = () => {
      if (xhr.status < 200 || xhr.status >= 300) {
        onError(getResponse(xhr));
        return;
      }
      onSuccess(getResponse(xhr));
    };
    const formData = new FormData();
    if (data) {
      for (const key of Object.keys(data)) {
        formData.append(key, data[key]);
      }
    }
    if (fileItem.file) {
      formData.append(name, fileItem.file);
    }
    xhr.open("post", action != null ? action : "", true);
    for (const key of Object.keys(headers)) {
      xhr.setRequestHeader(key, headers[key]);
    }
    xhr.send(formData);
    return {
      abort() {
        xhr.abort();
      }
    };
  };
  const isAcceptFile = (file, accept) => {
    if (accept && file) {
      const accepts = isArray$1(accept) ? accept : accept.split(",").map((x) => x.trim()).filter((x) => x);
      const fileExtension = (file.name.indexOf(".") > -1 ? `.${file.name.split(".").pop()}` : "").toLowerCase();
      return accepts.some((type) => {
        const typeText = type && type.toLowerCase();
        const fileType = (file.type || "").toLowerCase();
        const baseFileType = fileType.split("/")[0];
        if (typeText === fileType || `${baseFileType}${fileExtension.replace(".", "/")}` === typeText) {
          return true;
        }
        if (/^\*(\/\*)?$/.test(typeText)) {
          return true;
        }
        if (/\/\*/.test(typeText)) {
          return fileType.replace(/\/.*$/, "") === typeText.replace(/\/.*$/, "");
        }
        if (/\..*/.test(typeText)) {
          let suffixList = [typeText];
          if (typeText === ".jpg" || typeText === ".jpeg") {
            suffixList = [".jpg", ".jpeg"];
          }
          return suffixList.indexOf(fileExtension) > -1;
        }
        return false;
      });
    }
    return !!file;
  };
  const loopDirectory = (itemList, accept, callback) => {
    const files = [];
    let restFileCount = 0;
    const onFinish = () => {
      !restFileCount && callback(files);
    };
    const _loopDirectory = (item) => {
      restFileCount += 1;
      if (item == null ? void 0 : item.isFile) {
        item.file((file) => {
          restFileCount -= 1;
          if (isAcceptFile(file, accept)) {
            Object.defineProperty(file, "webkitRelativePath", {
              value: item.fullPath.replace(/^\//, "")
            });
            files.push(file);
          }
          onFinish();
        });
        return;
      }
      if (item == null ? void 0 : item.isDirectory) {
        const reader = item.createReader();
        let flag = false;
        const readEntries = () => {
          reader.readEntries((entries) => {
            if (!flag) {
              restFileCount -= 1;
              flag = true;
            }
            if (entries.length === 0) {
              onFinish();
            } else {
              readEntries();
              entries.forEach(_loopDirectory);
            }
          });
        };
        readEntries();
        return;
      }
      restFileCount -= 1;
      onFinish();
    };
    [].slice.call(itemList).forEach((item) => item.webkitGetAsEntry && _loopDirectory(item.webkitGetAsEntry()));
  };
  const isImage = (file) => {
    var _a;
    return (_a = file.type) == null ? void 0 : _a.includes("image");
  };
  const getFiles = (fileList, accept) => {
    if (!fileList) {
      return [];
    }
    const files = Array.from(fileList);
    if (accept) {
      return files.filter((file) => {
        return isAcceptFile(file, accept);
      });
    }
    return files;
  };
  const _sfc_main$7 = vue.defineComponent({
    name: "IconUpload",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-upload`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$6 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$6 = /* @__PURE__ */ vue.createElementVNode("path", { d: "M14.93 17.071 24.001 8l9.071 9.071m-9.07 16.071v-25M40 35v6H8v-6" }, null, -1);
  const _hoisted_3$6 = [
    _hoisted_2$6
  ];
  function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$6, 14, _hoisted_1$6);
  }
  var _IconUpload = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7]]);
  const IconUpload = Object.assign(_IconUpload, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconUpload.name, _IconUpload);
    }
  });
  var UploadButton = vue.defineComponent({
    name: "UploadButton",
    props: {
      disabled: {
        type: Boolean,
        default: false
      },
      directory: {
        type: Boolean,
        default: false
      },
      accept: String,
      listType: {
        type: String
      },
      tip: String,
      draggable: {
        type: Boolean,
        default: false
      },
      multiple: {
        type: Boolean,
        default: false
      },
      uploadFiles: {
        type: Function,
        required: true
      },
      hide: Boolean,
      onButtonClick: {
        type: Function
      }
    },
    setup(props, {
      slots
    }) {
      const prefixCls = getPrefixCls("upload");
      const {
        t: t2
      } = useI18n();
      const isDragging = vue.ref(false);
      const inputRef = vue.ref(null);
      const dropRef = vue.ref(null);
      const dragEnterCount = vue.ref(0);
      const setDragEnterCount = (type) => {
        if (type === "subtract") {
          dragEnterCount.value -= 1;
        } else if (type === "add") {
          dragEnterCount.value += 1;
        } else if (type === "reset") {
          dragEnterCount.value = 0;
        }
      };
      const handleClick = (e2) => {
        if (props.disabled)
          return;
        if (isFunction$1(props.onButtonClick)) {
          const result = props.onButtonClick(e2);
          if (isPromise(result)) {
            result.then((files) => {
              props.uploadFiles(getFiles(files));
            });
            return;
          }
        }
        if (inputRef.value) {
          inputRef.value.click();
        }
      };
      const handleInputChange = (e2) => {
        const target2 = e2.target;
        if (target2.files) {
          props.uploadFiles(getFiles(target2.files));
        }
        target2.value = "";
      };
      const handleDrop = (e2) => {
        var _a, _b;
        e2.preventDefault();
        isDragging.value = false;
        setDragEnterCount("reset");
        if (props.disabled) {
          return;
        }
        if (props.directory && ((_a = e2.dataTransfer) == null ? void 0 : _a.items)) {
          loopDirectory(e2.dataTransfer.items, props.accept, (files) => {
            props.uploadFiles(files);
          });
        } else {
          const files = getFiles((_b = e2.dataTransfer) == null ? void 0 : _b.files, props.accept);
          props.uploadFiles(props.multiple ? files : files.slice(0, 1));
        }
      };
      const handleDragLeave = (e2) => {
        e2.preventDefault();
        setDragEnterCount("subtract");
        if (dragEnterCount.value === 0) {
          isDragging.value = false;
          setDragEnterCount("reset");
        }
      };
      const handleDragOver = (e2) => {
        e2.preventDefault();
        if (!props.disabled && !isDragging.value) {
          isDragging.value = true;
        }
      };
      const renderButton = () => {
        if (slots.default) {
          return vue.createVNode("span", null, [slots.default()]);
        }
        if (props.listType === "picture-card") {
          return vue.createVNode("div", {
            "class": `${prefixCls}-picture-card`
          }, [vue.createVNode("div", {
            "class": `${prefixCls}-picture-card-text`
          }, [vue.createVNode(IconPlus, null, null)]), props.tip && vue.createVNode("div", {
            "class": `${prefixCls}-tip`
          }, [props.tip])]);
        }
        if (props.draggable) {
          return vue.createVNode("div", {
            "class": [`${prefixCls}-drag`, {
              [`${prefixCls}-drag-active`]: isDragging.value
            }]
          }, [vue.createVNode("div", null, [vue.createVNode(IconPlus, null, null)]), vue.createVNode("div", {
            "class": `${prefixCls}-drag-text`
          }, [isDragging.value ? t2("upload.dragHover") : t2("upload.drag")]), props.tip && vue.createVNode("div", {
            "class": `${prefixCls}-tip`
          }, [props.tip])]);
        }
        return vue.createVNode(Button, {
          "type": "primary",
          "disabled": props.disabled
        }, {
          default: () => [t2("upload.buttonText")],
          icon: () => vue.createVNode(IconUpload, null, null)
        });
      };
      const cls = vue.computed(() => [prefixCls, {
        [`${prefixCls}-type-picture-card`]: props.listType === "picture-card",
        [`${prefixCls}-draggable`]: props.draggable,
        [`${prefixCls}-disabled`]: props.disabled,
        [`${prefixCls}-hide`]: props.hide
      }]);
      return () => vue.createVNode("span", {
        "ref": dropRef,
        "class": cls.value,
        "onClick": handleClick,
        "onDragenter": () => {
          setDragEnterCount("add");
        },
        "onDrop": handleDrop,
        "onDragover": handleDragOver,
        "onDragleave": handleDragLeave
      }, [vue.createVNode("input", vue.mergeProps({
        "ref": inputRef,
        "type": "file",
        "style": {
          display: "none"
        },
        "disabled": props.disabled,
        "accept": props.accept,
        "multiple": props.multiple
      }, props.directory ? {
        webkitdirectory: "webkitdirectory"
      } : {}, {
        "onChange": handleInputChange
      }), null), renderButton()]);
    }
  });
  const _sfc_main$6 = vue.defineComponent({
    name: "IconPause",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-pause`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$5 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$5 = /* @__PURE__ */ vue.createElementVNode("path", { d: "M14 12h4v24h-4zM30 12h4v24h-4z" }, null, -1);
  const _hoisted_3$5 = /* @__PURE__ */ vue.createElementVNode("path", {
    fill: "currentColor",
    stroke: "none",
    d: "M14 12h4v24h-4zM30 12h4v24h-4z"
  }, null, -1);
  const _hoisted_4$3 = [
    _hoisted_2$5,
    _hoisted_3$5
  ];
  function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_4$3, 14, _hoisted_1$5);
  }
  var _IconPause = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6]]);
  const IconPause = Object.assign(_IconPause, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconPause.name, _IconPause);
    }
  });
  const _sfc_main$5 = vue.defineComponent({
    name: "IconPlayArrowFill",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-play-arrow-fill`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$4 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$4 = /* @__PURE__ */ vue.createElementVNode("path", {
    d: "M17.533 10.974a1 1 0 0 0-1.537.844v24.356a1 1 0 0 0 1.537.844L36.67 24.84a1 1 0 0 0 0-1.688L17.533 10.974Z",
    fill: "currentColor",
    stroke: "none"
  }, null, -1);
  const _hoisted_3$4 = [
    _hoisted_2$4
  ];
  function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$4, 14, _hoisted_1$4);
  }
  var _IconPlayArrowFill = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5]]);
  const IconPlayArrowFill = Object.assign(_IconPlayArrowFill, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconPlayArrowFill.name, _IconPlayArrowFill);
    }
  });
  const uploadInjectionKey = Symbol("ArcoUpload");
  var UploadProgress = vue.defineComponent({
    name: "UploadProgress",
    props: {
      file: {
        type: Object,
        required: true
      },
      listType: {
        type: String,
        required: true
      }
    },
    setup(props) {
      const prefixCls = getPrefixCls("upload-progress");
      const {
        t: t2
      } = useI18n();
      const uploadCtx = vue.inject(uploadInjectionKey, void 0);
      const renderIcon = () => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
        if (props.file.status === "error") {
          return vue.createVNode("span", {
            "class": [uploadCtx == null ? void 0 : uploadCtx.iconCls, `${uploadCtx == null ? void 0 : uploadCtx.iconCls}-upload`],
            "onClick": () => uploadCtx == null ? void 0 : uploadCtx.onUpload(props.file)
          }, [(uploadCtx == null ? void 0 : uploadCtx.showRetryButton) && ((_e = (_b = uploadCtx == null ? void 0 : (_a = uploadCtx.slots)["retry-icon"]) == null ? void 0 : _b.call(_a)) != null ? _e : (_d = (_c = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _c.retryIcon) == null ? void 0 : _d.call(_c)) || props.listType === "picture-card" ? vue.createVNode(IconUpload, null, null) : t2("upload.retry")]);
        }
        if (props.file.status === "done") {
          return vue.createVNode("span", {
            "class": [uploadCtx == null ? void 0 : uploadCtx.iconCls, `${uploadCtx == null ? void 0 : uploadCtx.iconCls}-success`]
          }, [(_k = (_j = (_g = uploadCtx == null ? void 0 : (_f = uploadCtx.slots)["success-icon"]) == null ? void 0 : _g.call(_f)) != null ? _j : (_i = (_h = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _h.successIcon) == null ? void 0 : _i.call(_h)) != null ? _k : vue.createVNode(IconCheck, null, null)]);
        }
        if (props.file.status === "init") {
          return vue.createVNode(Tooltip, {
            "content": t2("upload.start")
          }, {
            default: () => {
              var _a2, _b2, _c2, _d2, _e2, _f2;
              return [vue.createVNode("span", {
                "class": [uploadCtx == null ? void 0 : uploadCtx.iconCls, `${uploadCtx == null ? void 0 : uploadCtx.iconCls}-start`],
                "onClick": () => uploadCtx == null ? void 0 : uploadCtx.onUpload(props.file)
              }, [(_f2 = (_e2 = (_b2 = uploadCtx == null ? void 0 : (_a2 = uploadCtx.slots)["start-icon"]) == null ? void 0 : _b2.call(_a2)) != null ? _e2 : (_d2 = (_c2 = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _c2.startIcon) == null ? void 0 : _d2.call(_c2)) != null ? _f2 : vue.createVNode(IconPlayArrowFill, null, null)])];
            }
          });
        }
        return (uploadCtx == null ? void 0 : uploadCtx.showCancelButton) && vue.createVNode(Tooltip, {
          "content": t2("upload.cancel")
        }, {
          default: () => {
            var _a2, _b2, _c2, _d2, _e2, _f2;
            return [vue.createVNode("span", {
              "class": [uploadCtx == null ? void 0 : uploadCtx.iconCls, `${uploadCtx == null ? void 0 : uploadCtx.iconCls}-cancel`],
              "onClick": () => uploadCtx == null ? void 0 : uploadCtx.onAbort(props.file)
            }, [(_f2 = (_e2 = (_b2 = uploadCtx == null ? void 0 : (_a2 = uploadCtx.slots)["cancel-icon"]) == null ? void 0 : _b2.call(_a2)) != null ? _e2 : (_d2 = (_c2 = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _c2.cancelIcon) == null ? void 0 : _d2.call(_c2)) != null ? _f2 : vue.createVNode(IconPause, null, null)])];
          }
        });
      };
      const renderProgress = () => {
        var _a;
        if (["init", "uploading"].includes((_a = props.file.status) != null ? _a : "")) {
          const status = getProgressStatus(props.file.status);
          return vue.createVNode(Progress, {
            "type": "circle",
            "size": "mini",
            "showText": false,
            "status": status,
            "percent": props.file.percent
          }, null);
        }
        return null;
      };
      return () => vue.createVNode("span", {
        "class": prefixCls
      }, [renderProgress(), renderIcon()]);
    }
  });
  const _sfc_main$4 = vue.defineComponent({
    name: "IconFilePdf",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-file-pdf`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$3 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$3 = /* @__PURE__ */ vue.createElementVNode("path", { d: "M11 42h26a2 2 0 0 0 2-2V13.828a2 2 0 0 0-.586-1.414l-5.828-5.828A2 2 0 0 0 31.172 6H11a2 2 0 0 0-2 2v32a2 2 0 0 0 2 2Z" }, null, -1);
  const _hoisted_3$3 = /* @__PURE__ */ vue.createElementVNode("path", { d: "M22.305 21.028c.874 1.939 3.506 6.265 4.903 8.055 1.747 2.237 3.494 2.685 4.368 2.237.873-.447 1.21-4.548-7.425-2.685-7.523 1.623-7.424 3.58-6.988 4.476.728 1.193 2.522 2.627 5.678-6.266C25.699 18.79 24.489 17 23.277 17c-1.409 0-2.538.805-.972 4.028Z" }, null, -1);
  const _hoisted_4$2 = [
    _hoisted_2$3,
    _hoisted_3$3
  ];
  function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_4$2, 14, _hoisted_1$3);
  }
  var _IconFilePdf = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4]]);
  const IconFilePdf = Object.assign(_IconFilePdf, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconFilePdf.name, _IconFilePdf);
    }
  });
  const _sfc_main$3 = vue.defineComponent({
    name: "IconFileImage",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-file-image`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$2 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$2 = /* @__PURE__ */ vue.createElementVNode("path", { d: "m26 33 5-6v6h-5Zm0 0-3-4-4 4h7Zm11 9H11a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h21l7 7v27a2 2 0 0 1-2 2ZM17 19h1v1h-1v-1Z" }, null, -1);
  const _hoisted_3$2 = [
    _hoisted_2$2
  ];
  function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_3$2, 14, _hoisted_1$2);
  }
  var _IconFileImage = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3]]);
  const IconFileImage = Object.assign(_IconFileImage, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconFileImage.name, _IconFileImage);
    }
  });
  const _sfc_main$2 = vue.defineComponent({
    name: "IconFileVideo",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-file-video`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1$1 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2$1 = /* @__PURE__ */ vue.createElementVNode("path", { d: "M37 42H11a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h21l7 7v27a2 2 0 0 1-2 2Z" }, null, -1);
  const _hoisted_3$1 = /* @__PURE__ */ vue.createElementVNode("path", { d: "M22 27.796v-6l5 3-5 3Z" }, null, -1);
  const _hoisted_4$1 = [
    _hoisted_2$1,
    _hoisted_3$1
  ];
  function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_4$1, 14, _hoisted_1$1);
  }
  var _IconFileVideo = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2]]);
  const IconFileVideo = Object.assign(_IconFileVideo, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconFileVideo.name, _IconFileVideo);
    }
  });
  const _sfc_main$1 = vue.defineComponent({
    name: "IconFileAudio",
    props: {
      size: {
        type: [Number, String]
      },
      strokeWidth: {
        type: Number,
        default: 4
      },
      strokeLinecap: {
        type: String,
        default: "butt",
        validator: (value) => {
          return ["butt", "round", "square"].includes(value);
        }
      },
      strokeLinejoin: {
        type: String,
        default: "miter",
        validator: (value) => {
          return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
        }
      },
      rotate: Number,
      spin: Boolean
    },
    emits: {
      click: (ev) => true
    },
    setup(props, { emit }) {
      const prefixCls = getPrefixCls("icon");
      const cls = vue.computed(() => [prefixCls, `${prefixCls}-file-audio`, { [`${prefixCls}-spin`]: props.spin }]);
      const innerStyle = vue.computed(() => {
        const styles = {};
        if (props.size) {
          styles.fontSize = isNumber$1(props.size) ? `${props.size}px` : props.size;
        }
        if (props.rotate) {
          styles.transform = `rotate(${props.rotate}deg)`;
        }
        return styles;
      });
      const onClick = (ev) => {
        emit("click", ev);
      };
      return {
        cls,
        innerStyle,
        onClick
      };
    }
  });
  const _hoisted_1 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
  const _hoisted_2 = /* @__PURE__ */ vue.createElementVNode("path", { d: "M37 42H11a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h21l7 7v27a2 2 0 0 1-2 2Z" }, null, -1);
  const _hoisted_3 = /* @__PURE__ */ vue.createElementVNode("path", {
    d: "M25 30a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z",
    fill: "currentColor",
    stroke: "none"
  }, null, -1);
  const _hoisted_4 = /* @__PURE__ */ vue.createElementVNode("path", { d: "M25 30a3 3 0 1 1-6 0 3 3 0 0 1 6 0Zm0 0-.951-12.363a.5.5 0 0 1 .58-.532L30 18" }, null, -1);
  const _hoisted_5 = [
    _hoisted_2,
    _hoisted_3,
    _hoisted_4
  ];
  function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: "currentColor",
      class: vue.normalizeClass(_ctx.cls),
      style: vue.normalizeStyle(_ctx.innerStyle),
      "stroke-width": _ctx.strokeWidth,
      "stroke-linecap": _ctx.strokeLinecap,
      "stroke-linejoin": _ctx.strokeLinejoin,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, _hoisted_5, 14, _hoisted_1);
  }
  var _IconFileAudio = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
  const IconFileAudio = Object.assign(_IconFileAudio, {
    install: (app, options) => {
      var _a;
      const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
      app.component(iconPrefix + _IconFileAudio.name, _IconFileAudio);
    }
  });
  var UploadListItem = vue.defineComponent({
    name: "UploadListItem",
    props: {
      file: {
        type: Object,
        required: true
      },
      listType: {
        type: String,
        required: true
      }
    },
    setup(props) {
      const prefixCls = getPrefixCls("upload-list");
      const itemCls = `${prefixCls}-item`;
      const {
        t: t2
      } = useI18n();
      const uploadCtx = vue.inject(uploadInjectionKey, void 0);
      const renderFileIcon = () => {
        var _a, _b;
        let type = "";
        if (props.file.file && props.file.file.type) {
          type = props.file.file.type;
        } else {
          const extension = (_b = (_a = props.file.name) == null ? void 0 : _a.split(".")[1]) != null ? _b : "";
          if (["png", "jpg", "jpeg", "bmp", "gif", "webp"].includes(extension)) {
            type = "image";
          } else if (["mp4", "m2v", "mkv", "m4v", "mov"].includes(extension)) {
            type = "video";
          } else if (["mp3", "wav", "wmv", "m4a", "acc", "flac"].includes(extension)) {
            type = "audio";
          }
        }
        if (type.includes("image")) {
          return vue.createVNode(IconFileImage, null, null);
        }
        if (type.includes("pdf")) {
          return vue.createVNode(IconFilePdf, null, null);
        }
        if (type.includes("audio")) {
          return vue.createVNode(IconFileAudio, null, null);
        }
        if (type.includes("video")) {
          return vue.createVNode(IconFileVideo, null, null);
        }
        return vue.createVNode(IconFile, null, null);
      };
      return () => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w;
        return vue.createVNode("div", {
          "class": [itemCls, `${itemCls}-${props.file.status}`]
        }, [vue.createVNode("div", {
          "class": `${itemCls}-content`
        }, [(uploadCtx == null ? void 0 : uploadCtx.listType) === "picture" && vue.createVNode("span", {
          "class": `${itemCls}-thumbnail`
        }, [(_c = (_b = uploadCtx == null ? void 0 : (_a = uploadCtx.slots).image) == null ? void 0 : _b.call(_a, {
          fileItem: props.file
        })) != null ? _c : vue.createVNode("img", vue.mergeProps({
          "src": props.file.url,
          "alt": props.file.name
        }, (uploadCtx == null ? void 0 : uploadCtx.imageLoading) ? {
          loading: uploadCtx.imageLoading
        } : void 0), null)]), vue.createVNode("div", {
          "class": `${itemCls}-name`
        }, [(uploadCtx == null ? void 0 : uploadCtx.listType) === "text" && vue.createVNode("span", {
          "class": `${itemCls}-file-icon`
        }, [(_i = (_h = (_e = uploadCtx == null ? void 0 : (_d = uploadCtx.slots)["file-icon"]) == null ? void 0 : _e.call(_d, {
          fileItem: props.file
        })) != null ? _h : (_g = (_f = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _f.fileIcon) == null ? void 0 : _g.call(_f, props.file)) != null ? _i : renderFileIcon()]), (uploadCtx == null ? void 0 : uploadCtx.showLink) && props.file.url ? vue.createVNode("a", vue.mergeProps({
          "class": `${itemCls}-name-link`,
          "target": "_blank",
          "href": props.file.url
        }, (uploadCtx == null ? void 0 : uploadCtx.download) ? {
          download: props.file.name
        } : void 0), [(_o = (_n = (_k = uploadCtx == null ? void 0 : (_j = uploadCtx.slots)["file-name"]) == null ? void 0 : _k.call(_j, {
          fileItem: props.file
        })) != null ? _n : (_m = (_l = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _l.fileName) == null ? void 0 : _m.call(_l, props.file)) != null ? _o : props.file.name]) : vue.createVNode("span", {
          "class": `${itemCls}-name-text`,
          "onClick": () => uploadCtx == null ? void 0 : uploadCtx.onPreview(props.file)
        }, [(_u = (_t = (_q = uploadCtx == null ? void 0 : (_p = uploadCtx.slots)["file-name"]) == null ? void 0 : _q.call(_p, {
          fileItem: props.file
        })) != null ? _t : (_s = (_r = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _r.fileName) == null ? void 0 : _s.call(_r, props.file)) != null ? _u : props.file.name]), props.file.status === "error" && vue.createVNode(Tooltip, {
          "content": t2("upload.error")
        }, {
          default: () => {
            var _a2, _b2, _c2, _d2, _e2, _f2;
            return [vue.createVNode("span", {
              "class": [uploadCtx == null ? void 0 : uploadCtx.iconCls, `${uploadCtx == null ? void 0 : uploadCtx.iconCls}-error`]
            }, [(_f2 = (_e2 = (_b2 = uploadCtx == null ? void 0 : (_a2 = uploadCtx.slots)["error-icon"]) == null ? void 0 : _b2.call(_a2)) != null ? _e2 : (_d2 = (_c2 = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _c2.errorIcon) == null ? void 0 : _d2.call(_c2)) != null ? _f2 : vue.createVNode(IconExclamationCircleFill, null, null)])];
          }
        })]), vue.createVNode(UploadProgress, {
          "file": props.file,
          "listType": props.listType
        }, null)]), (uploadCtx == null ? void 0 : uploadCtx.showRemoveButton) && vue.createVNode("span", {
          "class": `${itemCls}-operation`
        }, [vue.createVNode(IconHover, {
          "onClick": () => {
            var _a2;
            return (_a2 = uploadCtx == null ? void 0 : uploadCtx.onRemove) == null ? void 0 : _a2.call(uploadCtx, props.file);
          }
        }, {
          default: () => {
            var _a2, _b2, _c2, _d2, _e2, _f2;
            return [vue.createVNode("span", {
              "class": [uploadCtx == null ? void 0 : uploadCtx.iconCls, `${uploadCtx == null ? void 0 : uploadCtx.iconCls}-remove`]
            }, [(_f2 = (_e2 = (_b2 = uploadCtx == null ? void 0 : (_a2 = uploadCtx.slots)["remove-icon"]) == null ? void 0 : _b2.call(_a2)) != null ? _e2 : (_d2 = (_c2 = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _c2.removeIcon) == null ? void 0 : _d2.call(_c2)) != null ? _f2 : vue.createVNode(IconDelete, null, null)])];
          }
        })]), (_w = uploadCtx == null ? void 0 : (_v = uploadCtx.slots)["extra-button"]) == null ? void 0 : _w.call(_v, {
          fileItem: props.file
        })]);
      };
    }
  });
  var UploadPictureItem = vue.defineComponent({
    name: "UploadPictureItem",
    props: {
      file: {
        type: Object,
        required: true
      },
      disabled: {
        type: Boolean,
        default: false
      }
    },
    setup(props) {
      const prefixCls = getPrefixCls("upload-list");
      const itemCls = `${prefixCls}-picture`;
      const cls = vue.computed(() => [itemCls, {
        [`${itemCls}-status-error`]: props.file.status === "error"
      }]);
      const uploadCtx = vue.inject(uploadInjectionKey, void 0);
      const renderCard = () => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C;
        if (props.file.status === "uploading") {
          return vue.createVNode(UploadProgress, {
            "file": props.file,
            "listType": "picture-card"
          }, null);
        }
        return vue.createVNode(vue.Fragment, null, [(_c = (_b = uploadCtx == null ? void 0 : (_a = uploadCtx.slots).image) == null ? void 0 : _b.call(_a, {
          fileItem: props.file
        })) != null ? _c : vue.createVNode("img", vue.mergeProps({
          "src": props.file.url,
          "alt": props.file.name
        }, (uploadCtx == null ? void 0 : uploadCtx.imageLoading) ? {
          loading: uploadCtx.imageLoading
        } : void 0), null), vue.createVNode("div", {
          "class": `${itemCls}-mask`
        }, [props.file.status === "error" && (uploadCtx == null ? void 0 : uploadCtx.showCancelButton) && vue.createVNode("div", {
          "class": `${itemCls}-error-tip`
        }, [vue.createVNode("span", {
          "class": [uploadCtx == null ? void 0 : uploadCtx.iconCls, `${uploadCtx == null ? void 0 : uploadCtx.iconCls}-error`]
        }, [(_i = (_h = (_e = uploadCtx == null ? void 0 : (_d = uploadCtx.slots)["error-icon"]) == null ? void 0 : _e.call(_d)) != null ? _h : (_g = (_f = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _f.errorIcon) == null ? void 0 : _g.call(_f)) != null ? _i : vue.createVNode(IconImageClose, null, null)])]), vue.createVNode("div", {
          "class": `${itemCls}-operation`
        }, [props.file.status !== "error" && (uploadCtx == null ? void 0 : uploadCtx.showPreviewButton) && vue.createVNode("span", {
          "class": [uploadCtx == null ? void 0 : uploadCtx.iconCls, `${uploadCtx == null ? void 0 : uploadCtx.iconCls}-preview`],
          "onClick": () => uploadCtx == null ? void 0 : uploadCtx.onPreview(props.file)
        }, [(_o = (_n = (_k = uploadCtx == null ? void 0 : (_j = uploadCtx.slots)["preview-icon"]) == null ? void 0 : _k.call(_j)) != null ? _n : (_m = (_l = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _l.previewIcon) == null ? void 0 : _m.call(_l)) != null ? _o : vue.createVNode(IconEye, null, null)]), ["init", "error"].includes(props.file.status) && (uploadCtx == null ? void 0 : uploadCtx.showRetryButton) && vue.createVNode("span", {
          "class": [uploadCtx == null ? void 0 : uploadCtx.iconCls, `${uploadCtx == null ? void 0 : uploadCtx.iconCls}-upload`],
          "onClick": () => uploadCtx == null ? void 0 : uploadCtx.onUpload(props.file)
        }, [(_u = (_t = (_q = uploadCtx == null ? void 0 : (_p = uploadCtx.slots)["retry-icon"]) == null ? void 0 : _q.call(_p)) != null ? _t : (_s = (_r = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _r.retryIcon) == null ? void 0 : _s.call(_r)) != null ? _u : vue.createVNode(IconUpload, null, null)]), !(uploadCtx == null ? void 0 : uploadCtx.disabled) && (uploadCtx == null ? void 0 : uploadCtx.showRemoveButton) && vue.createVNode("span", {
          "class": [uploadCtx == null ? void 0 : uploadCtx.iconCls, `${uploadCtx == null ? void 0 : uploadCtx.iconCls}-remove`],
          "onClick": () => uploadCtx == null ? void 0 : uploadCtx.onRemove(props.file)
        }, [(_A = (_z = (_w = uploadCtx == null ? void 0 : (_v = uploadCtx.slots)["remove-icon"]) == null ? void 0 : _w.call(_v)) != null ? _z : (_y = (_x = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _x.removeIcon) == null ? void 0 : _y.call(_x)) != null ? _A : vue.createVNode(IconDelete, null, null)]), (_C = uploadCtx == null ? void 0 : (_B = uploadCtx.slots)["extra-button"]) == null ? void 0 : _C.call(_B, props.file)])])]);
      };
      return () => vue.createVNode("span", {
        "class": cls.value
      }, [renderCard()]);
    }
  });
  var UploadList = vue.defineComponent({
    name: "UploadList",
    components: {
      UploadListItem,
      UploadPictureItem
    },
    props: {
      fileList: {
        type: Array,
        required: true
      },
      listType: {
        type: String,
        required: true
      }
    },
    setup(props, {
      slots
    }) {
      const prefixCls = getPrefixCls("upload");
      const cls = vue.computed(() => [`${prefixCls}-list`, `${prefixCls}-list-type-${props.listType}`]);
      const renderItem = (fileItem, index2) => {
        if (isFunction$1(slots["upload-item"])) {
          return slots["upload-item"]({
            fileItem,
            index: index2
          });
        }
        if (props.listType === "picture-card") {
          return vue.createVNode(UploadPictureItem, {
            "file": fileItem,
            "key": `item-${index2}`
          }, null);
        }
        return vue.createVNode(UploadListItem, {
          "file": fileItem,
          "listType": props.listType,
          "key": `item-${index2}`
        }, null);
      };
      return () => vue.createVNode(vue.TransitionGroup, {
        "tag": "div",
        "class": cls.value
      }, {
        default: () => {
          var _a;
          return [...props.fileList.map((item, index2) => renderItem(item, index2)), props.listType === "picture-card" && ((_a = slots["upload-button"]) == null ? void 0 : _a.call(slots))];
        }
      });
    }
  });
  var _Upload = vue.defineComponent({
    name: "Upload",
    props: {
      fileList: {
        type: Array,
        default: void 0
      },
      defaultFileList: {
        type: Array,
        default: () => []
      },
      accept: String,
      action: String,
      disabled: {
        type: Boolean,
        default: false
      },
      multiple: {
        type: Boolean,
        default: false
      },
      directory: {
        type: Boolean,
        default: false
      },
      draggable: {
        type: Boolean,
        default: false
      },
      tip: String,
      headers: {
        type: Object
      },
      data: {
        type: [Object, Function]
      },
      name: {
        type: [String, Function]
      },
      withCredentials: {
        type: Boolean,
        default: false
      },
      customRequest: {
        type: Function
      },
      limit: {
        type: Number,
        default: 0
      },
      autoUpload: {
        type: Boolean,
        default: true
      },
      showFileList: {
        type: Boolean,
        default: true
      },
      showRemoveButton: {
        type: Boolean,
        default: true
      },
      showRetryButton: {
        type: Boolean,
        default: true
      },
      showCancelButton: {
        type: Boolean,
        default: true
      },
      showUploadButton: {
        type: [Boolean, Object],
        default: true
      },
      showPreviewButton: {
        type: Boolean,
        default: true
      },
      download: {
        type: Boolean,
        default: false
      },
      showLink: {
        type: Boolean,
        default: true
      },
      imageLoading: {
        type: String
      },
      listType: {
        type: String,
        default: "text"
      },
      responseUrlKey: {
        type: [String, Function]
      },
      customIcon: {
        type: Object
      },
      imagePreview: {
        type: Boolean,
        default: false
      },
      onBeforeUpload: {
        type: Function
      },
      onBeforeRemove: {
        type: Function
      },
      onButtonClick: {
        type: Function
      }
    },
    emits: {
      "update:fileList": (fileList) => true,
      "exceedLimit": (fileList, files) => true,
      "change": (fileList, fileItem) => true,
      "progress": (fileItem, ev) => true,
      "preview": (fileItem) => true,
      "success": (fileItem) => true,
      "error": (fileItem) => true
    },
    setup(props, {
      emit,
      slots
    }) {
      const {
        fileList,
        disabled,
        listType,
        customIcon,
        showRetryButton,
        showCancelButton,
        showRemoveButton,
        showPreviewButton,
        imageLoading,
        download,
        showLink
      } = vue.toRefs(props);
      const prefixCls = getPrefixCls("upload");
      const {
        mergedDisabled,
        eventHandlers
      } = useFormItem({
        disabled
      });
      const _fileList = vue.ref([]);
      const fileMap = new Map();
      const requestMap = new Map();
      const isMax = vue.computed(() => {
        return props.limit > 0 && _fileList.value.length >= props.limit;
      });
      const checkFileList = (fileList2) => {
        fileMap.clear();
        const newFileList = fileList2 == null ? void 0 : fileList2.map((data, index2) => {
          var _a, _b, _c;
          const status = (_a = data.status) != null ? _a : "done";
          const fileItem = vue.reactive(__spreadProps(__spreadValues({}, data), {
            uid: (_b = data.uid) != null ? _b : `${Date.now()}${index2}`,
            status,
            percent: (_c = data.percent) != null ? _c : ["error", "init"].indexOf(status) > -1 ? 0 : 1
          }));
          fileMap.set(fileItem.uid, fileItem);
          return fileItem;
        });
        _fileList.value = newFileList != null ? newFileList : [];
      };
      checkFileList(props.defaultFileList);
      vue.watch(fileList, (fileList2) => {
        if (fileList2) {
          checkFileList(fileList2);
        }
      }, {
        immediate: true,
        deep: true
      });
      const updateFileList = (file) => {
        var _a, _b;
        emit("update:fileList", _fileList.value);
        emit("change", _fileList.value, file);
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a);
      };
      const updateFile = (id, file) => {
        for (const item of _fileList.value) {
          if (item.uid === id) {
            item.file = file;
            updateFileList(item);
            break;
          }
        }
      };
      const uploadFile = (fileItem) => {
        const handleProgress = (percent, event) => {
          const file = fileMap.get(fileItem.uid);
          if (file) {
            file.status = "uploading";
            file.percent = percent;
            emit("progress", file, event);
            updateFileList(file);
          }
        };
        const handleSuccess = (response) => {
          const file = fileMap.get(fileItem.uid);
          if (file) {
            file.status = "done";
            file.percent = 1;
            file.response = response;
            if (props.responseUrlKey) {
              if (isFunction$1(props.responseUrlKey)) {
                file.url = props.responseUrlKey(file);
              } else if (response[props.responseUrlKey]) {
                file.url = response[props.responseUrlKey];
              }
            }
            requestMap.delete(file.uid);
            emit("success", file);
            updateFileList(file);
          }
        };
        const handleError = (response) => {
          const file = fileMap.get(fileItem.uid);
          if (file) {
            file.status = "error";
            file.percent = 0;
            file.response = response;
            requestMap.delete(file.uid);
            emit("error", file);
            updateFileList(file);
          }
        };
        const option = {
          fileItem,
          action: props.action,
          name: props.name,
          data: props.data,
          headers: props.headers,
          withCredentials: props.withCredentials,
          onProgress: handleProgress,
          onSuccess: handleSuccess,
          onError: handleError
        };
        fileItem.status = "uploading";
        fileItem.percent = 0;
        const request = isFunction$1(props.customRequest) ? props.customRequest(option) : uploadRequest(option);
        requestMap.set(fileItem.uid, request);
        updateFileList(fileItem);
      };
      const abort = (fileItem) => {
        var _a;
        const req = requestMap.get(fileItem.uid);
        if (req) {
          (_a = req.abort) == null ? void 0 : _a.call(req);
          requestMap.delete(fileItem.uid);
          const file = fileMap.get(fileItem.uid);
          if (file) {
            file.status = "error";
            file.percent = 0;
            updateFileList(file);
          }
        }
      };
      const submit = (fileItem) => {
        if (fileItem) {
          const file = fileMap.get(fileItem.uid);
          if (file) {
            uploadFile(file);
          }
        } else {
          for (const item of _fileList.value) {
            if (item.status === "init") {
              uploadFile(item);
            }
          }
        }
      };
      const initUpload = async (file, index2) => {
        const uid = `${Date.now()}-${index2}`;
        const dataURL = isImage(file) ? URL.createObjectURL(file) : void 0;
        const fileItem = vue.reactive({
          uid,
          file,
          url: dataURL,
          name: file.name,
          status: "init",
          percent: 0
        });
        fileMap.set(uid, fileItem);
        _fileList.value = [..._fileList.value, fileItem];
        updateFileList(fileItem);
        if (props.autoUpload) {
          uploadFile(fileItem);
        }
      };
      const uploadFiles = (files) => {
        if (props.limit > 0 && _fileList.value.length + files.length > props.limit) {
          emit("exceedLimit", _fileList.value, files);
          return;
        }
        for (let i = 0; i < files.length; i++) {
          const file = files[i];
          if (isFunction$1(props.onBeforeUpload)) {
            Promise.resolve(props.onBeforeUpload(file)).then((result) => {
              if (result) {
                initUpload(isBoolean$1(result) ? file : result, i);
              }
            }).catch((err) => {
              console.error(err);
            });
          } else {
            initUpload(file, i);
          }
        }
      };
      const removeFile = (fileItem) => {
        _fileList.value = _fileList.value.filter((item) => {
          return item.uid !== fileItem.uid;
        });
        updateFileList(fileItem);
      };
      const handleRemove = (fileItem) => {
        if (isFunction$1(props.onBeforeRemove)) {
          Promise.resolve(props.onBeforeRemove(fileItem)).then((result) => {
            if (result) {
              removeFile(fileItem);
            }
          }).catch((err) => {
            console.error(err);
          });
        } else {
          removeFile(fileItem);
        }
      };
      const handlePreview = (fileItem) => {
        if (props.imagePreview && fileItem.url) {
          const current = imageList.value.indexOf(fileItem.url);
          if (current > -1) {
            imagePreviewCurrent.value = current;
            imagePreviewVisible.value = true;
          }
        }
        emit("preview", fileItem);
      };
      vue.provide(uploadInjectionKey, vue.reactive({
        disabled: mergedDisabled,
        listType,
        iconCls: `${prefixCls}-icon`,
        showRemoveButton,
        showRetryButton,
        showCancelButton,
        showPreviewButton,
        showLink,
        imageLoading,
        download,
        customIcon,
        slots,
        onUpload: uploadFile,
        onAbort: abort,
        onRemove: handleRemove,
        onPreview: handlePreview
      }));
      const mergedAccept = vue.computed(() => {
        if (props.accept) {
          return props.accept;
        }
        if (props.listType === "picture" || props.listType === "picture-card") {
          return "image/*";
        }
        return void 0;
      });
      const renderButton = () => {
        const button = vue.createVNode(UploadButton, {
          "key": "arco-upload-button",
          "disabled": mergedDisabled.value,
          "draggable": props.draggable,
          "listType": props.listType,
          "uploadFiles": uploadFiles,
          "multiple": props.multiple,
          "directory": props.directory,
          "tip": props.tip,
          "hide": !props.showUploadButton || isMax.value && !(isObject$1(props.showUploadButton) && props.showUploadButton.showOnExceedLimit),
          "accept": mergedAccept.value,
          "onButtonClick": props.onButtonClick
        }, {
          default: slots["upload-button"]
        });
        if (props.tip && props.listType !== "picture-card" && !props.draggable) {
          return vue.createVNode("span", null, [button, vue.createVNode("div", {
            "class": `${prefixCls}-tip`
          }, [props.tip])]);
        }
        return button;
      };
      const imagePreviewVisible = vue.ref(false);
      const imagePreviewCurrent = vue.ref(0);
      const handleImagePreviewChange = (current) => {
        imagePreviewCurrent.value = current;
      };
      const handleImagePreviewVisibleChange = (visible) => {
        imagePreviewVisible.value = visible;
      };
      const imageList = vue.computed(() => _fileList.value.filter((item) => Boolean(item.url)).map((item) => item.url));
      const render = () => {
        if (!props.showFileList) {
          return props.showUploadButton && renderButton();
        }
        return vue.createVNode("div", {
          "class": [`${prefixCls}-wrapper`, `${prefixCls}-wrapper-type-${props.listType}`]
        }, [props.imagePreview && imageList.value.length > 0 && vue.createVNode(ImagePreviewGroup, {
          "srcList": imageList.value,
          "visible": imagePreviewVisible.value,
          "current": imagePreviewCurrent.value,
          "onChange": handleImagePreviewChange,
          "onVisibleChange": handleImagePreviewVisibleChange
        }, null), props.listType !== "picture-card" && props.showUploadButton && renderButton(), vue.createVNode(UploadList, {
          "fileList": _fileList.value,
          "listType": props.listType
        }, {
          "upload-button": renderButton,
          "upload-item": slots["upload-item"]
        })]);
      };
      return {
        prefixCls,
        render,
        innerSubmit: submit,
        innerAbort: abort,
        innerUpdateFile: updateFile,
        innerUpload: uploadFiles
      };
    },
    methods: {
      submit(fileItem) {
        return this.innerSubmit(fileItem);
      },
      abort(fileItem) {
        return this.innerAbort(fileItem);
      },
      updateFile(id, file) {
        return this.innerUpdateFile(id, file);
      },
      upload(files) {
        return this.innerUpload(files);
      }
    },
    render() {
      return this.render();
    }
  });
  const Upload = Object.assign(_Upload, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _Upload.name, _Upload);
    }
  });
  var _OverflowList = vue.defineComponent({
    name: "OverflowList",
    props: {
      min: {
        type: Number,
        default: 0
      },
      margin: {
        type: Number,
        default: 8
      },
      from: {
        type: String,
        default: "end"
      }
    },
    emits: {
      change: (value) => true
    },
    setup(props, {
      emit,
      slots
    }) {
      const prefixCls = getPrefixCls("overflow-list");
      const listRef = vue.ref();
      const overflowRef = vue.ref();
      const spacerRef = vue.ref();
      const children = {};
      const itemWidths = [];
      const total = vue.ref(0);
      const overflowNumber = vue.ref(0);
      const showOverflow = vue.computed(() => overflowNumber.value > 0);
      const nextWidth = vue.ref(0);
      const isStart = vue.computed(() => props.from === "start");
      vue.watch(total, (cur, pre) => {
        if (overflowNumber.value > 0) {
          overflowNumber.value += cur - pre;
          if (overflowNumber.value < 0) {
            overflowNumber.value = 0;
          }
        }
      });
      vue.watch(overflowNumber, (val) => {
        emit("change", val);
      });
      const onResize = () => {
        var _a, _b, _c;
        if (listRef.value && children.value && spacerRef.value) {
          const spacerWidth = spacerRef.value.offsetWidth;
          if (spacerWidth > 1 && (overflowNumber.value === 0 || spacerWidth < nextWidth.value)) {
            return;
          }
          for (let i = 0; i < children.value.length; i++) {
            const element = children.value[i].el;
            if (element && element.offsetWidth) {
              itemWidths[i] = element.offsetWidth + props.margin;
            }
          }
          let remainingWidth = listRef.value.clientWidth - ((_b = (_a = overflowRef.value) == null ? void 0 : _a.offsetWidth) != null ? _b : 0) - (isStart.value ? props.margin : 0);
          const _itemWidths = isStart.value ? getReverse(itemWidths) : itemWidths;
          let count = 0;
          for (let i = 0; i < _itemWidths.length; i++) {
            const itemWidth = (_c = _itemWidths[i]) != null ? _c : 0;
            if (itemWidth < remainingWidth - 1) {
              remainingWidth -= itemWidth;
              count += 1;
            } else {
              nextWidth.value = itemWidth;
              break;
            }
          }
          if (count < props.min && props.min < total.value) {
            count = props.min;
          }
          if (overflowNumber.value !== total.value - count) {
            overflowNumber.value = total.value - count;
          }
        }
      };
      vue.watch(showOverflow, () => onResize(), {
        flush: "post"
      });
      vue.onMounted(() => {
        if (spacerRef.value && spacerRef.value.offsetWidth < 1) {
          onResize();
        }
      });
      const renderOverflow = () => {
        var _a, _b;
        const style = isStart.value ? {
          marginRight: `${props.margin}px`
        } : void 0;
        return vue.createVNode("div", {
          "ref": overflowRef,
          "class": `${prefixCls}-overflow`,
          "style": style
        }, [(_b = (_a = slots.overflow) == null ? void 0 : _a.call(slots, {
          number: overflowNumber.value
        })) != null ? _b : vue.createVNode(Tag, null, {
          default: () => [vue.createTextVNode("+"), overflowNumber.value]
        })]);
      };
      return () => {
        var _a, _b;
        children.value = getAllElements((_a = slots.default) == null ? void 0 : _a.call(slots));
        if (total.value !== children.value.length) {
          total.value = children.value.length;
          itemWidths.length = total.value;
        }
        let visibleChildren = children.value;
        if (overflowNumber.value > 0) {
          visibleChildren = isStart.value ? children.value.slice(overflowNumber.value) : children.value.slice(0, -overflowNumber.value);
        }
        const withMarginNumber = overflowNumber.value === 0 || isStart.value ? visibleChildren.length - 1 : visibleChildren.length;
        for (let i = 0; i < withMarginNumber; i++) {
          visibleChildren[i].props = vue.mergeProps((_b = visibleChildren[i].props) != null ? _b : {}, {
            style: {
              marginRight: `${props.margin}px`
            }
          });
        }
        return vue.createVNode("div", {
          "ref": listRef,
          "class": prefixCls
        }, [isStart.value && overflowNumber.value > 0 && renderOverflow(), visibleChildren, !isStart.value && overflowNumber.value > 0 && renderOverflow(), vue.createVNode(ResizeObserver, {
          "onResize": onResize
        }, {
          default: () => [vue.createVNode("div", {
            "ref": spacerRef,
            "class": `${prefixCls}-spacer`
          }, null)]
        })]);
      };
    }
  });
  const OverflowList = Object.assign(_OverflowList, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _OverflowList.name, _OverflowList);
    }
  });
  function _isSlot(s) {
    return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !vue.isVNode(s);
  }
  var Panel = vue.defineComponent({
    name: "TreeSelectPanel",
    components: {
      Tree
    },
    props: {
      treeProps: {
        type: Object,
        default: () => ({})
      },
      selectedKeys: {
        type: Array
      },
      showCheckable: {
        type: Boolean
      },
      treeSlots: {
        type: Object,
        default: () => ({})
      },
      scrollbar: {
        type: [Boolean, Object],
        default: true
      }
    },
    emits: ["change"],
    setup(props, {
      emit
    }) {
      const {
        showCheckable,
        selectedKeys,
        treeProps,
        scrollbar
      } = vue.toRefs(props);
      const {
        displayScrollbar,
        scrollbarProps
      } = useScrollbar(scrollbar);
      const prefixCls = getPrefixCls("tree-select");
      const refTree = vue.ref();
      const computedTreeProps = vue.computed(() => {
        return __spreadProps(__spreadValues({}, treeProps.value), {
          disableSelectActionOnly: true,
          checkedKeys: showCheckable.value ? selectedKeys.value : [],
          selectedKeys: showCheckable.value ? [] : selectedKeys.value
        });
      });
      const onSelect = (newVal, e2) => {
        var _a, _b;
        if (showCheckable.value) {
          (_b = (_a = refTree.value) == null ? void 0 : _a.toggleCheck) == null ? void 0 : _b.call(_a, newVal[0], e2);
        } else {
          emit("change", newVal);
        }
      };
      const onCheck = (newVal) => {
        emit("change", newVal);
      };
      const renderTree = () => {
        return vue.createVNode(Tree, vue.mergeProps({
          "ref": refTree
        }, computedTreeProps.value, {
          "onSelect": onSelect,
          "onCheck": onCheck
        }), props.treeSlots);
      };
      return () => {
        if (displayScrollbar.value) {
          let _slot;
          return vue.createVNode(Scrollbar, vue.mergeProps({
            "class": `${prefixCls}-tree-wrapper`
          }, scrollbarProps.value), _isSlot(_slot = renderTree()) ? _slot : {
            default: () => [_slot]
          });
        }
        return vue.createVNode("div", {
          "class": `${prefixCls}-tree-wrapper`
        }, [renderTree()]);
      };
    }
  });
  function isLabelValue(value) {
    return isObject$1(value);
  }
  function isValidKey(key) {
    return key !== void 0 && key !== null && key !== "";
  }
  function getKey(value) {
    return isLabelValue(value) ? value.value : value;
  }
  function getLabel(value) {
    return isLabelValue(value) ? value.label : void 0;
  }
  function isValidValue(value) {
    const key = getKey(value);
    return isValidKey(key);
  }
  function getKeys(value) {
    return value.map(getKey).filter(isValidKey);
  }
  function useSelectedState(props) {
    var _a;
    const {
      defaultValue,
      modelValue,
      key2TreeNode,
      multiple,
      treeCheckable,
      fallbackOption,
      fieldNames
    } = vue.toRefs(props);
    function normalizeValue(value) {
      const validValue = (isArray$1(value) ? value : [value]).filter(isValidValue);
      return (multiple == null ? void 0 : multiple.value) || (treeCheckable == null ? void 0 : treeCheckable.value) ? validValue : validValue.slice(0, 1);
    }
    function getLabelValues(value, originValue) {
      const res = [];
      const validValue = value ? value.filter(isValidValue) : [];
      if (validValue.length) {
        const originValueMap = new Map();
        originValue == null ? void 0 : originValue.forEach((item) => {
          originValueMap.set(item.value, item);
        });
        validValue.forEach((item) => {
          var _a2, _b, _c, _d, _e;
          const key = getKey(item);
          const originValueItem = originValueMap.get(key);
          const node = key2TreeNode.value.get(key);
          let fallbackNodeData = null;
          const nodeDataTitle = ((_a2 = fieldNames == null ? void 0 : fieldNames.value) == null ? void 0 : _a2.title) || "title";
          if (!node) {
            const fallbackResult = isFunction$1(fallbackOption == null ? void 0 : fallbackOption.value) ? fallbackOption == null ? void 0 : fallbackOption.value(key) : fallbackOption == null ? void 0 : fallbackOption.value;
            if (fallbackResult === false) {
              return;
            }
            if (isObject$1(fallbackResult)) {
              fallbackNodeData = fallbackResult;
            }
          }
          res.push(__spreadProps(__spreadValues(__spreadValues({}, isLabelValue(item) ? item : {}), originValueItem || {}), {
            value: key,
            label: (_e = (_d = (_c = (_b = getLabel(item)) != null ? _b : node == null ? void 0 : node.title) != null ? _c : originValueItem == null ? void 0 : originValueItem.label) != null ? _d : fallbackNodeData == null ? void 0 : fallbackNodeData[nodeDataTitle]) != null ? _e : key
          }));
        });
      }
      return res;
    }
    const computedModelValueKeys = vue.ref();
    const computedModelValue = vue.ref();
    vue.watchEffect(() => {
      var _a2;
      const isControlled = (modelValue == null ? void 0 : modelValue.value) !== void 0;
      const normalizeModelValue = normalizeValue((_a2 = modelValue == null ? void 0 : modelValue.value) != null ? _a2 : []);
      const modelValueKeys = getKeys(normalizeModelValue);
      computedModelValue.value = isControlled ? getLabelValues(modelValueKeys, getLabelValues(normalizeModelValue)) : void 0;
      computedModelValueKeys.value = isControlled ? modelValueKeys : void 0;
    });
    const normalizeDefaultValue = normalizeValue((_a = defaultValue == null ? void 0 : defaultValue.value) != null ? _a : []);
    const defaultKeys = getKeys(normalizeDefaultValue);
    const defaultLabelValues = getLabelValues(defaultKeys, getLabelValues(normalizeDefaultValue));
    const localValueKeys = vue.ref(defaultKeys || []);
    const localValue = vue.ref(defaultLabelValues);
    vue.watch(localValueKeys, () => {
      localValue.value = getLabelValues(localValueKeys.value, defaultLabelValues);
    });
    vue.watch([computedModelValueKeys, computedModelValue], ([valueKeys, value]) => {
      localValueKeys.value = valueKeys || [];
      localValue.value = value || [];
    });
    const selectedKeys = vue.computed(() => {
      var _a2;
      return (_a2 = computedModelValueKeys.value) != null ? _a2 : localValueKeys.value;
    });
    const selectedValue = vue.computed(() => {
      var _a2;
      return (_a2 = computedModelValue.value) != null ? _a2 : localValue.value;
    });
    return {
      selectedKeys,
      selectedValue,
      setLocalSelectedKeys(keys) {
        localValueKeys.value = keys;
      },
      localSelectedKeys: localValueKeys,
      localSelectedValue: localValue
    };
  }
  function useFilterTreeNode(props) {
    const {
      searchValue,
      flattenTreeData,
      filterMethod: propFilterMethod,
      disableFilter,
      fieldNames
    } = vue.toRefs(props);
    const keyField = vue.computed(() => {
      var _a;
      return ((_a = fieldNames.value) == null ? void 0 : _a.key) || "key";
    });
    const defaultFilterMethod = (keyword, node) => {
      const key = node[keyField.value];
      return !isUndefined(key) && String(key).indexOf(keyword) > -1;
    };
    const filterMethod = vue.computed(() => (propFilterMethod == null ? void 0 : propFilterMethod.value) || defaultFilterMethod);
    const filteredKeysSet = vue.ref();
    const isFiltering = vue.computed(() => !!searchValue.value);
    const isEmptyFilterResult = vue.computed(() => !(disableFilter == null ? void 0 : disableFilter.value) && isFiltering.value && filteredKeysSet.value && filteredKeysSet.value.size === 0);
    const filterTreeNode = vue.computed(() => (disableFilter == null ? void 0 : disableFilter.value) ? void 0 : (node) => {
      var _a, _b;
      if (!isFiltering.value)
        return true;
      const key = node[keyField.value];
      return (_b = (_a = filteredKeysSet.value) == null ? void 0 : _a.has(key || "")) != null ? _b : false;
    });
    const updateFilteredKeysSet = debounce((treeData, keyword) => {
      const hitNodes = treeData.filter((node) => filterMethod.value(keyword, node.treeNodeData));
      const _keysSet = new Set();
      hitNodes.forEach((node) => {
        _keysSet.add(node.key);
        node.pathParentKeys.forEach((_key) => {
          _keysSet.add(_key);
        });
      });
      filteredKeysSet.value = _keysSet;
    }, 100);
    vue.watchEffect(() => {
      if (disableFilter == null ? void 0 : disableFilter.value) {
        filteredKeysSet.value = void 0;
      } else {
        updateFilteredKeysSet(flattenTreeData.value, searchValue.value);
      }
    });
    return {
      isEmptyFilterResult,
      filterTreeNode
    };
  }
  function pickSubCompSlots(slots, subCompName) {
    const prefix = `${subCompName}-slot-`;
    const subSlots = Object.keys(slots).reduce((cur, s) => {
      if (s.startsWith(prefix)) {
        const subSlotName = s.slice(prefix.length);
        if (subSlotName) {
          cur[subSlotName] = slots[s];
        }
      }
      return cur;
    }, {});
    return subSlots;
  }
  const _sfc_main = vue.defineComponent({
    name: "TreeSelect",
    components: {
      Trigger,
      SelectView,
      Panel,
      Empty,
      Spin
    },
    inheritAttrs: false,
    props: {
      disabled: {
        type: Boolean
      },
      loading: {
        type: Boolean
      },
      error: {
        type: Boolean
      },
      size: {
        type: String
      },
      border: {
        type: Boolean,
        default: true
      },
      allowSearch: {
        type: [Boolean, Object],
        default: (props) => Boolean(props.multiple)
      },
      allowClear: {
        type: Boolean
      },
      placeholder: {
        type: String
      },
      maxTagCount: {
        type: Number
      },
      multiple: {
        type: Boolean
      },
      defaultValue: {
        type: [String, Number, Array, Object]
      },
      modelValue: {
        type: [String, Number, Array, Object]
      },
      fieldNames: {
        type: Object
      },
      data: {
        type: Array,
        default: () => []
      },
      labelInValue: {
        type: Boolean
      },
      treeCheckable: {
        type: Boolean
      },
      treeCheckStrictly: {
        type: Boolean
      },
      treeCheckedStrategy: {
        type: String,
        default: "all"
      },
      treeProps: {
        type: Object
      },
      triggerProps: {
        type: Object
      },
      popupVisible: {
        type: Boolean,
        default: void 0
      },
      defaultPopupVisible: {
        type: Boolean
      },
      dropdownStyle: {
        type: Object
      },
      dropdownClassName: {
        type: [String, Array]
      },
      filterTreeNode: {
        type: Function
      },
      loadMore: {
        type: Function
      },
      disableFilter: {
        type: Boolean
      },
      popupContainer: {
        type: [String, Object]
      },
      fallbackOption: {
        type: [Boolean, Function],
        default: true
      },
      selectable: {
        type: [Boolean, String, Function],
        default: true
      },
      scrollbar: {
        type: [Boolean, Object],
        default: true
      },
      showHeaderOnEmpty: {
        type: Boolean,
        default: false
      },
      showFooterOnEmpty: {
        type: Boolean,
        default: false
      }
    },
    emits: {
      "change": (value) => true,
      "update:modelValue": (value) => true,
      "popup-visible-change": (visible) => true,
      "update:popupVisible": (visible) => true,
      "search": (searchKey) => true,
      "clear": () => true
    },
    setup(props, { emit, slots }) {
      var _a, _b, _c;
      const {
        defaultValue,
        modelValue,
        multiple,
        popupVisible,
        defaultPopupVisible,
        treeCheckable,
        treeCheckStrictly,
        data,
        fieldNames,
        disabled,
        labelInValue,
        filterTreeNode,
        disableFilter,
        dropdownStyle,
        treeProps,
        fallbackOption,
        selectable,
        dropdownClassName
      } = vue.toRefs(props);
      const { mergedDisabled, eventHandlers } = useFormItem({
        disabled
      });
      const prefixCls = getPrefixCls("tree-select");
      const configCtx = vue.inject(configProviderInjectionKey, void 0);
      const TreeSelectEmpty = (_c = (_b = configCtx == null ? void 0 : (_a = configCtx.slots).empty) == null ? void 0 : _b.call(_a, {
        component: "tree-select"
      })) == null ? void 0 : _c[0];
      const isMultiple = vue.computed(() => multiple.value || treeCheckable.value);
      const isSelectable = (node, info) => {
        var _a2;
        if (selectable.value === "leaf")
          return info.isLeaf;
        if (isFunction$1(selectable.value))
          return selectable.value(node, info);
        return (_a2 = selectable.value) != null ? _a2 : false;
      };
      const isCheckable = vue.computed(() => treeCheckable.value ? isSelectable : false);
      const retainInputValue = vue.computed(() => isObject$1(props.allowSearch) && Boolean(props.allowSearch.retainInputValue));
      const { flattenTreeData, key2TreeNode } = useTreeData(vue.reactive({
        treeData: data,
        fieldNames,
        selectable: isSelectable,
        checkable: isCheckable
      }));
      const {
        selectedKeys,
        selectedValue,
        setLocalSelectedKeys,
        localSelectedKeys,
        localSelectedValue
      } = useSelectedState(vue.reactive({
        defaultValue,
        modelValue,
        key2TreeNode,
        multiple,
        treeCheckable,
        treeCheckStrictly,
        fallbackOption,
        fieldNames
      }));
      function isNodeClosable(node) {
        return treeCheckable.value ? isNodeCheckable(node) : isNodeSelectable(node);
      }
      const selectViewValue = vue.computed(() => {
        if (isUndefined(selectedValue.value)) {
          return [];
        }
        if (isMultiple.value && !mergedDisabled.value) {
          return selectedValue.value.map((i) => {
            const node = key2TreeNode.value.get(i.value);
            return __spreadProps(__spreadValues({}, i), {
              closable: !node || isNodeClosable(node)
            });
          });
        }
        return selectedValue.value;
      });
      const setSelectedKeys = (newVal) => {
        setLocalSelectedKeys(newVal);
        vue.nextTick(() => {
          var _a2, _b2;
          const forEmitValue = (labelInValue.value ? localSelectedValue.value : localSelectedKeys.value) || [];
          const emitValue = isMultiple.value ? forEmitValue : forEmitValue[0];
          emit("update:modelValue", emitValue);
          emit("change", emitValue);
          (_b2 = (_a2 = eventHandlers.value) == null ? void 0 : _a2.onChange) == null ? void 0 : _b2.call(_a2);
        });
      };
      const searchValue = vue.ref("");
      const [panelVisible, setLocalPanelVisible] = useMergeState(defaultPopupVisible.value, vue.reactive({
        value: popupVisible
      }));
      const setPanelVisible = (visible) => {
        if (visible !== panelVisible.value) {
          setLocalPanelVisible(visible);
          emit("popup-visible-change", visible);
          emit("update:popupVisible", visible);
        }
        if (!visible) {
          refSelectView.value && refSelectView.value.blur && refSelectView.value.blur();
        }
      };
      const { isEmptyFilterResult, filterTreeNode: computedFilterTreeNode } = useFilterTreeNode(vue.reactive({
        searchValue,
        flattenTreeData,
        filterMethod: filterTreeNode,
        disableFilter,
        fieldNames
      }));
      const isEmpty = vue.computed(() => !flattenTreeData.value.length || isEmptyFilterResult.value);
      const refSelectView = vue.ref();
      const computedDropdownStyle = vue.computed(() => {
        var _a2;
        return [
          (dropdownStyle == null ? void 0 : dropdownStyle.value) || {},
          ((_a2 = treeProps == null ? void 0 : treeProps.value) == null ? void 0 : _a2.virtualListProps) ? { "max-height": "unset" } : {}
        ];
      });
      const onBlur = () => {
        if (!retainInputValue.value && searchValue.value) {
          searchValue.value = "";
        }
      };
      return {
        refSelectView,
        prefixCls,
        TreeSelectEmpty,
        selectedValue,
        selectedKeys,
        mergedDisabled,
        searchValue,
        panelVisible,
        isEmpty,
        computedFilterTreeNode,
        isMultiple,
        selectViewValue,
        computedDropdownStyle,
        onSearchValueChange(newVal) {
          if (newVal !== searchValue.value) {
            setPanelVisible(true);
            searchValue.value = newVal;
            emit("search", newVal);
          }
        },
        onSelectChange(newVal) {
          setSelectedKeys(newVal);
          searchValue.value = "";
          if (!isMultiple.value) {
            setPanelVisible(false);
          }
        },
        onVisibleChange: setPanelVisible,
        onInnerClear() {
          setSelectedKeys([]);
          emit("clear");
        },
        pickSubCompSlots,
        isSelectable,
        isCheckable,
        onBlur,
        onItemRemove(id) {
          if (mergedDisabled.value)
            return;
          const node = key2TreeNode.value.get(id);
          if (treeCheckable.value && node) {
            if (isNodeClosable(node)) {
              const [newVal] = getCheckedStateByCheck({
                node,
                checked: false,
                checkedKeys: selectedKeys.value,
                indeterminateKeys: [],
                checkStrictly: treeCheckStrictly.value
              });
              setSelectedKeys(newVal);
            }
          } else {
            const newVal = selectedKeys.value.filter((i) => i !== id);
            setSelectedKeys(newVal);
          }
        }
      };
    }
  });
  function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_SelectView = vue.resolveComponent("SelectView");
    const _component_Spin = vue.resolveComponent("Spin");
    const _component_Panel = vue.resolveComponent("Panel");
    const _component_Trigger = vue.resolveComponent("Trigger");
    return vue.openBlock(), vue.createBlock(_component_Trigger, vue.mergeProps({
      class: `${_ctx.prefixCls}-trigger`,
      "auto-fit-popup-min-width": "",
      trigger: "click",
      position: "bl",
      "popup-offset": 4,
      "animation-name": "slide-dynamic-origin",
      "prevent-focus": true
    }, _ctx.triggerProps, {
      disabled: _ctx.mergedDisabled,
      "popup-visible": _ctx.panelVisible,
      "popup-container": _ctx.popupContainer,
      "click-to-close": !_ctx.allowSearch,
      "auto-fit-transform-origin": "",
      onPopupVisibleChange: _ctx.onVisibleChange
    }), {
      content: vue.withCtx(() => [
        vue.createElementVNode("div", {
          class: vue.normalizeClass([
            `${_ctx.prefixCls}-popup`,
            {
              [`${_ctx.prefixCls}-has-header`]: Boolean(_ctx.$slots.header),
              [`${_ctx.prefixCls}-has-footer`]: Boolean(_ctx.$slots.footer)
            },
            _ctx.dropdownClassName
          ]),
          style: vue.normalizeStyle(_ctx.computedDropdownStyle)
        }, [
          _ctx.$slots.header && (!_ctx.isEmpty || _ctx.showHeaderOnEmpty) ? (vue.openBlock(), vue.createElementBlock("div", {
            key: 0,
            class: vue.normalizeClass(`${_ctx.prefixCls}-header`)
          }, [
            vue.renderSlot(_ctx.$slots, "header")
          ], 2)) : vue.createCommentVNode("v-if", true),
          _ctx.loading ? vue.renderSlot(_ctx.$slots, "loader", { key: 1 }, () => [
            vue.createVNode(_component_Spin)
          ]) : _ctx.isEmpty ? vue.renderSlot(_ctx.$slots, "empty", { key: 2 }, () => [
            (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.TreeSelectEmpty ? _ctx.TreeSelectEmpty : "Empty")))
          ]) : (vue.openBlock(), vue.createBlock(_component_Panel, {
            key: 3,
            "selected-keys": _ctx.selectedKeys,
            "show-checkable": _ctx.treeCheckable,
            scrollbar: _ctx.scrollbar,
            "tree-props": __spreadProps(__spreadValues({
              actionOnNodeClick: _ctx.selectable === "leaf" ? "expand" : void 0,
              blockNode: true
            }, _ctx.treeProps), {
              data: _ctx.data,
              checkStrictly: _ctx.treeCheckStrictly,
              checkedStrategy: _ctx.treeCheckedStrategy,
              fieldNames: _ctx.fieldNames,
              multiple: _ctx.multiple,
              loadMore: _ctx.loadMore,
              filterTreeNode: _ctx.computedFilterTreeNode,
              size: _ctx.size,
              checkable: _ctx.isCheckable,
              selectable: _ctx.isSelectable,
              searchValue: _ctx.searchValue
            }),
            "tree-slots": _ctx.pickSubCompSlots(_ctx.$slots, "tree"),
            onChange: _ctx.onSelectChange
          }, null, 8, ["selected-keys", "show-checkable", "scrollbar", "tree-props", "tree-slots", "onChange"])),
          _ctx.$slots.footer && (!_ctx.isEmpty || _ctx.showFooterOnEmpty) ? (vue.openBlock(), vue.createElementBlock("div", {
            key: 4,
            class: vue.normalizeClass(`${_ctx.prefixCls}-footer`)
          }, [
            vue.renderSlot(_ctx.$slots, "footer")
          ], 2)) : vue.createCommentVNode("v-if", true)
        ], 6)
      ]),
      default: vue.withCtx(() => [
        vue.renderSlot(_ctx.$slots, "trigger", {}, () => [
          vue.createVNode(_component_SelectView, vue.mergeProps({
            ref: "refSelectView",
            "model-value": _ctx.selectViewValue,
            "input-value": _ctx.searchValue,
            "allow-search": Boolean(_ctx.allowSearch),
            "allow-clear": _ctx.allowClear,
            loading: _ctx.loading,
            size: _ctx.size,
            "max-tag-count": _ctx.maxTagCount,
            disabled: _ctx.mergedDisabled,
            opened: _ctx.panelVisible,
            error: _ctx.error,
            bordered: _ctx.border,
            placeholder: _ctx.placeholder,
            multiple: _ctx.isMultiple
          }, _ctx.$attrs, {
            onInputValueChange: _ctx.onSearchValueChange,
            onClear: _ctx.onInnerClear,
            onRemove: _ctx.onItemRemove,
            onBlur: _ctx.onBlur
          }), vue.createSlots({ _: 2 }, [
            _ctx.$slots.prefix ? {
              name: "prefix",
              fn: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "prefix")
              ])
            } : void 0,
            _ctx.$slots.label ? {
              name: "label",
              fn: vue.withCtx((selectedData) => [
                vue.renderSlot(_ctx.$slots, "label", vue.normalizeProps(vue.guardReactiveProps(selectedData)))
              ])
            } : void 0
          ]), 1040, ["model-value", "input-value", "allow-search", "allow-clear", "loading", "size", "max-tag-count", "disabled", "opened", "error", "bordered", "placeholder", "multiple", "onInputValueChange", "onClear", "onRemove", "onBlur"])
        ])
      ]),
      _: 3
    }, 16, ["class", "disabled", "popup-visible", "popup-container", "click-to-close", "onPopupVisibleChange"]);
  }
  var _TreeSelect = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
  const TreeSelect = Object.assign(_TreeSelect, {
    install: (app, options) => {
      setGlobalConfig(app, options);
      const componentPrefix = getComponentPrefix(options);
      app.component(componentPrefix + _TreeSelect.name, _TreeSelect);
    }
  });
  const components = {
    Button,
    Link,
    Typography,
    Divider,
    Grid,
    Layout,
    Space,
    Avatar,
    Badge,
    Calendar,
    Card,
    Carousel,
    Collapse,
    Comment,
    Descriptions,
    Empty,
    Image,
    Scrollbar,
    List,
    Popover,
    Statistic,
    Table,
    Tabs,
    Tag,
    Timeline,
    Tooltip,
    AutoComplete,
    Cascader,
    Checkbox,
    DatePicker,
    Form,
    Input,
    InputNumber,
    InputTag,
    Mention,
    Radio,
    Rate,
    Select,
    Slider,
    Switch,
    Textarea,
    TimePicker,
    Transfer,
    Tree,
    Upload,
    TreeSelect,
    Alter: Alert,
    Alert,
    Drawer,
    Message,
    Modal,
    Notification,
    Popconfirm,
    Progress,
    Result,
    Spin,
    Skeleton,
    Breadcrumb,
    Dropdown,
    Menu,
    PageHeader,
    Pagination,
    Steps,
    Affix,
    Anchor,
    BackTop,
    ConfigProvider,
    ResizeBox,
    Trigger,
    Split,
    Icon,
    OverflowList
  };
  const install = (app, options) => {
    for (const key of Object.keys(components)) {
      app.use(components[key], options);
    }
  };
  const ArcoVue = __spreadProps(__spreadValues({}, components), {
    AnchorLink,
    AvatarGroup,
    BreadcrumbItem,
    ButtonGroup,
    Calendar,
    CardMeta,
    CardGrid,
    CarouselItem,
    CascaderPanel,
    CheckboxGroup,
    CollapseItem,
    DescriptionsItem,
    WeekPicker,
    MonthPicker,
    YearPicker,
    QuarterPicker,
    RangePicker,
    Doption,
    Dgroup,
    Dsubmenu,
    DropdownButton,
    FormItem,
    Row,
    Col,
    GridItem,
    ImagePreview,
    ImagePreviewAction,
    ImagePreviewGroup,
    InputGroup,
    InputSearch,
    InputPassword,
    LayoutHeader,
    LayoutContent,
    LayoutFooter,
    LayoutSider,
    ListItem,
    ListItemMeta,
    MenuItem,
    MenuItemGroup,
    SubMenu,
    RadioGroup,
    Option,
    Optgroup,
    SkeletonLine,
    SkeletonShape,
    Countdown,
    Step,
    Thead,
    Td,
    Th,
    Tr,
    Tbody,
    TableColumn,
    TabPane,
    TimelineItem,
    TypographyParagraph,
    TypographyTitle,
    TypographyText,
    install,
    addI18nMessages,
    useLocale,
    getLocale,
    useFormItem
  });
  return ArcoVue;
});
//# sourceMappingURL=arco-vue.js.map
